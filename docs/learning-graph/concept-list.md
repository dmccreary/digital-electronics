# Digital Electronics Concept List

This file contains 250 concepts for the Digital Electronics learning graph.
Each concept is numbered with a unique ConceptID for use in the dependency graph.

## Concepts

1. Binary Number System
2. Decimal to Binary Conversion
3. Binary to Decimal Conversion
4. Hexadecimal Numbers
5. Hex to Binary Conversion
6. Octal Numbers
7. Binary Addition
8. Binary Subtraction
9. Two's Complement
10. Signed Binary Numbers
11. Overflow Detection
12. BCD Encoding
13. Gray Code
14. Weighted Codes
15. Boolean Variable
16. Boolean Constant
17. Boolean Expression
18. Boolean Function
19. Truth Table
20. AND Operation
21. OR Operation
22. NOT Operation
23. Boolean Algebra
24. Identity Law
25. Null Law
26. Idempotent Law
27. Complement Law
28. Commutative Law
29. Associative Law
30. Distributive Law
31. Absorption Law
32. De Morgan's Theorem
33. Dual Expression
34. Consensus Theorem
35. Boolean Proof Technique
36. Logic Gate
37. AND Gate
38. OR Gate
39. NOT Gate
40. Buffer Gate
41. NAND Gate
42. NOR Gate
43. XOR Gate
44. XNOR Gate
45. Gate Symbol
46. IEEE Gate Symbols
47. Functional Completeness
48. Universal Gate
49. NAND-Only Design
50. NOR-Only Design
51. Gate Delay
52. Propagation Delay
53. Rise Time
54. Fall Time
55. Fan-In
56. Fan-Out
57. Logic Levels
58. Noise Margin
59. Voltage Threshold
60. Logic Family
61. TTL Logic
62. CMOS Logic
63. Digital Signal
64. Analog vs Digital
65. Signal Integrity
66. Combinational Logic
67. Sequential Logic
68. Gate-Level Design
69. Boolean to Gates Mapping
70. Multi-Level Logic
71. Two-Level Logic
72. Sum of Products
73. Product of Sums
74. Minterm
75. Maxterm
76. Canonical Form
77. Standard Form
78. Minimal Form
79. Logic Minimization
80. Algebraic Simplification
81. Factoring
82. Common Term Extraction
83. Karnaugh Map
84. K-Map 2 Variable
85. K-Map 3 Variable
86. K-Map 4 Variable
87. K-Map Grouping Rules
88. Adjacent Cells
89. Don't Care Condition
90. Prime Implicant
91. Essential Prime Implicant
92. Implicant Cover
93. Minimal SOP
94. Minimal POS
95. Quine-McCluskey Method
96. Hazard
97. Static Hazard
98. Dynamic Hazard
99. Hazard-Free Design
100. Multiplexer
101. MUX 2-to-1
102. MUX 4-to-1
103. MUX 8-to-1
104. MUX Tree
105. MUX as Logic Function
106. Demultiplexer
107. DEMUX 1-to-4
108. Encoder
109. Decoder
110. 2-to-4 Decoder
111. 3-to-8 Decoder
112. Decoder Enable
113. Priority Encoder
114. 7-Segment Display
115. 7-Segment Decoder
116. Binary Comparator
117. Magnitude Comparator
118. Equality Comparator
119. Half Adder
120. Full Adder
121. Carry Bit
122. Sum Bit
123. Ripple Carry Adder
124. Carry Propagation Delay
125. Carry Lookahead Concept
126. Adder Subtractor
127. Overflow in Addition
128. ALU Concept
129. Parity Bit
130. Parity Generator
131. Parity Checker
132. Error Detection
133. Tri-State Buffer
134. Bus Architecture
135. Memory Element
136. State Concept
137. Feedback Loop
138. Bistable Element
139. SR Latch
140. SR Latch Truth Table
141. Invalid State Problem
142. Gated SR Latch
143. D Latch
144. Level Sensitive
145. Transparent Latch
146. Latch Timing Problem
147. Race Condition
148. Clock Signal
149. Clock Edge
150. Rising Edge
151. Falling Edge
152. Clock Period
153. Clock Frequency
154. Duty Cycle
155. D Flip-Flop
156. Edge Triggered
157. Positive Edge Triggered
158. Negative Edge Triggered
159. Master-Slave Flip-Flop
160. JK Flip-Flop
161. JK Toggle Mode
162. T Flip-Flop
163. Flip-Flop Symbol
164. Preset Input
165. Clear Input
166. Asynchronous Reset
167. Synchronous Reset
168. Setup Time
169. Hold Time
170. Clock-to-Q Delay
171. Timing Diagram
172. Timing Constraint
173. Timing Violation
174. Metastability
175. MTBF Concept
176. Synchronous System
177. Asynchronous Input
178. Synchronizer Circuit
179. Double Flop Synchronizer
180. Finite State Machine
181. FSM State
182. State Transition
183. Current State
184. Next State
185. Next State Logic
186. Output Logic
187. Moore Machine
188. Moore Output
189. Mealy Machine
190. Mealy Output
191. State Diagram
192. State Diagram Notation
193. State Table
194. State Encoding
195. Binary Encoding
196. One-Hot Encoding
197. Gray Code Encoding
198. State Assignment
199. State Minimization
200. Next State Equation
201. Output Equation
202. FSM Design Process
203. FSM Verification
204. Sequence Detector
205. Pattern Recognition FSM
206. Overlapping Detection
207. Non-Overlapping Detection
208. Traffic Light Controller
209. Vending Machine FSM
210. Counter
211. Up Counter
212. Down Counter
213. Up-Down Counter
214. Mod-N Counter
215. Binary Counter
216. BCD Counter
217. Decade Counter
218. Ring Counter
219. Johnson Counter
220. Counter State Diagram
221. Counter Overflow
222. Register
223. Parallel Load Register
224. Shift Register
225. Serial In Serial Out
226. Serial In Parallel Out
227. Parallel In Serial Out
228. Parallel In Parallel Out
229. Bidirectional Shift
230. Universal Shift Register
231. Enable Signal
232. Load Signal
233. Clear Signal
234. Register File
235. Datapath Concept
236. Control Unit
237. Register Transfer Level
238. RTL Notation
239. Verilog HDL
240. HDL vs Programming
241. Module Definition
242. Port Declaration
243. Input Port
244. Output Port
245. Inout Port
246. Wire Data Type
247. Reg Data Type
248. Parameter
249. Assign Statement
250. Continuous Assignment
251. Always Block
252. Sensitivity List
253. Blocking Assignment
254. Non-Blocking Assignment
255. If-Else in Verilog
256. Case Statement
257. Combinational Always
258. Sequential Always
259. Posedge Keyword
260. Negedge Keyword
261. Initial Block
262. Structural Modeling
263. Behavioral Modeling
264. Gate-Level Verilog
265. RTL Verilog
266. Module Instantiation
267. Hierarchical Design
268. Testbench
269. Stimulus Generation
270. Clock Generation
271. Test Vector
272. Self-Checking Testbench
273. Simulation
274. Simulation Time
275. Waveform Viewer
276. Debugging Waveforms
277. Synthesis
278. Synthesizable Code
279. Non-Synthesizable Code
280. FPGA Architecture
281. FPGA LUT
282. FPGA Flip-Flop
283. FPGA Routing
284. FPGA Implementation
285. Pin Assignment
286. Breadboard Prototyping
287. Logic Probe
288. Logic Analyzer
289. LED Indicator
290. Switch Input
291. Debouncing
292. Design Verification
293. Functional Verification
294. Timing Verification
295. Hardware-Software Boundary
296. Abstraction Levels
297. Design Hierarchy
298. Design Reuse
299. Design Documentation
300. Digital System Design

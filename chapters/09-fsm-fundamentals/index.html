
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="The core abstraction for designing sequential digital systems with well-defined behavior">
      
      
        <meta name="author" content="Dan McCreary">
      
      
        <link rel="canonical" href="https://dmccreary.github.io/digital-electronics/chapters/09-fsm-fundamentals/">
      
      
        <link rel="prev" href="../08-flip-flops-timing/references/">
      
      
        <link rel="next" href="quiz/">
      
      
      <link rel="icon" href="../../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.43">
    
    
      
        <title>Finite State Machine Fundamentals - Digital Electronics</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../css/extra.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  

<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-E7S8QWP8T0"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-E7S8QWP8T0",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-E7S8QWP8T0",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="maroon" data-md-color-accent="gold">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#finite-state-machine-fundamentals" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Digital Electronics" class="md-header__button md-logo" aria-label="Digital Electronics" data-md-component="logo">
      
  <img src="../../img/logo.jpg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Digital Electronics
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Finite State Machine Fundamentals
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/dmccreary/digital-electronics" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub Repo
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Digital Electronics" class="md-nav__button md-logo" aria-label="Digital Electronics" data-md-component="logo">
      
  <img src="../../img/logo.jpg" alt="logo">

    </a>
    Digital Electronics
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/dmccreary/digital-electronics" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub Repo
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    About
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../course-description/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Course Description
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Chapters
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Chapters
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../01-number-systems-binary-arithmetic/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    1. Number Systems
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../02-boolean-algebra-fundamentals/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    2. Boolean Algebra
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../03-logic-gates-digital-signals/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    3. Logic Gates
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../04-combinational-logic-design/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    4. Combinational Design
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../05-logic-minimization-kmaps/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    5. K-Maps
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../06-combinational-building-blocks/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    6. Building Blocks
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../07-intro-sequential-logic/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    7. Sequential Logic
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../08-flip-flops-timing/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    8. Flip-Flops
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_10" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="./" class="md-nav__link md-nav__link--active">
              
  
  <span class="md-ellipsis">
    9. FSM Fundamentals
  </span>
  

            </a>
            
              
              <label class="md-nav__link md-nav__link--active" for="__nav_4_10" id="__nav_4_10_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_10_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4_10">
            <span class="md-nav__icon md-icon"></span>
            9. FSM Fundamentals
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="quiz/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quiz
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="references/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Annotated References
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../10-fsm-design-applications/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    10. FSM Applications
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../11-registers-counters-datapath/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    11. Registers & Counters
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../12-verilog-hdl-fundamentals/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    12. Verilog Basics
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../13-verilog-modeling/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    13. Verilog Modeling
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../14-testbenches-simulation/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    14. Testbenches
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../15-fpga-lab-skills/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    15. FPGA & Lab
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../../lessons/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    Lessons
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../../sims/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    Sims
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../../learning-graph/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    Learning Graph
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
    <a href="../../prompts/equation-standards/" class="md-nav__link">
      
  
  <span class="md-ellipsis">
    Prompts
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../glossary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Glossary
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../license/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    License
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../how-we-built-this-site/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    How we built this site
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contact/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Contact
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span class="md-ellipsis">
      Summary
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#concepts-covered" class="md-nav__link">
    <span class="md-ellipsis">
      Concepts Covered
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#prerequisites" class="md-nav__link">
    <span class="md-ellipsis">
      Prerequisites
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduction-the-machine-that-remembers-where-its-been" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction: The Machine That Remembers Where It's Been
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#what-is-a-finite-state-machine" class="md-nav__link">
    <span class="md-ellipsis">
      What Is a Finite State Machine?
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fsm-state-snapshots-of-your-system" class="md-nav__link">
    <span class="md-ellipsis">
      FSM State: Snapshots of Your System
    </span>
  </a>
  
    <nav class="md-nav" aria-label="FSM State: Snapshots of Your System">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-fsm-state-concept-visualizer" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: FSM State Concept Visualizer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-transition-the-rules-of-movement" class="md-nav__link">
    <span class="md-ellipsis">
      State Transition: The Rules of Movement
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#current-state-and-next-state-times-arrow" class="md-nav__link">
    <span class="md-ellipsis">
      Current State and Next State: Time's Arrow
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Current State and Next State: Time's Arrow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-current-state-to-next-state-flow" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: Current State to Next State Flow
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#next-state-logic-the-decision-maker" class="md-nav__link">
    <span class="md-ellipsis">
      Next State Logic: The Decision Maker
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#output-logic-speaking-to-the-world" class="md-nav__link">
    <span class="md-ellipsis">
      Output Logic: Speaking to the World
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#moore-machine-outputs-depend-only-on-state" class="md-nav__link">
    <span class="md-ellipsis">
      Moore Machine: Outputs Depend Only on State
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#moore-output-the-state-speaks" class="md-nav__link">
    <span class="md-ellipsis">
      Moore Output: The State Speaks
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Moore Output: The State Speaks">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-moore-machine-simulator" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: Moore Machine Simulator
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mealy-machine-outputs-react-immediately" class="md-nav__link">
    <span class="md-ellipsis">
      Mealy Machine: Outputs React Immediately
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mealy-output-react-and-respond" class="md-nav__link">
    <span class="md-ellipsis">
      Mealy Output: React and Respond
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Mealy Output: React and Respond">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-mealy-machine-simulator" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: Mealy Machine Simulator
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#moore-vs-mealy-the-great-debate" class="md-nav__link">
    <span class="md-ellipsis">
      Moore vs Mealy: The Great Debate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-diagram-a-picture-worth-a-thousand-gates" class="md-nav__link">
    <span class="md-ellipsis">
      State Diagram: A Picture Worth a Thousand Gates
    </span>
  </a>
  
    <nav class="md-nav" aria-label="State Diagram: A Picture Worth a Thousand Gates">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-state-diagram-builder" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: State Diagram Builder
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-diagram-notation-speaking-the-language" class="md-nav__link">
    <span class="md-ellipsis">
      State Diagram Notation: Speaking the Language
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-table-the-complete-specification" class="md-nav__link">
    <span class="md-ellipsis">
      State Table: The Complete Specification
    </span>
  </a>
  
    <nav class="md-nav" aria-label="State Table: The Complete Specification">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-state-table-to-circuit" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: State Table to Circuit
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-encoding-giving-states-binary-names" class="md-nav__link">
    <span class="md-ellipsis">
      State Encoding: Giving States Binary Names
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-encoding-the-compact-choice" class="md-nav__link">
    <span class="md-ellipsis">
      Binary Encoding: The Compact Choice
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Binary Encoding: The Compact Choice">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-state-encoding-comparison" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: State Encoding Comparison
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#one-hot-encoding-one-bit-per-state" class="md-nav__link">
    <span class="md-ellipsis">
      One-Hot Encoding: One Bit Per State
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gray-code-encoding-smooth-transitions" class="md-nav__link">
    <span class="md-ellipsis">
      Gray Code Encoding: Smooth Transitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-assignment-optimizing-the-encoding" class="md-nav__link">
    <span class="md-ellipsis">
      State Assignment: Optimizing the Encoding
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#state-minimization-fewer-states-simpler-circuits" class="md-nav__link">
    <span class="md-ellipsis">
      State Minimization: Fewer States, Simpler Circuits
    </span>
  </a>
  
    <nav class="md-nav" aria-label="State Minimization: Fewer States, Simpler Circuits">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-state-minimization-visualizer" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: State Minimization Visualizer
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-fsm-design-process-from-words-to-gates" class="md-nav__link">
    <span class="md-ellipsis">
      The FSM Design Process: From Words to Gates
    </span>
  </a>
  
    <nav class="md-nav" aria-label="The FSM Design Process: From Words to Gates">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#diagram-complete-fsm-design-flow" class="md-nav__link">
    <span class="md-ellipsis">
      Diagram: Complete FSM Design Flow
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-designing-a-vending-machine-controller" class="md-nav__link">
    <span class="md-ellipsis">
      Example: Designing a Vending Machine Controller
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#common-fsm-design-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Common FSM Design Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#summary-and-key-takeaways" class="md-nav__link">
    <span class="md-ellipsis">
      Summary and Key Takeaways
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#practice-problems" class="md-nav__link">
    <span class="md-ellipsis">
      Practice Problems
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="finite-state-machine-fundamentals">Finite State Machine Fundamentals</h1>
<h2 id="summary">Summary</h2>
<p>This chapter introduces finite state machines (FSMs), the core abstraction for designing sequential digital systems with well-defined behavior. Students will learn the FSM model including states, transitions, inputs, and outputs, understand the distinction between Moore machines (outputs depend only on state) and Mealy machines (outputs depend on state and inputs), and master state diagram and state table representations. The chapter covers state encoding strategies including binary, one-hot, and Gray code encoding, along with state assignment optimization and state minimization techniques.</p>
<h2 id="concepts-covered">Concepts Covered</h2>
<p>This chapter covers the following 20 concepts from the learning graph:</p>
<ol>
<li>Finite State Machine</li>
<li>FSM State</li>
<li>State Transition</li>
<li>Current State</li>
<li>Next State</li>
<li>Next State Logic</li>
<li>Output Logic</li>
<li>Moore Machine</li>
<li>Moore Output</li>
<li>Mealy Machine</li>
<li>Mealy Output</li>
<li>State Diagram</li>
<li>State Diagram Notation</li>
<li>State Table</li>
<li>State Encoding</li>
<li>Binary Encoding</li>
<li>One-Hot Encoding</li>
<li>Gray Code Encoding</li>
<li>State Assignment</li>
<li>State Minimization</li>
</ol>
<h2 id="prerequisites">Prerequisites</h2>
<p>This chapter builds on concepts from:</p>
<ul>
<li><a href="../04-combinational-logic-design/">Chapter 4: Combinational Logic Design Fundamentals</a></li>
<li><a href="../07-intro-sequential-logic/">Chapter 7: Introduction to Sequential Logic</a></li>
<li><a href="../08-flip-flops-timing/">Chapter 8: Flip-Flops and Timing</a></li>
</ul>
<hr />
<h2 id="introduction-the-machine-that-remembers-where-its-been">Introduction: The Machine That Remembers Where It's Been</h2>
<p>Welcome to what might be the most empowering chapter in this entire course. You're about to learn how to design systems that think—well, at least systems that can remember what they're doing and decide what to do next based on what's happened before.</p>
<p>Consider a traffic light. It's not just randomly cycling colors. It <em>knows</em> it's currently showing green, it <em>knows</em> it should go yellow next, and it <em>knows</em> how long to wait. When a pedestrian presses the crossing button, it <em>knows</em> to factor that into its decision. That traffic light is running a finite state machine—and by the end of this chapter, you'll be able to design one from scratch.</p>
<p>Or think about your favorite video game. When your character is standing, they can jump, run, or duck. When they're jumping, they can't duck (physics, people!), but they can transition to falling. These relationships between actions form a state machine that governs everything from Mario's platforming to the AI controlling enemy behavior.</p>
<p>Here's the beautiful secret: finite state machines are the bridge between the abstract world of flip-flops and the complex behaviors we see in real digital systems. They're the <em>lingua franca</em> of sequential design—the language in which digital designers describe behavior before writing a single line of Verilog.</p>
<p>Ready to speak fluent state machine? Let's go!</p>
<h2 id="what-is-a-finite-state-machine">What Is a Finite State Machine?</h2>
<p>A <strong>Finite State Machine</strong> (FSM) is a mathematical model of computation that describes a system with a limited number of states, rules for transitioning between states, and (often) outputs that depend on the current state or transitions.</p>
<p>The word "finite" is crucial: the machine can only be in one of a predetermined, countable number of states. Unlike a general-purpose computer that can represent arbitrary amounts of information in memory, an FSM has exactly <span class="arithmatex">\(N\)</span> possible states, no more, no less.</p>
<p>Every FSM has five essential components:</p>
<ol>
<li><strong>States</strong>: The possible configurations the system can be in</li>
<li><strong>Inputs</strong>: External signals that affect transitions</li>
<li><strong>Outputs</strong>: Signals the system produces</li>
<li><strong>Transitions</strong>: Rules for moving between states</li>
<li><strong>Initial state</strong>: Where the system starts</li>
</ol>
<p>Think of an FSM like a board game where:</p>
<ul>
<li>The <strong>states</strong> are the squares on the board</li>
<li>The <strong>inputs</strong> are the dice rolls or card draws</li>
<li>The <strong>transitions</strong> are the rules saying "if you're here and you roll this, go there"</li>
<li>The <strong>outputs</strong> might be "collect $200" or "go to jail"</li>
<li>The <strong>initial state</strong> is "Start"</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">The Power of Abstraction</p>
<p>FSMs are powerful because they hide complexity. You don't need to think about flip-flops, timing, or gates when designing at the FSM level. You specify <em>behavior</em>, and then systematically derive the <em>implementation</em>.</p>
</div>
<p>Here's a simple example—a coin-operated turnstile:</p>
<table>
<thead>
<tr>
<th>Current State</th>
<th>Input</th>
<th>Next State</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>Locked</td>
<td>Push</td>
<td>Locked</td>
<td>Nothing (blocked)</td>
</tr>
<tr>
<td>Locked</td>
<td>Coin</td>
<td>Unlocked</td>
<td>Allow passage</td>
</tr>
<tr>
<td>Unlocked</td>
<td>Push</td>
<td>Locked</td>
<td>Person passes through</td>
</tr>
<tr>
<td>Unlocked</td>
<td>Coin</td>
<td>Unlocked</td>
<td>Nothing (coin returned)</td>
</tr>
</tbody>
</table>
<p>Two states. Two inputs. Complete specification of behavior. That's the elegance of FSMs.</p>
<h2 id="fsm-state-snapshots-of-your-system">FSM State: Snapshots of Your System</h2>
<p>An <strong>FSM State</strong> represents a unique configuration of the system—a snapshot of everything the machine needs to remember to determine its future behavior.</p>
<p>States capture memory in its most abstract form. When we say a traffic light is in the "Green" state, we're saying the system remembers it's showing green right now. When we say a vending machine is in the "75 cents deposited" state, it remembers exactly how much money has been inserted.</p>
<p>Key properties of states:</p>
<ul>
<li><strong>Mutually exclusive</strong>: The system is in exactly one state at any moment</li>
<li><strong>Collectively exhaustive</strong>: The states cover all possible situations</li>
<li><strong>Well-defined</strong>: Each state has clear meaning and implications</li>
<li><strong>Finite in number</strong>: There's a countable set of states</li>
</ul>
<p>States are typically given descriptive names that reflect their meaning:</p>
<ul>
<li>Traffic light: <code>GREEN</code>, <code>YELLOW</code>, <code>RED</code>, <code>WALK_SIGNAL</code></li>
<li>Lock combination: <code>IDLE</code>, <code>FIRST_CORRECT</code>, <code>SECOND_CORRECT</code>, <code>UNLOCKED</code></li>
<li>Elevator: <code>STOPPED_FLOOR_1</code>, <code>MOVING_UP</code>, <code>STOPPED_FLOOR_2</code>, <code>MOVING_DOWN</code></li>
</ul>
<div class="admonition note">
<p class="admonition-title">States vs. State Variables</p>
<p>We often implement states using flip-flops (state variables). A system with 4 states needs 2 flip-flops (since <span class="arithmatex">\(2^2 = 4\)</span>). But conceptually, we think about the <em>abstract states</em>, not the flip-flop values. The encoding is a separate concern we'll tackle later.</p>
</div>
<h4 id="diagram-fsm-state-concept-visualizer">Diagram: FSM State Concept Visualizer</h4>
<iframe src="../../sims/fsm-state-concept/main.html" width="100%" height="500px" scrolling="no"></iframe>

<details>
<summary>FSM State Concept Visualizer</summary>
<p>Type: microsim</p>
<p>Bloom Level: Understand (L2)
Bloom Verb: Explain</p>
<p>Learning Objective: Students will be able to explain what an FSM state represents and how a system can only occupy one state at a time while transitioning between states based on inputs.</p>
<p>Instructional Rationale: Visual representation of states as distinct "locations" with highlighting of the current state reinforces the concept that exactly one state is active at any moment.</p>
<p>Canvas Layout:</p>
<ul>
<li>Main area: Multiple state circles arranged visually</li>
<li>Current state highlighted with distinct color</li>
<li>Input controls at bottom</li>
<li>State description panel on side</li>
<li>Transition arrows showing possible next states</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Multiple input buttons to trigger transitions</li>
<li>Current state displays its name and description</li>
<li>Possible transitions highlighted from current state</li>
<li>Transition animation when input triggers state change</li>
<li>State history log showing sequence of states visited</li>
<li>Reset button to return to initial state</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>Current state name prominently displayed</li>
<li>State description text</li>
<li>Available inputs from current state</li>
<li>Where each input will lead</li>
<li>History of states visited</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>States as colored circles with names inside</li>
<li>Current state glowing or highlighted</li>
<li>Arrows showing transitions with input labels</li>
<li>Inactive states shown dimmer</li>
<li>Clean, uncluttered layout emphasizing one-at-a-time nature</li>
</ul>
<p>Implementation: p5.js with state tracking and transition animation</p>
</details>
<p>How many states do you need? That depends entirely on what your system needs to remember:</p>
<ul>
<li><strong>Remembering one binary choice</strong>: 2 states (e.g., ON/OFF)</li>
<li><strong>Remembering a sequence position</strong>: As many states as sequence steps</li>
<li><strong>Remembering multiple independent things</strong>: States multiply (3 options × 4 options = 12 states)</li>
</ul>
<p>A system that needs to track both whether it's powered on (2 choices) and which of 4 modes it's in (4 choices) needs <span class="arithmatex">\(2 \times 4 = 8\)</span> states, not 6.</p>
<h2 id="state-transition-the-rules-of-movement">State Transition: The Rules of Movement</h2>
<p>A <strong>State Transition</strong> defines how the system moves from one state to another based on inputs. Transitions are the dynamics of your FSM—they answer the question "what happens next?"</p>
<p>Every transition has three components:</p>
<ol>
<li><strong>Source state</strong>: Where you're coming from</li>
<li><strong>Input condition</strong>: What triggers the transition</li>
<li><strong>Destination state</strong>: Where you're going</li>
</ol>
<p>We can write transitions in several ways:</p>
<p><strong>Text notation</strong>: <code>STATE_A --[input=1]--&gt; STATE_B</code></p>
<p><strong>Table notation</strong>:</p>
<table>
<thead>
<tr>
<th>Current State</th>
<th>Input</th>
<th>Next State</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATE_A</td>
<td>1</td>
<td>STATE_B</td>
</tr>
<tr>
<td>STATE_A</td>
<td>0</td>
<td>STATE_A</td>
</tr>
</tbody>
</table>
<p><strong>Equation notation</strong>: If in STATE_A and input=1, then next_state = STATE_B</p>
<p>Important rules for transitions:</p>
<ul>
<li><strong>Deterministic</strong>: For any state and input combination, there's exactly one transition (one next state)</li>
<li><strong>Complete</strong>: Every state must have a transition defined for every possible input</li>
<li><strong>Self-loops allowed</strong>: A state can transition to itself (stay in place)</li>
</ul>
<p>What happens if you don't define a transition for some input? That's a design error. The system won't know what to do, and in real hardware, undefined behavior leads to unpredictable results.</p>
<div class="admonition warning">
<p class="admonition-title">Don't Forget the Default Cases</p>
<p>When designing FSMs, it's easy to focus on the "interesting" transitions and forget the cases where nothing happens. Always ask: "What should the system do if it's in state X and receives an unexpected input?" Usually, the answer is "stay in state X" (a self-loop).</p>
</div>
<p>Consider a simple sequence detector that looks for the pattern "01":</p>
<table>
<thead>
<tr>
<th>Current State</th>
<th>Input</th>
<th>Next State</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDLE</td>
<td>0</td>
<td>SAW_0</td>
<td>First 0 seen, looking for 1</td>
</tr>
<tr>
<td>IDLE</td>
<td>1</td>
<td>IDLE</td>
<td>Wrong start, keep waiting</td>
</tr>
<tr>
<td>SAW_0</td>
<td>0</td>
<td>SAW_0</td>
<td>Another 0, still valid start</td>
</tr>
<tr>
<td>SAW_0</td>
<td>1</td>
<td>DETECTED</td>
<td>Pattern complete!</td>
</tr>
<tr>
<td>DETECTED</td>
<td>0</td>
<td>SAW_0</td>
<td>Start of new pattern</td>
</tr>
<tr>
<td>DETECTED</td>
<td>1</td>
<td>IDLE</td>
<td>Pattern broken, reset</td>
</tr>
</tbody>
</table>
<p>Notice how every state-input pair has exactly one outcome. No ambiguity, no missing cases.</p>
<h2 id="current-state-and-next-state-times-arrow">Current State and Next State: Time's Arrow</h2>
<p>In FSM design, we constantly distinguish between <strong>Current State</strong> (where we are now) and <strong>Next State</strong> (where we'll be after the clock edge).</p>
<p>This distinction maps directly to our flip-flop knowledge from Chapter 8:</p>
<ul>
<li><strong>Current state</strong> is stored in flip-flops (the <span class="arithmatex">\(Q\)</span> outputs)</li>
<li><strong>Next state</strong> is computed by combinational logic (feeds the <span class="arithmatex">\(D\)</span> inputs)</li>
<li>At each <strong>clock edge</strong>, next state becomes current state</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code>                    ┌──────────────────────┐
Current State ──────┤                      │
(Q outputs)         │   Combinational      ├──── Next State
                    │   (Next State        │     (D inputs)
Inputs ─────────────┤    Logic)            │
                    └──────────────────────┘
                              │
                              └──── fed back to flip-flops
</code></pre></div></td></tr></table></div>
<p>This is the fundamental FSM equation in action:</p>
<div class="arithmatex">\[S^+ = f(S, I)\]</div>
<p>Where:</p>
<ul>
<li><span class="arithmatex">\(S^+\)</span> is the next state</li>
<li><span class="arithmatex">\(S\)</span> is the current state</li>
<li><span class="arithmatex">\(I\)</span> is the current inputs</li>
<li><span class="arithmatex">\(f\)</span> is the next-state function (defined by your transition table)</li>
</ul>
<p>At every clock edge, the flip-flops perform the update:</p>
<div class="arithmatex">\[S \leftarrow S^+\]</div>
<p>The separation between current and next state is what makes FSMs <em>synchronous</em>—all state changes happen simultaneously at clock edges, not whenever some random signal changes.</p>
<h4 id="diagram-current-state-to-next-state-flow">Diagram: Current State to Next State Flow</h4>
<iframe src="../../sims/current-next-state/main.html" width="100%" height="500px" scrolling="no"></iframe>

<details>
<summary>Current State to Next State Flow</summary>
<p>Type: microsim</p>
<p>Bloom Level: Understand (L2)
Bloom Verb: Describe</p>
<p>Learning Objective: Students will be able to describe how the next state is computed from the current state and inputs, and how the clock edge causes the transition to occur.</p>
<p>Instructional Rationale: Animating the flow from current state through next-state logic to next state, with clock edge triggering the update, makes the synchronous nature of FSMs concrete.</p>
<p>Canvas Layout:</p>
<ul>
<li>Left: Current state register (flip-flops) with Q outputs</li>
<li>Center: Next-state logic cloud with inputs feeding in</li>
<li>Right: Next state values (D inputs to flip-flops)</li>
<li>Bottom: Clock waveform with trigger button</li>
<li>Top: Visual of current vs next state values</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Input toggles to change external inputs</li>
<li>Current state display</li>
<li>Next state preview (computed but not yet latched)</li>
<li>Clock edge button to trigger state update</li>
<li>Animation showing data flow through the system</li>
<li>Step-by-step mode vs continuous clock mode</li>
<li>State equation display</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>Current state (binary and symbolic name)</li>
<li>All inputs</li>
<li>Next state computation (shows logic)</li>
<li>Next state result</li>
<li>Comparison of current vs next</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>Flip-flops shown as storage elements</li>
<li>Combinational logic as cloud/box</li>
<li>Data flow shown with animated arrows</li>
<li>Clock edge as rising pulse</li>
<li>State change animation at edge</li>
<li>Color distinction between current (blue) and next (orange)</li>
</ul>
<p>Implementation: p5.js with synchronized state updates and flow animation</p>
</details>
<p>Think of it this way: the current state is like your bank balance right now. The next state is what your balance will be after the next transaction (computed but not yet posted). The clock edge is when the bank "posts" the transaction and your balance actually changes.</p>
<h2 id="next-state-logic-the-decision-maker">Next State Logic: The Decision Maker</h2>
<p><strong>Next State Logic</strong> is the combinational circuit that computes what the next state should be based on the current state and inputs. It's the "brain" of your FSM.</p>
<p>The next state logic implements the transition table we've been drawing. For each combination of current state and inputs, it produces the next state.</p>
<p>Here's how it fits in the FSM architecture:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code>           ┌─────────────────────────────────────┐
           │                                     │
           ▼                                     │
    ┌────────────┐     ┌───────────────┐    ┌───┴───┐
    │   Next     │     │    State      │    │ Output │
    │   State    │────▶│   Register    │───▶│  Logic │──▶ Outputs
    │   Logic    │     │  (Flip-Flops) │    │        │
    └────────────┘     └───────────────┘    └────────┘
           ▲                   │
           │                   │
    Inputs │                   │ Current State
           │                   │
           └───────────────────┘
</code></pre></div></td></tr></table></div>
<p>Designing next state logic:</p>
<ol>
<li><strong>Start with the transition table</strong></li>
<li><strong>Assign binary codes to states</strong> (state encoding)</li>
<li><strong>Write Boolean equations for each flip-flop input</strong></li>
<li><strong>Simplify using K-maps or Boolean algebra</strong></li>
<li><strong>Implement with gates</strong></li>
</ol>
<p>Example: For a 2-bit state register (states encoded as 00, 01, 10, 11), you need equations for <span class="arithmatex">\(D_1\)</span> and <span class="arithmatex">\(D_0\)</span>:</p>
<p>[D_1 = f_1(Q_1, Q_0, inputs)]
[D_0 = f_0(Q_1, Q_0, inputs)]</p>
<p>These are just combinational logic functions—the same kind you've been designing since Chapter 4!</p>
<div class="admonition tip">
<p class="admonition-title">Next State Logic Is Just Combinational Logic</p>
<p>Don't let the FSM terminology intimidate you. The "next state logic" is simply combinational logic that you already know how to design. The inputs are state bits and external inputs. The outputs are the D inputs to your flip-flops.</p>
</div>
<h2 id="output-logic-speaking-to-the-world">Output Logic: Speaking to the World</h2>
<p><strong>Output Logic</strong> is the combinational circuit that generates the FSM's outputs based on current state (and possibly inputs). It's how your FSM communicates its decisions to the outside world.</p>
<p>Outputs might include:</p>
<ul>
<li><strong>Control signals</strong>: Enable a counter, start a motor, trigger an alarm</li>
<li><strong>Status indicators</strong>: LEDs, displays, ready/busy flags</li>
<li><strong>Data selects</strong>: Mux controls, memory addresses</li>
<li><strong>Handshaking</strong>: Request, acknowledge, valid signals</li>
</ul>
<p>Output logic comes in two flavors, depending on whether outputs depend only on state (Moore) or on state plus inputs (Mealy). We'll explore this distinction shortly.</p>
<p>The position of output logic in the architecture:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code>                                    ┌──────────────┐
Current State ─────────────────────▶│              │
                                    │   Output     │──▶ Outputs
Inputs ─────────────────────────────▶│   Logic     │
(only for Mealy machines)           │              │
                                    └──────────────┘
</code></pre></div></td></tr></table></div>
<p>Like next state logic, output logic is purely combinational. You derive it from the output specifications in your state table.</p>
<p>Example output equations for a traffic light controller:</p>
<p>[RED = Q_1 \cdot Q_0]
[YELLOW = Q_1 \cdot \overline{Q_0}]
[GREEN = \overline{Q_1} \cdot Q_0 + \overline{Q_1} \cdot \overline{Q_0}]</p>
<p>These equations turn on the appropriate light based on the encoded state value.</p>
<h2 id="moore-machine-outputs-depend-only-on-state">Moore Machine: Outputs Depend Only on State</h2>
<p>A <strong>Moore Machine</strong> is an FSM where outputs depend <em>only</em> on the current state—not on the inputs.</p>
<p>Named after Edward Moore who formalized this model in 1956, Moore machines have a clean separation between what you're doing (state) and what you're reacting to (inputs).</p>
<p>Key characteristics:</p>
<ul>
<li>Outputs change only when state changes</li>
<li>Outputs are "associated with" states, not transitions</li>
<li>Output logic uses only state bits as inputs</li>
<li>Outputs are synchronous to the clock (change at clock edges)</li>
</ul>
<p>Moore machine architecture:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code>           ┌─────────────────────────────────────┐
           │                                     │
           ▼                                     │
    ┌────────────┐     ┌───────────────┐    ┌───┴───────┐
    │   Next     │     │    State      │    │  Output   │
    │   State    │────▶│   Register    │───▶│   Logic   │──▶ Outputs
    │   Logic    │     │  (Flip-Flops) │    │ (f of S)  │
    └────────────┘     └───────────────┘    └───────────┘
           ▲                   │
    Inputs │                   │
           └───────────────────┘
</code></pre></div></td></tr></table></div>
<p>Notice: Inputs feed into next state logic but NOT into output logic.</p>
<p>In state diagrams, Moore outputs are written <em>inside</em> the state circles:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>        ┌─────────────┐
        │   STATE_A   │
        │  Out=1      │
        └─────────────┘
</code></pre></div></td></tr></table></div>
<p><strong>Advantages of Moore machines:</strong></p>
<ul>
<li>Outputs are glitch-free (change only at clock edges)</li>
<li>Easier to debug (output tells you the state)</li>
<li>Cleaner timing analysis</li>
<li>More predictable for interface design</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Often need more states to achieve same functionality as Mealy</li>
<li>Outputs respond one clock cycle later to input changes</li>
</ul>
<div class="admonition example">
<p class="admonition-title">Moore Machine Example: Traffic Light</p>
<p>A traffic light controller is naturally a Moore machine. The light color (output) depends only on the state (which phase we're in), not on the inputs (car sensors). When you're in the GREEN state, the green light is on—period. Input sensors affect transitions but not outputs.</p>
</div>
<h2 id="moore-output-the-state-speaks">Moore Output: The State Speaks</h2>
<p>The <strong>Moore Output</strong> is defined as a function of state only:</p>
<div class="arithmatex">\[Output = g(S)\]</div>
<p>Where <span class="arithmatex">\(S\)</span> is the current state and <span class="arithmatex">\(g\)</span> is the output function.</p>
<p>Since there's no input dependency, the output is stable for the entire time the machine is in a given state. It changes only when the state changes (at clock edges).</p>
<h4 id="diagram-moore-machine-simulator">Diagram: Moore Machine Simulator</h4>
<iframe src="../../sims/moore-machine/main.html" width="100%" height="550px" scrolling="no"></iframe>

<details>
<summary>Moore Machine Simulator</summary>
<p>Type: microsim</p>
<p>Bloom Level: Apply (L3)
Bloom Verb: Demonstrate</p>
<p>Learning Objective: Students will be able to demonstrate how Moore machine outputs depend only on the current state by manipulating inputs and observing that outputs change only when state changes, not when inputs change.</p>
<p>Instructional Rationale: Interactive exploration where students change inputs and observe that outputs remain stable until the next clock edge (when state might change) reinforces the Moore machine definition.</p>
<p>Canvas Layout:</p>
<ul>
<li>Left: State diagram with states and transitions</li>
<li>Center: Current state highlighted with output displayed</li>
<li>Right: Timing diagram showing inputs, state, and outputs</li>
<li>Bottom: Input controls and clock trigger</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Input toggle buttons</li>
<li>Clock edge button</li>
<li>Current state indicator</li>
<li>Output value display</li>
<li>Timing diagram that builds over time</li>
<li>Highlight showing output comes from state, not inputs</li>
<li>"Why didn't output change?" callouts when input changes but output doesn't</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>Current state and its associated outputs</li>
<li>Input values</li>
<li>When outputs change (only at state transitions)</li>
<li>Output equation showing state-only dependency</li>
<li>Timing relationship between clock, state, and outputs</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>State diagram with outputs shown inside states</li>
<li>Current state glowing</li>
<li>Output values prominently displayed</li>
<li>Timing diagram with clear cause-effect marking</li>
<li>Arrows from state to output (not from inputs to output)</li>
</ul>
<p>Implementation: p5.js with Moore machine simulation and timing diagram</p>
</details>
<p>Consider a simple 2-state Moore machine:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>State Encoding</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDLE</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>ACTIVE</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>The output equation is trivially:</p>
<div class="arithmatex">\[Output = Q\]</div>
<p>For a more complex Moore machine with 4 states and 2 outputs:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Encoding (Q1 Q0)</th>
<th>LED_A</th>
<th>LED_B</th>
</tr>
</thead>
<tbody>
<tr>
<td>OFF</td>
<td>00</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>STANDBY</td>
<td>01</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>RUNNING</td>
<td>10</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>ERROR</td>
<td>11</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Output equations:</p>
<p>[LED_A = Q_1]
[LED_B = Q_0]</p>
<p>Simple, clean, and glitch-free.</p>
<h2 id="mealy-machine-outputs-react-immediately">Mealy Machine: Outputs React Immediately</h2>
<p>A <strong>Mealy Machine</strong> is an FSM where outputs depend on <em>both</em> the current state and the current inputs.</p>
<p>Named after George Mealy who described this model in 1955, Mealy machines can produce outputs that react immediately to inputs, without waiting for a clock edge.</p>
<p>Key characteristics:</p>
<ul>
<li>Outputs can change whenever inputs change (even between clock edges)</li>
<li>Outputs are "associated with" transitions, not just states</li>
<li>Output logic uses both state bits and inputs</li>
<li>Outputs are asynchronous with respect to the clock</li>
</ul>
<p>Mealy machine architecture:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code>           ┌─────────────────────────────────────┐
           │                                     │
           ▼                                     │
    ┌────────────┐     ┌───────────────┐         │
    │   Next     │     │    State      │         │
    │   State    │────▶│   Register    │─────────┘
    │   Logic    │     │  (Flip-Flops) │
    └────────────┘     └───────────────┘
           ▲                   │
    Inputs │                   │
           │                   ▼
           │            ┌─────────────┐
           └───────────▶│   Output    │──▶ Outputs
                        │ Logic (f of │
                        │  S AND I)   │
                        └─────────────┘
</code></pre></div></td></tr></table></div>
<p>In state diagrams, Mealy outputs are written <em>on the transition arrows</em>:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>        ┌─────────┐   Input/Output   ┌─────────┐
        │ STATE_A │ ───────────────▶ │ STATE_B │
        │         │      1/Y         │         │
        └─────────┘                  └─────────┘
</code></pre></div></td></tr></table></div>
<p><strong>Advantages of Mealy machines:</strong></p>
<ul>
<li>Often fewer states needed for same functionality</li>
<li>Outputs respond to inputs within the same clock cycle</li>
<li>More "reactive" behavior</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Outputs can glitch if inputs are noisy or glitchy</li>
<li>Timing analysis more complex</li>
<li>Outputs may have combinational delay after input changes</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Mealy Output Glitches</p>
<p>Because Mealy outputs depend on combinational logic from inputs, they can produce glitches—brief incorrect values during input transitions. If your outputs drive other sequential logic, these glitches might get captured, causing errors. Register Mealy outputs if this is a concern.</p>
</div>
<h2 id="mealy-output-react-and-respond">Mealy Output: React and Respond</h2>
<p>The <strong>Mealy Output</strong> is defined as a function of both state and inputs:</p>
<div class="arithmatex">\[Output = h(S, I)\]</div>
<p>Where <span class="arithmatex">\(S\)</span> is the current state, <span class="arithmatex">\(I\)</span> is the inputs, and <span class="arithmatex">\(h\)</span> is the output function.</p>
<h4 id="diagram-mealy-machine-simulator">Diagram: Mealy Machine Simulator</h4>
<iframe src="../../sims/mealy-machine/main.html" width="100%" height="550px" scrolling="no"></iframe>

<details>
<summary>Mealy Machine Simulator</summary>
<p>Type: microsim</p>
<p>Bloom Level: Apply (L3)
Bloom Verb: Demonstrate</p>
<p>Learning Objective: Students will be able to demonstrate how Mealy machine outputs depend on both current state AND inputs by observing output changes that occur immediately when inputs change, without waiting for a clock edge.</p>
<p>Instructional Rationale: Contrasting Mealy behavior with Moore behavior (where outputs don't change between clock edges) makes the distinction clear and memorable.</p>
<p>Canvas Layout:</p>
<ul>
<li>Left: State diagram with transitions labeled Input/Output</li>
<li>Center: Current state with live output calculation</li>
<li>Right: Timing diagram showing immediate output response</li>
<li>Bottom: Input controls and clock trigger</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Input toggle buttons (outputs change immediately!)</li>
<li>Clock edge button (for state transitions)</li>
<li>Current state indicator</li>
<li>Output value display (updates asynchronously to inputs)</li>
<li>Timing diagram showing output changes between clock edges</li>
<li>Side-by-side comparison mode with equivalent Moore machine</li>
<li>Glitch simulation option</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>Current state</li>
<li>Input values</li>
<li>Output values (computed from state AND inputs)</li>
<li>Output equation showing both dependencies</li>
<li>When outputs change (can be between clock edges)</li>
<li>Highlight showing output reacts to input changes</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>State diagram with Input/Output on transitions</li>
<li>Current transition highlighted when triggered</li>
<li>Output values update immediately with input changes</li>
<li>Timing diagram shows asynchronous output behavior</li>
<li>Clear visual difference from Moore simulator</li>
</ul>
<p>Implementation: p5.js with Mealy machine simulation and immediate output updates</p>
</details>
<p>Example: Consider a Mealy machine for a door access controller</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Input</th>
<th>Output</th>
<th>Next State</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOCKED</td>
<td>correct_code=0</td>
<td>unlock=0</td>
<td>LOCKED</td>
</tr>
<tr>
<td>LOCKED</td>
<td>correct_code=1</td>
<td>unlock=1</td>
<td>UNLOCKED</td>
</tr>
<tr>
<td>UNLOCKED</td>
<td>timeout=0</td>
<td>unlock=1</td>
<td>UNLOCKED</td>
</tr>
<tr>
<td>UNLOCKED</td>
<td>timeout=1</td>
<td>unlock=0</td>
<td>LOCKED</td>
</tr>
</tbody>
</table>
<p>In the LOCKED state with correct_code=1, the door unlocks <em>immediately</em> (before the next clock edge), then the state transitions to UNLOCKED.</p>
<p>The output equation:</p>
<div class="arithmatex">\[unlock = (LOCKED \cdot correct\_code) + (UNLOCKED \cdot \overline{timeout})\]</div>
<p>Or in terms of state bits:</p>
<div class="arithmatex">\[unlock = (\overline{Q} \cdot correct\_code) + (Q \cdot \overline{timeout})\]</div>
<p>Notice how the output changes immediately when <code>correct_code</code> goes high, without waiting for a clock edge. This is the defining characteristic of Mealy machines.</p>
<h2 id="moore-vs-mealy-the-great-debate">Moore vs Mealy: The Great Debate</h2>
<p>Here's a side-by-side comparison to help you choose:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Moore Machine</th>
<th>Mealy Machine</th>
</tr>
</thead>
<tbody>
<tr>
<td>Outputs depend on</td>
<td>State only</td>
<td>State AND inputs</td>
</tr>
<tr>
<td>Output timing</td>
<td>Synchronous (at clock edges)</td>
<td>Asynchronous (can change anytime)</td>
</tr>
<tr>
<td>Output glitches</td>
<td>None (clean)</td>
<td>Possible (need care)</td>
</tr>
<tr>
<td>Number of states</td>
<td>Usually more</td>
<td>Usually fewer</td>
</tr>
<tr>
<td>Response latency</td>
<td>One clock cycle</td>
<td>Same clock cycle</td>
</tr>
<tr>
<td>State diagrams</td>
<td>Outputs inside states</td>
<td>Outputs on transitions</td>
</tr>
<tr>
<td>Debugging</td>
<td>Easier (state = output)</td>
<td>Harder (need inputs too)</td>
</tr>
</tbody>
</table>
<p><strong>When to use Moore:</strong></p>
<ul>
<li>Outputs must be glitch-free</li>
<li>Interfacing with other synchronous systems</li>
<li>Simpler debugging is valuable</li>
<li>One clock cycle latency is acceptable</li>
</ul>
<p><strong>When to use Mealy:</strong></p>
<ul>
<li>Minimum state count is important</li>
<li>Immediate response to inputs required</li>
<li>Outputs are registered before use anyway</li>
<li>State machine is simple enough that glitches aren't a concern</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">The Hybrid Approach</p>
<p>Many real designs use registered Mealy outputs—compute outputs as Mealy (from state and inputs) but register them through flip-flops before sending them out. This gives you the state efficiency of Mealy with the clean timing of Moore.</p>
</div>
<p>Here's a classic example showing the state difference:</p>
<p><strong>Sequence detector for "11" (detect when two 1s in a row)</strong></p>
<p>Moore version (3 states):</p>
<ul>
<li>S0: Haven't seen anything useful</li>
<li>S1: Saw one 1</li>
<li>S2: Saw two 1s in a row → output = 1</li>
</ul>
<p>Mealy version (2 states):</p>
<ul>
<li>S0: Haven't seen a 1 recently</li>
<li>S1: Just saw a 1 → if input=1, output=1 (detecting the pattern right now!)</li>
</ul>
<p>The Mealy machine needs one fewer state because it can output the detection signal <em>during</em> the second 1, rather than waiting for a dedicated "detected" state.</p>
<h2 id="state-diagram-a-picture-worth-a-thousand-gates">State Diagram: A Picture Worth a Thousand Gates</h2>
<p>A <strong>State Diagram</strong> is the graphical representation of an FSM, showing states as circles (or rounded rectangles) and transitions as arrows between them.</p>
<p>State diagrams are the most common way to specify FSM behavior during the design phase. They're intuitive, compact, and catch missing transitions at a glance.</p>
<p>Elements of a state diagram:</p>
<ul>
<li><strong>States</strong>: Circles or ovals with state name inside</li>
<li><strong>Initial state</strong>: Indicated by an arrow from nowhere (or filled dot)</li>
<li><strong>Transitions</strong>: Arrows from source state to destination state</li>
<li><strong>Transition labels</strong>: Input conditions that trigger the transition</li>
<li><strong>Outputs</strong>: Inside states (Moore) or on transitions (Mealy)</li>
</ul>
<h4 id="diagram-state-diagram-builder">Diagram: State Diagram Builder</h4>
<iframe src="../../sims/state-diagram-builder/main.html" width="100%" height="600px" scrolling="no"></iframe>

<details>
<summary>Interactive State Diagram</summary>
<p>Type: microsim</p>
<p>Bloom Level: Analyze (L4)
Bloom Verb: Examine</p>
<p>Learning Objective: Students will be able to examine state diagrams to trace execution paths, verify completeness, and identify potential design issues such as missing transitions or unreachable states.</p>
<p>Instructional Rationale: Interactive state diagram with animation of current state and transition highlighting builds intuition for how FSMs execute over time.</p>
<p>Canvas Layout:</p>
<ul>
<li>Main area: State diagram canvas with draggable states</li>
<li>Current state highlighted with animation</li>
<li>Input sequence panel at bottom</li>
<li>Execution trace panel on right</li>
<li>Validation messages for completeness</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Click states to view details</li>
<li>Hover transitions to see conditions</li>
<li>Input sequence entry (type binary string)</li>
<li>Play/step through execution</li>
<li>Highlight current state and taken transition</li>
<li>Warning indicators for incomplete transitions</li>
<li>Reachability analysis button</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>All states with names and outputs</li>
<li>All transitions with conditions</li>
<li>Current state (highlighted)</li>
<li>Input sequence being processed</li>
<li>Execution trace (state history)</li>
<li>Completeness check results</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>Clean state diagram with standard notation</li>
<li>Current state with glow/pulse animation</li>
<li>Active transition arrow highlighted</li>
<li>Input/output labeling consistent with selected mode (Moore/Mealy)</li>
<li>Grid snap for neat layout</li>
<li>Color coding by state type (initial, accepting, normal)</li>
</ul>
<p>Implementation: p5.js with state machine execution engine</p>
</details>
<p>Here's an example state diagram for a simple counter that counts 0→1→2→3→0:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code>        ┌─────────────────────────────────┐
        │                                 │
        ▼                                 │
   ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
──▶│  S0     │────▶│   S1    │────▶│   S2    │────▶│   S3    │
   │ count=0 │     │ count=1 │     │ count=2 │     │ count=3 │
   └─────────┘     └─────────┘     └─────────┘     └─────────┘
        │
        └── Initial state arrow
</code></pre></div></td></tr></table></div>
<p>(All transitions are unconditional on clock edge)</p>
<p>For a more complex example with conditional transitions:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code>            Input=0              Input=0
         ┌─────────┐          ┌─────────┐
         │         ▼          │         ▼
   ┌─────────┐          ┌─────────┐          ┌─────────┐
──▶│  IDLE   │─Input=1─▶│ SAW_1   │─Input=1─▶│DETECTED │
   │  out=0  │          │  out=0  │          │  out=1  │
   └─────────┘          └─────────┘          └─────────┘
                              │                   │
                              │    Input=0        │
                              ▼                   │
                         (back to IDLE)◀──────────┘
</code></pre></div></td></tr></table></div>
<p>State diagrams make it easy to verify:</p>
<ul>
<li><strong>Completeness</strong>: Every state has a transition for every input</li>
<li><strong>Reachability</strong>: Can every state be reached from the initial state?</li>
<li><strong>No dead ends</strong>: Can the machine escape from every state?</li>
</ul>
<h2 id="state-diagram-notation-speaking-the-language">State Diagram Notation: Speaking the Language</h2>
<p><strong>State Diagram Notation</strong> refers to the specific conventions used to represent states, transitions, and outputs in a state diagram.</p>
<p>While there's no single universal standard, common conventions include:</p>
<p><strong>State representation:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>┌──────────────┐
│ STATE_NAME   │  ← State name
│ Output=value │  ← Moore outputs (optional here)
└──────────────┘
</code></pre></div></td></tr></table></div>
<p><strong>Transition representation:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>──── Input_condition ────▶
          │
    Input/Output  ← Mealy notation (Input/Output)
</code></pre></div></td></tr></table></div>
<p><strong>Common notations for transitions:</strong></p>
<table>
<thead>
<tr>
<th>Notation</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X=1</code></td>
<td>Transition when input X equals 1</td>
</tr>
<tr>
<td><code>X</code></td>
<td>Same as X=1 (shorthand)</td>
</tr>
<tr>
<td><code>X'</code> or <code>~X</code></td>
<td>Transition when X equals 0</td>
</tr>
<tr>
<td><code>XY</code></td>
<td>Transition when X AND Y are both 1</td>
</tr>
<tr>
<td><code>X+Y</code></td>
<td>Transition when X OR Y is 1</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Always (unconditional transition)</td>
</tr>
<tr>
<td><code>else</code></td>
<td>Any input not covered by other transitions</td>
</tr>
</tbody>
</table>
<p><strong>Moore notation example:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>┌─────────┐           ┌─────────┐
│  GREEN  │───tmr────▶│ YELLOW  │
│ light=G │           │ light=Y │
└─────────┘           └─────────┘
</code></pre></div></td></tr></table></div>
<p><strong>Mealy notation example:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>┌─────────┐           ┌─────────┐
│  IDLE   │──req/ack─▶│ ACTIVE  │
└─────────┘           └─────────┘
</code></pre></div></td></tr></table></div>
<p>The <code>req/ack</code> means: when input <code>req</code>=1, transition and output <code>ack</code>=1.</p>
<p><strong>Initial state indicators:</strong></p>
<ul>
<li>Arrow from nowhere pointing to initial state</li>
<li>Filled circle with arrow to initial state</li>
<li>Double-circle around initial state</li>
<li>Label "START" or "RESET"</li>
</ul>
<p><strong>Multiple transitions with same destination:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code>        ┌─────┐
        │     │
    X=0 │     │ X=1
        ▼     ▼
    ┌─────────────┐
    │   NEXT      │
    └─────────────┘
</code></pre></div></td></tr></table></div>
<p>Or combined:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>    ─── X=0, X=1 ───▶ (meaning &quot;always&quot;)
</code></pre></div></td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">Notation Varies by Industry</p>
<p>EE courses often use the simple notation shown here. Industrial tools like Simulink or Quartus may use different conventions. The concepts are the same—just learn the specific notation required for your tools.</p>
</div>
<h2 id="state-table-the-complete-specification">State Table: The Complete Specification</h2>
<p>A <strong>State Table</strong> is a tabular representation of an FSM that explicitly lists every combination of current state and inputs, along with the resulting next state and outputs.</p>
<p>State tables are more verbose than state diagrams but are essential for:</p>
<ul>
<li>Systematic derivation of Boolean equations</li>
<li>Verification that all cases are covered</li>
<li>Input to CAD tools that synthesize hardware</li>
</ul>
<p>A complete state table has columns for:</p>
<ul>
<li>Current state</li>
<li>Each input (or input combination)</li>
<li>Next state</li>
<li>Each output</li>
</ul>
<p><strong>Moore machine state table format:</strong></p>
<table>
<thead>
<tr>
<th>Current State</th>
<th>Input</th>
<th>Next State</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>(determined by state only)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note: In a Moore table, output can be listed separately since it depends only on current state.</p>
<p><strong>Mealy machine state table format:</strong></p>
<table>
<thead>
<tr>
<th>Current State</th>
<th>Input</th>
<th>Next State</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>(output varies with input combination)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example: Sequence detector for "01" pattern</p>
<p><strong>Moore-style state table:</strong></p>
<table>
<thead>
<tr>
<th>Current State</th>
<th>State Encoding</th>
<th>Input X</th>
<th>Next State</th>
<th>Output Z</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDLE</td>
<td>00</td>
<td>0</td>
<td>SAW_0</td>
<td>0</td>
</tr>
<tr>
<td>IDLE</td>
<td>00</td>
<td>1</td>
<td>IDLE</td>
<td>0</td>
</tr>
<tr>
<td>SAW_0</td>
<td>01</td>
<td>0</td>
<td>SAW_0</td>
<td>0</td>
</tr>
<tr>
<td>SAW_0</td>
<td>01</td>
<td>1</td>
<td>FOUND</td>
<td>0</td>
</tr>
<tr>
<td>FOUND</td>
<td>10</td>
<td>0</td>
<td>SAW_0</td>
<td>1</td>
</tr>
<tr>
<td>FOUND</td>
<td>10</td>
<td>1</td>
<td>IDLE</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>From this table, we can derive:</p>
<p><strong>Next state equations:</strong></p>
<div class="arithmatex">\[Q_1^+ = Q_0 \cdot X\]</div>
<div class="arithmatex">\[Q_0^+ = \overline{X}\]</div>
<p><strong>Output equation:</strong></p>
<div class="arithmatex">\[Z = Q_1\]</div>
<h4 id="diagram-state-table-to-circuit">Diagram: State Table to Circuit</h4>
<iframe src="../../sims/state-table-circuit/main.html" width="100%" height="600px" scrolling="no"></iframe>

<details>
<summary>State Table to Circuit Derivation</summary>
<p>Type: microsim</p>
<p>Bloom Level: Apply (L3)
Bloom Verb: Implement</p>
<p>Learning Objective: Students will be able to implement an FSM circuit from a state table by deriving next-state and output equations and connecting them to flip-flops.</p>
<p>Instructional Rationale: Step-by-step derivation from state table through Boolean equations to circuit implementation makes the design process concrete and repeatable.</p>
<p>Canvas Layout:</p>
<ul>
<li>Left: Editable state table</li>
<li>Center: K-map or equation derivation area</li>
<li>Right: Generated circuit schematic</li>
<li>Bottom: Simulation controls to verify the design</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Edit state table entries</li>
<li>Auto-generate K-maps for next state and outputs</li>
<li>Highlight which row of table applies to current state/input</li>
<li>Step through: table → K-map → equation → circuit</li>
<li>Simulate the resulting circuit</li>
<li>Compare simulation results to table specification</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>State table with all entries</li>
<li>Derived Boolean equations</li>
<li>K-maps showing minimization</li>
<li>Circuit schematic</li>
<li>Current state/input/output during simulation</li>
<li>Match/mismatch indicator between spec and implementation</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>Clean tabular display</li>
<li>K-maps with standard formatting</li>
<li>Circuit schematic with D flip-flops and gates</li>
<li>Highlighting to show derivation steps</li>
<li>Animation of simulation through the circuit</li>
</ul>
<p>Implementation: p5.js with K-map solver and circuit rendering</p>
</details>
<p>The beauty of state tables is their completeness—every possible combination is explicitly defined, leaving no ambiguity.</p>
<h2 id="state-encoding-giving-states-binary-names">State Encoding: Giving States Binary Names</h2>
<p><strong>State Encoding</strong> is the process of assigning binary codes (flip-flop values) to abstract states. Since flip-flops store binary values, we need to translate state names like "IDLE" and "RUNNING" into patterns like "00" and "01".</p>
<p>For an FSM with <span class="arithmatex">\(N\)</span> states, we need at least <span class="arithmatex">\(\lceil \log_2 N \rceil\)</span> flip-flops.</p>
<table>
<thead>
<tr>
<th>Number of States</th>
<th>Minimum Flip-Flops Needed</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3-4</td>
<td>2</td>
</tr>
<tr>
<td>5-8</td>
<td>3</td>
</tr>
<tr>
<td>9-16</td>
<td>4</td>
</tr>
<tr>
<td>17-32</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>The encoding choice significantly affects:</p>
<ul>
<li><strong>Circuit complexity</strong>: Some encodings lead to simpler next-state logic</li>
<li><strong>Hazards and glitches</strong>: Some encodings minimize output glitches</li>
<li><strong>Speed</strong>: More flip-flops mean wider datapaths but potentially simpler logic</li>
<li><strong>Power consumption</strong>: One-hot encoding has more flip-flops but fewer transitions</li>
</ul>
<p>Common encoding strategies:</p>
<ol>
<li><strong>Binary encoding</strong>: Minimum flip-flops, states numbered 0, 1, 2, ...</li>
<li><strong>One-hot encoding</strong>: One flip-flop per state, exactly one is hot</li>
<li><strong>Gray code encoding</strong>: Adjacent states differ by only one bit</li>
</ol>
<p>Let's explore each in detail.</p>
<h2 id="binary-encoding-the-compact-choice">Binary Encoding: The Compact Choice</h2>
<p><strong>Binary Encoding</strong> (also called dense encoding) uses the minimum number of flip-flops by assigning sequential binary numbers to states.</p>
<p>For 4 states:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Binary Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0</td>
<td>00</td>
</tr>
<tr>
<td>S1</td>
<td>01</td>
</tr>
<tr>
<td>S2</td>
<td>10</td>
</tr>
<tr>
<td>S3</td>
<td>11</td>
</tr>
</tbody>
</table>
<p><strong>Advantages:</strong></p>
<ul>
<li>Minimum number of flip-flops</li>
<li>Natural if states represent a count</li>
<li>Commonly supported by synthesis tools</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Next-state logic can be complex</li>
<li>Multiple bits may change simultaneously (glitch potential)</li>
<li>Decoding state requires logic</li>
</ul>
<p>Binary encoding example for a 3-state FSM:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Code (Q1 Q0)</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDLE</td>
<td>00</td>
</tr>
<tr>
<td>PROCESS</td>
<td>01</td>
</tr>
<tr>
<td>DONE</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Code "11" is unused—a "don't care" that can simplify next-state logic.</p>
<h4 id="diagram-state-encoding-comparison">Diagram: State Encoding Comparison</h4>
<iframe src="../../sims/state-encoding-compare/main.html" width="100%" height="550px" scrolling="no"></iframe>

<details>
<summary>State Encoding Comparison Tool</summary>
<p>Type: microsim</p>
<p>Bloom Level: Evaluate (L5)
Bloom Verb: Compare</p>
<p>Learning Objective: Students will be able to compare binary, one-hot, and Gray code encodings for the same FSM, evaluating trade-offs in flip-flop count, next-state logic complexity, and transition behavior.</p>
<p>Instructional Rationale: Side-by-side comparison of the same FSM with different encodings reveals how encoding choice affects implementation complexity and circuit behavior.</p>
<p>Canvas Layout:</p>
<ul>
<li>Top: FSM state diagram (same for all encodings)</li>
<li>Center: Three columns showing Binary, One-Hot, and Gray encodings</li>
<li>Each column shows: encoding table, flip-flop count, logic complexity estimate</li>
<li>Bottom: Transition animation showing bit changes</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Select different FSMs to encode</li>
<li>Cycle through states to see bit patterns</li>
<li>Count simultaneous bit transitions</li>
<li>Toggle between encodings</li>
<li>Show/hide derived logic equations</li>
<li>Complexity metric comparison</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>All state encodings side by side</li>
<li>Number of flip-flops for each</li>
<li>Number of gates (estimated) for each</li>
<li>Bit transitions per state change</li>
<li>Which encoding is "best" for different criteria</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>Clean comparison table layout</li>
<li>Color-coded encodings</li>
<li>Transition visualization showing changing bits</li>
<li>Complexity bar chart comparison</li>
<li>Highlight differences between encodings</li>
</ul>
<p>Implementation: p5.js with encoding generator and complexity estimator</p>
</details>
<h2 id="one-hot-encoding-one-bit-per-state">One-Hot Encoding: One Bit Per State</h2>
<p><strong>One-Hot Encoding</strong> uses one flip-flop per state. Exactly one flip-flop is "1" (hot) at any time, identifying the current state.</p>
<p>For 4 states:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>One-Hot Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0</td>
<td>0001</td>
</tr>
<tr>
<td>S1</td>
<td>0010</td>
</tr>
<tr>
<td>S2</td>
<td>0100</td>
</tr>
<tr>
<td>S3</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p><strong>Advantages:</strong></p>
<ul>
<li>Very simple next-state logic (often just AND-OR)</li>
<li>Easy to decode current state (just read the hot bit)</li>
<li>Simple output logic</li>
<li>Only one bit changes per transition (no glitches)</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Many more flip-flops (one per state)</li>
<li>Wasted encoding space (<span class="arithmatex">\(2^N\)</span> codes, only <span class="arithmatex">\(N\)</span> used)</li>
<li>Invalid states possible if multiple bits become hot</li>
</ul>
<p>One-hot is especially popular in FPGAs where flip-flops are abundant but complex logic is expensive.</p>
<p><strong>Next-state equations are trivial:</strong></p>
<p>To set state S2 hot:</p>
<div class="arithmatex">\[Q_{S2}^+ = (\text{S1 hot AND transition\_to\_S2}) + (\text{S0 hot AND transition\_to\_S2}) + ...\]</div>
<p>Each equation is just an OR of the incoming transition conditions.</p>
<div class="admonition tip">
<p class="admonition-title">FPGAs Love One-Hot</p>
<p>Modern FPGAs have lots of flip-flops but limited routing and logic resources. One-hot encoding trades flip-flops for simpler logic, often resulting in faster and smaller designs on FPGAs. Many synthesis tools default to one-hot for FSMs.</p>
</div>
<h2 id="gray-code-encoding-smooth-transitions">Gray Code Encoding: Smooth Transitions</h2>
<p><strong>Gray Code Encoding</strong> assigns codes so that adjacent states (states connected by transitions) differ by only one bit.</p>
<p>Standard Gray code for 4 states:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Gray Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0</td>
<td>00</td>
</tr>
<tr>
<td>S1</td>
<td>01</td>
</tr>
<tr>
<td>S2</td>
<td>11</td>
</tr>
<tr>
<td>S3</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Notice: S0→S1→S2→S3→S0 each changes only one bit.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Only one bit changes per transition (minimal switching)</li>
<li>Reduces glitches on outputs</li>
<li>Lower power consumption (fewer transistor switches)</li>
<li>Avoids hazards in asynchronous interfaces</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Only works perfectly for cyclic sequences</li>
<li>Irregular FSMs may not benefit</li>
<li>Can't always achieve single-bit transitions for all state pairs</li>
</ul>
<p>Gray code is particularly useful for:</p>
<ul>
<li>Counters (where states are sequential)</li>
<li>Asynchronous domain crossings (single-bit changes are safer)</li>
<li>Low-power designs</li>
<li>ADC/DAC encoder wheels</li>
</ul>
<p>Example: Gray-coded 3-bit counter</p>
<table>
<thead>
<tr>
<th>Count</th>
<th>Binary</th>
<th>Gray</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>000</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>001</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>011</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>010</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>101</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>Binary 3→4 changes THREE bits (011→100). Gray 3→4 changes ONE bit (010→110). Much safer for asynchronous reads!</p>
<h2 id="state-assignment-optimizing-the-encoding">State Assignment: Optimizing the Encoding</h2>
<p><strong>State Assignment</strong> is the process of choosing which specific binary code to assign to each state to optimize the circuit for some criterion (usually minimum gate count or maximum speed).</p>
<p>Beyond the basic encoding strategies, you can further optimize by:</p>
<ol>
<li><strong>Analyzing transition patterns</strong>: Put frequently transitioning states close together (differ by fewer bits)</li>
<li><strong>Output-oriented assignment</strong>: States with same outputs get similar codes</li>
<li><strong>Don't-care exploitation</strong>: Unused codes can simplify logic</li>
<li><strong>Adjacent encoding</strong>: States that share transitions get adjacent codes</li>
</ol>
<p>Classical state assignment rules (heuristics):</p>
<ul>
<li><strong>Rule 1</strong>: States with the same next state should be adjacent (differ by one bit)</li>
<li><strong>Rule 2</strong>: States that are next states of the same state should be adjacent</li>
<li><strong>Rule 3</strong>: States with the same output should be adjacent (for Moore machines)</li>
</ul>
<p>These rules help group 1s together in K-maps, enabling larger groupings and simpler equations.</p>
<p>Example: Consider two possible encodings for the same 4-state FSM:</p>
<p><strong>Encoding A (arbitrary):</strong>
| State | Code |
|-------|------|
| IDLE | 00 |
| READ | 01 |
| WRITE | 10 |
| DONE | 11 |</p>
<p><strong>Encoding B (optimized based on transitions):</strong>
| State | Code |
|-------|------|
| IDLE | 00 |
| READ | 01 |
| DONE | 11 |
| WRITE | 10 |</p>
<p>If IDLE→READ and READ→DONE are the most common transitions, Encoding B keeps them adjacent (one bit change).</p>
<div class="admonition note">
<p class="admonition-title">Let the Tools Help</p>
<p>Modern synthesis tools have sophisticated state assignment algorithms. For small FSMs, manual optimization is educational. For large FSMs, let the tools do the heavy lifting—they can evaluate millions of possible assignments.</p>
</div>
<h2 id="state-minimization-fewer-states-simpler-circuits">State Minimization: Fewer States, Simpler Circuits</h2>
<p><strong>State Minimization</strong> is the process of reducing the number of states in an FSM without changing its external behavior.</p>
<p>Why minimize states?</p>
<ul>
<li>Fewer states = fewer flip-flops</li>
<li>Simpler next-state and output logic</li>
<li>Faster circuits</li>
<li>Lower power consumption</li>
</ul>
<p>Two states are <strong>equivalent</strong> if:</p>
<ol>
<li>They produce the same outputs for all inputs</li>
<li>They transition to equivalent next states for all inputs</li>
</ol>
<p>If two states are equivalent, we can merge them into one.</p>
<p><strong>Algorithm for state minimization:</strong></p>
<ol>
<li><strong>Group states by outputs</strong>: States with different outputs can't be equivalent</li>
<li><strong>Refine by next-state behavior</strong>: Split groups where states go to non-equivalent next states</li>
<li><strong>Repeat until stable</strong>: When no more splitting is needed, remaining groups contain equivalent states</li>
<li><strong>Merge equivalent states</strong>: Replace each group with a single state</li>
</ol>
<p>Example of minimizable FSM:</p>
<p>Original (4 states):</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Input=0</th>
<th>Input=1</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>B</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>D</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>D</td>
<td>D</td>
<td>C</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Analysis:</p>
<ul>
<li>A and B have same outputs (0) and same transitions → EQUIVALENT</li>
<li>C and D have same outputs (1) and same transitions → EQUIVALENT</li>
</ul>
<p>Minimized (2 states):</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Input=0</th>
<th>Input=1</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>AB</td>
<td>AB</td>
<td>CD</td>
<td>0</td>
</tr>
<tr>
<td>CD</td>
<td>CD</td>
<td>CD</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>We went from 4 states (2 flip-flops) to 2 states (1 flip-flop)!</p>
<h4 id="diagram-state-minimization-visualizer">Diagram: State Minimization Visualizer</h4>
<iframe src="../../sims/state-minimization/main.html" width="100%" height="550px" scrolling="no"></iframe>

<details>
<summary>State Minimization Step-by-Step</summary>
<p>Type: microsim</p>
<p>Bloom Level: Analyze (L4)
Bloom Verb: Differentiate</p>
<p>Learning Objective: Students will be able to differentiate between equivalent and non-equivalent states by applying the state minimization algorithm and identifying which states can be merged.</p>
<p>Instructional Rationale: Step-by-step visualization of the partitioning algorithm, showing how groups are split based on distinguishing sequences, makes the abstract algorithm concrete.</p>
<p>Canvas Layout:</p>
<ul>
<li>Left: Original state table</li>
<li>Center: Partitioning process visualization</li>
<li>Right: Minimized state table</li>
<li>Bottom: Step-by-step controls and explanation</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Step through minimization algorithm</li>
<li>Highlight current partition groups</li>
<li>Show why groups split (distinguishing input sequences)</li>
<li>Compare original and minimized FSM</li>
<li>Verify equivalence through simulation</li>
<li>Try custom FSMs</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>Original states and transitions</li>
<li>Current partition (equivalent state groups)</li>
<li>Reason for each split</li>
<li>Final equivalence classes</li>
<li>Minimized FSM</li>
<li>State count reduction</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>Color-coded equivalence classes</li>
<li>Partition tree showing splits</li>
<li>Before/after state diagrams</li>
<li>Clear step indicators</li>
<li>Merge animation for equivalent states</li>
</ul>
<p>Implementation: p5.js with partition refinement algorithm</p>
</details>
<p>State minimization is especially important when:</p>
<ul>
<li>The FSM was specified without concern for redundancy</li>
<li>Converting from one representation to another introduced extra states</li>
<li>Multiple designers contributed states that duplicate functionality</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Minimize Before Encoding</p>
<p>Always minimize your FSM before choosing a state encoding. There's no point optimizing the encoding for states you'll end up eliminating!</p>
</div>
<h2 id="the-fsm-design-process-from-words-to-gates">The FSM Design Process: From Words to Gates</h2>
<p>Let's put everything together with a complete FSM design flow:</p>
<p><strong>Step 1: Understand the problem</strong></p>
<ul>
<li>What are the inputs and outputs?</li>
<li>What sequence of operations is needed?</li>
<li>What must the system "remember"?</li>
</ul>
<p><strong>Step 2: Draw the state diagram</strong></p>
<ul>
<li>Identify the states (distinct situations)</li>
<li>Draw transitions (what causes state changes)</li>
<li>Label outputs (Moore: inside states; Mealy: on transitions)</li>
<li>Mark the initial state</li>
</ul>
<p><strong>Step 3: Create the state table</strong></p>
<ul>
<li>List all state-input combinations</li>
<li>Fill in next states and outputs</li>
<li>Verify completeness (no missing entries)</li>
</ul>
<p><strong>Step 4: Minimize states (optional but recommended)</strong></p>
<ul>
<li>Find and merge equivalent states</li>
<li>Simplify the state table</li>
</ul>
<p><strong>Step 5: Choose state encoding</strong></p>
<ul>
<li>Select binary, one-hot, Gray, or custom</li>
<li>Assign codes to each state</li>
</ul>
<p><strong>Step 6: Derive next-state equations</strong></p>
<ul>
<li>Use K-maps or Boolean algebra</li>
<li>Simplify the equations</li>
</ul>
<p><strong>Step 7: Derive output equations</strong></p>
<ul>
<li>Moore: Function of state only</li>
<li>Mealy: Function of state and inputs</li>
</ul>
<p><strong>Step 8: Implement the circuit</strong></p>
<ul>
<li>D flip-flops for state storage</li>
<li>Combinational logic for next-state and outputs</li>
<li>Don't forget the reset!</li>
</ul>
<p><strong>Step 9: Verify</strong></p>
<ul>
<li>Simulate with test inputs</li>
<li>Check all transitions</li>
<li>Verify timing requirements</li>
</ul>
<h4 id="diagram-complete-fsm-design-flow">Diagram: Complete FSM Design Flow</h4>
<iframe src="../../sims/fsm-design-flow/main.html" width="100%" height="600px" scrolling="no"></iframe>

<details>
<summary>Complete FSM Design Workflow</summary>
<p>Type: workflow</p>
<p>Bloom Level: Create (L6)
Bloom Verb: Design</p>
<p>Learning Objective: Students will be able to design a complete FSM from a word problem by following the systematic design flow from problem statement through state diagram, state table, encoding, equations, to circuit implementation.</p>
<p>Instructional Rationale: Guided workflow that takes students through each step of FSM design, with verification at each stage, builds confidence in the complete design process.</p>
<p>Canvas Layout:</p>
<ul>
<li>Main area: Current design stage with workspace</li>
<li>Left sidebar: Stage navigation (8 steps)</li>
<li>Right sidebar: Design artifacts (state diagram, table, equations)</li>
<li>Bottom: Verification and navigation controls</li>
</ul>
<p>Interactive Elements:</p>
<ul>
<li>Select from example problems or enter custom</li>
<li>Draw/edit state diagram</li>
<li>Edit state table entries</li>
<li>Choose encoding strategy</li>
<li>Derive equations (auto-check for errors)</li>
<li>Generate circuit schematic</li>
<li>Simulate the result</li>
<li>Verify against original specification</li>
</ul>
<p>Data Visibility:</p>
<ul>
<li>Current design stage</li>
<li>All artifacts created so far</li>
<li>Consistency checks between stages</li>
<li>Error indicators</li>
<li>Simulation results vs. expected behavior</li>
</ul>
<p>Visual Style:</p>
<ul>
<li>Workflow progress indicator</li>
<li>Clean workspace for each stage</li>
<li>Artifacts persist in sidebar as you progress</li>
<li>Verification checkmarks</li>
<li>Final circuit with highlighted correspondence to earlier stages</li>
</ul>
<p>Implementation: p5.js with multi-stage design environment</p>
</details>
<h2 id="example-designing-a-vending-machine-controller">Example: Designing a Vending Machine Controller</h2>
<p>Let's design a simple vending machine FSM from scratch. The machine:</p>
<ul>
<li>Accepts nickels (5¢) and dimes (10¢)</li>
<li>Dispenses a 15¢ item when enough money is inserted</li>
<li>Gives change if overpaid (20¢ inserted)</li>
</ul>
<p><strong>Step 1: Inputs and Outputs</strong></p>
<p>Inputs:</p>
<ul>
<li>N: Nickel inserted</li>
<li>D: Dime inserted</li>
</ul>
<p>Outputs:</p>
<ul>
<li>DISPENSE: Release the item</li>
<li>CHANGE: Give a nickel back</li>
</ul>
<p><strong>Step 2: State Diagram</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span></pre></div></td><td class="code"><div><pre><span></span><code>                    ┌─N/─┐
                    │    ▼
              ┌─────────────┐
              │     0¢      │
   ───────────│  (start)    │
              │ DISP=0,CH=0 │
              └─────────────┘
                    │ D
              ┌─────┴─────┐ N
              │           ├────────┐
              ▼           │        ▼
        ┌───────────┐     │  ┌───────────┐
        │    10¢    │     │  │     5¢    │
        │ DISP=0    │     │  │ DISP=0    │
        │ CH=0      │     │  │ CH=0      │
        └───────────┘     │  └───────────┘
              │           │        │
           N  │ D         │ N      │ D
              │           │        │
        ┌─────┴───────────┴────────┴─────┐
        │                                │
        ▼           ▼                    ▼
   ┌───────────┐  ┌───────────┐    ┌───────────┐
   │   15¢     │  │   20¢     │    │   15¢     │
   │ DISP=1    │  │ DISP=1    │    │ DISP=1    │
   │ CH=0      │  │ CH=1      │    │ CH=0      │
   └───────────┘  └───────────┘    └───────────┘
        │              │                │
        └──────────────┴────────────────┘
                       │
                       ▼
                  (back to 0¢)
</code></pre></div></td></tr></table></div>
<p>Actually, let me simplify this with a cleaner state table approach.</p>
<p><strong>States:</strong></p>
<table>
<thead>
<tr>
<th>State</th>
<th>Amount Collected</th>
<th>Encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0</td>
<td>0¢</td>
<td>00</td>
</tr>
<tr>
<td>S5</td>
<td>5¢</td>
<td>01</td>
</tr>
<tr>
<td>S10</td>
<td>10¢</td>
<td>10</td>
</tr>
<tr>
<td>S15</td>
<td>15¢ (dispense!)</td>
<td>11</td>
</tr>
</tbody>
</table>
<p><strong>Step 3: State Table (Mealy-style for immediate dispense)</strong></p>
<table>
<thead>
<tr>
<th>Current</th>
<th>N</th>
<th>D</th>
<th>Next</th>
<th>DISPENSE</th>
<th>CHANGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0</td>
<td>0</td>
<td>0</td>
<td>S0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>S0</td>
<td>1</td>
<td>0</td>
<td>S5</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>S0</td>
<td>0</td>
<td>1</td>
<td>S10</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>S5</td>
<td>0</td>
<td>0</td>
<td>S5</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>S5</td>
<td>1</td>
<td>0</td>
<td>S10</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>S5</td>
<td>0</td>
<td>1</td>
<td>S0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>S10</td>
<td>0</td>
<td>0</td>
<td>S10</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>S10</td>
<td>1</td>
<td>0</td>
<td>S0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>S10</td>
<td>0</td>
<td>1</td>
<td>S0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><strong>Step 4-5: Already minimized, using binary encoding above</strong></p>
<p><strong>Step 6-7: Derive equations</strong></p>
<p>Next-state equations:</p>
<div class="arithmatex">\[Q_1^+ = \overline{Q_1} \cdot Q_0 \cdot N + \overline{Q_1} \cdot \overline{Q_0} \cdot D + Q_1 \cdot \overline{Q_0} \cdot \overline{N} \cdot \overline{D}\]</div>
<div class="arithmatex">\[Q_0^+ = \overline{Q_1} \cdot \overline{Q_0} \cdot N + \overline{Q_1} \cdot Q_0 \cdot \overline{N} \cdot \overline{D}\]</div>
<p>Output equations:</p>
<div class="arithmatex">\[DISPENSE = Q_0 \cdot D + Q_1 \cdot N + Q_1 \cdot D\]</div>
<div class="arithmatex">\[CHANGE = Q_1 \cdot \overline{Q_0} \cdot D\]</div>
<p><strong>Step 8: Circuit Implementation</strong></p>
<p>Two D flip-flops, AND-OR logic for next state and outputs, and we're done!</p>
<h2 id="common-fsm-design-patterns">Common FSM Design Patterns</h2>
<p>Here are some patterns you'll see repeatedly:</p>
<p><strong>Counter FSM:</strong>
States represent count values; transitions increment on clock edge.</p>
<p><strong>Sequence Detector:</strong>
States track progress through a target pattern; output activates when pattern complete.</p>
<p><strong>Controller:</strong>
States represent phases of operation; transitions based on completion signals.</p>
<p><strong>Protocol Handler:</strong>
States represent protocol stages (idle, request, acknowledge, data, done).</p>
<p><strong>Debouncer:</strong>
States filter out rapid bounces from mechanical switches.</p>
<div class="admonition example">
<p class="admonition-title">Pattern: The Debounce FSM</p>
<p>Mechanical buttons bounce—they make and break contact multiple times when pressed. An FSM can filter this by requiring the button to be stable for several clock cycles before registering a press:</p>
<p>States: IDLE → COUNT_1 → COUNT_2 → COUNT_3 → PRESSED</p>
<p>Only after three consecutive cycles of button=1 do we acknowledge the press. Random bounces reset back to IDLE.</p>
</div>
<h2 id="summary-and-key-takeaways">Summary and Key Takeaways</h2>
<p>Congratulations! You've just acquired one of the most powerful tools in digital design. Finite state machines are everywhere—from the microcode controlling your CPU to the protocol handlers managing your network traffic.</p>
<p><strong>Core Concepts:</strong></p>
<ul>
<li><strong>FSM</strong>: A mathematical model with finite states, inputs, outputs, and transitions</li>
<li><strong>State</strong>: A snapshot of what the system remembers</li>
<li><strong>Transition</strong>: Movement from one state to another based on inputs</li>
<li><strong>Current vs Next state</strong>: The synchronous update model</li>
</ul>
<p><strong>Two Flavors:</strong></p>
<ul>
<li><strong>Moore machines</strong>: Outputs depend only on state (clean, predictable)</li>
<li><strong>Mealy machines</strong>: Outputs depend on state and inputs (reactive, fewer states)</li>
</ul>
<p><strong>Design Representations:</strong></p>
<ul>
<li><strong>State diagrams</strong>: Visual, intuitive, good for design</li>
<li><strong>State tables</strong>: Complete, systematic, good for implementation</li>
</ul>
<p><strong>Encoding Choices:</strong></p>
<ul>
<li><strong>Binary</strong>: Minimum flip-flops, compact</li>
<li><strong>One-hot</strong>: Simple logic, fast, FPGA-friendly</li>
<li><strong>Gray code</strong>: Single-bit transitions, glitch-free</li>
</ul>
<p><strong>Optimization:</strong></p>
<ul>
<li><strong>State minimization</strong>: Eliminate equivalent states</li>
<li><strong>State assignment</strong>: Choose codes to minimize logic</li>
</ul>
<p><strong>The Design Flow:</strong></p>
<ol>
<li>Understand the problem</li>
<li>Draw state diagram</li>
<li>Create state table</li>
<li>Minimize states</li>
<li>Choose encoding</li>
<li>Derive equations</li>
<li>Implement circuit</li>
<li>Verify!</li>
</ol>
<div class="admonition success">
<p class="admonition-title">The Big Picture</p>
<p>FSMs bridge the gap between abstract behavior ("count up, then reset") and concrete implementation (flip-flops and gates). Master FSM design, and you can implement any well-defined sequential behavior in hardware.</p>
</div>
<details>
<summary>Graphic Novel Suggestion</summary>
<p>An engaging graphic novel could tell the story of Edward Moore and George Mealy, the two researchers who formalized the mathematical models of sequential machines in the 1950s. Set against the backdrop of the early computing era at Bell Labs and IBM, the narrative could follow their parallel journeys to understanding how to describe systems that remember. The dramatic tension could build around the question: "Can any computation be described as a finite state machine?"—leading to the profound realization that while FSMs are powerful, they have fundamental limits (cue: the pumping lemma and the Chomsky hierarchy). The climax could show how their seemingly theoretical work became the foundation for everything from traffic light controllers to the protocol stacks that power the internet.</p>
</details>
<h2 id="practice-problems">Practice Problems</h2>
<p>Test your understanding with these exercises:</p>
<details class="question">
<summary>Problem 1: Moore vs Mealy Identification</summary>
<p>A system outputs a 1 whenever it sees the input sequence "10". Identify whether the following description is Moore or Mealy:</p>
<p>"In the state after seeing '1', if the input is '0', output 1 immediately while transitioning to the initial state."</p>
<p><strong>Solution:</strong>
This is a <strong>Mealy machine</strong>. The output (1) depends on both the current state ("after seeing 1") AND the current input ("input is 0"). In a Moore machine, the output would have to wait for the next state.</p>
</details>
<details class="question">
<summary>Problem 2: State Counting</summary>
<p>How many states are needed for an FSM that remembers the last 3 bits of input?</p>
<p><strong>Solution:</strong>
Each bit can be 0 or 1, so 3 bits have <span class="arithmatex">\(2^3 = 8\)</span> possible combinations. The FSM needs <strong>8 states</strong> to remember all possible 3-bit histories: 000, 001, 010, 011, 100, 101, 110, 111.</p>
</details>
<details class="question">
<summary>Problem 3: Encoding Selection</summary>
<p>A 6-state FSM will be implemented on an FPGA with abundant flip-flops but expensive routing. Which encoding would you recommend?</p>
<p><strong>Solution:</strong>
<strong>One-hot encoding</strong> is ideal for FPGAs with many flip-flops but limited logic/routing resources. One-hot uses 6 flip-flops (instead of 3 for binary) but has simpler next-state logic that requires less routing. Each next-state equation is just an OR of incoming transitions.</p>
</details>
<details class="question">
<summary>Problem 4: Next State Equation Derivation</summary>
<p>Given this state table, derive the next-state equation for Q (using D flip-flop):</p>
<table>
<thead>
<tr>
<th>Current Q</th>
<th>Input X</th>
<th>Next Q</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>Solution:</strong>
Looking at when Next Q = 1:
- Q=0, X=1 → 1
- Q=1, X=0 → 1</p>
<p>The equation is:
[D = \overline{Q} \cdot X + Q \cdot \overline{X} = Q \oplus X]</p>
<p>This is a T flip-flop behavior—toggle when X=1!</p>
</details>
<details class="question">
<summary>Problem 5: State Minimization</summary>
<p>States A and B both have output = 0. A goes to C on input 0 and D on input 1. B goes to C on input 0 and D on input 1. Are A and B equivalent?</p>
<p><strong>Solution:</strong>
Yes, <strong>A and B are equivalent</strong>:
1. Same outputs (0)
2. Same next states for all inputs (both go to C on 0, both go to D on 1)</p>
<p>They can be merged into a single state.</p>
</details>
<details class="question">
<summary>Problem 6: Complete FSM Design</summary>
<p>Design an FSM that outputs 1 whenever the total number of 1s seen so far is a multiple of 3 (including 0). Show the state diagram and derive the next-state equations using binary encoding.</p>
<p><strong>Solution:</strong></p>
<p><strong>States</strong> (count mod 3):
- S0: Count ≡ 0 (mod 3), Output = 1
- S1: Count ≡ 1 (mod 3), Output = 0
- S2: Count ≡ 2 (mod 3), Output = 0</p>
<p><strong>Transitions:</strong>
- From any state, input 0 → stay in same state
- From S0, input 1 → S1
- From S1, input 1 → S2
- From S2, input 1 → S0</p>
<p><strong>Encoding:</strong> S0=00, S1=01, S2=10</p>
<p><strong>State Table:</strong></p>
<table>
<thead>
<tr>
<th>Q1 Q0</th>
<th>X</th>
<th>Q1+ Q0+</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>00</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>01</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>00</td>
</tr>
</tbody>
</table>
<p><strong>Next-state equations:</strong></p>
<div class="arithmatex">\[Q_1^+ = \overline{Q_1} \cdot Q_0 \cdot X + Q_1 \cdot \overline{Q_0} \cdot \overline{X}\]</div>
<div class="arithmatex">\[Q_0^+ = \overline{Q_1} \cdot \overline{Q_0} \cdot X + \overline{Q_1} \cdot Q_0 \cdot \overline{X}\]</div>
<p><strong>Output equation:</strong></p>
<div class="arithmatex">\[Y = \overline{Q_1} \cdot \overline{Q_0}\]</div>
</details>
<p><a href="references/">See Annotated References</a></p>







  
  



  




                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../08-flip-flops-timing/references/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Annotated References">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Annotated References
              </div>
            </div>
          </a>
        
        
          
          <a href="quiz/" class="md-footer__link md-footer__link--next" aria-label="Next: Quiz">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                Quiz
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2026 Dan McCreary. Licensed under <a href="license/">CC BY-NC-SA 4.0</a> for non-commercial use.
    </div>
  
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy", "navigation.expand", "navigation.path", "navigation.prune", "navigation.indexes", "toc.follow", "navigation.top", "navigation.footer"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="../../js/katex.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Digital Electronics","text":""},{"location":"#digital-electronics","title":"Digital Electronics","text":"<p>Welcome to the digital electronics course website!</p> <p>Our goal is to provide resources for teaching some of the most difficult concepts in an introduction to digital electronics course by using generative AI to create lesson plans and simulations.</p> <p>To use this site you can use the search function in the upper right corner or use the navigation system on the left side of the pages.</p> <p>Please let me know if you have any comments or suggestions for improvements.</p> <p>Have fun!</p> <p>Dan McCreary LinkedIn</p>"},{"location":"about/","title":"About the Digital Electronics Course","text":"<p>What are the most difficult concepts for an undergraduate college student to understand in a digital electronics course?</p> <p>In an undergraduate digital electronics course, several concepts are often challenging for students to grasp due to their abstract nature or the level of detail involved. Some of the most difficult concepts typically include:</p> <ol> <li> <p>Boolean Algebra and Logic Gates: Understanding how Boolean algebra relates to the operation of basic logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR) and their use in creating complex circuits.</p> </li> <li> <p>Karnaugh Maps (K-Maps): These are used for simplifying Boolean expressions and can be quite challenging due to the need for spatial and logical reasoning.</p> </li> <li> <p>Flip-Flops and Latches: The concepts of storage elements like flip-flops and latches, which are fundamental to memory and sequential circuits, can be abstract and require a solid understanding of timing and control signals.</p> </li> <li> <p>Finite State Machines (FSMs): Designing and understanding FSMs, which are models of computation used in sequential logic, can be complex, especially when dealing with larger systems.</p> </li> <li> <p>Timing Analysis: Understanding the timing characteristics of digital circuits, such as setup and hold times, clock skew, and propagation delay, is crucial but can be difficult due to the abstract nature of these concepts.</p> </li> <li> <p>Digital-to-Analog (DAC) and Analog-to-Digital Converters (ADC): Understanding how digital systems interface with the analog world through DACs and ADCs requires a good grasp of both digital and analog principles.</p> </li> <li> <p>Signal Integrity and Noise Issues: Learning about how noise affects digital signals and the techniques used to mitigate these effects can be challenging, especially in high-speed digital design.</p> </li> <li> <p>Microprocessor Architecture and Assembly Language Programming: The intricacies of microprocessor architecture and the details of assembly language programming are often complex for students new to these concepts.</p> </li> <li> <p>Memory Architecture: Understanding different types of memory (RAM, ROM, Cache, etc.) and their architecture can be intricate due to the details involved in how they store and retrieve data.</p> </li> <li> <p>VHDL/Verilog for FPGA Design: Learning hardware description languages like VHDL or Verilog for FPGA (Field-Programmable Gate Array) design can be daunting due to the need to think in terms of hardware rather than software.</p> </li> </ol> <p>These topics require a solid foundation in basic electronics and mathematics, along with the ability to think abstractly and logically. The difficulty often lies in the transition from theoretical knowledge to practical application and understanding how these concepts interconnect to form complex digital systems.</p>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"Digital Electronics","text":"<p>This is a sophomore-level digital electronics course that covers the ABET-aligned EE curricula for digital electronics. This course feeds upper-division computer architecture, VLSI, and embedded systems courses.</p> <p>Here are the topics covered roughly in the order they are taught.</p>"},{"location":"course-description/#intended-audience","title":"Intended Audience","text":"<p>College students that plan on becoming majors in electrical engineering or computer-related fields.</p>"},{"location":"course-description/#prerequisites","title":"Prerequisites","text":"<p>Calculus 1 is required for several of the advanced topics in this course.</p>"},{"location":"course-description/#1-foundations-boolean-algebra-binary-logic","title":"1. Foundations: Boolean Algebra &amp; Binary Logic","text":""},{"location":"course-description/#core-concepts","title":"Core concepts","text":"<ul> <li>Binary number system (review, but formalized)</li> <li>Boolean variables, constants (0, 1)</li> <li>Boolean operators: AND, OR, NOT</li> <li>Truth tables as formal specifications</li> <li>Boolean expressions vs Boolean functions</li> </ul>"},{"location":"course-description/#boolean-algebra-laws-memorized-applied","title":"Boolean algebra laws (memorized + applied)","text":"<ul> <li>Identity, Null, Idempotent</li> <li>Complement</li> <li>Commutative, Associative, Distributive</li> <li>Absorption</li> <li>De Morgan\u2019s Theorems (very important)</li> </ul>"},{"location":"course-description/#why-this-matters","title":"Why this matters","text":"<p>This is where logical reasoning becomes mathematical, and students learn that:</p> <p>Digital circuits are physical realizations of Boolean functions.</p>"},{"location":"course-description/#2-logic-gates-gate-level-modeling","title":"2. Logic Gates &amp; Gate-Level Modeling","text":""},{"location":"course-description/#primitive-gates","title":"Primitive gates","text":"<ul> <li>NOT, AND, OR</li> <li>NAND, NOR (emphasized as functionally complete)</li> <li>XOR, XNOR</li> </ul>"},{"location":"course-description/#gate-properties","title":"Gate properties","text":"<ul> <li>Functional completeness</li> <li>Gate delay (introductory timing intuition)</li> <li>Fan-in / fan-out (qualitative)</li> <li>Symbol conventions and schematics</li> </ul>"},{"location":"course-description/#gate-level-abstraction","title":"Gate-level abstraction","text":"<ul> <li>Mapping Boolean expressions \u2192 gates</li> <li>Understanding that NAND/NOR dominate real hardware</li> </ul>"},{"location":"course-description/#3-combinational-logic-design","title":"3. Combinational Logic Design","text":""},{"location":"course-description/#canonical-representations","title":"Canonical representations","text":"<ul> <li>Sum-of-Products (SOP)</li> <li>Product-of-Sums (POS)</li> <li>Canonical vs minimal forms</li> </ul>"},{"location":"course-description/#standard-combinational-blocks","title":"Standard combinational blocks","text":"<p>Students design and analyze:</p> <ul> <li>Multiplexers (MUX)</li> <li>Demultiplexers</li> <li>Encoders / Decoders</li> <li>Priority encoders</li> <li>Comparators</li> <li> <p>Adders</p> </li> <li> <p>Half adder</p> </li> <li>Full adder</li> <li>Ripple-carry adder (conceptual)</li> </ul>"},{"location":"course-description/#design-workflow","title":"Design workflow","text":"<ol> <li>Problem statement</li> <li>Truth table</li> <li>Boolean expression</li> <li>Simplification</li> <li>Gate-level implementation</li> <li>(Later) Verilog model</li> </ol>"},{"location":"course-description/#4-logic-simplification-optimization","title":"4. Logic Simplification &amp; Optimization","text":""},{"location":"course-description/#algebraic-simplification","title":"Algebraic simplification","text":"<ul> <li>Manual application of Boolean laws</li> <li>Factoring and common-term extraction</li> </ul>"},{"location":"course-description/#karnaugh-maps-k-maps","title":"Karnaugh Maps (K-maps)","text":"<ul> <li>2-, 3-, and 4-variable K-maps</li> <li>Grouping rules</li> <li>Don\u2019t-care conditions</li> <li>Minimal SOP / POS solutions</li> </ul>"},{"location":"course-description/#design-tradeoffs","title":"Design tradeoffs","text":"<ul> <li>Gate count vs clarity</li> <li>Depth vs width</li> <li>Cost, power, and delay (introductory, not transistor-level)</li> </ul>"},{"location":"course-description/#5-introduction-to-sequential-logic","title":"5. Introduction to Sequential Logic","text":"<p>This is the big conceptual leap of the course.</p>"},{"location":"course-description/#memory-state","title":"Memory &amp; state","text":"<ul> <li>Difference between combinational and sequential logic</li> <li>Concept of state</li> <li>Clocked vs unclocked systems</li> </ul>"},{"location":"course-description/#latches","title":"Latches","text":"<ul> <li>SR latch</li> <li>D latch</li> <li>Level-sensitive behavior</li> <li>Why latches are dangerous in large designs</li> </ul>"},{"location":"course-description/#6-flip-flops-clocked-storage","title":"6. Flip-Flops &amp; Clocked Storage","text":""},{"location":"course-description/#flip-flop-types","title":"Flip-flop types","text":"<ul> <li>D flip-flop (primary focus)</li> <li>JK, T flip-flops (often covered conceptually)</li> </ul>"},{"location":"course-description/#timing-concepts-qualitative","title":"Timing concepts (qualitative)","text":"<ul> <li>Clock edge</li> <li>Setup time</li> <li>Hold time</li> <li>Clock-to-Q delay</li> <li>Metastability (introduced, not deeply analyzed)</li> </ul>"},{"location":"course-description/#7-synchronous-sequential-logic-design","title":"7. Synchronous Sequential Logic Design","text":"<p>This is the heart of EE 2301.</p>"},{"location":"course-description/#finite-state-machines-fsms","title":"Finite State Machines (FSMs)","text":"<ul> <li>Moore machines</li> <li>Mealy machines</li> <li>State diagrams</li> <li>State tables</li> <li>State encoding (binary, one-hot \u2014 at least conceptually)</li> </ul>"},{"location":"course-description/#fsm-design-process","title":"FSM design process","text":"<ol> <li>Word problem \u2192 states</li> <li>State diagram</li> <li>State table</li> <li>Next-state equations</li> <li>Output equations</li> <li>Implementation with flip-flops + combinational logic</li> </ol>"},{"location":"course-description/#common-examples","title":"Common examples","text":"<ul> <li>Counters (mod-N, up/down)</li> <li>Sequence detectors</li> <li>Controllers (traffic light, vending machine-style problems)</li> </ul>"},{"location":"course-description/#8-registers-counters-and-datapath-elements","title":"8. Registers, Counters, and Datapath Elements","text":""},{"location":"course-description/#registers","title":"Registers","text":"<ul> <li>Parallel registers</li> <li>Enable signals</li> <li>Load vs hold behavior</li> </ul>"},{"location":"course-description/#counters","title":"Counters","text":"<ul> <li>Synchronous counters</li> <li>Reset (synchronous vs asynchronous)</li> <li>Modulus control</li> </ul>"},{"location":"course-description/#datapath-intuition","title":"Datapath intuition","text":"<ul> <li>Registers + combinational logic + control</li> <li>Early exposure to CPU-style thinking</li> </ul>"},{"location":"course-description/#9-verilog-hdl-modeling","title":"9. Verilog HDL Modeling","text":"<p>This is where software-thinking students shine.</p>"},{"location":"course-description/#verilog-basics","title":"Verilog basics","text":"<ul> <li>Modules</li> <li>Ports (input/output)</li> <li>Wire vs reg</li> <li>Continuous assignments (<code>assign</code>)</li> <li>Procedural blocks (<code>always</code>)</li> </ul>"},{"location":"course-description/#modeling-styles","title":"Modeling styles","text":"<ul> <li>Combinational logic (<code>always @(*)</code>)</li> <li>Sequential logic (<code>always @(posedge clk)</code>)</li> <li>Structural vs behavioral modeling</li> </ul>"},{"location":"course-description/#testbenches","title":"Testbenches","text":"<ul> <li>Stimulus generation</li> <li>Observing outputs</li> <li>Simulation as verification</li> </ul>"},{"location":"course-description/#key-learning-outcome","title":"Key learning outcome","text":"<p>Students learn that:</p> <p>HDLs describe hardware behavior, not software execution.</p>"},{"location":"course-description/#10-design-simulation-and-verification-flow","title":"10. Design, Simulation, and Verification Flow","text":""},{"location":"course-description/#typical-toolchain","title":"Typical toolchain","text":"<ul> <li>Verilog editor</li> <li>Simulator (ModelSim / Questa / similar)</li> <li>FPGA or logic lab hardware</li> </ul>"},{"location":"course-description/#concepts-emphasized","title":"Concepts emphasized","text":"<ul> <li>Separation of design and verification</li> <li>Debugging with waveforms</li> <li>Functional correctness before optimization</li> </ul>"},{"location":"course-description/#11-integral-laboratory-component","title":"11. Integral Laboratory Component","text":"<p>The lab is not optional or cosmetic.</p>"},{"location":"course-description/#labs","title":"Labs","text":"<ul> <li>Breadboarding simple gate circuits (early)</li> <li>Using logic analyzers or FPGA boards</li> <li>Implementing combinational logic modules</li> <li>FSM implementations in Verilog</li> <li>Testing with switches, LEDs, clocks</li> </ul>"},{"location":"course-description/#skills-developed","title":"Skills developed","text":"<ul> <li>Translating theory \u2192 working hardware</li> <li>Debugging timing and logic errors</li> <li>Working within constraints (pins, clocks, resets)</li> </ul>"},{"location":"course-description/#12-professional-programmatic-outcomes","title":"12. Professional &amp; Programmatic Outcomes","text":"<p>By the end of EE 2301, students can:</p> <ul> <li>Think in Boolean abstractions</li> <li>Design correct, clocked digital systems</li> <li>Read and write Verilog</li> <li>Understand how hardware differs fundamentally from software</li> <li> <p>Prepare for:</p> </li> <li> <p>Computer architecture</p> </li> <li>Embedded systems</li> <li>VLSI / FPGA design</li> <li>Operating systems (indirectly)</li> </ul>"},{"location":"course-description/#topics-not-covered","title":"Topics Not Covered","text":"<p>Important boundary clarification:</p> <ul> <li>\u274c No transistor-level CMOS design</li> <li>\u274c No asynchronous circuit theory</li> <li>\u274c No advanced timing closure or synthesis</li> <li>\u274c No CPU pipeline design</li> </ul> <p>These topics will come later \u2014 this course builds the mental scaffolding.</p>"},{"location":"course-description/#why-ee-2301-is-a-pivot-course","title":"Why EE 2301 Is a Pivot Course","text":"<p>This course is where students stop thinking:</p> <p>\"The computer just runs code\"</p> <p>\u2026and start thinking:</p> <p>\"The computer is a carefully synchronized state machine built from logic.\"</p>"},{"location":"course-description/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this course, students will be able to:</p>"},{"location":"course-description/#remember","title":"Remember","text":"<ul> <li>Recall the truth tables for all primitive logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR)</li> <li>List the fundamental Boolean algebra laws (Identity, Null, Idempotent, Complement, Commutative, Associative, Distributive, Absorption)</li> <li>State De Morgan's Theorems</li> <li>Identify the symbols for standard logic gates</li> <li>Name the timing parameters for flip-flops (setup time, hold time, clock-to-Q delay)</li> </ul>"},{"location":"course-description/#understand","title":"Understand","text":"<ul> <li>Explain the difference between combinational and sequential logic</li> <li>Describe how Boolean expressions map to physical gate implementations</li> <li>Interpret truth tables and state diagrams</li> <li>Distinguish between Moore and Mealy state machines</li> <li>Explain why NAND and NOR gates are functionally complete</li> <li>Describe the concept of metastability in digital systems</li> </ul>"},{"location":"course-description/#apply","title":"Apply","text":"<ul> <li>Use Karnaugh maps to simplify Boolean expressions up to 4 variables</li> <li>Apply Boolean algebra laws to reduce logic expressions</li> <li>Implement combinational circuits using standard blocks (MUX, decoders, adders)</li> <li>Design finite state machines from word problem specifications</li> <li>Write synthesizable Verilog code for combinational and sequential logic</li> <li>Use simulation tools to verify digital designs</li> </ul>"},{"location":"course-description/#analyze","title":"Analyze","text":"<ul> <li>Analyze timing diagrams to identify setup and hold violations</li> <li>Decompose complex digital systems into combinational and sequential components</li> <li>Trace signal propagation through multi-level logic circuits</li> <li>Debug logic errors using waveform analysis</li> <li>Examine FSM state transitions for correctness and completeness</li> </ul>"},{"location":"course-description/#evaluate","title":"Evaluate","text":"<ul> <li>Compare design tradeoffs between gate count, propagation delay, and power consumption</li> <li>Assess whether a circuit implementation meets functional specifications</li> <li>Critique state encoding choices (binary vs. one-hot) for specific applications</li> <li>Judge the quality of Verilog code for clarity and synthesizability</li> <li>Evaluate when to use latches versus flip-flops in a design</li> </ul>"},{"location":"course-description/#create","title":"Create","text":"<ul> <li>Design complete synchronous digital systems from specifications</li> <li>Construct testbenches to verify Verilog module functionality</li> <li>Develop FSM-based controllers for real-world applications (traffic lights, vending machines)</li> <li>Build working circuits on breadboards and FPGA platforms</li> <li>Synthesize optimized gate-level implementations from behavioral descriptions</li> </ul>"},{"location":"glossary/","title":"Digital Electronics Glossary of Terms","text":""},{"location":"glossary/#abet-aligned-ee-curriculum","title":"ABET-aligned EE Curriculum","text":"<p>A curriculum aligned with the standards of the Accreditation Board for Engineering and Technology.</p> <p>A carefully scaffolded, outcomes-driven program that ensures students don\u2019t just learn electrical engineering concepts \u2014 they learn how to think, design, build, and verify real engineering systems at a professional level.</p> <p>ABET stands for Accreditation Board for Engineering and Technology. It is not a government agency; it is a professional accreditor recognized by industry, licensing boards, and universities.</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#python","title":"Python","text":"<p>MicroSims are about how we use generative AI to create animations and simulations.  The language of AI is Python.  So we wanted to create a site that could be easily understood by Python developers.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"references/","title":"References for Digital Electronics","text":""},{"location":"references/#commercial-tools","title":"Commercial Tools","text":"<p>Logicly - Logicly is a $50 digital circuit simulator.  It has components for the standard logic gates and flip-flops.</p>"},{"location":"chapters/","title":"Chapters","text":"<p>This textbook is organized into 15 chapters covering 300 concepts in digital electronics.</p>"},{"location":"chapters/#chapter-overview","title":"Chapter Overview","text":"<ol> <li> <p>Number Systems and Binary Arithmetic - Covers binary, hexadecimal, and octal number systems along with arithmetic operations and encoding schemes.</p> </li> <li> <p>Boolean Algebra Fundamentals - Introduces Boolean variables, operations, expressions, functions, truth tables, and Boolean algebra laws.</p> </li> <li> <p>Logic Gates and Digital Signal Properties - Covers primitive logic gates, functional completeness, timing parameters, and signal characteristics.</p> </li> <li> <p>Combinational Logic Design Fundamentals - Introduces combinational vs sequential logic, gate-level design, and canonical forms.</p> </li> <li> <p>Logic Minimization and Karnaugh Maps - Covers K-maps, grouping rules, prime implicants, and hazard-free design.</p> </li> <li> <p>Combinational Building Blocks - Covers multiplexers, decoders, comparators, adders, and ALU concepts.</p> </li> <li> <p>Introduction to Sequential Logic - Introduces memory elements, latches, and clock signals.</p> </li> <li> <p>Flip-Flops and Timing - Covers edge-triggered flip-flops, timing parameters, and synchronization.</p> </li> <li> <p>Finite State Machine Fundamentals - Introduces FSMs, Moore and Mealy machines, state diagrams, and encoding methods.</p> </li> <li> <p>FSM Design and Applications - Covers the FSM design process and practical applications.</p> </li> <li> <p>Registers, Counters, and Datapath - Covers registers, shift registers, counters, and datapath concepts.</p> </li> <li> <p>Verilog HDL Fundamentals - Introduces Verilog modules, ports, data types, and assignments.</p> </li> <li> <p>Verilog Behavioral and Structural Modeling - Covers always blocks, modeling styles, and hierarchical design.</p> </li> <li> <p>Testbenches and Simulation - Covers testbench creation, simulation, and synthesis concepts.</p> </li> <li> <p>FPGA Implementation and Laboratory Skills - Covers FPGA architecture, implementation, and laboratory practices.</p> </li> </ol>"},{"location":"chapters/#how-to-use-this-textbook","title":"How to Use This Textbook","text":"<p>This textbook is designed with a careful progression of concepts where each chapter builds on the knowledge from previous chapters. The learning graph ensures that all prerequisite concepts are covered before they are needed. Students should work through chapters sequentially, as later chapters assume familiarity with earlier material.</p> <p>Note: Each chapter includes a list of concepts covered from the learning graph. Make sure to complete prerequisites before moving to advanced chapters.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/","title":"Number Systems and Binary Arithmetic","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#summary","title":"Summary","text":"<p>This chapter establishes the mathematical foundation for digital electronics by introducing number systems used in digital design. Students will learn to convert between binary, decimal, hexadecimal, and octal representations, perform binary arithmetic operations, understand signed number representation using two's complement, and work with specialized encoding schemes like BCD and Gray code. These skills are essential for all subsequent work in digital circuit design.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>Binary Number System</li> <li>Decimal to Binary Conversion</li> <li>Binary to Decimal Conversion</li> <li>Hexadecimal Numbers</li> <li>Hex to Binary Conversion</li> <li>Octal Numbers</li> <li>Binary Addition</li> <li>Binary Subtraction</li> <li>Two's Complement</li> <li>Signed Binary Numbers</li> <li>Overflow Detection</li> <li>BCD Encoding</li> <li>Gray Code</li> <li>Weighted Codes</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#prerequisites","title":"Prerequisites","text":"<p>This chapter assumes only the prerequisites listed in the course description. Students should have a basic understanding of arithmetic and number representation from prior mathematics courses.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#introduction-why-computers-dont-count-like-we-do","title":"Introduction: Why Computers Don't Count Like We Do","text":"<p>Here's a fun fact to start your journey into digital electronics: computers are terrible at counting to ten. It's not that they're lazy or didn't pay attention in kindergarten\u2014it's that they physically can't. Deep inside every processor, every memory chip, and every digital circuit, there are billions of tiny switches that can only be in one of two states: on or off. That's it. No \"sort of on\" or \"mostly off.\" Just on and off.</p> <p>This fundamental limitation (which, as you'll discover, is actually a superpower) means that computers think in binary\u2014a number system with only two digits. If you've ever wondered why computer scientists seem obsessed with powers of 2, or why your hard drive has weird capacities like 256 GB instead of a nice round 250 GB, this chapter will give you the answers.</p> <p>Think of it this way: if you only had two fingers, you'd probably count differently too. Welcome to the world of binary arithmetic, where 10 + 10 = 100, and that's not a typo\u2014it's just how things work around here.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-binary-number-system","title":"The Binary Number System","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#understanding-positional-notation","title":"Understanding Positional Notation","text":"<p>Before diving into binary, let's remind ourselves how our familiar decimal system works. When you write the number 347, each digit's position tells you what it's worth:</p> <ul> <li>The 3 is in the \"hundreds\" place: \\(3 \\times 100 = 300\\)</li> <li>The 4 is in the \"tens\" place: \\(4 \\times 10 = 40\\)</li> <li>The 7 is in the \"ones\" place: \\(7 \\times 1 = 7\\)</li> </ul> <p>Add them up: \\(300 + 40 + 7 = 347\\). Simple enough, right?</p> <p>Notice that each position is a power of 10:</p> Position 3rd 2nd 1st 0th Power \\(10^3\\) \\(10^2\\) \\(10^1\\) \\(10^0\\) Value 1000 100 10 1 <p>This is called positional notation with base 10 (or radix 10). The magic insight is that we can use any base we want\u2014we just happened to evolve with 10 fingers.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-base-2","title":"Binary: Base 2","text":"<p>In binary, we use base 2 instead of base 10. This means:</p> <ul> <li>We only have two digits: 0 and 1 (called bits, short for \"binary digits\")</li> <li>Each position represents a power of 2</li> </ul> <p>Here's the binary equivalent of our position table:</p> Position 7th 6th 5th 4th 3rd 2nd 1st 0th Power \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) Value 128 64 32 16 8 4 2 1 <p>Memorize These Powers of 2</p> <p>Knowing the first 8-10 powers of 2 by heart will make your life in digital electronics much easier: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024...</p> <p>Let's decode the binary number \\(10110101_2\\) (the subscript 2 tells us it's binary):</p> Bit 1 0 1 1 0 1 0 1 Position value 128 64 32 16 8 4 2 1 Contribution 128 0 32 16 0 4 0 1 <p>Sum: \\(128 + 32 + 16 + 4 + 1 = 181_{10}\\)</p> <p>That's binary to decimal conversion in a nutshell\u2014just add up the position values wherever there's a 1.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-binary-place-value-visualizer","title":"Diagram: Binary Place Value Visualizer","text":"Binary Place Value Visualizer Type: microsim  Bloom Level: Understand (L2) Bloom Verb: interpret, explain  Learning Objective: Students will be able to explain how positional notation works in binary by interactively toggling bits and observing the resulting decimal value.  Canvas Layout: - Width: 700px, Height: 400px - Top section: 8 large toggle buttons representing bits (positions 7 through 0) - Middle section: Display showing power of 2 labels under each bit ($2^7$, $2^6$, etc.) - Bottom section: Running calculation showing which position values are \"active\" and the total decimal result  Visual Elements: - 8 square toggle buttons (80x80px each) arranged horizontally - Each button shows \"0\" or \"1\" in large font - Active bits (1s) highlighted in bright blue, inactive bits (0s) in gray - Position values displayed beneath each button - Calculation line shows: \"128 + 32 + 16 + 4 + 1 = 181\" - Large decimal result display at bottom  Interactive Controls: - Click any bit to toggle between 0 and 1 - \"Clear All\" button sets all bits to 0 - \"Random\" button generates a random 8-bit number - \"Challenge Mode\" button shows a target decimal for student to create  Behavior: - When a bit is toggled, immediately recalculate and display the new decimal value - Active bits visually \"light up\" with animation - Calculation line updates dynamically to show only active terms  Instructional Rationale: Toggle-based exploration with immediate feedback is appropriate because students need to see the concrete relationship between bit positions and values. The step-by-step calculation display makes the addition process explicit.  Implementation: p5.js with responsive canvas"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-binary-matters","title":"Why Binary Matters","text":"<p>You might be thinking, \"This seems inconvenient. Why not just use decimal?\" Great question! Here's why binary is perfect for computers:</p> <ol> <li>Reliability: It's easy to distinguish between \"on\" and \"off,\" but hard to reliably distinguish between 10 different voltage levels</li> <li>Noise immunity: If electrical noise corrupts a signal slightly, a 1 is still a 1</li> <li>Simple logic: AND, OR, NOT operations map directly to physical circuits</li> <li>Mathematical elegance: Boolean algebra makes circuit design systematic</li> </ol> <p>As we'll see in later chapters, this binary foundation enables everything from adding two numbers to running complex operating systems.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#converting-between-binary-and-decimal","title":"Converting Between Binary and Decimal","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-to-decimal-the-position-value-method","title":"Binary to Decimal: The Position-Value Method","text":"<p>We already saw this method in action. Here's the systematic process:</p> <ol> <li>Write out the binary number</li> <li>Label each bit with its position value (right to left, starting at 1)</li> <li>Multiply each bit by its position value</li> <li>Sum the results</li> </ol> <p>Example: Convert \\(1101011_2\\) to decimal.</p> Bit position 6 5 4 3 2 1 0 Position value 64 32 16 8 4 2 1 Binary digit 1 1 0 1 0 1 1 Contribution 64 32 0 8 0 2 1 <p>Result: \\(64 + 32 + 8 + 2 + 1 = 107_{10}\\)</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#decimal-to-binary-the-repeated-division-method","title":"Decimal to Binary: The Repeated Division Method","text":"<p>Going the other direction requires a different approach. The most reliable method is repeated division by 2:</p> <ol> <li>Divide the decimal number by 2</li> <li>Record the remainder (0 or 1)</li> <li>Use the quotient as the new dividend</li> <li>Repeat until the quotient is 0</li> <li>Read the remainders from bottom to top</li> </ol> <p>Example: Convert \\(107_{10}\\) to binary.</p> Division Quotient Remainder 107 \u00f7 2 53 1 53 \u00f7 2 26 1 26 \u00f7 2 13 0 13 \u00f7 2 6 1 6 \u00f7 2 3 0 3 \u00f7 2 1 1 1 \u00f7 2 0 1 <p>Reading remainders from bottom to top: \\(1101011_2\\) \u2713</p> <p>The Remainder Trick</p> <p>Why does this work? Each remainder tells you whether that power of 2 \"fits\" into the remaining value. The first remainder tells you if the number is odd (needs a \\(2^0 = 1\\)), the second tells you about \\(2^1\\), and so on.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-decimal-to-binary-conversion-stepper","title":"Diagram: Decimal to Binary Conversion Stepper","text":"Decimal to Binary Conversion Stepper Type: microsim  Bloom Level: Apply (L3) Bloom Verb: execute, calculate  Learning Objective: Students will be able to apply the repeated division method to convert any decimal number to binary by stepping through the algorithm interactively.  Canvas Layout: - Width: 700px, Height: 450px - Left side: Input field for decimal number - Center: Step-by-step division display showing quotient and remainder at each step - Right side: Growing binary result (built from remainders)  Visual Elements: - Large input field for decimal number (0-255) - Division steps displayed as rows: \"107 \u00f7 2 = 53 remainder 1\" - Arrow pointing to remainder at each step - Binary result building from right to left as remainders are collected - Final result highlighted in a bordered box  Interactive Controls: - Text input for decimal number (with validation 0-255) - \"Step\" button advances to next division - \"Complete\" button shows all steps at once - \"Reset\" button clears and starts over - Speed slider for auto-step mode  Behavior: - Each click of \"Step\" performs one division and highlights the new remainder - Remainders stack up to form the binary representation - Visual animation shows remainder \"moving\" to binary result area - Auto-step mode animates through all steps with adjustable delay  Data Visibility Requirements: - Stage 1: Show decimal input value - Stage 2: Show first division with quotient and remainder highlighted - Stage 3-N: Show successive divisions with running binary result - Final: Show complete binary number with verification (convert back)  Instructional Rationale: Step-by-step progression allows students to predict each remainder before revealing it, reinforcing understanding of the algorithm rather than just memorizing results.  Implementation: p5.js"},{"location":"chapters/01-number-systems-binary-arithmetic/#hexadecimal-binarys-best-friend","title":"Hexadecimal: Binary's Best Friend","text":"<p>Typing out long strings of 1s and 0s gets tedious fast. Imagine debugging a 32-bit value: \\(11010110111010001001010011110000_2\\). Your eyes are already glazing over, aren't they?</p> <p>Enter hexadecimal (hex for short): base 16. Hex uses digits 0-9 plus letters A-F to represent values 0-15:</p> Decimal Binary Hex 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-hex-works-so-well","title":"Why Hex Works So Well","text":"<p>Here's the clever bit: \\(16 = 2^4\\). This means every hex digit corresponds exactly to four binary digits. That messy 32-bit number from earlier? In hex, it's just:</p> <p>\\(11010110111010001001010011110000_2 = \\text{D6E894F0}_{16}\\)</p> <p>Much more manageable! Here's how the conversion works:</p> <ol> <li>Group binary digits into sets of 4 (from the right)</li> <li>Convert each group to its hex equivalent</li> </ol> <p>Example: Convert \\(10110111_2\\) to hex.</p> Group 1011 0111 Hex digit B 7 <p>Result: \\(\\text{B7}_{16}\\)</p> <p>To go back to binary, just reverse the process\u2014each hex digit becomes four binary digits.</p> <p>Hex Notation Conventions</p> <p>You'll see hex numbers written in several ways:</p> <ul> <li>With subscript: \\(\\text{B7}_{16}\\)</li> <li>With 0x prefix: 0xB7 (common in programming)</li> <li>With h suffix: B7h (common in assembly language)</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-number-base-converter","title":"Diagram: Number Base Converter","text":"Number Base Converter Type: microsim  Bloom Level: Apply (L3) Bloom Verb: calculate, use  Learning Objective: Students will be able to convert between binary, decimal, and hexadecimal representations fluently by practicing with an interactive converter that shows equivalent representations simultaneously.  Canvas Layout: - Width: 700px, Height: 350px - Three large display panels arranged horizontally: Binary, Decimal, Hex - Input mode selector to choose which base to type in - Grouped binary digits with hex alignment indicators  Visual Elements: - Binary display: 8 bits shown with grouping lines every 4 bits - Decimal display: numeric value with leading zeros option - Hex display: 2 hex digits with 0x prefix - Visual grouping lines connecting binary groups to hex digits - Active input field highlighted with cursor  Interactive Controls: - Radio buttons to select input mode (Binary, Decimal, or Hex) - Text input field for entering numbers in selected base - \"Random\" button generates a random 8-bit value - Bit width selector: 4, 8, 16, or 32 bits  Behavior: - Entering a value in one base immediately updates the other two - Invalid input (non-binary digits in binary mode, etc.) shows error highlight - Grouping lines animate to show correspondence between bases - Overflow warning if value exceeds selected bit width  Implementation: p5.js with responsive layout"},{"location":"chapters/01-number-systems-binary-arithmetic/#octal-the-retro-alternative","title":"Octal: The Retro Alternative","text":"<p>While we're on alternative bases, let's briefly cover octal (base 8). Octal uses digits 0-7, and since \\(8 = 2^3\\), each octal digit represents exactly three binary digits.</p> Decimal Binary Octal 0 000 0 1 001 1 2 010 2 3 011 3 4 100 4 5 101 5 6 110 6 7 111 7 <p>Example: Convert \\(10110111_2\\) to octal.</p> <p>First, group into threes from the right (adding a leading zero if needed):</p> Group 010 110 111 Octal digit 2 6 7 <p>Result: \\(267_8\\)</p> <p>Octal was popular in early computing when machines used 12-bit, 24-bit, or 36-bit words (all divisible by 3). Today, hex dominates because 8-bit bytes (divisible by 4) are universal. However, you'll still encounter octal in Unix file permissions (chmod 755, anyone?) and some programming contexts.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-addition-the-foundation-of-arithmetic","title":"Binary Addition: The Foundation of Arithmetic","text":"<p>Now that we can represent numbers in binary, let's learn to do math with them. Binary addition follows the same principles as decimal addition, but with simpler rules because there are only two digits.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-four-addition-rules","title":"The Four Addition Rules","text":"<p>Here's everything you need to know about adding two binary digits:</p> A B Sum Carry 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 <p>The last row is the interesting one: \\(1 + 1 = 10_2\\) (which is 2 in decimal). We write down 0 and carry the 1, just like in decimal when \\(5 + 5 = 10\\).</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#multi-bit-addition","title":"Multi-Bit Addition","text":"<p>Let's add \\(1011_2 + 1101_2\\) step by step:</p> <pre><code>  Carries:  1 1 1\n            1 0 1 1\n          + 1 1 0 1\n          ---------\n          1 1 0 0 0\n</code></pre> <p>Working from right to left:</p> <ol> <li>Position 0: \\(1 + 1 = 10_2\\), write 0, carry 1</li> <li>Position 1: \\(1 + 0 + 1 = 10_2\\), write 0, carry 1</li> <li>Position 2: \\(1 + 1 + 1 = 11_2\\), write 1, carry 1</li> <li>Position 3: \\(1 + 1 + 1 = 11_2\\), write 1, carry 1</li> <li>Carry out becomes the 5th bit</li> </ol> <p>Verification: \\(11_{10} + 13_{10} = 24_{10}\\), and \\(11000_2 = 24_{10}\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-binary-addition-practice-tool","title":"Diagram: Binary Addition Practice Tool","text":"Binary Addition Practice Tool Type: microsim  Bloom Level: Apply (L3) Bloom Verb: calculate, practice  Learning Objective: Students will be able to perform binary addition correctly, including managing carries, by practicing with immediate feedback and step-by-step visualization.  Canvas Layout: - Width: 700px, Height: 450px - Center: Traditional vertical addition layout with carry row, two operands, and result - Right side: Feedback panel showing current step and hints - Bottom: Score tracker for practice mode  Visual Elements: - Carry row at top (initially hidden, revealed as carries occur) - Two 8-bit operand rows with editable fields in practice mode - Sum row where student enters answers (or shows result in demo mode) - Column highlighting to show current position being calculated - Green checkmarks for correct digits, red X for incorrect  Interactive Controls: - \"Demo Mode\" / \"Practice Mode\" toggle - In Demo: \"Step\" button advances column by column, \"Auto\" button animates - In Practice: Student clicks on result bits to toggle them, \"Check\" validates - \"New Problem\" button generates random addends - Difficulty slider: 4-bit, 8-bit, or 16-bit problems  Behavior: - Demo mode: Steps through addition column by column, showing carry logic - Practice mode: Student fills in carries and sum bits, gets immediate feedback - Incorrect answers highlight red with hint about what went wrong - Score tracks correct/incorrect for gamification  Data Visibility Requirements: - Stage 1: Show two operands - Stage 2-N: Highlight current column, show addition of two bits plus carry - Show carry-out when it occurs - Final: Complete sum with all carries visible  Instructional Rationale: Immediate feedback during practice helps students self-correct errors in carry handling, the most common mistake in binary addition.  Implementation: p5.js"},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-subtraction-and-twos-complement","title":"Binary Subtraction and Two's Complement","text":"<p>Subtraction in binary is where things get interesting. While you can do it with borrowing (just like decimal subtraction), computers use a clever trick that lets them subtract using the same addition circuits. This trick is called two's complement.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-concept-of-complements","title":"The Concept of Complements","text":"<p>A complement is basically the \"opposite\" of a number within a given range. For example, if we're working with single decimal digits (0-9), the complement of 3 is 7, because \\(3 + 7 = 10\\).</p> <p>In binary, we have two useful complements:</p> <ul> <li>One's complement: Flip all the bits (0 becomes 1, 1 becomes 0)</li> <li>Two's complement: One's complement plus 1</li> </ul> <p>Example: Find the two's complement of \\(01011001_2\\)</p> <ol> <li>Original: \\(01011001\\)</li> <li>One's complement (flip bits): \\(10100110\\)</li> <li>Two's complement (add 1): \\(10100111\\)</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-magic-of-twos-complement","title":"The Magic of Two's Complement","text":"<p>Here's the beautiful trick: if you want to calculate \\(A - B\\), you can instead calculate \\(A + (\\text{two's complement of } B)\\). The hardware that does addition can also do subtraction!</p> <p>Example: Calculate \\(10010110_2 - 01011001_2\\)</p> <p>Instead of subtracting, we'll add the two's complement of \\(01011001_2\\):</p> <ol> <li>Two's complement of \\(01011001_2 = 10100111_2\\) (from above)</li> <li>Add: \\(10010110_2 + 10100111_2\\)</li> </ol> <pre><code>    Carries: 1 1 1 1 1 1 1\n             1 0 0 1 0 1 1 0\n           + 1 0 1 0 0 1 1 1\n           -----------------\n           1 0 0 1 1 1 1 0 1\n</code></pre> <ol> <li>Discard the carry-out (overflow bit): \\(00111101_2\\)</li> <li>Check: \\(150_{10} - 89_{10} = 61_{10}\\), and \\(00111101_2 = 61_{10}\\) \u2713</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-twos-complement-visualizer","title":"Diagram: Two's Complement Visualizer","text":"Two's Complement Visualizer Type: microsim  Bloom Level: Understand (L2) Bloom Verb: explain, interpret  Learning Objective: Students will be able to explain how two's complement representation works and why it enables subtraction using addition hardware.  Canvas Layout: - Width: 700px, Height: 430px - Top: Original binary number display (8 bits) - Middle: Step-by-step transformation showing one's complement and two's complement - Bottom: Decimal interpretation panel showing signed vs unsigned values  Visual Elements: - 8-bit binary display with bit position labels - Arrow showing transformation from original to one's complement - Arrow showing +1 step to two's complement - Color coding: original bits in blue, flipped bits in orange, final +1 in green - Number line visualization showing negative number position  Interactive Controls: - 8 toggle buttons for inputting a binary number - \"Calculate Complement\" button triggers step-by-step animation - \"Show Number Line\" checkbox reveals circular number line representation - Signed/Unsigned toggle for decimal display  Behavior: - Clicking \"Calculate Complement\" animates bit flipping one position at a time - The +1 step shows carry propagation if applicable - Number line view shows how positive and negative numbers wrap around  Data Visibility Requirements: - Stage 1: Show original 8-bit value with decimal equivalent - Stage 2: Show one's complement (all bits flipped) with intermediate value - Stage 3: Show two's complement (after +1) with final value - Stage 4: Show verification that original + complement = 0 (with overflow discarded)  Instructional Rationale: Seeing each step separately helps students understand WHY two's complement works, not just HOW to calculate it.  Implementation: p5.js"},{"location":"chapters/01-number-systems-binary-arithmetic/#signed-binary-numbers","title":"Signed Binary Numbers","text":"<p>So far, we've only represented positive numbers (unsigned values). But real-world computation needs negative numbers too. How do we represent -42 in binary?</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-sign-magnitude-approach-not-used-much","title":"The Sign-Magnitude Approach (Not Used Much)","text":"<p>The obvious approach: reserve one bit for the sign (0 = positive, 1 = negative) and use the rest for magnitude.</p> <p>\\(+5 = 0000 0101\\) \\(-5 = 1000 0101\\)</p> <p>This seems intuitive, but it causes problems:</p> <ul> <li>We have two representations of zero (+0 and -0)</li> <li>Addition hardware doesn't work directly\u2014we need to check signs first</li> <li>It's wasteful and complicated</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#twos-complement-representation-the-standard","title":"Two's Complement Representation (The Standard)","text":"<p>Modern computers use two's complement for signed integers. The most significant bit (MSB) indicates sign:</p> <ul> <li>MSB = 0: positive number (interpret normally)</li> <li>MSB = 1: negative number (value is \\(-2^{n-1} + \\text{remaining bits}\\))</li> </ul> <p>For 8-bit two's complement:</p> Binary Unsigned Value Signed Value 0000 0000 0 0 0000 0001 1 +1 0111 1111 127 +127 1000 0000 128 -128 1111 1111 255 -1 <p>The Asymmetry</p> <p>Notice something odd? With 8 bits, we can represent -128 through +127. There's one more negative number than positive! This is because we \"use up\" the all-zeros pattern for zero itself. In n-bit two's complement:</p> <ul> <li>Minimum value: \\(-2^{n-1}\\)</li> <li>Maximum value: \\(2^{n-1} - 1\\)</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-twos-complement-is-brilliant","title":"Why Two's Complement Is Brilliant","text":"<p>The beauty of two's complement is that addition works the same whether numbers are signed or unsigned. The hardware doesn't need to know which interpretation you're using! This is why it became the universal standard for integer arithmetic.</p> <p>Example: \\((-3) + 5\\) in 8-bit two's complement</p> <p>\\(-3_{10} = 11111101_2\\) (two's complement of 3) \\(+5_{10} = 00000101_2\\)</p> <pre><code>    11111101\n  + 00000101\n  ----------\n  1 00000010\n</code></pre> <p>Discarding the carry-out: \\(00000010_2 = 2_{10}\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#overflow-detection","title":"Overflow Detection","text":"<p>When arithmetic results exceed the range a given number of bits can represent, we get overflow. This is one of the sneakiest bugs in digital systems\u2014everything looks normal, but the answer is completely wrong.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#unsigned-overflow","title":"Unsigned Overflow","text":"<p>For unsigned numbers, overflow occurs when a carry-out propagates beyond the most significant bit. Adding \\(11111111_2 + 00000001_2\\) (255 + 1) gives \\(100000000_2\\), which needs 9 bits. If we only have 8, the result wraps around to 0.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#signed-overflow","title":"Signed Overflow","text":"<p>For signed numbers, overflow is trickier. It occurs when:</p> <ul> <li>Adding two positive numbers gives a negative result</li> <li>Adding two negative numbers gives a positive result</li> </ul> <p>The key insight: signed overflow occurs when the carry into the MSB differs from the carry out of the MSB.</p> <p>Example of signed overflow: \\(01111111_2 + 00000001_2\\) (+127 + 1)</p> <pre><code>    Carries: 1 1 1 1 1 1 1 0\n             0 1 1 1 1 1 1 1   (+127)\n           + 0 0 0 0 0 0 0 1   (+1)\n           -----------------\n             1 0 0 0 0 0 0 0   (-128 ???)\n</code></pre> <p>The result \\(10000000_2\\) is interpreted as -128 in signed representation. That's clearly wrong! The carry into the MSB was 1, but the carry out was 0\u2014they differ, signaling overflow.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-overflow-detection-simulator","title":"Diagram: Overflow Detection Simulator","text":"Overflow Detection Simulator Type: microsim  Bloom Level: Analyze (L4) Bloom Verb: differentiate, examine  Learning Objective: Students will be able to differentiate between situations that cause overflow and those that don't by examining carry patterns in signed addition.  Canvas Layout: - Width: 700px, Height: 450px - Top: Two 8-bit input panels for operands with signed decimal display - Middle: Addition visualization with carry chain highlighted - Bottom: Result panel with overflow indicator and explanation  Visual Elements: - 8-bit operand displays with MSB visually emphasized (larger, colored differently) - Carry chain showing all 9 carry bits explicitly - Carry-in to MSB and carry-out from MSB specially highlighted - XOR gate icon between the two critical carries - Overflow LED: green (no overflow) or red (overflow) - Explanation text describing why overflow did/didn't occur  Interactive Controls: - Toggle buttons for each operand bit - Quick-select buttons for interesting cases: \"+127 + 1\", \"-128 + (-1)\", \"50 + 50\" - Signed/Unsigned interpretation toggle - \"Test Random\" button for practice  Behavior: - Changing any operand bit immediately recalculates everything - Carry chain animates to show propagation - Overflow detection shows carry-in vs carry-out comparison - Explanation updates based on current numbers  Data Visibility Requirements: - Show both operands with signed decimal interpretation - Highlight carry-in to bit 7 and carry-out from bit 7 - Show XOR of these two carries - Display overflow flag result  Instructional Rationale: By explicitly showing the two critical carries and their XOR, students can verify the overflow detection rule rather than just memorizing it.  Implementation: p5.js"},{"location":"chapters/01-number-systems-binary-arithmetic/#bcd-encoding-when-decimal-display-matters","title":"BCD Encoding: When Decimal Display Matters","text":"<p>Binary-Coded Decimal (BCD) represents each decimal digit separately in 4 bits. Instead of converting the whole number to binary, we convert each digit independently.</p> <p>Example: Encode \\(47_{10}\\) in BCD</p> <ul> <li>4 in binary: 0100</li> <li>7 in binary: 0111</li> <li>BCD result: 0100 0111</li> </ul> <p>Compare to pure binary: \\(47_{10} = 00101111_2\\)</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-bcd-exists","title":"Why BCD Exists","text":"<p>BCD seems wasteful (we're using 8 bits to store a number that fits in 6), so why use it? Several practical reasons:</p> <ol> <li>Easy decimal display: Each 4-bit group directly maps to a display digit</li> <li>Exact decimal arithmetic: No binary rounding errors for financial calculations</li> <li>Legacy hardware: Seven-segment displays, calculators, and some industrial equipment expect BCD</li> </ol> <p>BCD addition requires special handling when a group exceeds 9. If adding two BCD digits produces a result from 10-15, we add 6 to \"fix\" it:</p> <p>Example: \\(27_{BCD} + 35_{BCD}\\)</p> <pre><code>    0010 0111\n  + 0011 0101\n  -----------\n    0101 1100\n</code></pre> <p>The second group is \\(1100_2 = 12_{10}\\), which is invalid BCD. Add 6:</p> <pre><code>    0101 1100\n  + 0000 0110\n  -----------\n    0110 0010\n</code></pre> <p>Result: \\(0110 0010_{BCD} = 62_{10}\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#gray-code-when-only-one-bit-should-change","title":"Gray Code: When Only One Bit Should Change","text":"<p>Here's a puzzle: what happens if you're reading a binary counter right at the moment it transitions from 0111 to 1000? All four bits change simultaneously\u2014but in real hardware, they don't change at exactly the same instant. For a brief moment, you might read garbage like 0000 or 1111.</p> <p>Gray code solves this by ensuring only one bit changes between consecutive values:</p> Decimal Binary Gray Code 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 <p>Notice how each step changes exactly one bit. This makes Gray code perfect for:</p> <ul> <li>Position encoders (rotary and linear)</li> <li>Analog-to-digital converters</li> <li>State machine encoding to avoid glitches</li> <li>Communication systems where bit errors should be minimized</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#converting-binary-to-gray-code","title":"Converting Binary to Gray Code","text":"<p>The conversion is surprisingly simple using XOR:</p> <p>\\(G_n = B_n\\) (copy the MSB) \\(G_i = B_{i+1} \\oplus B_i\\) (XOR each bit with the one above it)</p> <p>Example: Convert \\(1011_2\\) to Gray code</p> <ul> <li>\\(G_3 = B_3 = 1\\)</li> <li>\\(G_2 = B_3 \\oplus B_2 = 1 \\oplus 0 = 1\\)</li> <li>\\(G_1 = B_2 \\oplus B_1 = 0 \\oplus 1 = 1\\)</li> <li>\\(G_0 = B_1 \\oplus B_0 = 1 \\oplus 1 = 0\\)</li> </ul> <p>Gray code: \\(1110\\)</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-gray-code-vs-binary-counter-animation","title":"Diagram: Gray Code vs Binary Counter Animation","text":"Gray Code vs Binary Counter Animation Type: microsim  Bloom Level: Analyze (L4) Bloom Verb: compare, contrast  Learning Objective: Students will be able to contrast Gray code and binary counting by observing how many bits change during each transition in both systems.  Canvas Layout: - Width: 700px, Height: 400px - Left side: 4-bit binary counter display - Right side: 4-bit Gray code counter display - Bottom: Bit-change histogram and transition indicators  Visual Elements: - Two columns of 4 large bits each, showing binary and Gray code - Bits that will change on next count highlighted in yellow - Counter showing decimal value (0-15) - Bar graph showing \"bits changed\" history for each encoding - Transition arrows between bit patterns  Interactive Controls: - \"Step\" button advances both counters by one - \"Auto\" toggle for continuous counting with speed slider - \"Reset\" button returns to zero - \"Show Hazard\" checkbox simulates what happens during transitions  Behavior: - Each step highlights which bits are about to change BEFORE the transition - Animation shows bits flipping (binary often has cascading effect, Gray has single flip) - Hazard mode shows how binary can produce brief invalid outputs during multi-bit transitions - Histogram tracks average bits changed over time  Data Visibility Requirements: - Current value in both encodings with decimal equivalent - Highlighted bits that will change on next increment - Count of bits changing per transition - Running average comparison  Instructional Rationale: Side-by-side comparison makes the single-bit-change property of Gray code immediately visible and memorable.  Implementation: p5.js"},{"location":"chapters/01-number-systems-binary-arithmetic/#weighted-codes-and-other-representations","title":"Weighted Codes and Other Representations","text":"<p>Binary and Gray code are just two of many possible codes. A weighted code is one where each bit position has a specific \"weight\" that determines its contribution to the value.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#standard-binary-8-4-2-1-weighted","title":"Standard Binary: 8-4-2-1 Weighted","text":"<p>Regular binary is a weighted code with weights 8, 4, 2, 1 for a 4-bit number. But other weight combinations are possible and sometimes useful.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#2-4-2-1-code","title":"2-4-2-1 Code","text":"<p>This code uses weights 2, 4, 2, 1 (notice the repeated weights). It's useful because it's self-complementing: to get the 9's complement of a BCD digit, just flip all bits.</p> Decimal 2-4-2-1 0 0000 1 0001 2 0010 3 0011 4 0100 5 1011 6 1100 7 1101 8 1110 9 1111 <p>To find the 9's complement of 3 (which is 6): flip \\(0011 \\rightarrow 1100\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#excess-3-code","title":"Excess-3 Code","text":"<p>Excess-3 is BCD with 3 added to each value. It's also self-complementing and was popular in early computers.</p> Decimal BCD Excess-3 0 0000 0011 1 0001 0100 2 0010 0101 3 0011 0110 4 0100 0111 5 0101 1000 6 0110 1001 7 0111 1010 8 1000 1011 9 1001 1100"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-weighted-codes-comparison-table","title":"Diagram: Weighted Codes Comparison Table","text":"Weighted Codes Comparison Table Type: infographic  Bloom Level: Remember (L1) Bloom Verb: identify, list  Learning Objective: Students will be able to identify different weighted code representations for decimal digits by comparing multiple encoding schemes in an interactive table.  Canvas Layout: - Width: 700px, Height: 350px - Interactive table showing multiple encoding schemes - Header row with column selectors - Hover reveals calculation for each code  Visual Elements: - Table with columns: Decimal, 8-4-2-1 BCD, 2-4-2-1, Excess-3, Gray - Each cell shows 4-bit value - Hover on cell shows calculation breakdown (e.g., \"2\u00d71 + 4\u00d70 + 2\u00d70 + 1\u00d71 = 3\") - Self-complement pairs highlighted with matching colors  Interactive Controls: - Column visibility checkboxes to show/hide encoding schemes - Decimal digit selector (0-9) to highlight a specific row - \"Show Complements\" toggle to highlight 9's complement pairs - \"Verify Weight\" mode: click any cell to see weight calculation  Behavior: - Hovering a cell shows how the weights produce the decimal value - Clicking a row highlights it across all visible columns - Complement mode draws lines connecting 0\u21949, 1\u21948, 2\u21947, etc.  Implementation: HTML/CSS table with JavaScript interactivity"},{"location":"chapters/01-number-systems-binary-arithmetic/#practical-applications","title":"Practical Applications","text":"<p>Let's tie these concepts together with real-world examples you'll encounter in digital design.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#memory-addressing","title":"Memory Addressing","text":"<p>Computer memory is addressed using binary numbers. A 16-bit address bus can access \\(2^{16} = 65,536\\) memory locations. This is why you see memory sizes like 64K, 256K, or 4G\u2014they're all powers of 2.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#color-representation","title":"Color Representation","text":"<p>RGB colors use 8 bits per channel (red, green, blue), giving 24-bit color with over 16 million possibilities. That's \\(2^{24} = 16,777,216\\) colors. Web colors like #FF5733 are just three hex values packed together.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#digital-signal-processing","title":"Digital Signal Processing","text":"<p>Audio samples are typically 16-bit signed integers, ranging from -32,768 to +32,767. This gives enough precision for high-quality sound while fitting nicely into 2 bytes.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#error-detection","title":"Error Detection","text":"<p>Parity bits add a single bit to detect single-bit errors in transmission. Even parity means the total number of 1s (including the parity bit) is always even. It's a simple application of binary counting.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#key-takeaways","title":"Key Takeaways","text":"<p>As we wrap up this chapter, let's summarize the essential concepts:</p> <ol> <li>Binary is the language of digital circuits because it maps directly to physical on/off states</li> <li>Positional notation works the same regardless of base\u2014only the base value changes</li> <li>Hexadecimal is binary's shorthand, with each hex digit representing exactly 4 bits</li> <li>Two's complement enables subtraction using addition, simplifying hardware design</li> <li>Overflow must be detected to avoid silent calculation errors</li> <li>Gray code prevents glitches during counter transitions</li> <li>Different codes serve different purposes\u2014there's no single \"best\" representation</li> </ol> <p>These fundamentals will appear constantly throughout your digital electronics journey. When you're debugging a circuit and see 0xDEADBEEF in memory, you'll know exactly what you're looking at (and appreciate the programmer's sense of humor).</p> Self-Check: Can you convert 200 to binary using repeated division? <p>\\(200 \\div 2 = 100\\) remainder 0 \\(100 \\div 2 = 50\\) remainder 0 \\(50 \\div 2 = 25\\) remainder 0 \\(25 \\div 2 = 12\\) remainder 1 \\(12 \\div 2 = 6\\) remainder 0 \\(6 \\div 2 = 3\\) remainder 0 \\(3 \\div 2 = 1\\) remainder 1 \\(1 \\div 2 = 0\\) remainder 1</p> <p>Reading bottom to top: \\(11001000_2\\)</p> Self-Check: What is the 8-bit two's complement of 100? <p>Original: \\(01100100_2\\) One's complement: \\(10011011_2\\) Two's complement (add 1): \\(10011100_2\\)</p> <p>Interpretation: This represents \\(-100\\) in signed 8-bit format.</p> <p>In the next chapter, we'll put these number systems to work as we explore Boolean algebra\u2014the mathematical framework that governs all digital logic.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/","title":"Boolean Algebra Fundamentals","text":""},{"location":"chapters/02-boolean-algebra-fundamentals/#summary","title":"Summary","text":"<p>This chapter transforms logical reasoning into a mathematical framework that forms the theoretical foundation of all digital circuits. Students will learn about Boolean variables, constants, and the three fundamental operations (AND, OR, NOT), how to construct and interpret Boolean expressions and functions, the role of truth tables as formal specifications, and all essential Boolean algebra laws including De Morgan's theorem. Mastering these concepts enables students to analyze and simplify digital logic mathematically.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>Boolean Variable</li> <li>Boolean Constant</li> <li>Boolean Expression</li> <li>Boolean Function</li> <li>Truth Table</li> <li>AND Operation</li> <li>OR Operation</li> <li>NOT Operation</li> <li>Boolean Algebra</li> <li>Identity Law</li> <li>Null Law</li> <li>Idempotent Law</li> <li>Complement Law</li> <li>Commutative Law</li> <li>Associative Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>De Morgan's Theorem</li> <li>Dual Expression</li> <li>Consensus Theorem</li> <li>Boolean Proof Technique</li> </ol>"},{"location":"chapters/02-boolean-algebra-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Number Systems and Binary Arithmetic</li> </ul>"},{"location":"chapters/02-boolean-algebra-fundamentals/#introduction-welcome-to-the-world-of-true-and-false","title":"Introduction: Welcome to the World of True and False","text":"<p>Have you ever had an argument that was so simple it could only end with a \"yes\" or \"no\"? Welcome to Boolean algebra, where every argument ends that way. Named after mathematician George Boole (who presumably never had to answer \"maybe\" to dinner plans), Boolean algebra is a mathematical system where there are only two possible values: true and false, or as we electrical engineers prefer to call them, 1 and 0.</p> <p>Here's the thing that makes Boolean algebra so powerful: those same rules that govern simple true/false logic are exactly the rules that govern how billions of transistors in your computer make decisions every nanosecond. When you type a key, scroll a page, or run a program, you're ultimately relying on circuits that evaluate Boolean expressions. Digital circuits are, quite literally, Boolean functions made physical.</p> <p>Think of Boolean algebra as the \"grammar\" of digital logic. Just as you need to understand English grammar before writing a novel, you need to understand Boolean algebra before designing digital circuits. The good news? This grammar has far fewer exceptions than English. (No \"i before e except after c\" nonsense here!)</p> <p>By the end of this chapter, you'll be able to manipulate logical expressions with the same confidence that you manipulate algebraic equations\u2014and you'll understand why a law discovered in 1847 by a self-taught mathematician became the foundation for the digital revolution.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-variables-and-constants-the-building-blocks","title":"Boolean Variables and Constants: The Building Blocks","text":""},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-constants","title":"Boolean Constants","text":"<p>Let's start with the simplest possible idea: in the Boolean world, there are exactly two constants:</p> <ul> <li>0 (false, low, off)</li> <li>1 (true, high, on)</li> </ul> <p>That's it. No decimals, no fractions, no irrational numbers lurking about. Zero and one. Off and on. False and true. If regular algebra is an all-you-can-eat buffet of numbers, Boolean algebra is a very exclusive restaurant with exactly two items on the menu.</p> <p>These constants correspond directly to physical voltage levels in digital circuits. Typically, 0 represents a low voltage (near ground) and 1 represents a high voltage (near the power supply). But we'll worry about those physical details later\u2014for now, just remember: two values, and two values only.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-variables","title":"Boolean Variables","text":"<p>A Boolean variable is a symbol that can hold one of the two Boolean constants. We typically use uppercase letters like A, B, C, X, Y, or Z to represent Boolean variables. Sometimes you'll see lowercase letters or descriptive names like <code>enable</code>, <code>reset</code>, or <code>clock</code>\u2014especially in hardware description languages.</p> <p>Here's the key insight: a Boolean variable is like a light switch. At any given moment, it's either ON (1) or OFF (0). It can't be \"kind of on\" or \"mostly off.\" This binary nature is what makes digital systems so reliable\u2014there's no ambiguity about what state a signal is in.</p> Symbol Possible Values Physical Analogy A 0 or 1 Light switch B 0 or 1 Door (open/closed) X 0 or 1 Valve (open/closed) enable 0 or 1 Permission granted <p>Why Binary?</p> <p>Binary isn't just simpler\u2014it's more robust. When you only need to distinguish between two states (high vs. low voltage), you can tolerate a lot of electrical noise. Trying to distinguish between 10 different voltage levels? That's much harder to get right reliably.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#the-three-fundamental-operations","title":"The Three Fundamental Operations","text":"<p>With only two values to work with, you might think Boolean algebra would be boring. But here's where it gets interesting: we can combine Boolean values using operations (also called operators or gates). There are three fundamental operations that form the basis of all Boolean logic.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#not-operation-inversion","title":"NOT Operation (Inversion)","text":"<p>The NOT operation is the simplest: it flips the value. Give it a 0, it returns 1. Give it a 1, it returns 0. In mathematical notation, we write the NOT of A as:</p> <ul> <li>\\(\\overline{A}\\) (A with a bar over it)</li> <li>\\(A'\\) (A prime)</li> <li>\\(\\neg A\\) (logical negation symbol)</li> </ul> <p>Think of NOT as a contrarian friend who always disagrees with you. You say \"yes,\" they say \"no.\" You say \"no,\" they say \"yes.\"</p> A \\(\\overline{A}\\) 0 1 1 0 <p>In circuit terms, NOT is implemented by an inverter\u2014a simple gate that inverts its input.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#and-operation-conjunction","title":"AND Operation (Conjunction)","text":"<p>The AND operation takes two inputs and produces an output of 1 only if both inputs are 1. If either input (or both) is 0, the output is 0. We write A AND B as:</p> <ul> <li>\\(A \\cdot B\\) (A dot B)</li> <li>\\(AB\\) (just written together, like multiplication)</li> <li>\\(A \\land B\\) (logical AND symbol)</li> </ul> <p>Here's a great way to think about AND: imagine two switches in series controlling a light. The light only turns on if both Switch A AND Switch B are closed. Open either one, and the light goes off.</p> A B \\(A \\cdot B\\) 0 0 0 0 1 0 1 0 0 1 1 1 <p>Memory trick: AND is like multiplication in regular algebra. In fact, if you treat 0 and 1 as regular numbers, \\(A \\cdot B\\) works exactly like multiplication: \\(0 \\times 0 = 0\\), \\(0 \\times 1 = 0\\), \\(1 \\times 0 = 0\\), \\(1 \\times 1 = 1\\). This isn't a coincidence!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#or-operation-disjunction","title":"OR Operation (Disjunction)","text":"<p>The OR operation produces an output of 1 if at least one input is 1. Only when both inputs are 0 does the output become 0. We write A OR B as:</p> <ul> <li>\\(A + B\\) (A plus B)</li> <li>\\(A \\lor B\\) (logical OR symbol)</li> </ul> <p>Think of OR as two switches in parallel controlling a light. The light turns on if Switch A OR Switch B (or both!) are closed. The light only goes off if both switches are open.</p> A B \\(A + B\\) 0 0 0 0 1 1 1 0 1 1 1 1 <p>Wait, 1 + 1 = 1? Yes! This is Boolean addition, not regular arithmetic. In Boolean algebra, \\(1 + 1 = 1\\), not 2. Remember, there are only two values allowed. If the output is \"true,\" it stays true\u2014it doesn't become \"extra true.\"</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-three-fundamental-operations","title":"Diagram: Three Fundamental Operations","text":"Three Fundamental Operations Interactive Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Demonstrate  Learning Objective: Demonstrate how the three fundamental Boolean operations (AND, OR, NOT) transform input values into output values through interactive exploration.  Instructional Rationale: Interactive toggle switches allow students to immediately see the cause-and-effect relationship between inputs and outputs, reinforcing the truth table patterns through hands-on experimentation.  Canvas Layout:  - Three panels side by side showing NOT, AND, and OR operations - Each panel has clickable input toggles (squares that show 0 or 1) - NOT panel: one input, one output - AND/OR panels: two inputs, one output - Operation symbol and name displayed in each panel - Output displays prominently with color coding (0=gray, 1=green)  Interactive Elements:  - Click on input squares to toggle between 0 and 1 - Outputs update immediately when inputs change - Visual connection lines from inputs through operation symbol to output  Visual Style:  - Clean, modern design with rounded rectangles for inputs/outputs - Color scheme: inputs in blue tones, outputs green when 1, gray when 0 - Operation symbols clearly labeled (NOT: inverter triangle, AND: D-shape, OR: curved shape)  Data Visibility:  - Current input values always visible - Current output value always visible - Expression shown below each operation (e.g., \"A AND B = 1\")  Implementation: p5.js with canvas-based toggle buttons"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-expressions-building-more-complex-logic","title":"Boolean Expressions: Building More Complex Logic","text":"<p>Now that we have our three fundamental operations, we can combine them to create Boolean expressions\u2014formulas that describe more complex logical relationships.</p> <p>A Boolean expression is any valid combination of:</p> <ul> <li>Boolean constants (0, 1)</li> <li>Boolean variables (A, B, C, ...)</li> <li>Boolean operators (AND, OR, NOT)</li> <li>Parentheses (for grouping)</li> </ul> <p>Here are some examples of Boolean expressions:</p> <ul> <li>\\(\\overline{A}\\) \u2014 \"NOT A\"</li> <li>\\(A \\cdot B\\) \u2014 \"A AND B\"</li> <li>\\(A + B\\) \u2014 \"A OR B\"</li> <li>\\(\\overline{A} + B\\) \u2014 \"NOT A OR B\"</li> <li>\\(A \\cdot (B + C)\\) \u2014 \"A AND (B OR C)\"</li> <li>\\(\\overline{A \\cdot B}\\) \u2014 \"NOT (A AND B)\"</li> </ul>"},{"location":"chapters/02-boolean-algebra-fundamentals/#order-of-operations-precedence","title":"Order of Operations (Precedence)","text":"<p>Just like in regular algebra where multiplication happens before addition, Boolean algebra has its own precedence rules:</p> <ol> <li>Parentheses \u2014 highest priority, evaluated first</li> <li>NOT \u2014 evaluated next</li> <li>AND \u2014 evaluated before OR</li> <li>OR \u2014 evaluated last</li> </ol> <p>So the expression \\(A + B \\cdot C\\) means \\(A + (B \\cdot C)\\), not \\((A + B) \\cdot C\\). The AND happens first, just like multiplication happens before addition in regular algebra.</p> <p>Precedence Example</p> <p>Evaluate \\(\\overline{A} + B \\cdot C\\) when \\(A=1\\), \\(B=1\\), \\(C=0\\):</p> <ol> <li>First, NOT: \\(\\overline{A} = \\overline{1} = 0\\)</li> <li>Next, AND: \\(B \\cdot C = 1 \\cdot 0 = 0\\)</li> <li>Finally, OR: \\(0 + 0 = 0\\)</li> </ol> <p>Result: 0</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-functions-expressions-with-a-name","title":"Boolean Functions: Expressions with a Name","text":"<p>A Boolean function is simply a Boolean expression that has been given a name and explicitly shows its input variables. We write it as:</p> \\[F(A, B, C) = A \\cdot B + \\overline{C}\\] <p>This function, named \\(F\\), takes three inputs (\\(A\\), \\(B\\), \\(C\\)) and produces one output based on the expression \\(A \\cdot B + \\overline{C}\\).</p> <p>The distinction between expressions and functions is subtle but useful:</p> <ul> <li>An expression is the formula itself: \\(A \\cdot B + \\overline{C}\\)</li> <li>A function wraps that expression with a name and declares its inputs: \\(F(A, B, C) = A \\cdot B + \\overline{C}\\)</li> </ul> <p>Think of it this way: the expression is the recipe, and the function is the recipe with a title and ingredient list at the top.</p> <p>Every Boolean function with \\(n\\) input variables can be thought of as a mapping from \\(2^n\\) possible input combinations to output values. A function of 3 variables has \\(2^3 = 8\\) possible input combinations. A function of 4 variables has \\(2^4 = 16\\) combinations. This exponential growth is why simplifying Boolean functions becomes increasingly important as the number of variables grows.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#truth-tables-the-complete-picture","title":"Truth Tables: The Complete Picture","text":"<p>A truth table is a systematic way to show all possible input combinations for a Boolean function and its corresponding output for each combination. It's like a lookup table for your function\u2014give me any inputs, and I'll tell you the output.</p> <p>For a function with \\(n\\) variables, the truth table has \\(2^n\\) rows. Let's build a truth table for \\(F(A, B) = A \\cdot B + \\overline{B}\\):</p> Row A B \\(\\overline{B}\\) \\(A \\cdot B\\) \\(A \\cdot B + \\overline{B}\\) 0 0 0 1 0 1 1 0 1 0 0 0 2 1 0 1 0 1 3 1 1 0 1 1 <p>Notice that we included intermediate columns to show our work. This makes it easier to verify the calculation and catch errors. The rightmost column gives us our final answer: the function outputs 1 for inputs (0,0), (1,0), and (1,1), and outputs 0 only for input (0,1).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#truth-tables-as-specifications","title":"Truth Tables as Specifications","text":"<p>Here's a powerful idea: truth tables can serve as specifications for digital circuits. If someone gives you a truth table, you have a complete, unambiguous definition of what the circuit should do. There's no interpretation needed\u2014every possible input has a defined output.</p> <p>This is why truth tables are so important in digital design:</p> <ul> <li>Designers use them to specify what a circuit should do</li> <li>Verifiers use them to check if a circuit works correctly</li> <li>Optimizers use them to find simpler implementations</li> </ul>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-truth-table-builder","title":"Diagram: Truth Table Builder","text":"Truth Table Builder MicroSim Type: microsim  Bloom Level: Apply (L3) Bloom Verb: Execute  Learning Objective: Enable students to build truth tables for Boolean expressions by entering expressions and seeing the complete truth table generated automatically.  Instructional Rationale: Active construction of truth tables reinforces understanding of how Boolean expressions map inputs to outputs. The immediate feedback helps students verify their mental model.  Canvas Layout:  - Top section: Expression input area with example expressions shown - Variable selector: Choose 2, 3, or 4 variables - Main area: Generated truth table with all rows - Highlight feature: Click any row to highlight input-output path  Interactive Elements:  - Text input field for Boolean expression using notation: AND (*), OR (+), NOT (!) - Dropdown to select number of variables (2-4) - \"Generate\" button to create truth table - Clickable rows to highlight and explain the evaluation - Example expressions as clickable chips to auto-populate  Visual Style:  - Table with alternating row colors for readability - Output column color-coded: green for 1, gray for 0 - Expression parsing feedback (valid/invalid indicator) - Current row highlighted when clicked  Error Handling:  - Display helpful message for invalid expressions - Suggest corrections for common syntax errors  Implementation: p5.js with string parsing for expression evaluation"},{"location":"chapters/02-boolean-algebra-fundamentals/#introduction-to-boolean-algebra-laws","title":"Introduction to Boolean Algebra Laws","text":"<p>Now we arrive at the heart of this chapter: the laws of Boolean algebra. These laws are your toolkit for manipulating and simplifying Boolean expressions. Learn them well, and you'll be able to transform complex, gate-hungry expressions into elegant, minimal circuits.</p> <p>Why do we care about simplification? Because simpler expressions mean:</p> <ul> <li>Fewer gates \u2014 less hardware, lower cost</li> <li>Lower power consumption \u2014 fewer transistors switching</li> <li>Faster circuits \u2014 fewer gate delays in the path</li> <li>Easier debugging \u2014 simpler designs are easier to understand</li> </ul> <p>The laws we're about to explore are theorems that have been proven to always hold true for Boolean algebra. Unlike regular algebra where \\(x \\cdot x = x^2\\), in Boolean algebra \\(A \\cdot A = A\\). Different system, different rules!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#identity-law","title":"Identity Law","text":"<p>The Identity Law tells us what happens when you combine a variable with the \"identity elements\" 0 and 1:</p> <p>[A + 0 = A] [A \\cdot 1 = A]</p> <p>In words:</p> <ul> <li>OR-ing anything with 0 leaves it unchanged</li> <li>AND-ing anything with 1 leaves it unchanged</li> </ul> <p>This makes intuitive sense: adding false to something doesn't change its truth value, and multiplying by true doesn't change anything either.</p> <p>Analogy: Think of 0 as \"adding zero\" in regular math (\\(x + 0 = x\\)) and 1 as \"multiplying by one\" (\\(x \\times 1 = x\\)).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#null-law-annulment-law","title":"Null Law (Annulment Law)","text":"<p>The Null Law (also called the Annulment Law) describes the \"dominating\" elements:</p> <p>[A + 1 = 1] [A \\cdot 0 = 0]</p> <p>In words:</p> <ul> <li>OR-ing anything with 1 always gives 1</li> <li>AND-ing anything with 0 always gives 0</li> </ul> <p>These are the \"override\" cases. If one input is already at the dominating value, the other input doesn't matter.</p> <p>Analogy: It's like multiplying by zero in regular math\u2014no matter what else is there, the result is zero. Similarly, if you already know something is definitely true (1), OR-ing it with anything else keeps it true.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#idempotent-law","title":"Idempotent Law","text":"<p>The Idempotent Law tells us what happens when we combine a variable with itself:</p> <p>[A + A = A] [A \\cdot A = A]</p> <p>\"Idempotent\" comes from Latin meaning \"same power\"\u2014applying the operation multiple times has the same effect as applying it once.</p> <p>This is one of those laws that makes Boolean algebra different from regular algebra. In regular algebra, \\(x + x = 2x\\) and \\(x \\cdot x = x^2\\). But in Boolean algebra, there are no 2's or squares\u2014only 0 and 1. Combining something with itself doesn't make it \"more true\" or \"more false.\"</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#complement-law","title":"Complement Law","text":"<p>The Complement Law describes what happens when you combine a variable with its own complement (NOT):</p> <p>[A + \\overline{A} = 1] [A \\cdot \\overline{A} = 0]</p> <p>In words:</p> <ul> <li>A variable OR its complement is always 1</li> <li>A variable AND its complement is always 0</li> </ul> <p>This should feel right: something is either true or not true (always true as a disjunction), but it can't be both true and not true at the same time (always false as a conjunction).</p> <p>Analogy: It's like asking \"Is the light on OR off?\" The answer is always yes. But \"Is the light on AND off simultaneously?\" The answer is always no.</p> <p>Also, applying NOT twice returns you to the original value:</p> \\[\\overline{\\overline{A}} = A\\] <p>Double negation cancels out, just like in regular logic: \"I'm not not going to the party\" means you're going.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#commutative-law","title":"Commutative Law","text":"<p>The Commutative Law says that the order of operands doesn't matter for AND and OR:</p> <p>[A + B = B + A] [A \\cdot B = B \\cdot A]</p> <p>You can swap the inputs around freely. Just like in regular algebra where \\(3 + 5 = 5 + 3\\).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#associative-law","title":"Associative Law","text":"<p>The Associative Law says that grouping doesn't matter when you have multiple AND or multiple OR operations:</p> <p>[A + (B + C) = (A + B) + C] [A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C]</p> <p>This means you can remove parentheses when you have a chain of the same operation: \\(A + B + C\\) is unambiguous, as is \\(A \\cdot B \\cdot C\\).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#distributive-law","title":"Distributive Law","text":"<p>The Distributive Law is where things get interesting. Like regular algebra, AND distributes over OR:</p> \\[A \\cdot (B + C) = A \\cdot B + A \\cdot C\\] <p>But here's a twist\u2014in Boolean algebra, OR also distributes over AND!</p> \\[A + (B \\cdot C) = (A + B) \\cdot (A + C)\\] <p>This second form has no counterpart in regular algebra. In ordinary algebra, \\(a + (b \\times c) \\neq (a + b) \\times (a + c)\\). But in Boolean algebra, it works! This is one of the surprising and powerful features of Boolean algebra.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-boolean-algebra-laws-explorer","title":"Diagram: Boolean Algebra Laws Explorer","text":"Boolean Algebra Laws Interactive Explorer Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Explain  Learning Objective: Students will be able to explain how each Boolean algebra law transforms expressions by stepping through concrete examples with specific values.  Instructional Rationale: Seeing the same law applied with different variable values helps students generalize the pattern. Step-through interaction ensures they can't skip ahead without seeing the transformation.  Canvas Layout:  - Law selector at top (dropdown or tabs): Identity, Null, Idempotent, Complement, Commutative, Associative, Distributive - Left side: Original expression with variable value toggles - Center: Transformation arrow with law name - Right side: Equivalent simplified expression - Bottom: Evaluation showing both sides equal the same result  Interactive Elements:  - Dropdown/tabs to select which law to explore - Toggle buttons for variable values (A=0/1, B=0/1, C=0/1) - \"Step\" button to show transformation step by step - Visual highlighting of which part of expression is being transformed  Data Visibility:  - Original expression: A + 0 = A (with current value of A shown) - After applying law: Result shown - Verification: Both sides evaluated to show equality  Visual Style:  - Clean mathematical notation - Transformation arrows between equivalent forms - Color coding: variables in blue, constants in gray, result in green - Law name and formula shown prominently  Implementation: p5.js with canvas-based controls"},{"location":"chapters/02-boolean-algebra-fundamentals/#absorption-law","title":"Absorption Law","text":"<p>The Absorption Law lets you simplify expressions where a term \"absorbs\" a more complex term:</p> <p>[A + A \\cdot B = A] [A \\cdot (A + B) = A]</p> <p>At first glance, this might seem strange. Let's think through the first one: \\(A + A \\cdot B = A\\).</p> <ul> <li>If \\(A = 0\\): \\(0 + 0 \\cdot B = 0 + 0 = 0 = A\\) \u2713</li> <li>If \\(A = 1\\): \\(1 + 1 \\cdot B = 1 + B = 1 = A\\) \u2713 (by the null law)</li> </ul> <p>The term \\(A\\) \"absorbs\" the \\(A \\cdot B\\) term because if \\(A\\) is already true, who cares about \\(A \\cdot B\\)? And if \\(A\\) is false, then \\(A \\cdot B\\) is also false.</p> <p>Analogy: Imagine you're at a buffet. You take item A. Then someone offers you \"A along with B.\" If you already have A, taking \"A with B\" doesn't add anything useful\u2014you still just have A (you already took it!).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#de-morgans-theorem","title":"De Morgan's Theorem","text":"<p>De Morgan's Theorem is arguably the most important theorem in Boolean algebra for practical circuit design. It provides a way to convert between AND and OR operations:</p> <p>[\\overline{A \\cdot B} = \\overline{A} + \\overline{B}] [\\overline{A + B} = \\overline{A} \\cdot \\overline{B}]</p> <p>In words:</p> <ul> <li>The complement of an AND is the OR of the complements</li> <li>The complement of an OR is the AND of the complements</li> </ul> <p>These theorems are incredibly useful because they let you:</p> <ol> <li>Convert between gate types \u2014 Transform an AND expression into an OR expression (with inversions)</li> <li>Push inversions inward \u2014 Move NOT operations closer to the variables</li> <li>Implement logic with different gate types \u2014 Crucial when you only have certain gates available</li> </ol> <p>Memory trick: \"Break the bar, change the sign.\" When you \"break\" the NOT bar over an expression, you change AND to OR (or OR to AND) and apply NOT to each individual term.</p> <p>Let's verify the first form with a truth table:</p> A B \\(A \\cdot B\\) \\(\\overline{A \\cdot B}\\) \\(\\overline{A}\\) \\(\\overline{B}\\) \\(\\overline{A} + \\overline{B}\\) 0 0 0 1 1 1 1 0 1 0 1 1 0 1 1 0 0 1 0 1 1 1 1 1 0 0 0 0 <p>The columns \\(\\overline{A \\cdot B}\\) and \\(\\overline{A} + \\overline{B}\\) are identical\u2014the theorem holds!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-de-morgans-theorem-visualizer","title":"Diagram: De Morgan's Theorem Visualizer","text":"De Morgan's Theorem Interactive Visualizer Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Interpret  Learning Objective: Students will be able to interpret De Morgan's theorem by seeing how expressions with the bar broken and unbroken produce identical outputs for all input combinations.  Instructional Rationale: Visualizing both forms of an expression side-by-side with the same inputs creates a strong mental link between the equivalent forms. The \"break the bar\" animation reinforces the transformation rule.  Canvas Layout:  - Two-column display showing both forms of De Morgan's theorem - Left column: Original form (e.g., \\(\\overline{A \\cdot B}\\)) - Right column: Transformed form (e.g., \\(\\overline{A} + \\overline{B}\\)) - Shared input toggles at top for A and B values - Gate diagram below each expression showing equivalent circuits - Animation showing \"break the bar\" transformation  Interactive Elements:  - Toggle buttons for A and B inputs - \"Break the Bar\" button triggers animation showing transformation - Tab selector for: \\(\\overline{A \\cdot B}\\) form vs \\(\\overline{A + B}\\) form - Both sides update simultaneously when inputs change  Visual Style:  - Expression notation with proper overlines - Circuit symbols shown below expressions - Color-coded: inputs blue, intermediate values yellow, outputs green - Animation shows bar \"breaking\" and operation symbol changing  Data Visibility:  - Input values prominently displayed - Intermediate computation steps shown - Final outputs shown with equality check (both should always match)  Implementation: p5.js with animation for bar-breaking effect"},{"location":"chapters/02-boolean-algebra-fundamentals/#dual-expression","title":"Dual Expression","text":"<p>Every Boolean expression has a dual expression obtained by:</p> <ol> <li>Swapping all AND operators with OR operators</li> <li>Swapping all OR operators with AND operators</li> <li>Swapping all 0s with 1s</li> <li>Swapping all 1s with 0s</li> <li>Keeping the variables unchanged</li> </ol> <p>For example:</p> <ul> <li>The dual of \\(A + B \\cdot C\\) is \\(A \\cdot (B + C)\\)</li> <li>The dual of \\(A + 0\\) is \\(A \\cdot 1\\)</li> <li>The dual of \\(A \\cdot \\overline{B}\\) is \\(A + \\overline{B}\\)</li> </ul> <p>The Principle of Duality: If a Boolean equation is valid, its dual is also valid. This is why Boolean algebra laws often come in pairs\u2014each law has a dual.</p> <p>Look back at our laws:</p> Law One Form Dual Form Identity \\(A + 0 = A\\) \\(A \\cdot 1 = A\\) Null \\(A + 1 = 1\\) \\(A \\cdot 0 = 0\\) Idempotent \\(A + A = A\\) \\(A \\cdot A = A\\) Complement \\(A + \\overline{A} = 1\\) \\(A \\cdot \\overline{A} = 0\\) Absorption \\(A + A \\cdot B = A\\) \\(A \\cdot (A + B) = A\\) De Morgan \\(\\overline{A + B} = \\overline{A} \\cdot \\overline{B}\\) \\(\\overline{A \\cdot B} = \\overline{A} + \\overline{B}\\) <p>Notice how each pair is just the dual of the other! This duality principle means you only need to memorize half the laws\u2014you can derive the other half by taking the dual.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#consensus-theorem","title":"Consensus Theorem","text":"<p>The Consensus Theorem is a more advanced law that helps eliminate redundant terms:</p> \\[A \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot C\\] <p>The term \\(B \\cdot C\\) is the \"consensus term\"\u2014it's redundant because it's implied by the other two terms. Here's the intuition:</p> <ul> <li>If \\(A = 1\\), then \\(A \\cdot B = B\\) covers the case where \\(B = 1\\)</li> <li>If \\(A = 0\\), then \\(\\overline{A} \\cdot C = C\\) covers the case where \\(C = 1\\)</li> <li>The term \\(B \\cdot C\\) only matters when both \\(B = 1\\) and \\(C = 1\\), but in that case, either \\(A = 1\\) (first term covers it) or \\(A = 0\\) (second term covers it)</li> </ul> <p>The dual form is:</p> \\[(A + B) \\cdot (\\overline{A} + C) \\cdot (B + C) = (A + B) \\cdot (\\overline{A} + C)\\] <p>The Consensus Theorem is particularly useful in Karnaugh map simplification (covered in a later chapter) and in finding minimal expressions.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-proof-techniques","title":"Boolean Proof Techniques","text":"<p>Now that we have a toolkit of laws, how do we prove that two Boolean expressions are equivalent or simplify a complex expression? There are several approaches.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#method-1-truth-table-verification","title":"Method 1: Truth Table Verification","text":"<p>Create truth tables for both expressions. If the output columns are identical for all input combinations, the expressions are equivalent.</p> <p>Pros: Guaranteed to work, very systematic Cons: Gets tedious for many variables (\\(2^n\\) rows), doesn't show why they're equivalent</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#method-2-algebraic-manipulation","title":"Method 2: Algebraic Manipulation","text":"<p>Start with one expression and apply Boolean laws step-by-step until you reach the other expression (or a simpler form).</p> <p>Example: Prove that \\(\\overline{A} \\cdot B + A \\cdot B = B\\)</p> <p>[\\overline{A} \\cdot B + A \\cdot B] [= B \\cdot (\\overline{A} + A) \\text{ ... Distributive Law (factoring)}] [= B \\cdot 1 \\text{ ... Complement Law}] [= B \\text{ ... Identity Law}]</p> <p>This method requires practice and familiarity with the laws, but it's faster than truth tables for complex expressions.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#method-3-reducing-to-canonical-forms","title":"Method 3: Reducing to Canonical Forms","text":"<p>Convert both expressions to the same canonical form (like Sum-of-Products or Product-of-Sums\u2014covered in the next chapter). If the canonical forms match, the expressions are equivalent.</p> <p>Let's work through a more complex example.</p> <p>Example: Simplify \\(F = A \\cdot B + A \\cdot \\overline{B} + \\overline{A} \\cdot B\\)</p> <p>[F = A \\cdot B + A \\cdot \\overline{B} + \\overline{A} \\cdot B] [= A \\cdot (B + \\overline{B}) + \\overline{A} \\cdot B \\text{ ... Distributive (factor A)}] [= A \\cdot 1 + \\overline{A} \\cdot B \\text{ ... Complement Law}] [= A + \\overline{A} \\cdot B \\text{ ... Identity Law}] [= (A + \\overline{A}) \\cdot (A + B) \\text{ ... Distributive Law (OR over AND)}] [= 1 \\cdot (A + B) \\text{ ... Complement Law}] [= A + B \\text{ ... Identity Law}]</p> <p>We simplified a three-term expression down to just \\(A + B\\)!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-boolean-simplification-stepper","title":"Diagram: Boolean Simplification Stepper","text":"Boolean Simplification Stepper MicroSim Type: microsim  Bloom Level: Apply (L3) Bloom Verb: Apply  Learning Objective: Students will be able to apply Boolean algebra laws to simplify expressions step-by-step, with immediate feedback on which laws are applicable at each stage.  Instructional Rationale: Guided step-through with law identification helps students internalize the simplification process. Seeing which laws apply at each step builds pattern recognition skills.  Canvas Layout:  - Expression display area at top showing current state - List of applicable laws (clickable buttons) - History panel showing steps taken - Final simplified result with gate count comparison - Reset and example expression buttons  Interactive Elements:  - Current expression displayed prominently - Buttons for each Boolean law that can be applied - Clicking a law shows preview of transformation - \"Apply\" button to confirm and advance - \"Undo\" button to step back - \"Hint\" button suggests next good step  Data Visibility:  - Starting expression - Current expression after each step - Law applied at each step - Running count of gates/terms  Example Problems:  - \\(\\overline{A} \\cdot B + A \\cdot B\\) (simplifies to \\(B\\)) - \\(A + A \\cdot B\\) (simplifies to \\(A\\)) - \\(A \\cdot B + A \\cdot \\overline{B} + \\overline{A} \\cdot B\\) (simplifies to \\(A + B\\))  Visual Style:  - Laws color-coded by type (identity=blue, complement=green, De Morgan=orange) - Transformation preview in lighter color before applying - History shows crossed-out terms and applied law names  Implementation: p5.js with expression parsing and law matching"},{"location":"chapters/02-boolean-algebra-fundamentals/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's walk through a complete example that uses multiple concepts from this chapter.</p> <p>Problem: A digital lock should open when:</p> <ul> <li>The correct 2-bit code is entered (both bits A and B must be 1), OR</li> <li>The master override switch M is activated</li> </ul> <p>Express this as a Boolean function, create its truth table, and simplify if possible.</p> <p>Step 1: Define the function</p> \\[F(A, B, M) = (A \\cdot B) + M\\] <p>Step 2: Create the truth table</p> A B M \\(A \\cdot B\\) \\((A \\cdot B) + M\\) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 <p>Step 3: Analysis</p> <p>The function is already in a simple form. The lock opens in 4 out of 8 cases:</p> <ul> <li>Rows 1, 3, 5: M=1 (master override)</li> <li>Row 6: A=1, B=1 (correct code)</li> <li>Row 7: Both conditions satisfied</li> </ul> <p>The expression \\(F = A \\cdot B + M\\) is already minimal for this specification.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you practice Boolean algebra, watch out for these common pitfalls:</p> <ol> <li> <p>Forgetting that \\(1 + 1 = 1\\): This isn't regular arithmetic!</p> </li> <li> <p>Mixing up De Morgan's: Remember, you change the operation AND swap complements. Don't do just one or the other.</p> </li> <li> <p>Forgetting precedence: \\(A + B \\cdot C\\) is \\(A + (B \\cdot C)\\), not \\((A + B) \\cdot C\\).</p> </li> <li> <p>Applying regular algebra rules: \\(A + A \\neq 2A\\) and \\(A \\cdot A \\neq A^2\\).</p> </li> <li> <p>Skipping verification: After simplifying, check your work with a truth table. It catches errors!</p> </li> </ol>"},{"location":"chapters/02-boolean-algebra-fundamentals/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've completed your first deep dive into Boolean algebra. Here's what you've learned:</p> <ul> <li>Boolean variables can only be 0 or 1, true or false</li> <li>Three fundamental operations: NOT (inverts), AND (both true), OR (at least one true)</li> <li>Boolean expressions combine variables and operators</li> <li>Truth tables completely specify a Boolean function's behavior</li> <li>Boolean laws let you simplify expressions:</li> <li>Identity, Null, Idempotent, Complement</li> <li>Commutative, Associative, Distributive</li> <li>Absorption</li> <li>De Morgan's Theorem</li> <li>Consensus Theorem</li> <li>Duality means laws come in pairs\u2014swap AND/OR and 0/1</li> <li>Proof techniques include truth tables and algebraic manipulation</li> </ul> <p>These concepts form the mathematical foundation for everything else in digital electronics. In the next chapter, we'll see how these Boolean expressions map directly to logic gates\u2014the physical building blocks of digital circuits.</p> <p>Key Insight</p> <p>Boolean algebra bridges the gap between logical thinking and electronic circuits. Every Boolean expression can be implemented in hardware, and every digital circuit implements a Boolean function. Master these fundamentals, and you've mastered the language of digital design.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Simplify using Boolean laws <p>Simplify \\(F = A \\cdot \\overline{A} + B\\)</p> <p>Solution: \\(F = A \\cdot \\overline{A} + B\\) \\(= 0 + B\\) (Complement Law) \\(= B\\) (Identity Law)</p> Problem 2: Apply De Morgan's Theorem <p>Express \\(\\overline{A + B + C}\\) using only AND operations and individual complements.</p> <p>Solution: \\(\\overline{A + B + C} = \\overline{A} \\cdot \\overline{B} \\cdot \\overline{C}\\) (De Morgan's extended to three variables)</p> Problem 3: Verify with truth table <p>Prove that \\(A + \\overline{A} \\cdot B = A + B\\)</p> <p>Solution: | A | B | \\(\\overline{A}\\) | \\(\\overline{A} \\cdot B\\) | \\(A + \\overline{A} \\cdot B\\) | \\(A + B\\) | |---|---|----------------|------------------------|---------------------------|---------| | 0 | 0 | 1 | 0 | 0 | 0 | | 0 | 1 | 1 | 1 | 1 | 1 | | 1 | 0 | 0 | 0 | 1 | 1 | | 1 | 1 | 0 | 0 | 1 | 1 |</p> <p>The last two columns match \u2713</p> Problem 4: Find the dual <p>What is the dual of \\(A \\cdot (B + C) = A \\cdot B + A \\cdot C\\)?</p> <p>Solution: Swap AND\u2194OR and 0\u21941 (no constants here): \\(A + (B \\cdot C) = (A + B) \\cdot (A + C)\\) (This is the OR-over-AND distributive law!)</p>"},{"location":"chapters/03-logic-gates-digital-signals/","title":"Logic Gates and Digital Signal Properties","text":""},{"location":"chapters/03-logic-gates-digital-signals/#summary","title":"Summary","text":"<p>This chapter bridges the gap between Boolean algebra theory and physical circuit implementation by introducing logic gates as the building blocks of digital systems. Students will learn about all primitive gates (AND, OR, NOT, NAND, NOR, XOR, XNOR), the concept of functional completeness and universal gates, gate timing characteristics including propagation delay, fan-in and fan-out considerations, logic families (TTL and CMOS), and digital signal properties. Understanding these concepts is essential for designing real hardware that correctly implements Boolean functions.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 30 concepts from the learning graph:</p> <ol> <li>Logic Gate</li> <li>AND Gate</li> <li>OR Gate</li> <li>NOT Gate</li> <li>Buffer Gate</li> <li>NAND Gate</li> <li>NOR Gate</li> <li>XOR Gate</li> <li>XNOR Gate</li> <li>Gate Symbol</li> <li>IEEE Gate Symbols</li> <li>Functional Completeness</li> <li>Universal Gate</li> <li>NAND-Only Design</li> <li>NOR-Only Design</li> <li>Gate Delay</li> <li>Propagation Delay</li> <li>Rise Time</li> <li>Fall Time</li> <li>Fan-In</li> <li>Fan-Out</li> <li>Logic Levels</li> <li>Noise Margin</li> <li>Voltage Threshold</li> <li>Logic Family</li> <li>TTL Logic</li> <li>CMOS Logic</li> <li>Digital Signal</li> <li>Analog vs Digital</li> <li>Signal Integrity</li> </ol>"},{"location":"chapters/03-logic-gates-digital-signals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Boolean Algebra Fundamentals</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#introduction-from-symbols-to-silicon","title":"Introduction: From Symbols to Silicon","text":"<p>In the last chapter, you learned to speak the language of Boolean algebra\u2014AND, OR, NOT, truth tables, and all those elegant mathematical laws. But here's the thing: equations don't compute anything by themselves. You can't power your laptop with De Morgan's theorem (though wouldn't that be nice for your electricity bill?).</p> <p>This chapter is where the rubber meets the road\u2014or more accurately, where the math meets the metal. We're going to transform those abstract Boolean operations into logic gates: physical electronic components that actually do the computation. These tiny circuits are the atoms of the digital universe, and everything from your smartphone to a supercomputer is built from combinations of these fundamental building blocks.</p> <p>Think of it this way: Boolean algebra is like sheet music, describing what notes should be played. Logic gates are the actual instruments that produce the sound. You can't have a symphony without both.</p> <p>By the end of this chapter, you'll understand not just what logic gates do (that's the easy part\u2014they implement Boolean functions), but how they behave in the real world: their timing quirks, their voltage requirements, their limitations, and why engineers sometimes spend weeks worrying about a few nanoseconds of delay. Welcome to the physical reality of digital design!</p>"},{"location":"chapters/03-logic-gates-digital-signals/#what-is-a-logic-gate","title":"What is a Logic Gate?","text":"<p>A logic gate is an electronic circuit that implements a Boolean operation. It takes one or more binary inputs (0s and 1s represented as voltage levels) and produces a binary output based on a specific logical function.</p> <p>Here's the fundamental insight that makes digital electronics possible:</p> <p>A logic gate is a Boolean function built from transistors.</p> <p>Every logic gate you'll ever encounter is essentially an arrangement of transistors configured to produce the correct output for each possible input combination. The transistors act as electronic switches, and their clever arrangement makes Boolean logic physically real.</p> <p>Logic gates have several key characteristics:</p> <ul> <li>Binary inputs and outputs: Each signal is either HIGH (1) or LOW (0)</li> <li>Deterministic behavior: For any given set of inputs, the output is always the same</li> <li>Finite response time: Outputs don't change instantaneously (more on this later)</li> <li>Power consumption: Gates need energy to operate\u2014there's no free computation!</li> </ul> Property Description Function The Boolean operation performed (AND, OR, NOT, etc.) Inputs Number and type of binary input signals Output Resulting binary signal based on the function Symbol Standardized graphical representation Physical Realization Transistor-level implementation"},{"location":"chapters/03-logic-gates-digital-signals/#gate-symbols-the-visual-language","title":"Gate Symbols: The Visual Language","text":"<p>Before we dive into each gate type, let's talk about gate symbols\u2014the standardized graphical representations used in circuit diagrams (called schematics). These symbols are your visual vocabulary for reading and drawing digital circuits.</p> <p>There are two main standards for gate symbols:</p> <ol> <li>Distinctive-shape symbols: Each gate type has a unique shape that makes it instantly recognizable</li> <li>IEEE rectangular symbols: All gates use rectangles with function labels inside</li> </ol> <p>Throughout this textbook (and in most of industry), we use the distinctive-shape symbols because they're faster to recognize at a glance. When you see that curved back of an OR gate or the flat back of an AND gate, you immediately know what operation is happening.</p> <p>Symbol Recognition is a Superpower</p> <p>Experienced digital designers can \"read\" a complex schematic as quickly as you read text, because the gate shapes become second nature. Invest time in learning these symbols now, and circuit diagrams will speak to you.</p> <p>Let's meet the gates!</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-buffer-gate-the-simplest-gate","title":"The Buffer Gate: The Simplest Gate","text":"<p>We'll start with the buffer gate, which seems almost too simple to exist. A buffer takes one input and produces an output that's... exactly the same as the input.</p> <p>Wait, what? Why would we need a gate that does nothing?</p> <p>Actually, buffers do several important things:</p> <ul> <li>Signal restoration: They boost weakened signals back to full strength</li> <li>Impedance matching: They provide proper drive capability for subsequent circuits</li> <li>Timing adjustment: They add controlled delays when needed</li> <li>Isolation: They prevent one part of a circuit from affecting another</li> </ul> <p>Think of a buffer like a relay runner in a race\u2014they receive the baton and pass it on unchanged, but they provide fresh energy and proper form for the handoff.</p> <p>Truth Table:</p> A Y 0 0 1 1 <p>Boolean Expression: \\(Y = A\\)</p> <p>The buffer symbol is a triangle pointing to the right:</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-buffer-gate-symbol","title":"Diagram: Buffer Gate Symbol","text":"Buffer Gate Interactive Type: microsim  Bloom Level: Remember (L1) Bloom Verb: Identify  Learning Objective: Students will be able to identify the buffer gate symbol and verify that its output equals its input.  Instructional Rationale: Interactive visualization helps cement the visual symbol in memory while demonstrating the trivial but important input-output relationship.  Canvas Layout:  - Center: Buffer gate symbol (triangle) with animated input/output - Left side: Input toggle showing 0 or 1 - Right side: Output display showing 0 or 1 - Signal flow animation from input through gate to output - Truth table shown below the gate  Interactive Elements:  - Click on input to toggle between 0 and 1 - Visual signal flow (colored line) shows signal propagation - Output updates to match input  Visual Style:  - Clean gate symbol with proper proportions - Color coding: input wire blue, output wire green when 1, gray when 0 - Input/output values displayed in circles at wire endpoints  Implementation: p5.js with logic-gate-lib.js for gate drawing"},{"location":"chapters/03-logic-gates-digital-signals/#the-not-gate-inverter-the-contrarian","title":"The NOT Gate (Inverter): The Contrarian","text":"<p>The NOT gate, also called an inverter, is the simplest gate that actually changes its input. It implements the Boolean NOT operation, flipping 0 to 1 and 1 to 0.</p> <p>If the buffer is a relay runner who passes the baton unchanged, the inverter is a relay runner who switches teams mid-race. Give it HIGH, get LOW. Give it LOW, get HIGH. It's the contrarian of the logic gate family.</p> <p>Truth Table:</p> A Y 0 1 1 0 <p>Boolean Expression: \\(Y = \\overline{A}\\)</p> <p>The inverter symbol is a triangle (like the buffer) with a small circle at the output. That circle is called a bubble and universally indicates inversion in digital logic. Remember this\u2014bubbles mean NOT!</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-not-gate-inverter-interactive","title":"Diagram: NOT Gate (Inverter) Interactive","text":"NOT Gate Interactive Visualization Type: microsim  Bloom Level: Remember (L1) Bloom Verb: Identify  Learning Objective: Students will be able to identify the inverter symbol and predict that its output is always the opposite of its input.  Instructional Rationale: The inversion bubble is a critical symbol element that appears on many gates. Early exposure with interactive feedback builds recognition.  Canvas Layout:  - Center: Inverter symbol (triangle with bubble) with animated input/output - Left side: Input toggle showing 0 or 1 - Right side: Output display showing inverted value - Emphasis on the \"bubble\" with tooltip explanation  Interactive Elements:  - Click on input to toggle between 0 and 1 - Output automatically shows inverted value - Highlight bubble when mouse hovers over it with explanation \"bubble = inversion\"  Visual Style:  - Gate symbol with emphasized inversion bubble - Complementary colors for input/output to reinforce inversion concept - Animation: color \"flip\" when value changes  Implementation: p5.js with logic-gate-lib.js"},{"location":"chapters/03-logic-gates-digital-signals/#the-and-gate-both-must-be-true","title":"The AND Gate: Both Must Be True","text":"<p>The AND gate implements Boolean AND, producing a HIGH output only when all inputs are HIGH. For a 2-input AND gate:</p> <p>Truth Table:</p> A B Y 0 0 0 0 1 0 1 0 0 1 1 1 <p>Boolean Expression: \\(Y = A \\cdot B\\)</p> <p>Here's a memorable analogy: An AND gate is like a security door with two locks. Both locks must be unlocked (both inputs = 1) for the door to open (output = 1). If either lock is still locked, the door stays shut.</p> <p>The AND gate symbol has a flat back and a curved front (like the letter D):</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-and-gate-interactive","title":"Diagram: AND Gate Interactive","text":"AND Gate Interactive Visualization Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Demonstrate  Learning Objective: Students will be able to demonstrate that the AND gate outputs 1 only when both inputs are 1.  Instructional Rationale: Two-input toggle interaction allows students to explore all four input combinations and internalize the \"both must be true\" rule.  Canvas Layout:  - Center: AND gate symbol (D-shape) with two inputs and one output - Left side: Two input toggles stacked vertically - Right side: Output display - Truth table shown below with current row highlighted  Interactive Elements:  - Click on either input to toggle its value - Gate output updates immediately - Current input combination highlighted in truth table - Visual indication (glow effect) when output is HIGH  Visual Style:  - Standard AND gate symbol with proper D-shape - Wire colors: blue for inputs, green for HIGH output, gray for LOW - Connection lines from inputs through gate body to output - Highlighted row in truth table matches current state  Implementation: p5.js with logic-gate-lib.js  <p>AND gates can have more than two inputs. A 3-input AND gate outputs 1 only when A AND B AND C are all 1. The principle extends to any number of inputs: all must be HIGH.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-or-gate-at-least-one-must-be-true","title":"The OR Gate: At Least One Must Be True","text":"<p>The OR gate implements Boolean OR, producing a HIGH output when at least one input is HIGH. Only when all inputs are LOW does the output become LOW.</p> <p>Truth Table:</p> A B Y 0 0 0 0 1 1 1 0 1 1 1 1 <p>Boolean Expression: \\(Y = A + B\\)</p> <p>If the AND gate is a security door with two locks, the OR gate is like an automatic door with two motion sensors. If either sensor (or both!) detects motion, the door opens. Only when both sensors see nothing does the door stay closed.</p> <p>The OR gate symbol has a curved back (looking like a shield or curved arrow):</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-or-gate-interactive","title":"Diagram: OR Gate Interactive","text":"OR Gate Interactive Visualization Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Demonstrate  Learning Objective: Students will be able to demonstrate that the OR gate outputs 1 when at least one input is 1.  Instructional Rationale: Contrasting OR behavior with AND (learned previously) helps students distinguish between the two operations. Side-by-side truth table comparison reinforces the difference.  Canvas Layout:  - Center: OR gate symbol (curved shield shape) with two inputs and one output - Left side: Two input toggles stacked vertically - Right side: Output display - Truth table shown below with current row highlighted  Interactive Elements:  - Click on either input to toggle its value - Gate output updates immediately - Current input combination highlighted in truth table - Compare mode: Optional toggle to show AND gate result alongside for contrast  Visual Style:  - Standard OR gate symbol with proper curves - Wire colors consistent with AND gate for pattern recognition - Curved input lines entering gate at proper positions  Implementation: p5.js with logic-gate-lib.js  <p>Like AND gates, OR gates can have more than two inputs. A 3-input OR gate outputs 1 when A OR B OR C (at least one) is 1.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-nand-gate-not-and-combined","title":"The NAND Gate: NOT-AND Combined","text":"<p>The NAND gate (pronounced \"nand,\" not \"N-A-N-D\") is an AND gate with an inverted output. Its name is a contraction of \"NOT-AND.\"</p> <p>Truth Table:</p> A B Y 0 0 1 0 1 1 1 0 1 1 1 0 <p>Boolean Expression: \\(Y = \\overline{A \\cdot B}\\)</p> <p>Notice that the NAND output is exactly opposite of the AND output\u2014every 0 becomes 1 and vice versa. The NAND gate is represented by the AND symbol with a bubble at the output.</p> <p>Here's something remarkable about the NAND gate:</p> <p>The NAND gate is called a \"universal gate\" because you can build any other logic function using only NAND gates.</p> <p>We'll explore this superpower in depth later, but it's why NAND gates are so important in real digital circuits. Engineers love gates that can do everything!</p> <p>Analogy: If AND is \"both must be true,\" then NAND is \"they can't both be true.\" It outputs LOW only when both inputs are HIGH\u2014the \"veto\" condition.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nand-gate-interactive","title":"Diagram: NAND Gate Interactive","text":"NAND Gate Interactive Visualization Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Compare  Learning Objective: Students will be able to compare NAND output with AND output and explain that NAND is the complement of AND.  Instructional Rationale: Showing NAND alongside AND in a comparison view helps students see the inversion relationship. The bubble on the symbol connects visually to the inversion concept from the NOT gate.  Canvas Layout:  - Split view: NAND gate on left, AND gate on right (for comparison) - Shared input toggles control both gates simultaneously - Both outputs displayed with their values - Inversion relationship shown with visual indicator  Interactive Elements:  - Click inputs to toggle values - Both gates update simultaneously - Visual highlight showing output values are always opposite - Emphasis on the inversion bubble's role  Visual Style:  - NAND: AND symbol + bubble (emphasized) - Side-by-side comparison layout - Color scheme: NAND output red/green, AND output gray/green - Annotation showing \\(\\overline{AND}\\) relationship  Implementation: p5.js with logic-gate-lib.js"},{"location":"chapters/03-logic-gates-digital-signals/#the-nor-gate-not-or-combined","title":"The NOR Gate: NOT-OR Combined","text":"<p>The NOR gate is an OR gate with an inverted output. Its name is a contraction of \"NOT-OR.\"</p> <p>Truth Table:</p> A B Y 0 0 1 0 1 0 1 0 0 1 1 0 <p>Boolean Expression: \\(Y = \\overline{A + B}\\)</p> <p>The NOR output is the opposite of OR\u2014it outputs HIGH only when neither input is HIGH. The NOR gate is represented by the OR symbol with a bubble at the output.</p> <p>Like NAND, the NOR gate is also a universal gate. You can build any logic function using only NOR gates! Early computers actually used NOR gates extensively\u2014the Apollo Guidance Computer that landed humans on the Moon was built entirely from NOR gates.</p> <p>Analogy: If OR is \"at least one must be true,\" then NOR is \"neither can be true.\" It's like having two security guards who both have to be off duty for the building to be accessible.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nor-gate-interactive","title":"Diagram: NOR Gate Interactive","text":"NOR Gate Interactive Visualization Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Compare  Learning Objective: Students will be able to compare NOR output with OR output and explain that NOR is the complement of OR.  Instructional Rationale: Parallel structure to the NAND visualization reinforces the pattern of inverted gates. Students see both universal gates in the same comparative format.  Canvas Layout:  - Split view: NOR gate on left, OR gate on right (for comparison) - Shared input toggles control both gates simultaneously - Both outputs displayed with their values - Label \"Universal Gate\" badge on NOR  Interactive Elements:  - Click inputs to toggle values - Both gates update simultaneously - Visual highlight showing output values are always opposite - Badge/callout indicating NOR is a universal gate  Visual Style:  - NOR: OR symbol + bubble (emphasized) - Side-by-side comparison layout - Consistent styling with NAND comparison view - \"Universal Gate\" badge for NOR  Implementation: p5.js with logic-gate-lib.js"},{"location":"chapters/03-logic-gates-digital-signals/#the-xor-gate-the-odd-one-out","title":"The XOR Gate: The Odd One Out","text":"<p>The XOR gate (exclusive OR) outputs HIGH when an odd number of inputs are HIGH. For a 2-input XOR gate, this means the output is HIGH when the inputs are different:</p> <p>Truth Table:</p> A B Y 0 0 0 0 1 1 1 0 1 1 1 0 <p>Boolean Expression: \\(Y = A \\oplus B = A \\cdot \\overline{B} + \\overline{A} \\cdot B\\)</p> <p>Notice that unlike OR, XOR outputs LOW when both inputs are HIGH. It's \"exclusive\"\u2014it excludes the case where both are true.</p> <p>Analogy: XOR is like a light switch controlled from two locations (like at the top and bottom of stairs). Flipping either switch changes the light state. If both switches are in the same position (both up or both down), the light is off. If they're in opposite positions, the light is on. The output indicates \"are these different?\"</p> <p>The XOR gate symbol is the OR gate symbol with an extra curved line on the input side:</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-xor-gate-interactive","title":"Diagram: XOR Gate Interactive","text":"XOR Gate Interactive Visualization Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Contrast  Learning Objective: Students will be able to contrast XOR with OR and explain that XOR outputs 1 when inputs differ.  Instructional Rationale: The \"difference detector\" framing helps students remember XOR behavior. Comparing with OR directly shows the critical difference in the (1,1) case.  Canvas Layout:  - Main: XOR gate with interactive inputs - Comparison panel: OR gate showing difference in (1,1) case - Below: Visual \"difference detector\" representation (two values with = vs \u2260 symbol) - Truth table with \"different?\" column added for clarity  Interactive Elements:  - Click inputs to toggle values - \"Different?\" indicator changes with inputs - Special animation when both inputs are 1 showing XOR = 0, OR = 1 - Highlight the distinguishing row in truth table  Visual Style:  - XOR symbol with distinctive extra curve - \"\u2260\" and \"=\" symbols to reinforce difference detection - Red/green for match/mismatch indication - Callout: \"XOR = Are they different?\"  Implementation: p5.js with logic-gate-lib.js  <p>XOR Applications</p> <p>XOR gates are incredibly useful:</p> <ul> <li>Parity checking: Detect transmission errors</li> <li>Encryption: XOR with a key scrambles data</li> <li>Addition: The sum bit in a binary adder is XOR</li> <li>Comparison: Detect if two values are different</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#the-xnor-gate-same-or-different","title":"The XNOR Gate: Same or Different?","text":"<p>The XNOR gate (exclusive NOR) is an XOR gate with an inverted output. It outputs HIGH when the inputs are the same:</p> <p>Truth Table:</p> A B Y 0 0 1 0 1 0 1 0 0 1 1 1 <p>Boolean Expression: \\(Y = \\overline{A \\oplus B} = A \\cdot B + \\overline{A} \\cdot \\overline{B}\\)</p> <p>If XOR is the \"difference detector,\" XNOR is the \"equality detector.\" It asks \"are these the same?\" and outputs 1 if yes, 0 if no.</p> <p>The XNOR gate symbol is the XOR symbol with a bubble at the output (following the pattern of NAND and NOR):</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-xnor-gate-interactive","title":"Diagram: XNOR Gate Interactive","text":"XNOR Gate Interactive Visualization Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Explain  Learning Objective: Students will be able to explain that XNOR outputs 1 when both inputs are the same (both 0 or both 1).  Instructional Rationale: Presenting XNOR as \"equality detector\" provides a memorable mental model. The truth table pattern (1 on the diagonal) reinforces this visually.  Canvas Layout:  - Main: XNOR gate with interactive inputs - \"Same?\" indicator prominently displayed - Truth table with diagonal pattern highlighted - Comparison with XOR to show inversion relationship  Interactive Elements:  - Click inputs to toggle values - \"Same?\" indicator with checkmark or X - Diagonal pattern in truth table lights up when inputs match - Output color matches \"same\" status  Visual Style:  - XNOR symbol: XOR + bubble - \"=\" symbol when inputs match, \"\u2260\" when different - Green glow on diagonal entries of truth table - Clean, symmetrical layout emphasizing the equality function  Implementation: p5.js with logic-gate-lib.js"},{"location":"chapters/03-logic-gates-digital-signals/#summary-the-complete-gate-family","title":"Summary: The Complete Gate Family","text":"<p>Let's take a moment to see all the primitive gates together. This is your complete toolkit for building any digital circuit:</p> Gate Symbol Expression Output = 1 When... Buffer Triangle \\(Y = A\\) Input is 1 NOT Triangle + bubble \\(Y = \\overline{A}\\) Input is 0 AND D-shape \\(Y = A \\cdot B\\) Both inputs are 1 OR Shield \\(Y = A + B\\) At least one input is 1 NAND D-shape + bubble \\(Y = \\overline{A \\cdot B}\\) Not both inputs are 1 NOR Shield + bubble \\(Y = \\overline{A + B}\\) Neither input is 1 XOR Shield + extra curve \\(Y = A \\oplus B\\) Inputs are different XNOR XOR + bubble \\(Y = \\overline{A \\oplus B}\\) Inputs are the same"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-all-logic-gates-gallery","title":"Diagram: All Logic Gates Gallery","text":"Complete Logic Gate Gallery Type: microsim  Bloom Level: Remember (L1) Bloom Verb: Recognize  Learning Objective: Students will be able to recognize all eight primitive logic gate symbols and associate each with its name and function.  Instructional Rationale: A visual gallery view reinforces symbol recognition through repeated exposure. Interactive elements encourage exploration of each gate type.  Canvas Layout:  - Grid of all 8 gate types (4x2 arrangement) - Each gate cell shows: symbol, name, and Boolean expression - Hover/click to see truth table for each gate - Visual grouping: basic gates, inverted gates, XOR family  Interactive Elements:  - Hover over any gate to see its truth table - Click to select and show enlarged view - Quiz mode: Show symbol, guess the name - Filter buttons: All, Basic, Inverted, XOR family  Visual Style:  - Consistent sizing and spacing for all gates - Color-coded by family (blue=basic, orange=inverted, purple=XOR) - Clean labels with proper mathematical notation - Responsive grid layout  Implementation: p5.js with logic-gate-lib.js, using grid layout"},{"location":"chapters/03-logic-gates-digital-signals/#ieee-gate-symbols","title":"IEEE Gate Symbols","text":"<p>While the distinctive-shape symbols are most common in industry and academia, you should also be aware of IEEE rectangular symbols (also called IEC symbols). In this notation, all gates are rectangles with a function label inside.</p> Gate IEEE Symbol Label Buffer 1 NOT 1 (with bubble) AND &amp; OR \u22651 NAND &amp; (with bubble) NOR \u22651 (with bubble) XOR =1 XNOR =1 (with bubble) <p>The IEEE symbols are more consistent (all rectangles) but less intuitive (you have to read the label). You'll encounter them in some textbooks and CAD tools, so it's worth being able to recognize them.</p> <p>Symbol Conventions</p> <p>In this textbook, we use distinctive-shape symbols exclusively. If you encounter IEEE symbols elsewhere, just look for the function label and the presence or absence of the output bubble.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#functional-completeness-the-universal-building-block","title":"Functional Completeness: The Universal Building Block","text":"<p>Now we arrive at one of the most elegant ideas in digital logic: functional completeness. A set of logic gates is functionally complete if you can build any Boolean function using only gates from that set.</p> <p>The set {AND, OR, NOT} is functionally complete. Given these three gate types, you can implement any Boolean expression. This makes intuitive sense\u2014these are the three fundamental Boolean operations.</p> <p>But here's the twist: you don't actually need all three. Some single gate types are functionally complete by themselves!</p> <p>A gate that can implement any Boolean function by itself is called a universal gate.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#universal-gates-one-gate-to-rule-them-all","title":"Universal Gates: One Gate to Rule Them All","text":"<p>Both NAND and NOR are universal gates. Using only NAND gates (or only NOR gates), you can build any digital circuit. This is a profound result with enormous practical implications.</p> <p>Why does this matter? In integrated circuit manufacturing:</p> <ul> <li>Using a single gate type simplifies the manufacturing process</li> <li>All gates have identical characteristics (delay, power, etc.)</li> <li>Design becomes more regular and predictable</li> <li>Testing and verification are simplified</li> </ul> <p>Let's see how NAND can implement the basic operations.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#nand-only-design","title":"NAND-Only Design","text":"<p>Building NOT from NAND:</p> <p>Connect both inputs of a NAND gate together: [Y = \\overline{A \\cdot A} = \\overline{A}]</p> <p>A NAND gate with tied inputs is an inverter!</p> <p>Building AND from NAND:</p> <p>Use two NAND gates\u2014one as the actual NAND, and one configured as a NOT to invert the output: [Y = \\overline{\\overline{A \\cdot B}} = A \\cdot B]</p> <p>Building OR from NAND:</p> <p>Use three NAND gates\u2014first invert each input (using NAND as NOT), then NAND the results: [Y = \\overline{\\overline{A} \\cdot \\overline{B}} = A + B]</p> <p>This last one uses De Morgan's theorem: \\(\\overline{\\overline{A} \\cdot \\overline{B}} = A + B\\)</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nand-universal-gate-builder","title":"Diagram: NAND Universal Gate Builder","text":"NAND Universal Gate Builder MicroSim Type: microsim  Bloom Level: Apply (L3) Bloom Verb: Implement  Learning Objective: Students will be able to implement NOT, AND, and OR operations using only NAND gates.  Instructional Rationale: Building other gates from NAND reinforces both the universality concept and the underlying Boolean algebra (especially De Morgan's theorem for OR).  Canvas Layout:  - Three sections: NOT from NAND, AND from NAND, OR from NAND - Each section shows the NAND-only circuit implementation - Input toggles for each circuit - Truth table verification for each implementation  Interactive Elements:  - Toggle inputs for each demonstration circuit - Watch signal propagation through NAND gates - Truth table fills in as user explores all combinations - \"Verify\" button confirms the implementation matches the target function  Data Visibility:  - Each intermediate NAND output labeled with its value - Final output compared to expected gate behavior - Signal path highlighted as it propagates  Visual Style:  - Clean circuit diagrams with multiple NAND gates - Color-coded signals (blue input, yellow intermediate, green output) - NAND gates clearly drawn with distinctive symbols - Grouping boxes around each implementation  Implementation: p5.js with logic-gate-lib.js, signal propagation animation"},{"location":"chapters/03-logic-gates-digital-signals/#nor-only-design","title":"NOR-Only Design","text":"<p>NOR can also build everything! The process is similar, but uses De Morgan's theorem in the other direction.</p> <p>Building NOT from NOR:</p> \\[Y = \\overline{A + A} = \\overline{A}\\] <p>Building OR from NOR:</p> \\[Y = \\overline{\\overline{A + B}} = A + B\\] <p>Building AND from NOR:</p> \\[Y = \\overline{\\overline{A} + \\overline{B}} = A \\cdot B\\]"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nor-universal-gate-builder","title":"Diagram: NOR Universal Gate Builder","text":"NOR Universal Gate Builder MicroSim Type: microsim  Bloom Level: Apply (L3) Bloom Verb: Implement  Learning Objective: Students will be able to implement NOT, AND, and OR operations using only NOR gates.  Instructional Rationale: Parallel structure to NAND demonstration reinforces the dual nature of the universal gates and strengthens De Morgan's theorem understanding.  Canvas Layout:  - Three sections: NOT from NOR, OR from NOR, AND from NOR - Each section shows the NOR-only circuit implementation - Input toggles for each circuit - Truth table verification for each implementation  Interactive Elements:  - Toggle inputs for each demonstration circuit - Watch signal propagation through NOR gates - Truth table fills in as user explores all combinations - Compare button to show NAND equivalent side-by-side  Visual Style:  - Circuit diagrams with multiple NOR gates - Consistent color scheme with NAND demonstration - NOR gates with distinctive OR shape + bubble - Clear labeling of intermediate signals  Implementation: p5.js with logic-gate-lib.js  <p>Historical Note</p> <p>The Apollo Guidance Computer, which navigated astronauts to the Moon and back, was built using approximately 5,600 NOR gates and nothing else. The simplicity of using a single gate type was crucial for reliability in the hostile environment of space.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#gate-delay-nothing-happens-instantly","title":"Gate Delay: Nothing Happens Instantly","text":"<p>Now let's talk about something that separates theoretical Boolean algebra from real physical circuits: time.</p> <p>In Boolean algebra, if you change an input, the output changes instantly. In real circuits, that's not true. Every logic gate takes some time to respond to input changes. This time is called gate delay or propagation delay.</p> <p>Propagation delay is the time between when an input changes and when the output responds. Typical propagation delays range from:</p> <ul> <li>Sub-nanosecond for modern high-speed logic</li> <li>A few nanoseconds for standard CMOS logic</li> <li>Tens of nanoseconds for older technology</li> </ul> <p>Why does delay matter?</p> <ul> <li>It limits how fast your circuit can operate</li> <li>Multiple gates in series accumulate delay (critical path)</li> <li>Timing violations can cause incorrect behavior</li> <li>Clock speeds are ultimately limited by propagation delay</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-propagation-delay-visualizer","title":"Diagram: Propagation Delay Visualizer","text":"Propagation Delay Visualizer MicroSim Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Explain  Learning Objective: Students will be able to explain that logic gates have non-zero propagation delay, and that this delay accumulates in multi-gate paths.  Instructional Rationale: Time-domain visualization of signal propagation through gates makes the abstract concept of delay tangible. Adjustable parameters allow exploration of how delay affects circuit timing.  Canvas Layout:  - Top: Timing diagram showing input signal and output response - Middle: Gate symbol with propagation delay labeled - Bottom: Multi-gate chain showing accumulated delay - Time axis with nanosecond scale  Interactive Elements:  - Input pulse generator (click to trigger) - Slider to adjust propagation delay value - View single gate delay vs. multi-gate chain - Play/pause animation control - Speed control for animation  Data Visibility:  - Input transition time clearly marked - Output transition time clearly marked - Propagation delay value displayed in ns - Total path delay for multi-gate circuits  Visual Style:  - Timing diagram with clean waveforms - Delay shown as horizontal gap between transitions - Color coding: input blue, output green - Accumulated delay highlighted in chain view  Implementation: p5.js with animation for signal propagation"},{"location":"chapters/03-logic-gates-digital-signals/#rise-time-and-fall-time","title":"Rise Time and Fall Time","text":"<p>When a digital signal changes from LOW to HIGH, it doesn't happen instantaneously\u2014the voltage ramps up over time. Similarly, going from HIGH to LOW takes time.</p> <ul> <li>Rise time (\\(t_r\\)): Time for signal to go from 10% to 90% of full voltage</li> <li>Fall time (\\(t_f\\)): Time for signal to go from 90% to 10% of full voltage</li> </ul> <p>Rise and fall times are typically measured between 10% and 90% of the voltage swing because real signals have gradual transitions, not perfect vertical edges.</p> Parameter Symbol Description Propagation delay (low-to-high) \\(t_{pLH}\\) Delay when output goes from LOW to HIGH Propagation delay (high-to-low) \\(t_{pHL}\\) Delay when output goes from HIGH to LOW Rise time \\(t_r\\) Time for signal to rise from 10% to 90% Fall time \\(t_f\\) Time for signal to fall from 90% to 10%"},{"location":"chapters/03-logic-gates-digital-signals/#fan-in-and-fan-out-how-many-connections","title":"Fan-In and Fan-Out: How Many Connections?","text":"<p>When designing circuits, you need to consider how many inputs and outputs each gate can handle.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#fan-in","title":"Fan-In","text":"<p>Fan-in is the number of inputs a gate has. A 2-input AND gate has a fan-in of 2. An 8-input NAND gate has a fan-in of 8.</p> <p>Why does fan-in matter?</p> <ul> <li>Propagation delay increases with fan-in: More inputs mean more transistors in the signal path</li> <li>Physical size increases: More inputs require more silicon area</li> <li>Power consumption increases: More transistors switching</li> </ul> <p>In practice, gates with very high fan-in (like 16 or 32 inputs) are rarely used. Instead, designers cascade lower fan-in gates.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#fan-out","title":"Fan-Out","text":"<p>Fan-out is the number of gate inputs that one output can drive reliably. If a gate output is connected to the inputs of 5 other gates, its fan-out is 5.</p> <p>Why does fan-out matter?</p> <ul> <li>Each driven input presents an electrical load</li> <li>Driving too many gates weakens the signal</li> <li>Exceeding fan-out limits causes incorrect logic levels</li> <li>High fan-out increases propagation delay</li> </ul> <p>Fan-Out Limits</p> <p>Every logic family has a maximum fan-out specification. Exceeding this can cause:</p> <ul> <li>Logic levels that don't reach valid HIGH or LOW thresholds</li> <li>Increased propagation delay</li> <li>Unreliable circuit operation</li> <li>Marginal failures that are hard to debug</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-fan-in-and-fan-out-explorer","title":"Diagram: Fan-In and Fan-Out Explorer","text":"Fan-In and Fan-Out Interactive Explorer Type: microsim  Bloom Level: Analyze (L4) Bloom Verb: Examine  Learning Objective: Students will be able to examine how increasing fan-in affects gate delay and how excessive fan-out can degrade signal quality.  Instructional Rationale: Interactive parameter adjustment helps students develop intuition about the engineering tradeoffs involved in gate connections.  Canvas Layout:  - Left panel: Fan-in demonstration with adjustable gate inputs (2-8) - Right panel: Fan-out demonstration showing one gate driving multiple loads - Metrics display: delay increase, signal quality indicator - Warning indicators when limits exceeded  Interactive Elements:  - Slider to adjust fan-in (2 to 8 inputs) - Slider to adjust fan-out (1 to 15 load gates) - Toggle to show/hide delay effects - Warning animation when fan-out exceeds safe limit - Reset button to return to defaults  Visual Effects:  - Gate grows to accommodate more inputs (fan-in) - Output branches to multiple gates (fan-out) - Signal quality meter (green/yellow/red) - Delay bar graph showing relative timing  Visual Style:  - Clean schematic representation - Color-coded warning levels - Animated signal propagation - Metrics displayed as bar graphs  Implementation: p5.js with dynamic gate rendering"},{"location":"chapters/03-logic-gates-digital-signals/#logic-levels-what-counts-as-0-or-1","title":"Logic Levels: What Counts as 0 or 1?","text":"<p>So far, we've talked about 0 and 1 as if they were absolute values. In real circuits, we're dealing with voltages, and there's a range of voltages that count as \"logic LOW\" (0) and a range that count as \"logic HIGH\" (1).</p> <p>Logic levels define the voltage ranges for valid 0 and 1 values. For a typical 5V logic family:</p> Level Symbol Voltage Range Logic LOW (input) \\(V_{IL}\\) 0V to 0.8V Logic LOW (output) \\(V_{OL}\\) 0V to 0.4V Logic HIGH (input) \\(V_{IH}\\) 2.0V to 5.0V Logic HIGH (output) \\(V_{OH}\\) 2.4V to 5.0V Undefined/Forbidden - 0.8V to 2.0V <p>Notice that:</p> <ul> <li>Outputs have tighter specifications than inputs</li> <li>There's a \"forbidden zone\" in the middle</li> <li>This creates noise margin\u2014room for signals to degrade slightly without errors</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#voltage-thresholds","title":"Voltage Thresholds","text":"<p>Voltage thresholds are the decision points where a gate interprets a signal as HIGH vs. LOW:</p> <ul> <li>\\(V_{IL}\\): Maximum voltage guaranteed to be recognized as LOW (input)</li> <li>\\(V_{IH}\\): Minimum voltage guaranteed to be recognized as HIGH (input)</li> <li>\\(V_{OL}\\): Maximum voltage output when driving LOW</li> <li>\\(V_{OH}\\): Minimum voltage output when driving HIGH</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#noise-margin-room-for-error","title":"Noise Margin: Room for Error","text":"<p>Noise margin is the amount by which a signal can be corrupted and still be correctly interpreted. It's the difference between what one gate outputs and what the next gate needs to reliably recognize.</p> <p>[\\text{Noise Margin LOW} = V_{IL} - V_{OL}] [\\text{Noise Margin HIGH} = V_{OH} - V_{IH}]</p> <p>For our 5V example:</p> <ul> <li>Low noise margin: 0.8V - 0.4V = 0.4V</li> <li>High noise margin: 2.4V - 2.0V = 0.4V</li> </ul> <p>This means the signal can pick up 0.4V of noise and still be correctly recognized. Higher noise margins make circuits more robust in noisy environments.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-logic-levels-and-noise-margin","title":"Diagram: Logic Levels and Noise Margin","text":"Logic Levels and Noise Margin Visualizer Type: microsim  Bloom Level: Understand (L2) Bloom Verb: Interpret  Learning Objective: Students will be able to interpret voltage level diagrams and identify the noise margin that allows reliable signal transmission between gates.  Instructional Rationale: Visual representation of voltage ranges with adjustable noise injection helps students understand how digital signals remain reliable despite analog imperfections.  Canvas Layout:  - Left: Voltage scale (0V to 5V) with colored zones for LOW, FORBIDDEN, HIGH - Center: Two gates (driver and receiver) showing signal transmission - Right: Noise margin visualization as a bar - Bottom: Noise injection slider to see effect on signal  Interactive Elements:  - Slider to inject noise into signal - Toggle between different logic families (5V TTL, 3.3V CMOS, etc.) - Watch signal degrade as noise increases - Warning when signal enters forbidden zone - Success indicator when signal correctly received  Data Visibility:  - Current voltage level displayed numerically - Noise margin remaining shown as percentage - Threshold values labeled on voltage scale - Output and input specs clearly differentiated  Visual Style:  - Voltage scale with colored bands (green=valid, red=forbidden) - Arrow showing signal path from output to input - Noise shown as jagged overlay on signal line - Clean gradient transitions between zones  Implementation: p5.js with interactive noise simulation"},{"location":"chapters/03-logic-gates-digital-signals/#logic-families-ttl-and-cmos","title":"Logic Families: TTL and CMOS","text":"<p>A logic family is a group of logic devices that share common electrical characteristics and are designed to work together. The two most important families historically are TTL and CMOS.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#ttl-logic-transistor-transistor-logic","title":"TTL Logic (Transistor-Transistor Logic)","text":"<p>TTL was the dominant logic family from the 1960s through the 1980s. Key characteristics:</p> <ul> <li>Uses bipolar junction transistors (BJTs)</li> <li>5V power supply</li> <li>Fast switching speeds (for its era)</li> <li>Higher power consumption than CMOS</li> <li>Robust noise immunity</li> <li>Multiple subfamilies (74LS, 74S, 74F, etc.)</li> </ul> <p>TTL part numbers typically start with \"74\" (commercial grade) or \"54\" (military grade). The 7400 is a quad 2-input NAND gate\u2014one of the most famous ICs ever made.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#cmos-logic-complementary-metal-oxide-semiconductor","title":"CMOS Logic (Complementary Metal-Oxide-Semiconductor)","text":"<p>CMOS dominates modern digital electronics. Key characteristics:</p> <ul> <li>Uses MOSFETs (field-effect transistors)</li> <li>Wide supply voltage range (3V to 15V typically)</li> <li>Extremely low static power consumption</li> <li>Higher speed than TTL in modern processes</li> <li>More sensitive to static electricity</li> <li>Dominates all modern integrated circuits</li> </ul> Feature TTL CMOS Transistor Type BJT MOSFET Typical Supply 5V 1.8V to 5V Static Power Higher Very low Speed Fast (historical) Faster (modern) Noise Immunity Good Excellent Dominance Era 1960s-1980s 1990s-present <p>Why CMOS Won</p> <p>CMOS's extremely low static power consumption became crucial as chip density increased. A chip with millions of TTL gates would consume enormous power and generate excessive heat. CMOS only consumes significant power when switching, making modern processors possible.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-logic-family-comparison","title":"Diagram: Logic Family Comparison","text":"TTL vs CMOS Logic Family Comparison Type: infographic  Bloom Level: Analyze (L4) Bloom Verb: Compare  Learning Objective: Students will be able to compare TTL and CMOS logic families across key parameters including power consumption, speed, noise immunity, and voltage levels.  Instructional Rationale: Side-by-side comparison with interactive parameter exploration helps students understand the engineering tradeoffs that led to CMOS dominance.  Canvas Layout:  - Two-column layout: TTL on left, CMOS on right - Comparison bars for: power, speed, noise margin, supply voltage - Interactive toggle to simulate circuit behavior under each family - Historical timeline showing technology evolution  Interactive Elements:  - Hover over each parameter for detailed explanation - Toggle switch to select 5V or 3.3V CMOS variant - Click on timeline to see key milestones - Power consumption animation when switching  Visual Style:  - Bar graphs for quantitative comparisons - Color scheme: TTL in orange, CMOS in blue - Icons representing transistor types - Clean, modern infographic style  Implementation: p5.js with hover interactions and animated comparisons"},{"location":"chapters/03-logic-gates-digital-signals/#digital-signals-the-analog-reality","title":"Digital Signals: The Analog Reality","text":"<p>Here's a truth that might surprise you: digital signals don't actually exist.</p> <p>At the physical level, every signal is analog\u2014a continuous voltage that varies over time. \"Digital\" is an abstraction we impose by defining threshold voltages and ignoring the messy analog behavior in between.</p> <p>A digital signal is an analog voltage that we interpret as having discrete states (0 and 1) based on threshold levels. This interpretation gives us:</p> <ul> <li>Noise immunity: Small voltage variations are ignored</li> <li>Reliable regeneration: Each gate restores signal quality</li> <li>Predictable logic: Boolean algebra applies</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#analog-vs-digital","title":"Analog vs Digital","text":"Aspect Analog Digital Values Continuous Discrete (0 or 1) Noise Accumulates Cleaned up at each stage Processing Linear circuits Logic gates Representation Direct physical quantity Encoded binary Degradation Gradual Cliff effect <p>The genius of digital systems is that even though the underlying physics is analog, the abstraction layers let us reason about discrete 0s and 1s with mathematical precision.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#signal-integrity-keeping-signals-clean","title":"Signal Integrity: Keeping Signals Clean","text":"<p>Signal integrity refers to the ability of a signal to maintain valid logic levels as it travels through a circuit. Poor signal integrity causes logic errors that are notoriously difficult to debug.</p> <p>Factors affecting signal integrity:</p> <ul> <li>Transmission line effects: Long wires behave like transmission lines</li> <li>Crosstalk: Signals on adjacent wires interfere with each other</li> <li>Ground bounce: Switching noise on the ground connection</li> <li>Power supply noise: Fluctuations in power delivery</li> <li>Reflections: Signal bouncing at impedance discontinuities</li> </ul> <p>Good signal integrity practices:</p> <ul> <li>Keep trace lengths short when possible</li> <li>Use proper power supply decoupling (capacitors near IC power pins)</li> <li>Maintain proper termination for high-speed signals</li> <li>Separate noisy signals from sensitive ones</li> <li>Use ground planes and proper PCB layout techniques</li> </ul> <p>Why Signal Integrity Matters</p> <p>As clock speeds increase, signal integrity becomes more critical. What worked fine at 1 MHz may fail catastrophically at 1 GHz. Digital designers must understand analog effects to build reliable high-speed circuits.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-signal-integrity-issues","title":"Diagram: Signal Integrity Issues","text":"Signal Integrity Problems Visualizer Type: microsim  Bloom Level: Analyze (L4) Bloom Verb: Examine  Learning Objective: Students will be able to examine how various physical effects (noise, reflections, crosstalk) degrade digital signal quality and potentially cause logic errors.  Instructional Rationale: Visualizing signal degradation helps students understand why clean signals matter and connects abstract concepts to physical reality.  Canvas Layout:  - Top: Ideal digital signal waveform - Middle: Same signal with selected degradation applied - Bottom: Logic interpretation showing correct vs. incorrect readings - Side panel: Controls for different signal integrity issues  Interactive Elements:  - Toggle buttons for: Noise, Ringing, Crosstalk, Ground bounce - Severity slider for each effect - Threshold lines showing where logic errors occur - Error counter tracking logic interpretation mistakes  Visual Effects:  - Ideal signal as clean square wave - Degraded signal with realistic effects - Threshold zones highlighted - Error moments flashing when signal crosses wrong threshold  Visual Style:  - Oscilloscope-like display with grid - Green for clean signal, red for degraded - Yellow warning zones around thresholds - Professional, technical appearance  Implementation: p5.js with signal waveform rendering and noise simulation"},{"location":"chapters/03-logic-gates-digital-signals/#putting-it-all-together-from-theory-to-practice","title":"Putting It All Together: From Theory to Practice","text":"<p>Let's trace the journey from Boolean algebra to physical circuits:</p> <ol> <li>Boolean Expression: \\(F = A \\cdot B + C\\)</li> <li>Truth Table: Define output for all 8 input combinations</li> <li>Gate Selection: Choose AND, OR gates to implement</li> <li>Logic Family: Pick CMOS at 3.3V</li> <li>Timing Analysis: Calculate propagation delay through critical path</li> <li>Fan-Out Check: Ensure each gate can drive its loads</li> <li>Layout Considerations: Plan for signal integrity</li> </ol> <p>This workflow connects the abstract mathematics you learned in Chapter 2 to the physical reality of electronic circuits.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-boolean-to-gates-workflow","title":"Diagram: Boolean to Gates Workflow","text":"Boolean Expression to Gate Circuit Workflow Type: workflow  Bloom Level: Apply (L3) Bloom Verb: Execute  Learning Objective: Students will be able to execute the workflow of transforming a Boolean expression into a gate-level circuit implementation.  Instructional Rationale: Step-by-step visualization of the design process helps students understand how theoretical Boolean algebra becomes physical circuits.  Canvas Layout:  - Vertical workflow diagram with 5 stages - Left: Boolean expression input - Center: Step-by-step transformation visualization - Right: Final gate circuit - Bottom: Truth table verification  Workflow Steps:  1. Enter Boolean expression 2. Parse expression into operation tree 3. Map operations to gates (AND, OR, NOT symbols) 4. Connect gates into circuit diagram 5. Verify with truth table  Interactive Elements:  - Text input for Boolean expression - Step-through buttons (Next, Previous) - Expression examples as clickable chips - Final circuit is interactive (can toggle inputs)  Visual Style:  - Clean workflow arrows between stages - Gate symbols drawn progressively - Connection wires animate as they're drawn - Verification checkmark when complete  Implementation: p5.js with expression parsing and circuit rendering"},{"location":"chapters/03-logic-gates-digital-signals/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you work with logic gates, watch out for these pitfalls:</p> <ol> <li> <p>Confusing NAND and AND: Remember, the bubble inverts! NAND outputs 1 when AND would output 0.</p> </li> <li> <p>Ignoring propagation delay: In fast circuits, accumulated gate delays matter enormously.</p> </li> <li> <p>Exceeding fan-out: Just because you can connect 20 gates doesn't mean you should. Check the specifications!</p> </li> <li> <p>Mixing logic families: Connecting TTL outputs to CMOS inputs (or vice versa) requires level shifting.</p> </li> <li> <p>Forgetting about the forbidden zone: Voltages in the undefined region can cause unpredictable behavior.</p> </li> <li> <p>Assuming ideal behavior: Real gates have real limitations\u2014delays, power consumption, noise sensitivity.</p> </li> </ol>"},{"location":"chapters/03-logic-gates-digital-signals/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've bridged the gap between Boolean algebra and physical circuits. Here's what you've learned:</p> <ul> <li>Logic gates implement Boolean operations in hardware</li> <li>Primitive gates: Buffer, NOT, AND, OR, NAND, NOR, XOR, XNOR</li> <li>Gate symbols provide visual vocabulary for circuit diagrams</li> <li>NAND and NOR are universal gates\u2014each can implement any function alone</li> <li>Propagation delay limits circuit speed</li> <li>Rise/fall time describes signal transition speed</li> <li>Fan-in is the number of gate inputs</li> <li>Fan-out is the number of gates one output can drive</li> <li>Logic levels define voltage ranges for valid 0 and 1</li> <li>Noise margin provides tolerance for signal degradation</li> <li>TTL and CMOS are major logic families (CMOS dominates today)</li> <li>Signal integrity keeps signals clean in real circuits</li> </ul> <p>These concepts form the foundation for everything that follows\u2014combinational logic design, sequential circuits, and beyond. You now understand that Boolean algebra isn't just mathematical abstraction; it's the language of the physical circuits that power our digital world.</p> <p>Key Insight</p> <p>Logic gates are where mathematics meets physics. Every gate implements a Boolean function using transistors, and understanding both the logical behavior and physical characteristics is essential for designing reliable digital systems.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#practice-problems","title":"Practice Problems","text":"Problem 1: Gate Identification <p>Match each truth table to its gate type:</p> <p>Table A: | A | B | Y | |---|---|---| | 0 | 0 | 1 | | 0 | 1 | 0 | | 1 | 0 | 0 | | 1 | 1 | 0 |</p> <p>Solution: This is a NOR gate. Output is 1 only when both inputs are 0.</p> Problem 2: NAND Universality <p>Show how to implement an OR gate using only NAND gates.</p> <p>Solution:</p> <ol> <li>Create NOT gates from NAND by tying inputs together</li> <li>Invert input A: \\(\\overline{A}\\) using NAND(A,A)</li> <li>Invert input B: \\(\\overline{B}\\) using NAND(B,B)</li> <li>NAND the results: \\(\\overline{\\overline{A} \\cdot \\overline{B}} = A + B\\) (De Morgan's)</li> </ol> <p>Total: 3 NAND gates</p> Problem 3: Timing Calculation <p>A circuit has three gates in series, each with a propagation delay of 5 ns. What is the minimum time from input change to valid output?</p> <p>Solution: Total delay = 3 \u00d7 5 ns = 15 ns</p> <p>This is the critical path delay\u2014the output isn't valid until 15 ns after the input changes.</p> Problem 4: Fan-Out Analysis <p>A gate output is connected to 8 other gate inputs. If the maximum fan-out specification is 10, is this design safe?</p> <p>Solution: Yes, the design is within specification (8 &lt; 10). However, operating close to the limit may increase propagation delay and reduce noise margin. It would be prudent to use a buffer if more loads are added later.</p> Problem 5: Noise Margin <p>Given \\(V_{OH} = 2.4V\\), \\(V_{IH} = 2.0V\\), \\(V_{OL} = 0.4V\\), and \\(V_{IL} = 0.8V\\), calculate both noise margins.</p> <p>Solution:</p> <ul> <li>High noise margin: \\(V_{OH} - V_{IH} = 2.4V - 2.0V = 0.4V\\)</li> <li>Low noise margin: \\(V_{IL} - V_{OL} = 0.8V - 0.4V = 0.4V\\)</li> </ul> <p>Both noise margins are 0.4V, meaning signals can tolerate up to 0.4V of noise in either direction.</p>"},{"location":"chapters/04-combinational-logic-design/","title":"Combinational Logic Design Fundamentals","text":""},{"location":"chapters/04-combinational-logic-design/#summary","title":"Summary","text":"<p>This chapter introduces the systematic methodology for designing combinational logic circuits where outputs depend only on current inputs. Students will learn the distinction between combinational and sequential logic, how to map Boolean expressions to gate-level implementations, canonical representations including Sum of Products (SOP) and Product of Sums (POS), minterms and maxterms, and the foundations of logic minimization including an introduction to Karnaugh maps. These design techniques form the core workflow for creating digital circuits from specifications.</p>"},{"location":"chapters/04-combinational-logic-design/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>Gate-Level Design</li> <li>Boolean to Gates Mapping</li> <li>Multi-Level Logic</li> <li>Two-Level Logic</li> <li>Sum of Products</li> <li>Product of Sums</li> <li>Minterm</li> <li>Maxterm</li> <li>Canonical Form</li> <li>Standard Form</li> <li>Minimal Form</li> <li>Logic Minimization</li> <li>Algebraic Simplification</li> <li>Factoring</li> <li>Common Term Extraction</li> <li>Karnaugh Map</li> <li>K-Map 2 Variable</li> <li>K-Map 3 Variable</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Boolean Algebra Fundamentals</li> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/05-logic-minimization-kmaps/","title":"Logic Minimization and Karnaugh Maps","text":""},{"location":"chapters/05-logic-minimization-kmaps/#summary","title":"Summary","text":"<p>This chapter provides advanced techniques for optimizing Boolean functions to create efficient circuit implementations. Students will master 4-variable Karnaugh maps and their grouping rules, learn to identify prime implicants and essential prime implicants, handle don't-care conditions for further optimization, derive minimal SOP and POS expressions, understand the Quine-McCluskey method for larger functions, and design hazard-free circuits. These optimization skills are critical for creating practical, cost-effective digital systems.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>K-Map 4 Variable</li> <li>K-Map Grouping Rules</li> <li>Adjacent Cells</li> <li>Don't Care Condition</li> <li>Prime Implicant</li> <li>Essential Prime Implicant</li> <li>Implicant Cover</li> <li>Minimal SOP</li> <li>Minimal POS</li> <li>Quine-McCluskey Method</li> <li>Hazard</li> <li>Static Hazard</li> <li>Dynamic Hazard</li> <li>Hazard-Free Design</li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/06-combinational-building-blocks/","title":"Combinational Building Blocks","text":""},{"location":"chapters/06-combinational-building-blocks/#summary","title":"Summary","text":"<p>This chapter introduces the standard combinational circuit modules that serve as building blocks for larger digital systems. Students will design and analyze multiplexers, demultiplexers, encoders, decoders, priority encoders, binary and magnitude comparators, half and full adders, ripple-carry adders, and understand ALU concepts. Additional topics include parity generation and checking for error detection, tri-state buffers, and bus architecture. These modular components are fundamental to constructing complex digital systems efficiently.</p>"},{"location":"chapters/06-combinational-building-blocks/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 35 concepts from the learning graph:</p> <ol> <li>Multiplexer</li> <li>MUX 2-to-1</li> <li>MUX 4-to-1</li> <li>MUX 8-to-1</li> <li>MUX Tree</li> <li>MUX as Logic Function</li> <li>Demultiplexer</li> <li>DEMUX 1-to-4</li> <li>Encoder</li> <li>Decoder</li> <li>2-to-4 Decoder</li> <li>3-to-8 Decoder</li> <li>Decoder Enable</li> <li>Priority Encoder</li> <li>7-Segment Display</li> <li>7-Segment Decoder</li> <li>Binary Comparator</li> <li>Magnitude Comparator</li> <li>Equality Comparator</li> <li>Half Adder</li> <li>Full Adder</li> <li>Carry Bit</li> <li>Sum Bit</li> <li>Ripple Carry Adder</li> <li>Carry Propagation Delay</li> <li>Carry Lookahead Concept</li> <li>Adder Subtractor</li> <li>Overflow in Addition</li> <li>ALU Concept</li> <li>Parity Bit</li> <li>Parity Generator</li> <li>Parity Checker</li> <li>Error Detection</li> <li>Tri-State Buffer</li> <li>Bus Architecture</li> </ol>"},{"location":"chapters/06-combinational-building-blocks/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/07-intro-sequential-logic/","title":"Introduction to Sequential Logic","text":""},{"location":"chapters/07-intro-sequential-logic/#summary","title":"Summary","text":"<p>This chapter marks the conceptual leap from combinational to sequential logic, where circuits can store information and their outputs depend on both current inputs and past history. Students will learn about memory elements, the concept of state, feedback loops in circuits, bistable elements, and latches including SR and D latches. The chapter also covers level-sensitive behavior, timing problems with latches, race conditions, and introduces clock signals as the foundation for synchronous design. Understanding these concepts is essential before studying flip-flops and finite state machines.</p>"},{"location":"chapters/07-intro-sequential-logic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Memory Element</li> <li>State Concept</li> <li>Feedback Loop</li> <li>Bistable Element</li> <li>SR Latch</li> <li>SR Latch Truth Table</li> <li>Invalid State Problem</li> <li>Gated SR Latch</li> <li>D Latch</li> <li>Level Sensitive</li> <li>Transparent Latch</li> <li>Latch Timing Problem</li> <li>Race Condition</li> <li>Clock Signal</li> <li>Clock Edge</li> <li>Rising Edge</li> <li>Falling Edge</li> <li>Clock Period</li> <li>Clock Frequency</li> <li>Duty Cycle</li> </ol>"},{"location":"chapters/07-intro-sequential-logic/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/08-flip-flops-timing/","title":"Flip-Flops and Timing","text":""},{"location":"chapters/08-flip-flops-timing/#summary","title":"Summary","text":"<p>This chapter covers edge-triggered flip-flops, the fundamental storage elements in synchronous digital systems. Students will learn about D, JK, and T flip-flops, understand edge-triggering mechanisms including master-slave configurations, and work with asynchronous preset and clear inputs. Critical timing concepts including setup time, hold time, clock-to-Q delay, timing diagrams, and timing violations are thoroughly covered. The chapter also addresses metastability, its causes, and synchronization techniques including the double-flop synchronizer for handling asynchronous inputs safely.</p>"},{"location":"chapters/08-flip-flops-timing/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>D Flip-Flop</li> <li>Edge Triggered</li> <li>Positive Edge Triggered</li> <li>Negative Edge Triggered</li> <li>Master-Slave Flip-Flop</li> <li>JK Flip-Flop</li> <li>JK Toggle Mode</li> <li>T Flip-Flop</li> <li>Flip-Flop Symbol</li> <li>Preset Input</li> <li>Clear Input</li> <li>Asynchronous Reset</li> <li>Synchronous Reset</li> <li>Setup Time</li> <li>Hold Time</li> <li>Clock-to-Q Delay</li> <li>Timing Diagram</li> <li>Timing Constraint</li> <li>Timing Violation</li> <li>Metastability</li> <li>MTBF Concept</li> <li>Synchronous System</li> <li>Asynchronous Input</li> <li>Synchronizer Circuit</li> <li>Double Flop Synchronizer</li> </ol>"},{"location":"chapters/08-flip-flops-timing/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 7: Introduction to Sequential Logic</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/09-fsm-fundamentals/","title":"Finite State Machine Fundamentals","text":""},{"location":"chapters/09-fsm-fundamentals/#summary","title":"Summary","text":"<p>This chapter introduces finite state machines (FSMs), the core abstraction for designing sequential digital systems with well-defined behavior. Students will learn the FSM model including states, transitions, inputs, and outputs, understand the distinction between Moore machines (outputs depend only on state) and Mealy machines (outputs depend on state and inputs), and master state diagram and state table representations. The chapter covers state encoding strategies including binary, one-hot, and Gray code encoding, along with state assignment optimization and state minimization techniques.</p>"},{"location":"chapters/09-fsm-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Finite State Machine</li> <li>FSM State</li> <li>State Transition</li> <li>Current State</li> <li>Next State</li> <li>Next State Logic</li> <li>Output Logic</li> <li>Moore Machine</li> <li>Moore Output</li> <li>Mealy Machine</li> <li>Mealy Output</li> <li>State Diagram</li> <li>State Diagram Notation</li> <li>State Table</li> <li>State Encoding</li> <li>Binary Encoding</li> <li>One-Hot Encoding</li> <li>Gray Code Encoding</li> <li>State Assignment</li> <li>State Minimization</li> </ol>"},{"location":"chapters/09-fsm-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> <li>Chapter 7: Introduction to Sequential Logic</li> <li>Chapter 8: Flip-Flops and Timing</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/10-fsm-design-applications/","title":"FSM Design and Applications","text":""},{"location":"chapters/10-fsm-design-applications/#summary","title":"Summary","text":"<p>This chapter applies FSM theory to practical design problems, teaching students the complete workflow from specification to implementation. Students will learn to derive next-state and output equations from state tables, follow the systematic FSM design process, and verify FSM designs for correctness. The chapter includes practical applications including sequence detectors with overlapping and non-overlapping detection modes, pattern recognition FSMs, and classic controller examples such as traffic light controllers and vending machine FSMs.</p>"},{"location":"chapters/10-fsm-design-applications/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>Next State Equation</li> <li>Output Equation</li> <li>FSM Design Process</li> <li>FSM Verification</li> <li>Sequence Detector</li> <li>Pattern Recognition FSM</li> <li>Overlapping Detection</li> <li>Non-Overlapping Detection</li> <li>Traffic Light Controller</li> <li>Vending Machine FSM</li> </ol>"},{"location":"chapters/10-fsm-design-applications/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 9: Finite State Machine Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/11-registers-counters-datapath/","title":"Registers, Counters, and Datapath","text":""},{"location":"chapters/11-registers-counters-datapath/#summary","title":"Summary","text":"<p>This chapter covers the sequential building blocks that form the foundation of digital datapath design. Students will learn about registers including parallel load and shift registers with various configurations (SISO, SIPO, PISO, PIPO), bidirectional and universal shift registers, and control signals for enable, load, and clear operations. Counter design is thoroughly covered including up, down, and up-down counters, mod-N counters, BCD and decade counters, and specialized counters like ring and Johnson counters. The chapter concludes with datapath concepts, control units, and register transfer level (RTL) abstraction.</p>"},{"location":"chapters/11-registers-counters-datapath/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 29 concepts from the learning graph:</p> <ol> <li>Counter</li> <li>Up Counter</li> <li>Down Counter</li> <li>Up-Down Counter</li> <li>Mod-N Counter</li> <li>Binary Counter</li> <li>BCD Counter</li> <li>Decade Counter</li> <li>Ring Counter</li> <li>Johnson Counter</li> <li>Counter State Diagram</li> <li>Counter Overflow</li> <li>Register</li> <li>Parallel Load Register</li> <li>Shift Register</li> <li>Serial In Serial Out</li> <li>Serial In Parallel Out</li> <li>Parallel In Serial Out</li> <li>Parallel In Parallel Out</li> <li>Bidirectional Shift</li> <li>Universal Shift Register</li> <li>Enable Signal</li> <li>Load Signal</li> <li>Clear Signal</li> <li>Register File</li> <li>Datapath Concept</li> <li>Control Unit</li> <li>Register Transfer Level</li> <li>RTL Notation</li> </ol>"},{"location":"chapters/11-registers-counters-datapath/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 8: Flip-Flops and Timing</li> <li>Chapter 9: Finite State Machine Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/","title":"Verilog HDL Fundamentals","text":""},{"location":"chapters/12-verilog-hdl-fundamentals/#summary","title":"Summary","text":"<p>This chapter introduces Verilog as a hardware description language, emphasizing that HDLs describe hardware behavior rather than software execution. Students will learn the fundamental distinction between HDL and programming languages, Verilog module structure and syntax, port declarations (input, output, inout), data types including wire and reg, parameters for configurable designs, continuous assignments using the assign statement, initial blocks for simulation, and module instantiation for building hierarchical designs. These fundamentals prepare students for behavioral and structural modeling.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>Verilog HDL</li> <li>HDL vs Programming</li> <li>Module Definition</li> <li>Port Declaration</li> <li>Input Port</li> <li>Output Port</li> <li>Inout Port</li> <li>Wire Data Type</li> <li>Reg Data Type</li> <li>Parameter</li> <li>Assign Statement</li> <li>Continuous Assignment</li> <li>Initial Block</li> <li>Module Instantiation</li> </ol>"},{"location":"chapters/12-verilog-hdl-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> <li>Chapter 7: Introduction to Sequential Logic</li> <li>Chapter 11: Registers, Counters, and Datapath</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/13-verilog-modeling/","title":"Verilog Behavioral and Structural Modeling","text":""},{"location":"chapters/13-verilog-modeling/#summary","title":"Summary","text":"<p>This chapter covers advanced Verilog constructs for modeling digital systems at various levels of abstraction. Students will master the always block and sensitivity lists, understand the critical difference between blocking and non-blocking assignments, use if-else and case statements for decision logic, and write combinational always blocks (with @(*)) and sequential always blocks (with @(posedge clk)). The chapter covers three modeling styles: structural modeling using gate primitives and module instantiation, behavioral modeling using procedural statements, and gate-level Verilog. RTL Verilog and hierarchical design principles complete the coverage.</p>"},{"location":"chapters/13-verilog-modeling/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Always Block</li> <li>Sensitivity List</li> <li>Blocking Assignment</li> <li>Non-Blocking Assignment</li> <li>If-Else in Verilog</li> <li>Case Statement</li> <li>Combinational Always</li> <li>Sequential Always</li> <li>Posedge Keyword</li> <li>Negedge Keyword</li> <li>Structural Modeling</li> <li>Behavioral Modeling</li> <li>Gate-Level Verilog</li> <li>RTL Verilog</li> <li>Hierarchical Design</li> </ol>"},{"location":"chapters/13-verilog-modeling/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 12: Verilog HDL Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/14-testbenches-simulation/","title":"Testbenches and Simulation","text":""},{"location":"chapters/14-testbenches-simulation/#summary","title":"Summary","text":"<p>This chapter covers the verification side of digital design, teaching students to validate their Verilog designs through simulation before hardware implementation. Students will learn to create testbenches, generate stimulus including clock signals and test vectors, build self-checking testbenches for automated verification, run simulations, and interpret results using waveform viewers for debugging. The chapter also covers the synthesis process, distinguishing between synthesizable and non-synthesizable code constructs, preparing students for FPGA implementation.</p>"},{"location":"chapters/14-testbenches-simulation/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 12 concepts from the learning graph:</p> <ol> <li>Testbench</li> <li>Stimulus Generation</li> <li>Clock Generation</li> <li>Test Vector</li> <li>Self-Checking Testbench</li> <li>Simulation</li> <li>Simulation Time</li> <li>Waveform Viewer</li> <li>Debugging Waveforms</li> <li>Synthesis</li> <li>Synthesizable Code</li> <li>Non-Synthesizable Code</li> </ol>"},{"location":"chapters/14-testbenches-simulation/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 12: Verilog HDL Fundamentals</li> <li>Chapter 13: Verilog Behavioral and Structural Modeling</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/15-fpga-lab-skills/","title":"FPGA Implementation and Laboratory Skills","text":""},{"location":"chapters/15-fpga-lab-skills/#summary","title":"Summary","text":"<p>This chapter bridges theory and practice by covering FPGA implementation and hands-on laboratory skills. Students will learn FPGA architecture including look-up tables (LUTs), flip-flops, and routing resources, the FPGA implementation flow, and pin assignment. Laboratory skills include breadboard prototyping, using logic probes and logic analyzers, working with LED indicators and switch inputs, and implementing switch debouncing. The chapter covers design verification approaches including functional and timing verification, design hierarchy and reuse principles, documentation practices, and the complete digital system design workflow.</p>"},{"location":"chapters/15-fpga-lab-skills/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>FPGA Architecture</li> <li>FPGA LUT</li> <li>FPGA Flip-Flop</li> <li>FPGA Routing</li> <li>FPGA Implementation</li> <li>Pin Assignment</li> <li>Breadboard Prototyping</li> <li>Logic Probe</li> <li>Logic Analyzer</li> <li>LED Indicator</li> <li>Switch Input</li> <li>Debouncing</li> <li>Design Verification</li> <li>Functional Verification</li> <li>Timing Verification</li> <li>Hardware-Software Boundary</li> <li>Abstraction Levels</li> <li>Design Hierarchy</li> <li>Design Reuse</li> <li>Design Documentation</li> <li>Digital System Design</li> </ol>"},{"location":"chapters/15-fpga-lab-skills/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 8: Flip-Flops and Timing</li> <li>Chapter 10: FSM Design and Applications</li> <li>Chapter 13: Verilog Behavioral and Structural Modeling</li> <li>Chapter 14: Testbenches and Simulation</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"learning-graph/","title":"Learning Graph for Digital Electronics","text":"<p>This section contains the learning graph for this textbook. A learning graph is a graph of concepts used in this textbook. Each concept is represented by a node in a network graph. Concepts are connected by directed edges that indicate what concepts each node depends on before that concept is understood by the student.</p> <p>A learning graph is the foundational data structure for intelligent textbooks that can recommend learning paths. A learning graph is like a roadmap of concepts to help students arrive at their learning goals.</p> <p>At the left of the learning graph are prerequisite or foundational concepts. They have no outbound edges. They only have inbound edges for other concepts that depend on understanding these foundational prerequisite concepts. At the far right we have the most advanced concepts in the course. To master these concepts you must understand all the concepts that they point to.</p>"},{"location":"learning-graph/#learning-graph-statistics","title":"Learning Graph Statistics","text":"<ul> <li>Total Concepts: 300</li> <li>Foundational Concepts: 6</li> <li>Total Dependencies: 526 edges</li> <li>Taxonomy Categories: 11</li> <li>Longest Learning Path: 24 concepts</li> </ul> <p>Here are other files used by the learning graph.</p>"},{"location":"learning-graph/#course-description","title":"Course Description","text":"<p>We use the Course Description as the source document for the concepts that are included in this course. The course description uses the 2001 Bloom taxonomy to order learning objectives.</p>"},{"location":"learning-graph/#list-of-concepts","title":"List of Concepts","text":"<p>We use generative AI to convert the course description into a Concept List. Each concept is in the form of a short Title Case label with most labels under 32 characters long.</p>"},{"location":"learning-graph/#concept-dependency-list","title":"Concept Dependency List","text":"<p>We next use generative AI to create a Directed Acyclic Graph (DAG). DAGs do not have cycles where concepts depend on themselves. We provide the DAG in two formats. One is a CSV file and the other format is a JSON file that uses the vis-network JavaScript library format. The vis-network format uses <code>nodes</code>, <code>edges</code> and <code>metadata</code> elements with edges containing <code>from</code> and <code>to</code> properties. This makes it easy for you to view and edit the learning graph using an editor built with the vis-network tools.</p>"},{"location":"learning-graph/#analysis-documentation","title":"Analysis &amp; Documentation","text":""},{"location":"learning-graph/#course-description-quality-assessment","title":"Course Description Quality Assessment","text":"<p>This report rates the overall quality of the course description for the purpose of generating a learning graph.</p> <ul> <li>Course description fields and content depth analysis</li> <li>Validates course description has sufficient depth for generating 200 concepts</li> <li>Compares course description against similar courses</li> <li>Identifies content gaps and strengths</li> <li>Suggests areas of improvement</li> </ul> <p>View the Course Description Quality Assessment</p>"},{"location":"learning-graph/#learning-graph-quality-validation","title":"Learning Graph Quality Validation","text":"<p>This report gives you an overall assessment of the quality of the learning graph. It uses graph algorithms to look for specific quality patterns in the graph.</p> <ul> <li>Graph structure validation - all concepts are connected</li> <li>DAG validation (no cycles detected)</li> <li>Foundational concepts: 6 entry points</li> <li>Indegree distribution analysis</li> <li>Longest dependency chains</li> <li>Connectivity: all nodes connected to the main cluster</li> </ul> <p>View the Learning Graph Quality Validation</p>"},{"location":"learning-graph/#concept-taxonomy","title":"Concept Taxonomy","text":"<p>In order to see patterns in the learning graph, it is useful to assign colors to each concept based on the concept type. We use generative AI to create about a dozen categories for our concepts and then place each concept into a single primary classifier.</p> <ul> <li>11 taxonomy categories covering digital electronics topics</li> <li>Category organization - foundational elements first, verification and lab skills last</li> <li>Balanced categories (4.7% - 12.3% each)</li> <li>All categories under 30% threshold</li> <li>Pedagogical flow from Boolean algebra through Verilog</li> <li>Clear 3-5 letter abbreviations for use in CSV file</li> </ul> <p>View the Concept Taxonomy</p>"},{"location":"learning-graph/#taxonomy-distribution","title":"Taxonomy Distribution","text":"<p>This reports shows how many concepts fit into each category of the taxonomy. Our goal is a somewhat balanced taxonomy where each category holds an equal number of concepts. We also don't want any category to contain over 30% of our concepts.</p> <ul> <li>Statistical breakdown by category</li> <li>Detailed concept listing by category</li> <li>Visual distribution table</li> <li>Balance verification</li> </ul> <p>View the Taxonomy Distribution Report</p>"},{"location":"learning-graph/concept-list/","title":"Digital Electronics Concept List","text":"<p>This file contains 250 concepts for the Digital Electronics learning graph. Each concept is numbered with a unique ConceptID for use in the dependency graph.</p>"},{"location":"learning-graph/concept-list/#concepts","title":"Concepts","text":"<ol> <li>Binary Number System</li> <li>Decimal to Binary Conversion</li> <li>Binary to Decimal Conversion</li> <li>Hexadecimal Numbers</li> <li>Hex to Binary Conversion</li> <li>Octal Numbers</li> <li>Binary Addition</li> <li>Binary Subtraction</li> <li>Two's Complement</li> <li>Signed Binary Numbers</li> <li>Overflow Detection</li> <li>BCD Encoding</li> <li>Gray Code</li> <li>Weighted Codes</li> <li>Boolean Variable</li> <li>Boolean Constant</li> <li>Boolean Expression</li> <li>Boolean Function</li> <li>Truth Table</li> <li>AND Operation</li> <li>OR Operation</li> <li>NOT Operation</li> <li>Boolean Algebra</li> <li>Identity Law</li> <li>Null Law</li> <li>Idempotent Law</li> <li>Complement Law</li> <li>Commutative Law</li> <li>Associative Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>De Morgan's Theorem</li> <li>Dual Expression</li> <li>Consensus Theorem</li> <li>Boolean Proof Technique</li> <li>Logic Gate</li> <li>AND Gate</li> <li>OR Gate</li> <li>NOT Gate</li> <li>Buffer Gate</li> <li>NAND Gate</li> <li>NOR Gate</li> <li>XOR Gate</li> <li>XNOR Gate</li> <li>Gate Symbol</li> <li>IEEE Gate Symbols</li> <li>Functional Completeness</li> <li>Universal Gate</li> <li>NAND-Only Design</li> <li>NOR-Only Design</li> <li>Gate Delay</li> <li>Propagation Delay</li> <li>Rise Time</li> <li>Fall Time</li> <li>Fan-In</li> <li>Fan-Out</li> <li>Logic Levels</li> <li>Noise Margin</li> <li>Voltage Threshold</li> <li>Logic Family</li> <li>TTL Logic</li> <li>CMOS Logic</li> <li>Digital Signal</li> <li>Analog vs Digital</li> <li>Signal Integrity</li> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>Gate-Level Design</li> <li>Boolean to Gates Mapping</li> <li>Multi-Level Logic</li> <li>Two-Level Logic</li> <li>Sum of Products</li> <li>Product of Sums</li> <li>Minterm</li> <li>Maxterm</li> <li>Canonical Form</li> <li>Standard Form</li> <li>Minimal Form</li> <li>Logic Minimization</li> <li>Algebraic Simplification</li> <li>Factoring</li> <li>Common Term Extraction</li> <li>Karnaugh Map</li> <li>K-Map 2 Variable</li> <li>K-Map 3 Variable</li> <li>K-Map 4 Variable</li> <li>K-Map Grouping Rules</li> <li>Adjacent Cells</li> <li>Don't Care Condition</li> <li>Prime Implicant</li> <li>Essential Prime Implicant</li> <li>Implicant Cover</li> <li>Minimal SOP</li> <li>Minimal POS</li> <li>Quine-McCluskey Method</li> <li>Hazard</li> <li>Static Hazard</li> <li>Dynamic Hazard</li> <li>Hazard-Free Design</li> <li>Multiplexer</li> <li>MUX 2-to-1</li> <li>MUX 4-to-1</li> <li>MUX 8-to-1</li> <li>MUX Tree</li> <li>MUX as Logic Function</li> <li>Demultiplexer</li> <li>DEMUX 1-to-4</li> <li>Encoder</li> <li>Decoder</li> <li>2-to-4 Decoder</li> <li>3-to-8 Decoder</li> <li>Decoder Enable</li> <li>Priority Encoder</li> <li>7-Segment Display</li> <li>7-Segment Decoder</li> <li>Binary Comparator</li> <li>Magnitude Comparator</li> <li>Equality Comparator</li> <li>Half Adder</li> <li>Full Adder</li> <li>Carry Bit</li> <li>Sum Bit</li> <li>Ripple Carry Adder</li> <li>Carry Propagation Delay</li> <li>Carry Lookahead Concept</li> <li>Adder Subtractor</li> <li>Overflow in Addition</li> <li>ALU Concept</li> <li>Parity Bit</li> <li>Parity Generator</li> <li>Parity Checker</li> <li>Error Detection</li> <li>Tri-State Buffer</li> <li>Bus Architecture</li> <li>Memory Element</li> <li>State Concept</li> <li>Feedback Loop</li> <li>Bistable Element</li> <li>SR Latch</li> <li>SR Latch Truth Table</li> <li>Invalid State Problem</li> <li>Gated SR Latch</li> <li>D Latch</li> <li>Level Sensitive</li> <li>Transparent Latch</li> <li>Latch Timing Problem</li> <li>Race Condition</li> <li>Clock Signal</li> <li>Clock Edge</li> <li>Rising Edge</li> <li>Falling Edge</li> <li>Clock Period</li> <li>Clock Frequency</li> <li>Duty Cycle</li> <li>D Flip-Flop</li> <li>Edge Triggered</li> <li>Positive Edge Triggered</li> <li>Negative Edge Triggered</li> <li>Master-Slave Flip-Flop</li> <li>JK Flip-Flop</li> <li>JK Toggle Mode</li> <li>T Flip-Flop</li> <li>Flip-Flop Symbol</li> <li>Preset Input</li> <li>Clear Input</li> <li>Asynchronous Reset</li> <li>Synchronous Reset</li> <li>Setup Time</li> <li>Hold Time</li> <li>Clock-to-Q Delay</li> <li>Timing Diagram</li> <li>Timing Constraint</li> <li>Timing Violation</li> <li>Metastability</li> <li>MTBF Concept</li> <li>Synchronous System</li> <li>Asynchronous Input</li> <li>Synchronizer Circuit</li> <li>Double Flop Synchronizer</li> <li>Finite State Machine</li> <li>FSM State</li> <li>State Transition</li> <li>Current State</li> <li>Next State</li> <li>Next State Logic</li> <li>Output Logic</li> <li>Moore Machine</li> <li>Moore Output</li> <li>Mealy Machine</li> <li>Mealy Output</li> <li>State Diagram</li> <li>State Diagram Notation</li> <li>State Table</li> <li>State Encoding</li> <li>Binary Encoding</li> <li>One-Hot Encoding</li> <li>Gray Code Encoding</li> <li>State Assignment</li> <li>State Minimization</li> <li>Next State Equation</li> <li>Output Equation</li> <li>FSM Design Process</li> <li>FSM Verification</li> <li>Sequence Detector</li> <li>Pattern Recognition FSM</li> <li>Overlapping Detection</li> <li>Non-Overlapping Detection</li> <li>Traffic Light Controller</li> <li>Vending Machine FSM</li> <li>Counter</li> <li>Up Counter</li> <li>Down Counter</li> <li>Up-Down Counter</li> <li>Mod-N Counter</li> <li>Binary Counter</li> <li>BCD Counter</li> <li>Decade Counter</li> <li>Ring Counter</li> <li>Johnson Counter</li> <li>Counter State Diagram</li> <li>Counter Overflow</li> <li>Register</li> <li>Parallel Load Register</li> <li>Shift Register</li> <li>Serial In Serial Out</li> <li>Serial In Parallel Out</li> <li>Parallel In Serial Out</li> <li>Parallel In Parallel Out</li> <li>Bidirectional Shift</li> <li>Universal Shift Register</li> <li>Enable Signal</li> <li>Load Signal</li> <li>Clear Signal</li> <li>Register File</li> <li>Datapath Concept</li> <li>Control Unit</li> <li>Register Transfer Level</li> <li>RTL Notation</li> <li>Verilog HDL</li> <li>HDL vs Programming</li> <li>Module Definition</li> <li>Port Declaration</li> <li>Input Port</li> <li>Output Port</li> <li>Inout Port</li> <li>Wire Data Type</li> <li>Reg Data Type</li> <li>Parameter</li> <li>Assign Statement</li> <li>Continuous Assignment</li> <li>Always Block</li> <li>Sensitivity List</li> <li>Blocking Assignment</li> <li>Non-Blocking Assignment</li> <li>If-Else in Verilog</li> <li>Case Statement</li> <li>Combinational Always</li> <li>Sequential Always</li> <li>Posedge Keyword</li> <li>Negedge Keyword</li> <li>Initial Block</li> <li>Structural Modeling</li> <li>Behavioral Modeling</li> <li>Gate-Level Verilog</li> <li>RTL Verilog</li> <li>Module Instantiation</li> <li>Hierarchical Design</li> <li>Testbench</li> <li>Stimulus Generation</li> <li>Clock Generation</li> <li>Test Vector</li> <li>Self-Checking Testbench</li> <li>Simulation</li> <li>Simulation Time</li> <li>Waveform Viewer</li> <li>Debugging Waveforms</li> <li>Synthesis</li> <li>Synthesizable Code</li> <li>Non-Synthesizable Code</li> <li>FPGA Architecture</li> <li>FPGA LUT</li> <li>FPGA Flip-Flop</li> <li>FPGA Routing</li> <li>FPGA Implementation</li> <li>Pin Assignment</li> <li>Breadboard Prototyping</li> <li>Logic Probe</li> <li>Logic Analyzer</li> <li>LED Indicator</li> <li>Switch Input</li> <li>Debouncing</li> <li>Design Verification</li> <li>Functional Verification</li> <li>Timing Verification</li> <li>Hardware-Software Boundary</li> <li>Abstraction Levels</li> <li>Design Hierarchy</li> <li>Design Reuse</li> <li>Design Documentation</li> <li>Digital System Design</li> </ol>"},{"location":"learning-graph/concept-taxonomy/","title":"Digital Electronics Concept Taxonomy","text":"<p>This taxonomy organizes the 300 concepts into 12 categories for visualization and navigation.</p>"},{"location":"learning-graph/concept-taxonomy/#categories","title":"Categories","text":"TaxonomyID Category Name Description FOUND Foundation Concepts Prerequisites and fundamental ideas needed before starting the course NUMSYS Number Systems Binary, hexadecimal, octal, and encoding schemes BOOL Boolean Algebra Boolean operations, laws, theorems, and simplification GATES Logic Gates Primitive gates, properties, symbols, and characteristics COMB Combinational Logic Combinational circuit design, canonical forms, and K-maps BLOCKS Building Blocks Standard combinational modules (MUX, decoders, adders) SEQ Sequential Basics Latches, memory elements, and feedback concepts FLIPFLOP Flip-Flops Edge-triggered storage, timing, and flip-flop types FSM Finite State Machines State machines, encoding, design process, and applications REG Registers &amp; Counters Registers, shift registers, counters, and datapath HDL Verilog HDL Hardware description language syntax and modeling VERIFY Verification &amp; Lab Simulation, FPGA, testing, and laboratory skills"},{"location":"learning-graph/concept-taxonomy/#category-descriptions","title":"Category Descriptions","text":""},{"location":"learning-graph/concept-taxonomy/#found-foundation-concepts","title":"FOUND - Foundation Concepts","text":"<p>Concepts that form the absolute foundation, typically prerequisite knowledge or standalone concepts that anchor the learning graph.</p>"},{"location":"learning-graph/concept-taxonomy/#numsys-number-systems","title":"NUMSYS - Number Systems","text":"<p>Binary arithmetic, number representations, conversions, and special encoding schemes like BCD and Gray code.</p>"},{"location":"learning-graph/concept-taxonomy/#bool-boolean-algebra","title":"BOOL - Boolean Algebra","text":"<p>Boolean variables, operations, expressions, functions, truth tables, and all Boolean algebra laws including De Morgan's theorem.</p>"},{"location":"learning-graph/concept-taxonomy/#gates-logic-gates","title":"GATES - Logic Gates","text":"<p>All primitive logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR), their symbols, properties like delay, fan-in/fan-out, and logic levels.</p>"},{"location":"learning-graph/concept-taxonomy/#comb-combinational-logic","title":"COMB - Combinational Logic","text":"<p>Combinational circuit design methodology including SOP/POS forms, minterms, maxterms, K-maps, and logic minimization.</p>"},{"location":"learning-graph/concept-taxonomy/#blocks-building-blocks","title":"BLOCKS - Building Blocks","text":"<p>Standard combinational building blocks: multiplexers, demultiplexers, encoders, decoders, comparators, adders, and ALU concepts.</p>"},{"location":"learning-graph/concept-taxonomy/#seq-sequential-basics","title":"SEQ - Sequential Basics","text":"<p>Introduction to sequential logic: memory elements, state concept, feedback, latches (SR, D), and clock signals.</p>"},{"location":"learning-graph/concept-taxonomy/#flipflop-flip-flops","title":"FLIPFLOP - Flip-Flops","text":"<p>Edge-triggered flip-flops (D, JK, T), timing parameters (setup, hold, clock-to-Q), metastability, and synchronization.</p>"},{"location":"learning-graph/concept-taxonomy/#fsm-finite-state-machines","title":"FSM - Finite State Machines","text":"<p>Moore and Mealy machines, state diagrams, state tables, encoding methods, design process, and FSM applications.</p>"},{"location":"learning-graph/concept-taxonomy/#reg-registers-counters","title":"REG - Registers &amp; Counters","text":"<p>Registers, shift registers, counters (up/down, ring, Johnson), datapath concepts, and register transfer level.</p>"},{"location":"learning-graph/concept-taxonomy/#hdl-verilog-hdl","title":"HDL - Verilog HDL","text":"<p>Verilog language constructs: modules, ports, data types, assignments, always blocks, modeling styles, and hierarchy.</p>"},{"location":"learning-graph/concept-taxonomy/#verify-verification-lab","title":"VERIFY - Verification &amp; Lab","text":"<p>Testbenches, simulation, waveforms, synthesis, FPGA implementation, and laboratory/prototyping skills.</p>"},{"location":"learning-graph/course-description-assessment/","title":"Course Description Quality Assessment","text":"<p>Course: Digital Electronics Assessment Date: 2026-01-30 Quality Score: 91/100</p>"},{"location":"learning-graph/course-description-assessment/#scoring-breakdown","title":"Scoring Breakdown","text":"Element Points Max Assessment Title 5 5 \"Digital Electronics\" - clear and descriptive Target Audience 5 5 College students majoring in EE or computer-related fields Prerequisites 5 5 Calculus 1 clearly stated Main Topics Covered 10 10 Comprehensive 12 topics from Boolean algebra to verification Topics Excluded 5 5 Clear boundaries (no CMOS, no async, no timing closure, no CPU pipelines) Learning Outcomes Header 5 5 Clear \"After completing this course, students will be able to:\" Remember Level 9 10 5 specific outcomes with appropriate verbs Understand Level 10 10 6 specific outcomes covering key concepts Apply Level 10 10 6 specific outcomes for practical skills Analyze Level 9 10 5 specific outcomes for analytical skills Evaluate Level 9 10 5 specific outcomes for judgment skills Create Level 9 10 5 specific outcomes including capstone activities Descriptive Context 5 5 Excellent context about course importance as a \"pivot course\" <p>Total: 91/100</p>"},{"location":"learning-graph/course-description-assessment/#strengths","title":"Strengths","text":"<ul> <li>Excellent topic breadth and depth covering 12 major areas</li> <li>Clear prerequisites and audience definition</li> <li>Strong pedagogical narrative explaining why topics matter</li> <li>Good exclusion boundaries defining what is NOT covered</li> <li>Complete Bloom's Taxonomy coverage with specific, actionable outcomes</li> <li>Well-organized progression from foundations to advanced topics</li> </ul>"},{"location":"learning-graph/course-description-assessment/#estimated-concept-count","title":"Estimated Concept Count","text":"<p>Based on the course description, approximately 180-200 distinct concepts can be derived:</p> <ul> <li>Boolean Algebra &amp; Binary Logic: ~25 concepts</li> <li>Logic Gates &amp; Gate-Level Modeling: ~20 concepts</li> <li>Combinational Logic Design: ~25 concepts</li> <li>Logic Simplification &amp; Optimization: ~20 concepts</li> <li>Sequential Logic Introduction: ~15 concepts</li> <li>Flip-Flops &amp; Clocked Storage: ~15 concepts</li> <li>Synchronous Sequential Logic: ~25 concepts</li> <li>Registers, Counters, Datapath: ~15 concepts</li> <li>Verilog HDL Modeling: ~20 concepts</li> <li>Design, Simulation, Verification: ~10 concepts</li> <li>Laboratory Skills: ~10 concepts</li> </ul>"},{"location":"learning-graph/course-description-assessment/#comparison-with-similar-courses","title":"Comparison with Similar Courses","text":"<p>This course description is comparable to standard ABET-aligned EE digital electronics courses at:</p> <ul> <li>University-level EE 2xxx courses</li> <li>IEEE/ACM computer engineering curricula</li> <li>Similar in scope to classic textbooks (Mano, Wakerly, Katz)</li> </ul>"},{"location":"learning-graph/course-description-assessment/#recommendation","title":"Recommendation","text":"<p>\u2705 APPROVED - The quality score of 91 exceeds the 70-point threshold. This course description provides sufficient depth and breadth to generate a high-quality learning graph with 200 concepts.</p>"},{"location":"learning-graph/quality-metrics/","title":"Learning Graph Quality Metrics Report","text":""},{"location":"learning-graph/quality-metrics/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 300</li> <li>Foundational Concepts (no dependencies): 6</li> <li>Concepts with Dependencies: 294</li> <li>Average Dependencies per Concept: 1.79</li> </ul>"},{"location":"learning-graph/quality-metrics/#graph-structure-validation","title":"Graph Structure Validation","text":"<ul> <li>Valid DAG Structure: \u274c No</li> <li>Self-Dependencies: None detected \u2705</li> <li>Cycles Detected: 0</li> </ul>"},{"location":"learning-graph/quality-metrics/#foundational-concepts","title":"Foundational Concepts","text":"<p>These concepts have no prerequisites:</p> <ul> <li>1: Binary Number System</li> <li>15: Boolean Variable</li> <li>114: 7-Segment Display</li> <li>148: Clock Signal</li> <li>239: Verilog HDL</li> <li>280: FPGA Architecture</li> </ul>"},{"location":"learning-graph/quality-metrics/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<ul> <li>Maximum Dependency Chain Length: 24</li> </ul>"},{"location":"learning-graph/quality-metrics/#longest-learning-path","title":"Longest Learning Path:","text":"<ol> <li>Boolean Variable (ID: 15)</li> <li>Boolean Constant (ID: 16)</li> <li>Boolean Expression (ID: 17)</li> <li>Boolean Function (ID: 18)</li> <li>Truth Table (ID: 19)</li> <li>Logic Gate (ID: 36)</li> <li>Combinational Logic (ID: 66)</li> <li>Memory Element (ID: 135)</li> <li>Feedback Loop (ID: 137)</li> <li>Bistable Element (ID: 138)</li> <li>SR Latch (ID: 139)</li> <li>Gated SR Latch (ID: 142)</li> <li>D Latch (ID: 143)</li> <li>D Flip-Flop (ID: 155)</li> <li>Finite State Machine (ID: 180)</li> <li>FSM State (ID: 181)</li> <li>State Transition (ID: 182)</li> <li>Next State (ID: 184)</li> <li>Next State Logic (ID: 185)</li> <li>Next State Equation (ID: 200)</li> <li>FSM Design Process (ID: 202)</li> <li>Sequence Detector (ID: 204)</li> <li>Overlapping Detection (ID: 206)</li> <li>Non-Overlapping Detection (ID: 207)</li> </ol>"},{"location":"learning-graph/quality-metrics/#orphaned-nodes-analysis","title":"Orphaned Nodes Analysis","text":"<ul> <li>Total Orphaned Nodes: 101</li> </ul> <p>Concepts that are not prerequisites for any other concept:</p> <ul> <li>2: Decimal to Binary Conversion</li> <li>5: Hex to Binary Conversion</li> <li>6: Octal Numbers</li> <li>14: Weighted Codes</li> <li>33: Dual Expression</li> <li>34: Consensus Theorem</li> <li>46: IEEE Gate Symbols</li> <li>49: NAND-Only Design</li> <li>50: NOR-Only Design</li> <li>53: Rise Time</li> <li>54: Fall Time</li> <li>55: Fan-In</li> <li>56: Fan-Out</li> <li>59: Voltage Threshold</li> <li>61: TTL Logic</li> <li>62: CMOS Logic</li> <li>64: Analog vs Digital</li> <li>65: Signal Integrity</li> <li>70: Multi-Level Logic</li> <li>78: Minimal Form</li> </ul> <p>...and 81 more</p>"},{"location":"learning-graph/quality-metrics/#connected-components","title":"Connected Components","text":"<ul> <li>Number of Connected Components: 1</li> </ul> <p>\u2705 All concepts are connected in a single graph.</p>"},{"location":"learning-graph/quality-metrics/#indegree-analysis","title":"Indegree Analysis","text":"<p>Top 10 concepts that are prerequisites for the most other concepts:</p> Rank Concept ID Concept Label Indegree 1 36 Logic Gate 19 2 66 Combinational Logic 17 3 155 D Flip-Flop 17 4 1 Binary Number System 16 5 23 Boolean Algebra 13 6 239 Verilog HDL 13 7 180 Finite State Machine 10 8 17 Boolean Expression 8 9 251 Always Block 8 10 19 Truth Table 7"},{"location":"learning-graph/quality-metrics/#outdegree-distribution","title":"Outdegree Distribution","text":"Dependencies Number of Concepts 0 6 1 112 2 147 3 27 4 6 5 1 10 1"},{"location":"learning-graph/quality-metrics/#recommendations","title":"Recommendations","text":"<ul> <li>\u26a0\ufe0f Many orphaned nodes (101): Consider if these should be prerequisites for advanced concepts</li> <li>\u2139\ufe0f Long dependency chains (24): Ensure students can follow extended learning paths</li> </ul> <p>Report generated by learning-graph-reports/analyze_graph.py</p>"},{"location":"learning-graph/taxonomy-distribution/","title":"Taxonomy Distribution Report","text":""},{"location":"learning-graph/taxonomy-distribution/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 300</li> <li>Number of Taxonomies: 11</li> <li>Average Concepts per Taxonomy: 27.3</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#distribution-summary","title":"Distribution Summary","text":"Category TaxonomyID Count Percentage Status Building Blocks BLOCKS 35 11.7% \u2705 Combinational Logic COMB 34 11.3% \u2705 Verification &amp; Lab VERIFY 33 11.0% \u2705 Logic Gates GATES 30 10.0% \u2705 Finite State Machines FSM 30 10.0% \u2705 Registers &amp; Counters REG 29 9.7% \u2705 Verilog HDL HDL 29 9.7% \u2705 Flip-Flops FLIPFLOP 25 8.3% \u2705 Boolean Algebra BOOL 21 7.0% \u2705 Sequential Basics SEQ 20 6.7% \u2705 Number Systems NUMSYS 14 4.7% \u2705"},{"location":"learning-graph/taxonomy-distribution/#visual-distribution","title":"Visual Distribution","text":"<pre><code>BLOCKS \u2588\u2588\u2588\u2588\u2588  35 ( 11.7%)\nCOMB   \u2588\u2588\u2588\u2588\u2588  34 ( 11.3%)\nVERIFY \u2588\u2588\u2588\u2588\u2588  33 ( 11.0%)\nGATES  \u2588\u2588\u2588\u2588\u2588  30 ( 10.0%)\nFSM    \u2588\u2588\u2588\u2588\u2588  30 ( 10.0%)\nREG    \u2588\u2588\u2588\u2588  29 (  9.7%)\nHDL    \u2588\u2588\u2588\u2588  29 (  9.7%)\nFLIPFLOP \u2588\u2588\u2588\u2588  25 (  8.3%)\nBOOL   \u2588\u2588\u2588  21 (  7.0%)\nSEQ    \u2588\u2588\u2588  20 (  6.7%)\nNUMSYS \u2588\u2588  14 (  4.7%)\n</code></pre>"},{"location":"learning-graph/taxonomy-distribution/#balance-analysis","title":"Balance Analysis","text":""},{"location":"learning-graph/taxonomy-distribution/#no-over-represented-categories","title":"\u2705 No Over-Represented Categories","text":"<p>All categories are under the 30% threshold. Good balance!</p>"},{"location":"learning-graph/taxonomy-distribution/#category-details","title":"Category Details","text":""},{"location":"learning-graph/taxonomy-distribution/#building-blocks-blocks","title":"Building Blocks (BLOCKS)","text":"<p>Count: 35 concepts (11.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Multiplexer</li> </ol> </li> <li> <ol> <li>MUX 2-to-1</li> </ol> </li> <li> <ol> <li>MUX 4-to-1</li> </ol> </li> <li> <ol> <li>MUX 8-to-1</li> </ol> </li> <li> <ol> <li>MUX Tree</li> </ol> </li> <li> <ol> <li>MUX as Logic Function</li> </ol> </li> <li> <ol> <li>Demultiplexer</li> </ol> </li> <li> <ol> <li>DEMUX 1-to-4</li> </ol> </li> <li> <ol> <li>Encoder</li> </ol> </li> <li> <ol> <li>Decoder</li> </ol> </li> <li> <ol> <li>2-to-4 Decoder</li> </ol> </li> <li> <ol> <li>3-to-8 Decoder</li> </ol> </li> <li> <ol> <li>Decoder Enable</li> </ol> </li> <li> <ol> <li>Priority Encoder</li> </ol> </li> <li> <ol> <li>7-Segment Display</li> </ol> </li> <li>...and 20 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#combinational-logic-comb","title":"Combinational Logic (COMB)","text":"<p>Count: 34 concepts (11.3%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Combinational Logic</li> </ol> </li> <li> <ol> <li>Sequential Logic</li> </ol> </li> <li> <ol> <li>Gate-Level Design</li> </ol> </li> <li> <ol> <li>Boolean to Gates Mapping</li> </ol> </li> <li> <ol> <li>Multi-Level Logic</li> </ol> </li> <li> <ol> <li>Two-Level Logic</li> </ol> </li> <li> <ol> <li>Sum of Products</li> </ol> </li> <li> <ol> <li>Product of Sums</li> </ol> </li> <li> <ol> <li>Minterm</li> </ol> </li> <li> <ol> <li>Maxterm</li> </ol> </li> <li> <ol> <li>Canonical Form</li> </ol> </li> <li> <ol> <li>Standard Form</li> </ol> </li> <li> <ol> <li>Minimal Form</li> </ol> </li> <li> <ol> <li>Logic Minimization</li> </ol> </li> <li> <ol> <li>Algebraic Simplification</li> </ol> </li> <li>...and 19 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#verification-lab-verify","title":"Verification &amp; Lab (VERIFY)","text":"<p>Count: 33 concepts (11.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Testbench</li> </ol> </li> <li> <ol> <li>Stimulus Generation</li> </ol> </li> <li> <ol> <li>Clock Generation</li> </ol> </li> <li> <ol> <li>Test Vector</li> </ol> </li> <li> <ol> <li>Self-Checking Testbench</li> </ol> </li> <li> <ol> <li>Simulation</li> </ol> </li> <li> <ol> <li>Simulation Time</li> </ol> </li> <li> <ol> <li>Waveform Viewer</li> </ol> </li> <li> <ol> <li>Debugging Waveforms</li> </ol> </li> <li> <ol> <li>Synthesis</li> </ol> </li> <li> <ol> <li>Synthesizable Code</li> </ol> </li> <li> <ol> <li>Non-Synthesizable Code</li> </ol> </li> <li> <ol> <li>FPGA Architecture</li> </ol> </li> <li> <ol> <li>FPGA LUT</li> </ol> </li> <li> <ol> <li>FPGA Flip-Flop</li> </ol> </li> <li>...and 18 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#logic-gates-gates","title":"Logic Gates (GATES)","text":"<p>Count: 30 concepts (10.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Logic Gate</li> </ol> </li> <li> <ol> <li>AND Gate</li> </ol> </li> <li> <ol> <li>OR Gate</li> </ol> </li> <li> <ol> <li>NOT Gate</li> </ol> </li> <li> <ol> <li>Buffer Gate</li> </ol> </li> <li> <ol> <li>NAND Gate</li> </ol> </li> <li> <ol> <li>NOR Gate</li> </ol> </li> <li> <ol> <li>XOR Gate</li> </ol> </li> <li> <ol> <li>XNOR Gate</li> </ol> </li> <li> <ol> <li>Gate Symbol</li> </ol> </li> <li> <ol> <li>IEEE Gate Symbols</li> </ol> </li> <li> <ol> <li>Functional Completeness</li> </ol> </li> <li> <ol> <li>Universal Gate</li> </ol> </li> <li> <ol> <li>NAND-Only Design</li> </ol> </li> <li> <ol> <li>NOR-Only Design</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#finite-state-machines-fsm","title":"Finite State Machines (FSM)","text":"<p>Count: 30 concepts (10.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Finite State Machine</li> </ol> </li> <li> <ol> <li>FSM State</li> </ol> </li> <li> <ol> <li>State Transition</li> </ol> </li> <li> <ol> <li>Current State</li> </ol> </li> <li> <ol> <li>Next State</li> </ol> </li> <li> <ol> <li>Next State Logic</li> </ol> </li> <li> <ol> <li>Output Logic</li> </ol> </li> <li> <ol> <li>Moore Machine</li> </ol> </li> <li> <ol> <li>Moore Output</li> </ol> </li> <li> <ol> <li>Mealy Machine</li> </ol> </li> <li> <ol> <li>Mealy Output</li> </ol> </li> <li> <ol> <li>State Diagram</li> </ol> </li> <li> <ol> <li>State Diagram Notation</li> </ol> </li> <li> <ol> <li>State Table</li> </ol> </li> <li> <ol> <li>State Encoding</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#registers-counters-reg","title":"Registers &amp; Counters (REG)","text":"<p>Count: 29 concepts (9.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Counter</li> </ol> </li> <li> <ol> <li>Up Counter</li> </ol> </li> <li> <ol> <li>Down Counter</li> </ol> </li> <li> <ol> <li>Up-Down Counter</li> </ol> </li> <li> <ol> <li>Mod-N Counter</li> </ol> </li> <li> <ol> <li>Binary Counter</li> </ol> </li> <li> <ol> <li>BCD Counter</li> </ol> </li> <li> <ol> <li>Decade Counter</li> </ol> </li> <li> <ol> <li>Ring Counter</li> </ol> </li> <li> <ol> <li>Johnson Counter</li> </ol> </li> <li> <ol> <li>Counter State Diagram</li> </ol> </li> <li> <ol> <li>Counter Overflow</li> </ol> </li> <li> <ol> <li>Register</li> </ol> </li> <li> <ol> <li>Parallel Load Register</li> </ol> </li> <li> <ol> <li>Shift Register</li> </ol> </li> <li>...and 14 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#verilog-hdl-hdl","title":"Verilog HDL (HDL)","text":"<p>Count: 29 concepts (9.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Verilog HDL</li> </ol> </li> <li> <ol> <li>HDL vs Programming</li> </ol> </li> <li> <ol> <li>Module Definition</li> </ol> </li> <li> <ol> <li>Port Declaration</li> </ol> </li> <li> <ol> <li>Input Port</li> </ol> </li> <li> <ol> <li>Output Port</li> </ol> </li> <li> <ol> <li>Inout Port</li> </ol> </li> <li> <ol> <li>Wire Data Type</li> </ol> </li> <li> <ol> <li>Reg Data Type</li> </ol> </li> <li> <ol> <li>Parameter</li> </ol> </li> <li> <ol> <li>Assign Statement</li> </ol> </li> <li> <ol> <li>Continuous Assignment</li> </ol> </li> <li> <ol> <li>Always Block</li> </ol> </li> <li> <ol> <li>Sensitivity List</li> </ol> </li> <li> <ol> <li>Blocking Assignment</li> </ol> </li> <li>...and 14 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#flip-flops-flipflop","title":"Flip-Flops (FLIPFLOP)","text":"<p>Count: 25 concepts (8.3%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>D Flip-Flop</li> </ol> </li> <li> <ol> <li>Edge Triggered</li> </ol> </li> <li> <ol> <li>Positive Edge Triggered</li> </ol> </li> <li> <ol> <li>Negative Edge Triggered</li> </ol> </li> <li> <ol> <li>Master-Slave Flip-Flop</li> </ol> </li> <li> <ol> <li>JK Flip-Flop</li> </ol> </li> <li> <ol> <li>JK Toggle Mode</li> </ol> </li> <li> <ol> <li>T Flip-Flop</li> </ol> </li> <li> <ol> <li>Flip-Flop Symbol</li> </ol> </li> <li> <ol> <li>Preset Input</li> </ol> </li> <li> <ol> <li>Clear Input</li> </ol> </li> <li> <ol> <li>Asynchronous Reset</li> </ol> </li> <li> <ol> <li>Synchronous Reset</li> </ol> </li> <li> <ol> <li>Setup Time</li> </ol> </li> <li> <ol> <li>Hold Time</li> </ol> </li> <li>...and 10 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#boolean-algebra-bool","title":"Boolean Algebra (BOOL)","text":"<p>Count: 21 concepts (7.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Boolean Variable</li> </ol> </li> <li> <ol> <li>Boolean Constant</li> </ol> </li> <li> <ol> <li>Boolean Expression</li> </ol> </li> <li> <ol> <li>Boolean Function</li> </ol> </li> <li> <ol> <li>Truth Table</li> </ol> </li> <li> <ol> <li>AND Operation</li> </ol> </li> <li> <ol> <li>OR Operation</li> </ol> </li> <li> <ol> <li>NOT Operation</li> </ol> </li> <li> <ol> <li>Boolean Algebra</li> </ol> </li> <li> <ol> <li>Identity Law</li> </ol> </li> <li> <ol> <li>Null Law</li> </ol> </li> <li> <ol> <li>Idempotent Law</li> </ol> </li> <li> <ol> <li>Complement Law</li> </ol> </li> <li> <ol> <li>Commutative Law</li> </ol> </li> <li> <ol> <li>Associative Law</li> </ol> </li> <li>...and 6 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#sequential-basics-seq","title":"Sequential Basics (SEQ)","text":"<p>Count: 20 concepts (6.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Memory Element</li> </ol> </li> <li> <ol> <li>State Concept</li> </ol> </li> <li> <ol> <li>Feedback Loop</li> </ol> </li> <li> <ol> <li>Bistable Element</li> </ol> </li> <li> <ol> <li>SR Latch</li> </ol> </li> <li> <ol> <li>SR Latch Truth Table</li> </ol> </li> <li> <ol> <li>Invalid State Problem</li> </ol> </li> <li> <ol> <li>Gated SR Latch</li> </ol> </li> <li> <ol> <li>D Latch</li> </ol> </li> <li> <ol> <li>Level Sensitive</li> </ol> </li> <li> <ol> <li>Transparent Latch</li> </ol> </li> <li> <ol> <li>Latch Timing Problem</li> </ol> </li> <li> <ol> <li>Race Condition</li> </ol> </li> <li> <ol> <li>Clock Signal</li> </ol> </li> <li> <ol> <li>Clock Edge</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#number-systems-numsys","title":"Number Systems (NUMSYS)","text":"<p>Count: 14 concepts (4.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Binary Number System</li> </ol> </li> <li> <ol> <li>Decimal to Binary Conversion</li> </ol> </li> <li> <ol> <li>Binary to Decimal Conversion</li> </ol> </li> <li> <ol> <li>Hexadecimal Numbers</li> </ol> </li> <li> <ol> <li>Hex to Binary Conversion</li> </ol> </li> <li> <ol> <li>Octal Numbers</li> </ol> </li> <li> <ol> <li>Binary Addition</li> </ol> </li> <li> <ol> <li>Binary Subtraction</li> </ol> </li> <li> <ol> <li>Two's Complement</li> </ol> </li> <li> <ol> <li>Signed Binary Numbers</li> </ol> </li> <li> <ol> <li>Overflow Detection</li> </ol> </li> <li> <ol> <li>BCD Encoding</li> </ol> </li> <li> <ol> <li>Gray Code</li> </ol> </li> <li> <ol> <li>Weighted Codes</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recommendations","title":"Recommendations","text":"<ul> <li>\u2705 Excellent balance: Categories are evenly distributed (spread: 7.0%)</li> <li>\u2705 MISC category minimal: Good categorization specificity</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#educational-use-recommendations","title":"Educational Use Recommendations","text":"<ul> <li>Use taxonomy categories for color-coding in graph visualizations</li> <li>Design curriculum modules based on taxonomy groupings</li> <li>Create filtered views for focused learning paths</li> <li>Use categories for assessment organization</li> <li>Enable navigation by topic area in interactive tools</li> </ul> <p>Report generated by learning-graph-reports/taxonomy_distribution.py</p>"},{"location":"lessons/logic-gates/","title":"Logic Gates","text":""},{"location":"prompts/equation-standards/","title":"Equation standards","text":"<p>I just realized that our preferred convention for writing LaTeX equations in this       book is to use the \"\\(\" and \"\\)\" notation, not \"\\(\\(\" and \"\\)\\)\" to signify the start       and end of a LaTeX equations.  Please do two things: 1. - fix any existing              equations in chapter 1 and 2 and 2. Add a note to the CLAUDE.md file that this is       our preferred way of adding equations.  </p> <p>I can see both chapters use \\(...\\) for inline math and Chapter 2 also uses \\(\\(...\\)\\) for   display math. I'll convert these to \\(...\\) for inline and [...] for display math,    then update CLAUDE.md. </p>"},{"location":"prompts/generate-chapter-content/","title":"Generate Chapter Content","text":""},{"location":"prompts/generate-chapter-content/#chapter-1","title":"Chapter 1","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/01-number-systems-binary-arithmetic/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. After you generate the content for the chapter, write the log to logs/ch-01.md Make sure to put an  element that points to the main.html after the #### Diagram and before the  when you generate any diagram."},{"location":"prompts/generate-chapter-content/#chapter-2","title":"Chapter 2","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/02-boolean-algebra-fundamentals/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an  element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-02.md"},{"location":"prompts/generate-chapter-content/#chapter-3","title":"Chapter 3","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/03-logic-gates-digital-signals/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-03.md"},{"location":"prompts/generate-chapter-content/#chapter-4","title":"Chapter 4","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/04-combinational-logic-design/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-04.md <p>05-logic-minimization-kmaps 06-combinational-building-blocks 07-intro-sequential-logic 08-flip-flops-timing 09-fsm-fundamentals 10-fsm-design-applications 11-registers-counters-datapath 12-verilog-hdl-fundamentals 13-verilog-modeling 14-testbenches-simulation 15-fpga-lab-skills</p>"},{"location":"prompts/generate-cover-image/","title":"Generate A Cover Image","text":"<p>You will need an API key for OpenAI and set it as an environment variable. Then run this:</p> <p>../claude-skills/src/image-generation/generate-cover.sh</p>"},{"location":"sims/","title":"Digital Electronics Simulations","text":"<p>These simulations all use a common library of simple electronic logic gates.</p>"},{"location":"sims/#logic-gates","title":"Logic Gates","text":"<p>Logic Gate Library</p>"},{"location":"sims/#flip-flop","title":"Flip Flop","text":"<p>Flip Flop</p>"},{"location":"sims/binary-place-value/","title":"Binary Place Value Visualizer","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/binary-place-value/main.html\" width=\"100%\" height=\"402px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run in Fullscreen</p>"},{"location":"sims/binary-place-value/#description","title":"Description","text":"<p>This interactive MicroSim helps students understand how binary positional notation works. Each bit position has a specific weight (power of 2), and the decimal value is the sum of all active bit weights.</p>"},{"location":"sims/binary-place-value/#key-features","title":"Key Features","text":"<ul> <li>8 toggleable bit buttons (positions 7 through 0)</li> <li>Power of 2 labels showing the weight of each position</li> <li>Dynamic calculation display showing active terms (e.g., \"128 + 32 + 4 = 164\")</li> <li>Large decimal result display</li> <li>Challenge mode for practicing binary-to-decimal conversion</li> </ul>"},{"location":"sims/binary-place-value/#how-to-use","title":"How to Use","text":"<ol> <li>Toggle bits: Click any bit button to toggle it between 0 and 1</li> <li>Observe the calculation: Watch how the calculation line updates to show only active terms</li> <li>Check the result: See the decimal equivalent displayed prominently below</li> <li>Practice with challenges: Click \"Challenge\" to get a target decimal number to create</li> </ol>"},{"location":"sims/binary-place-value/#controls","title":"Controls","text":"Button Action Bit buttons Toggle between 0 (gray) and 1 (blue) Clear All Reset all bits to 0 Random Generate a random 8-bit number Challenge Start challenge mode with a target decimal"},{"location":"sims/binary-place-value/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/binary-place-value/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this activity, students will be able to:</p> <ul> <li>Understand how positional notation assigns weight to each bit position</li> <li>Apply binary-to-decimal conversion by summing active bit weights</li> <li>Explain why the rightmost bit is worth 1 and each position doubles in value</li> <li>Create specific decimal values by selecting the correct combination of bits</li> </ul>"},{"location":"sims/binary-place-value/#blooms-taxonomy-level","title":"Bloom's Taxonomy Level","text":"<p>Understand (L2) - Students explain and demonstrate how binary positional notation works through interactive exploration.</p>"},{"location":"sims/binary-place-value/#target-audience","title":"Target Audience","text":"<ul> <li>High school students learning binary number systems</li> <li>College freshmen/sophomores in digital electronics or computer science</li> <li>Prerequisites: Basic understanding of decimal place value</li> </ul>"},{"location":"sims/binary-place-value/#activities","title":"Activities","text":"<ol> <li> <p>Exploration (5 min): Toggle bits randomly and observe patterns in the decimal output.</p> </li> <li> <p>Guided Discovery (10 min):</p> </li> <li>Start with all bits off</li> <li>Turn on only the rightmost bit (position 0) - note the value is 1</li> <li>Turn on only position 1 - note the value is 2</li> <li> <p>Continue through all positions, noting the doubling pattern</p> </li> <li> <p>Pattern Recognition (5 min):</p> </li> <li>What's the maximum value with all 8 bits on? (255)</li> <li>What's the minimum value with at least one bit on? (1)</li> <li> <p>How many different values can 8 bits represent? (256)</p> </li> <li> <p>Challenge Practice (10 min): Use Challenge mode to practice converting decimal to binary.</p> </li> </ol>"},{"location":"sims/binary-place-value/#assessment","title":"Assessment","text":"<ul> <li>Given a binary number, calculate the decimal equivalent without the simulator</li> <li>Given a decimal number (0-255), determine which bits must be on</li> <li>Explain why 8 bits can represent exactly 256 different values</li> </ul>"},{"location":"sims/binary-place-value/#technical-details","title":"Technical Details","text":""},{"location":"sims/binary-place-value/#implementation","title":"Implementation","text":"<ul> <li>Built with p5.js for responsive canvas rendering</li> <li>Canvas-based controls (no DOM elements) for reliable iframe embedding</li> <li>Width-responsive design adapts to container size</li> </ul>"},{"location":"sims/binary-place-value/#canvas-layout","title":"Canvas Layout","text":"<ul> <li>Top section: Binary string display (e.g., \"Binary: 10100100\u2082\")</li> <li>Middle section: 8 bit toggle buttons with power of 2 labels</li> <li>Bottom section: Calculation breakdown and large decimal result</li> <li>Control area: Clear All, Random, and Challenge buttons</li> </ul>"},{"location":"sims/binary-place-value/#references","title":"References","text":"<ul> <li>Wikipedia: Binary Number - Overview of binary number system</li> <li>Khan Academy: Binary Numbers - Video tutorial on binary</li> <li>p5.js Reference - Documentation for the p5.js library</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/","title":"Decimal to Binary Conversion Stepper","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/decimal-to-binary-stepper/main.html\" width=\"100%\" height=\"542px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run in Fullscreen</p>"},{"location":"sims/decimal-to-binary-stepper/#description","title":"Description","text":"<p>This interactive MicroSim teaches the repeated division algorithm for converting decimal numbers to binary. Students can step through each division operation, observing how remainders accumulate to form the binary representation.</p>"},{"location":"sims/decimal-to-binary-stepper/#the-algorithm","title":"The Algorithm","text":"<p>The repeated division method works as follows:</p> <ol> <li>Divide the decimal number by 2</li> <li>Record the remainder (0 or 1)</li> <li>Use the quotient as the new dividend</li> <li>Repeat until the quotient is 0</li> <li>Read the remainders from bottom to top</li> </ol>"},{"location":"sims/decimal-to-binary-stepper/#key-features","title":"Key Features","text":"<ul> <li>Step-by-step progression: Click \"Step\" to advance one division at a time</li> <li>Visual remainder tracking: Each remainder is highlighted as it's computed</li> <li>Binary result building: Watch the binary number grow from right to left</li> <li>Input flexibility: Enter any decimal value from 0-255</li> <li>Verification: Final result shows decimal equivalent for confirmation</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#how-to-use","title":"How to Use","text":"<ol> <li>Enter a value: Click the input field and type a decimal number (0-255)</li> <li>Press Enter to start with your new value</li> <li>Click Step: Advance through one division at a time</li> <li>Predict: Before each step, try to predict the quotient and remainder</li> <li>Click Complete: Skip to see the full solution</li> <li>Click Reset: Start over with the current value</li> </ol>"},{"location":"sims/decimal-to-binary-stepper/#understanding-the-display","title":"Understanding the Display","text":"Column Meaning Division The current dividend divided by 2 Quotient Result of integer division (next dividend) Remainder The bit value for this position (0 or 1) <p>The arrow on the right reminds you to read remainders from bottom to top to form the binary number.</p>"},{"location":"sims/decimal-to-binary-stepper/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/decimal-to-binary-stepper/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this activity, students will be able to:</p> <ul> <li>Apply the repeated division algorithm to convert any decimal number (0-255) to binary</li> <li>Explain why each remainder represents a specific bit position</li> <li>Predict quotients and remainders before seeing them</li> <li>Verify conversions by checking the binary result</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#blooms-taxonomy-level","title":"Bloom's Taxonomy Level","text":"<p>Apply (L3) - Students execute the algorithm step-by-step, practicing the mechanical process while building understanding.</p>"},{"location":"sims/decimal-to-binary-stepper/#target-audience","title":"Target Audience","text":"<ul> <li>High school students learning binary number systems</li> <li>College freshmen/sophomores in digital electronics or computer science</li> <li>Prerequisites: Understanding of division with remainders, familiarity with binary place values</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min):</li> <li>Convert 10 to binary using the stepper</li> <li> <p>Note the pattern of remainders</p> </li> <li> <p>Guided Practice (10 min):</p> </li> <li>Convert 42 to binary, predicting each step before clicking</li> <li> <p>Verify: \\(42 = 32 + 8 + 2 = 2^5 + 2^3 + 2^1 = 101010_2\\)</p> </li> <li> <p>Pattern Recognition (5 min):</p> </li> <li>Convert powers of 2 (2, 4, 8, 16, 32...)</li> <li> <p>What do you notice about the binary representations?</p> </li> <li> <p>Challenge Problems (10 min):</p> </li> <li>Convert 255 (maximum 8-bit value)</li> <li>Convert 128 (minimum 8-bit value with MSB=1)</li> <li>Convert 170 (alternating pattern)</li> </ol>"},{"location":"sims/decimal-to-binary-stepper/#assessment","title":"Assessment","text":"<ul> <li>Given a decimal number, perform the conversion without the simulator</li> <li>Explain why odd numbers always have a 1 in the rightmost position</li> <li>Describe what determines how many bits are needed for a conversion</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#technical-details","title":"Technical Details","text":""},{"location":"sims/decimal-to-binary-stepper/#implementation","title":"Implementation","text":"<ul> <li>Built with p5.js for responsive canvas rendering</li> <li>Canvas-based controls (no DOM elements) for reliable iframe embedding</li> <li>Width-responsive design adapts to container size</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#canvas-layout","title":"Canvas Layout","text":"<ul> <li>Input section: Decimal value entry with editable field</li> <li>Division table: Step-by-step breakdown showing division, quotient, remainder</li> <li>Binary result: Growing binary number with highlighted digits</li> <li>Control area: Step, Complete, and Reset buttons</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#why-this-algorithm-works","title":"Why This Algorithm Works","text":"<p>Each division by 2 essentially \"peels off\" one bit of the binary representation:</p> <ul> <li>The remainder tells you whether that bit position is 0 or 1</li> <li>The quotient contains the remaining higher-order bits</li> <li>The first remainder is the LSB (rightmost bit)</li> <li>The last remainder is the MSB (leftmost bit)</li> </ul> <p>This is why we read remainders bottom-to-top: we compute the LSB first but need to write the MSB first.</p>"},{"location":"sims/decimal-to-binary-stepper/#references","title":"References","text":"<ul> <li>Wikipedia: Binary Number - Overview of binary number system</li> <li>Khan Academy: Converting decimal to binary - Tutorial on conversion methods</li> <li>p5.js Reference - Documentation for the p5.js library</li> </ul>"},{"location":"sims/flip-flop/","title":"Flip Flop MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/flip-flop/main.html\" width=\"100%\" height=\"450px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Flip Flop MicroSim in Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/flip-flop/#description","title":"Description","text":"<p>This interactive simulation demonstrates the behavior of an SR (Set-Reset) flip-flop, one of the fundamental building blocks of digital memory. The flip-flop is constructed using NAND gates, showing how simple logic gates can be combined to create circuits that \"remember\" their state.</p>"},{"location":"sims/flip-flop/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of NAND gate connections</li> <li>Interactive Set and Reset inputs</li> <li>Real-time display of Q and Q' (not Q) outputs</li> <li>Animation of signal propagation through the circuit</li> </ul>"},{"location":"sims/flip-flop/#how-to-use","title":"How to Use","text":"<ol> <li>Click the Set button to set the flip-flop output Q to 1</li> <li>Click the Reset button to reset the flip-flop output Q to 0</li> <li>Observe how the outputs maintain their state after the input returns to its default value</li> <li>Notice the cross-coupled feedback that enables the memory function</li> </ol>"},{"location":"sims/flip-flop/#challenges","title":"Challenges","text":"<p>Explaining electronic components like flip-flops through animation can be challenging due to several reasons:</p> <ol> <li> <p>Abstract Concepts: Flip-flops are digital logic circuits used in electronics and computing. They store and manipulate binary data (0s and 1s). The concepts involved in how they work\u2014like logic gates, binary states, clock signals, and data storage\u2014are abstract and not directly observable, making them hard to represent visually.</p> </li> <li> <p>Complex Functionality: Flip-flops have different types (like SR, JK, D, and T flip-flops) and each type has its unique mode of operation. This complexity can be difficult to condense into a simplified animation without losing essential details.</p> </li> <li> <p>Timing and Synchronization: Flip-flops often operate based on clock signals, and their behavior is dependent on the timing of these signals. Accurately depicting timing and synchronization in an animation can be challenging, as it requires precise representation of these temporal aspects.</p> </li> <li> <p>Scale and Interaction with Other Components: Flip-flops are usually part of larger electronic systems. Showing how they interact with other components in a system (like processors or memory units) within the limited scope of an animation can be difficult, as it might require a broader context that is hard to visualize succinctly.</p> </li> <li> <p>Viewer Background Knowledge: Understanding the operation of flip-flops often requires a background in electronics or computer science. Animations need to be designed considering the viewer's prior knowledge, which can vary widely, making it hard to create a one-size-fits-all explanation.</p> </li> <li> <p>Visual Simplicity vs. Technical Accuracy: Striking the right balance between simplicity for easier understanding and technical accuracy for correctness is a major challenge. Over-simplification can lead to misconceptions, while too much detail can overwhelm the viewer.</p> </li> </ol> <p>To effectively use animation for explaining flip-flops, it's essential to focus on clear, step-by-step visual representations, using metaphor or analogy where possible, and providing sufficient explanatory context to make the abstract concepts more relatable.</p>"},{"location":"sims/flip-flop/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/flip-flop/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Explain how NAND gates can be combined to create a flip-flop circuit</li> <li>Describe the difference between Set and Reset operations</li> <li>Demonstrate understanding of how flip-flops store binary data</li> <li>Identify the forbidden state in an SR flip-flop and explain why it should be avoided</li> </ul>"},{"location":"sims/flip-flop/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics students</li> <li>College students in introductory digital electronics courses</li> <li>Prerequisites: Basic understanding of logic gates (AND, OR, NOT, NAND)</li> </ul>"},{"location":"sims/flip-flop/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Allow students to freely interact with the simulation, observing how Set and Reset inputs affect the outputs.</p> </li> <li> <p>Guided Investigation: Have students create a truth table for the SR flip-flop by testing all input combinations and recording the outputs.</p> </li> <li> <p>Extension Activity: Discuss how multiple flip-flops can be connected to create registers and counters, leading into the shift register simulation.</p> </li> </ol>"},{"location":"sims/flip-flop/#assessment","title":"Assessment","text":"<ul> <li>What happens when both Set and Reset are activated simultaneously?</li> <li>Why is the flip-flop called a \"memory\" element?</li> <li>Draw the circuit diagram of an SR flip-flop using NAND gates.</li> </ul>"},{"location":"sims/flip-flop/#references","title":"References","text":"<ul> <li>Falstad Flip-Flop Simulator - Interactive circuit simulator with flip-flop examples</li> <li>Wikipedia: Flip-flop (electronics) - Comprehensive overview of flip-flop types and applications</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> </ul>"},{"location":"sims/graph-viewer/","title":"Learning Graph Viewer","text":"<p>This interactive viewer allows you to explore the learning graph for the Digital Electronics course.</p>"},{"location":"sims/graph-viewer/#features","title":"Features","text":"<ul> <li>Search: Type in the search box to find specific concepts</li> <li>Category Filtering: Use checkboxes to show/hide concept categories</li> <li>Interactive Navigation: Click and drag to explore, scroll to zoom</li> <li>Statistics: View real-time counts of visible nodes and edges</li> </ul>"},{"location":"sims/graph-viewer/#using-the-viewer","title":"Using the Viewer","text":"<ol> <li> <p>Search for Concepts: Start typing in the search box to find concepts. Click on a result to focus on that node.</p> </li> <li> <p>Filter by Category: Use the category checkboxes in the sidebar to show or hide groups of related concepts. Use \"Check All\" or \"Uncheck All\" for bulk operations.</p> </li> <li> <p>Navigate the Graph:</p> </li> <li>Drag to pan around the graph</li> <li>Scroll to zoom in and out</li> <li> <p>Click on a node to select it and highlight its connections</p> </li> <li> <p>View Statistics: The sidebar shows counts of visible nodes, edges, and foundational concepts.</p> </li> </ol>"},{"location":"sims/graph-viewer/#graph-structure","title":"Graph Structure","text":"<ul> <li>Foundational Concepts (left side): Prerequisites with no dependencies</li> <li>Advanced Concepts (right side): Topics that build on multiple prerequisites</li> <li>Edges: Arrows point from a concept to its prerequisites</li> </ul>"},{"location":"sims/graph-viewer/#launch-the-viewer","title":"Launch the Viewer","text":"<p>Open Learning Graph Viewer</p>"},{"location":"sims/logic-gates/","title":"Logic Gates MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/logic-gates/main.html\" width=\"100%\" height=\"450px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Logic Gates MicroSim in Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/logic-gates/#description","title":"Description","text":"<p>This interactive simulation provides a visual library of digital logic gates, demonstrating how each gate processes binary inputs to produce outputs. The simulation uses p5.js to render high-quality gate symbols following standard IEEE conventions.</p>"},{"location":"sims/logic-gates/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of all common logic gate types</li> <li>Interactive inputs to test gate behavior</li> <li>Real-time output display</li> <li>Standard IEEE gate symbols</li> <li>Reusable gate drawing library for building complex circuits</li> </ul>"},{"location":"sims/logic-gates/#how-to-use","title":"How to Use","text":"<ol> <li>Click on input nodes to toggle between 0 (LOW) and 1 (HIGH) states</li> <li>Observe how the output changes based on the gate's logic function</li> <li>Experiment with different input combinations to understand each gate's truth table</li> <li>Use the gate library as a foundation for building more complex circuits</li> </ol>"},{"location":"sims/logic-gates/#logic-gate-types","title":"Logic Gate Types","text":"Gate Symbol Function AND Flat back, curved front Output is 1 only when ALL inputs are 1 OR Curved back, pointed front Output is 1 when ANY input is 1 NOT Triangle with bubble Inverts the input NAND AND with bubble Inverted AND output NOR OR with bubble Inverted OR output XOR OR with extra curved line Output is 1 when inputs DIFFER XNOR XOR with bubble Output is 1 when inputs are SAME"},{"location":"sims/logic-gates/#goals","title":"Goals","text":"<p>Our goal in this simulation is to:</p> <ol> <li>Use generative AI to build a library of high-quality logical gate drawings using the p5.js library.</li> <li>Use this library to build a logic simulator that can simulate simple digital logic gates.</li> </ol> <p>Drawing Gates - Tutorial on creating gate graphics</p>"},{"location":"sims/logic-gates/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/logic-gates/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Identify and draw the standard symbols for each logic gate type</li> <li>Create truth tables for each logic gate</li> <li>Predict the output of a logic gate given any combination of inputs</li> <li>Explain the relationship between basic gates (AND, OR, NOT) and derived gates (NAND, NOR, XOR, XNOR)</li> </ul>"},{"location":"sims/logic-gates/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics and computer science students</li> <li>College students in introductory digital logic courses</li> <li>Prerequisites: Understanding of binary numbers (0 and 1)</li> </ul>"},{"location":"sims/logic-gates/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Interact with each gate type, testing all possible input combinations and recording results.</p> </li> <li> <p>Guided Investigation: Complete the truth table worksheet for each gate, verifying answers with the simulation.</p> </li> <li> <p>Extension Activity: Design a simple circuit using multiple gates (e.g., a half-adder) and predict its behavior before testing.</p> </li> </ol>"},{"location":"sims/logic-gates/#assessment","title":"Assessment","text":"<ul> <li>Draw the symbol for each of the seven logic gates from memory</li> <li>Given a truth table, identify which logic gate it represents</li> <li>Explain why NAND and NOR gates are called \"universal gates\"</li> </ul>"},{"location":"sims/logic-gates/#references","title":"References","text":"<ul> <li>Wikipedia: Logic Gate - Overview of logic gate types and applications</li> <li>All About Circuits: Logic Gates - Comprehensive tutorial on digital logic gates</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> <li>IEEE Std 91-1984 - Standard for logic gate symbols</li> </ul>"},{"location":"sims/logic-gates/01-drawing-gates/","title":"Drawing Gates","text":"<p>We will be using the Processing version 5 JavaScript library for doing web-based drawing.  This is called the p5.js library.  Because Processing has been around since 2000 there is able code that generative AI has been trained on.  Getting the correct results is pretty easy. </p> <p>We need a library for drawing gates in our simulators. We use the following drawing conventions:</p> <p>The standard function parameters are:</p> <ol> <li>X position on the canvas</li> <li>Y position on the canvas</li> <li>Width of the gate (not including connecting wires)</li> <li>Height of the gate</li> <li>Length of the connecting wires</li> </ol> <p>The drawing must be made so that the fill color, stroke color, and stroke can all be inherited from the drawing context.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#drawing-basic","title":"Drawing basic","text":""},{"location":"sims/logic-gates/01-drawing-gates/#buffer","title":"Buffer","text":"<p>We will start with a simple buffer logic gate that does not change the input signal.  We use a triangle shape to draw a buffer.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-buffer-prompt","title":"Sample Buffer Prompt","text":"<pre><code>Create a p5.js function called drawBuffer(x,y,w,h,l) for a logic buffer symbol.  The function should take parameters x, y, width, height and wire length.\nPlace the logic gate with the upper left corner of the triangle at the point x,y with a width and height from the parameters.  Add wire length as input and output wires.\n\nCreate a test of this function on a 200x300 canvas drawing three examples of the drawBuffer using different sizes.\n\nDraw the tests on a lightgray background.\n</code></pre> <p>ChatGPT Dialog using the p5.js Visual Art Composer</p>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-buffer-response","title":"Sample Buffer Response","text":"<pre><code>// Draw Buffer Function\nfunction setup() {\n  createCanvas(200, 300);\n  background('lightgray');\n  drawBuffer(50, 50, 30, 40, 20);\n  drawBuffer(100, 120, 40, 60, 30);\n  drawBuffer(30, 200, 50, 70, 40);\n}\n\nfunction drawBuffer(x, y, w, h, l) {\n\n  // Draw input wire\n  line(x - l, y + h / 2, x, y + h / 2);\n\n  // Draw the buffer (triangle)\n  triangle(x, y, x, y + h, x + w, y + h / 2);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n}\n</code></pre> <p>Edit this MicroSim on p5.js Editor</p>"},{"location":"sims/logic-gates/01-drawing-gates/#drawing-an-inverter","title":"Drawing an Inverter","text":""},{"location":"sims/logic-gates/01-drawing-gates/#inverter-prompt","title":"Inverter Prompt","text":"<pre><code>That was perfect!\nNow create a new function called drawInverter.\nIt will have exactly the same input parameters,\nbut the drawing will have a small circle at the\nright tip of the triangle.\n\nDraw the tests on a lightgray background.\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#inverter-response","title":"Inverter Response","text":"<pre><code>// Draw Inverter\n// Test the drawInverter function with different sizes\n\nfunction setup() {\n  createCanvas(200, 300);\n  background(240); // light gray background\n  drawInverter(50, 50, 30, 40, 20);\n  drawInverter(100, 120, 40, 60, 30);\n  drawInverter(30, 200, 50, 70, 40);\n}\n\nfunction drawInverter(x, y, w, h, l) {\n  // Draw input wire\n  line(x - l, y + h / 2, x, y + h / 2);\n\n  // Draw the buffer (triangle)\n  triangle(x, y, x, y + h, x + w, y + h / 2);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n\n  // Draw small circle at the right tip of the triangle\n  circle(x + w, y + h / 2, w / 5);\n}\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#the-and-gate","title":"The AND Gate","text":""},{"location":"sims/logic-gates/01-drawing-gates/#sample-and-prompt","title":"Sample AND Prompt","text":"<pre><code>That was also perfect!\nNow create a new function called drawAND that will draw\na AND logic gate.\nThis will be similar to the previous functions,\nbut instead of drawing a triangle you will need\nto make the right side of the shape a circle.\nPlace a series of points on the canvas using the vertex(x,y) function that makes the correct shape.\nUse beginShape() and endShape() around the points.\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-and-response","title":"Sample AND Response","text":"<pre><code>// Draw And Logic Gate\n// Test the drawAND function with different sizes\n\nfunction setup() {\n  createCanvas(200, 300);\n  background(200); // light gray background\n  drawAND(50, 20, 40, 40, 20);\n  drawAND(100, 70, 40, 60, 30);\n  drawAND(80, 150, 70, 50, 20);\n}\n\nfunction drawAND(x, y, w, h, l) {\n  // Draw input wires\n  line(x - l, y + h / 3, x, y + h / 3);\n  line(x - l, y + 2 * h / 3, x, y + 2 * h / 3);\n\n  // Draw the AND gate shape\n  beginShape();\n  vertex(x, y); // top left corner\n  vertex(x + w * 0.6, y); // top right corner (start of semicircle)\n  // Create semicircle\n  for (let angle = -HALF_PI; angle &lt;= HALF_PI; angle += 0.01) {\n    let sx = x + w * 0.6 + cos(angle) * w * 0.4;\n    let sy = y + h / 2 + sin(angle) * h / 2;\n    vertex(sx, sy);\n  }\n  vertex(x + w * 0.6, y + h); // bottom right corner (end of semicircle)\n  vertex(x, y + h); // bottom left corner\n  endShape(CLOSE);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n}\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#failed-attempts-at-or-gate","title":"Failed Attempts at OR Gate","text":"<p>This is where GPT-4 falls apart.  Despite my best attempts, I could not get GPT-4 to correctly draw the complex curves needed for a logical OR gate.  You can see the results in the transcript.</p> <p>I had to resort to manually drawing the curves, which was a slow-painful process and took several hours to make it robust enough that it could work with a variety of sizes.</p> <p>I think this really demonstrates the limits of what GPT-4 is capable of, and what it can't do.</p> <p></p> <p>Edit the Logical OR gate MicroSim</p> <p>One hint that GPT-4 did give was to use the map function to have the x-coordinates move linearly and only use the sin() functions on the y-coordinates.  This worked reasonably well and the curves do match up pretty closely with the official SVG drawing of the OR gate. If you want a precise mapping you can also write a program that converts the SVG points to a set of (x,y) points.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#nor-symbol-prompt","title":"NOR Symbol Prompt","text":"<p>Once we have a good OR gate, we can ask GPT to just use that to create a NOR gate.  All it has to do is add a circle on the output.</p> <p>Here is the code it generated:</p> <pre><code>function drawNOR(x, y, w, h, l) {\n  // Draw the OR part\n  drawOR(x, y, w, h, l);\n\n  // Draw the NOT circle at the output\n  let outputX = x + w + l * 0.5;\n  let outputY = y + h / 2;\n  let circleRadius = l * 0.3;\n  ellipse(outputX, outputY, circleRadius, circleRadius);\n}\n</code></pre> <p>So it is clear that GPT-4 has been trained on how to add a small bit of drawing to an existing function.</p> <p>Note that it tends to use ellipse() rather than circle(). I don't know exactly why it does this.  Perhaps it believes that ellipse is more general and easier to customize.  I think that circle with only three parameters is a little easier to read.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#xor-gate","title":"XOR Gate","text":""},{"location":"sims/logic-gates/01-drawing-gates/#xnor-prompt","title":"XNOR Prompt","text":"<pre><code>Now can you please repeat the same process \nbut this time generate the code for an exclusive OR.  \nPlease call the new function drawXOR and make the \nparameters exactly the same.\n</code></pre> <p>It got the result pretty close.  The only real cleanup is to move the new arc to the end and add a noFill() for the new extra curve. This is an easy to change.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#xnor","title":"XNOR","text":"<p>Our last function is XNOR, which just adds a circle to the XOR symbol.</p> <p>Edit the XNOR MicroSim</p> <p>Note that we did not automatically fill the circle with black.  We decided to inherit the fill from the drawing context.  Forcing the circle to fill with black is a valid option and might make drawings a little easier to read.  This could also be an additional parameter to these functions.</p>"},{"location":"sims/shift-register/","title":"Shift Register MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/shift-register/main.html\" width=\"100%\" height=\"400px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Shift Register MicroSim in Fullscreen</p>"},{"location":"sims/shift-register/#description","title":"Description","text":"<p>This interactive simulation demonstrates the operation of a 74HC594 shift register, a common integrated circuit used to convert serial data into parallel output. The simulation includes a logic analyzer display that shows the timing relationships between the DATA IN, CLOCK, and LATCH signals.</p>"},{"location":"sims/shift-register/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of the 74HC594 shift register chip</li> <li>Real-time logic analyzer showing signal waveforms</li> <li>Interactive DATA IN toggle (ON/OFF)</li> <li>CLOCK button to shift data into the register</li> <li>LATCH button to transfer shift register contents to output</li> <li>Reset button to clear all states</li> <li>8-bit output display with LED indicators</li> </ul>"},{"location":"sims/shift-register/#how-to-use","title":"How to Use","text":"<ol> <li>Set DATA IN to ON or OFF using the radio buttons</li> <li>Click Next Clock to shift the current DATA IN value into the register</li> <li>Repeat steps 1-2 to load a complete 8-bit pattern</li> <li>Click Latch to transfer the shift register contents to the output pins</li> <li>Observe the LED indicators showing the parallel output</li> <li>Watch the Logic Analyzer to see the timing of each signal</li> <li>Click Reset to clear the register and start over</li> </ol>"},{"location":"sims/shift-register/#understanding-the-logic-analyzer","title":"Understanding the Logic Analyzer","text":"<p>The logic analyzer display shows three signals:</p> <ul> <li>DATA IN (blue): The current input data level</li> <li>CLOCK (red): Pulses each time you click \"Next Clock\"</li> <li>LATCH (green): Pulses when you click \"Latch\"</li> </ul> <p>Each rising edge of the CLOCK signal shifts the DATA IN value into the first position of the shift register, pushing all existing bits one position to the right.</p>"},{"location":"sims/shift-register/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/shift-register/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Explain the difference between serial and parallel data transfer</li> <li>Describe how a shift register converts serial input to parallel output</li> <li>Identify the function of CLOCK and LATCH signals in a shift register</li> <li>Demonstrate the sequence of operations needed to load an 8-bit pattern</li> </ul>"},{"location":"sims/shift-register/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics students</li> <li>College students in digital electronics courses</li> <li>Prerequisites: Understanding of flip-flops and binary numbers</li> </ul>"},{"location":"sims/shift-register/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Load the binary pattern for the letter \"A\" (01000001) into the shift register and display it on the outputs.</p> </li> <li> <p>Guided Investigation: Document the timing sequence by recording what happens at each clock pulse as you shift in a specific bit pattern.</p> </li> <li> <p>Extension Activity: Calculate how many clock pulses are needed to shift data through multiple cascaded shift registers. Discuss applications like LED displays or motor control.</p> </li> </ol>"},{"location":"sims/shift-register/#assessment","title":"Assessment","text":"<ul> <li>What is the difference between the shift register and the output register in the 74HC594?</li> <li>Why is a separate LATCH signal needed?</li> <li>How many clock pulses are required to load all 8 bits?</li> <li>Describe a real-world application where shift registers are used.</li> </ul>"},{"location":"sims/shift-register/#references","title":"References","text":"<ul> <li>Wikipedia: Shift Register - Overview of shift register types and applications</li> <li>Texas Instruments 74HC594 Datasheet - Technical specifications for the 74HC594</li> <li>SparkFun Shift Register Tutorial - Practical guide to using shift registers with microcontrollers</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> </ul>"},{"location":"sims/template/","title":"MicroSim Template","text":"![Image Name](./image.png){ width=\"400\" }    Figure caption. <p>Run the MicroSim Edit the MicroSim</p>"},{"location":"sims/template/#about-this-microsim","title":"About this MicroSim","text":"<p>This MicroSim teaches us how to specify the drawing of a static filled circle.</p>"},{"location":"sims/template/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a single file p5.js sketch.\nDraw a green circle on a 600x400 canvas with a radius of 200.\n</code></pre>"},{"location":"sims/template/#sample-response","title":"Sample Response","text":"<pre><code>let canvasHeight = 400;\nlet aspectRatio = 1.91; // Open Graph standard\nlet canvasWidth = canvasHeight * aspectRatio;\nlet radius = 200;\nfunction setup() {\nconst canvas = createCanvas(canvasWidth, canvasHeight);\n  canvas.parent('canvas-container');\n  fill(245);\n  rect(0,0, canvasWidth, canvasHeight);\n  fill('green');\n  circle(canvasWidth/2, canvasHeight/2, radius);\n}\n</code></pre>"},{"location":"sims/template/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/template/#grade-level-subject-and-topic","title":"Grade Level, Subject and Topic","text":"<p>9th grade geometry. Circle and radius.</p>"},{"location":"sims/template/#activities","title":"Activities","text":""},{"location":"sims/template/#fill-color","title":"Fill Color","text":"<p>Change the color in the prompt.  You can specify any one of the 140 named colors.</p>"},{"location":"sims/template/#border-weight","title":"Border Weight","text":"<p>Change the prompt to include a black border of width 10.</p>"},{"location":"sims/template/#border-color","title":"Border Color","text":"<p>Change the prompt to make the border purple.</p>"},{"location":"sims/template/#change-the-radius","title":"Change the Radius","text":"<p>Change the prompt to make the circle smaller or larger by changing the radius from 10 to 200.</p>"},{"location":"sims/template/#change-the-location","title":"Change the Location","text":"<p>Change the prompt to move the circle to the left or right.</p>"},{"location":"sims/template/TODO/","title":"TODO: Fix MicroSim Metadata","text":"<p>MicroSim: template Repository: digital-electronics Generated: 2026-01-23</p>"},{"location":"sims/template/TODO/#issues-found","title":"Issues Found","text":"<p>The following issues prevented automatic metadata generation:</p> <ol> <li>No description found</li> </ol>"},{"location":"sims/template/TODO/#required-actions","title":"Required Actions","text":""},{"location":"sims/template/TODO/#high-priority","title":"High Priority","text":"<ul> <li>[ ] Create or fix <code>main.html</code> - the main simulation file</li> <li>[ ] Add a meaningful title that describes the simulation</li> <li>[ ] Write a clear description (2-3 sentences) explaining what the MicroSim does</li> </ul>"},{"location":"sims/template/TODO/#medium-priority","title":"Medium Priority","text":"<ul> <li>[ ] Create <code>index.md</code> with proper YAML frontmatter:   <pre><code>---\ntitle: \"Your Title Here\"\ndescription: \"Brief description for SEO\"\n---\n</code></pre></li> <li>[ ] Add an iframe to display the simulation</li> <li>[ ] Add a \"Run Fullscreen\" button</li> </ul>"},{"location":"sims/template/TODO/#low-priority","title":"Low Priority","text":"<ul> <li>[ ] Add a lesson plan section</li> <li>[ ] Add references section</li> <li>[ ] Create a screenshot for social media preview</li> </ul>"},{"location":"sims/template/TODO/#detected-information","title":"Detected Information","text":"<ul> <li>Framework: p5.js</li> <li>Detected subjects: Mathematics, Computer Science, Chemistry, Engineering</li> <li>Visualization types: graph, interactive-demo, map</li> <li>Has main.html: Yes</li> <li>Has index.md: Yes</li> </ul>"},{"location":"sims/template/TODO/#after-fixing","title":"After Fixing","text":"<p>Once you've addressed the issues above, run the metadata standardization:</p> <pre><code># Use Claude Code's microsim-utils skill to standardize\n# Or manually create metadata.json following the schema\n</code></pre> <p>Delete this TODO.md file after creating proper metadata.json.</p>"}]}
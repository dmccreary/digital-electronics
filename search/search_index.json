{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Digital Electronics","text":""},{"location":"#digital-electronics","title":"Digital Electronics","text":"<p>Welcome to the digital electronics course website!</p> <p>Our goal is to provide resources for teaching some of the most difficult concepts in an introduction to digital electronics course by using generative AI to create lesson plans and simulations.</p> <p>To use this site you can use the search function in the upper right corner or use the navigation system on the left side of the pages.</p> <p>Please let me know if you have any comments or suggestions for improvements.</p> <p>Have fun!</p> <p>Dan McCreary LinkedIn</p>"},{"location":"about/","title":"About the Digital Electronics Course","text":"<p>What are the most difficult concepts for an undergraduate college student to understand in a digital electronics course?</p> <p>In an undergraduate digital electronics course, several concepts are often challenging for students to grasp due to their abstract nature or the level of detail involved. Some of the most difficult concepts typically include:</p> <ol> <li> <p>Boolean Algebra and Logic Gates: Understanding how Boolean algebra relates to the operation of basic logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR) and their use in creating complex circuits.</p> </li> <li> <p>Karnaugh Maps (K-Maps): These are used for simplifying Boolean expressions and can be quite challenging due to the need for spatial and logical reasoning.</p> </li> <li> <p>Flip-Flops and Latches: The concepts of storage elements like flip-flops and latches, which are fundamental to memory and sequential circuits, can be abstract and require a solid understanding of timing and control signals.</p> </li> <li> <p>Finite State Machines (FSMs): Designing and understanding FSMs, which are models of computation used in sequential logic, can be complex, especially when dealing with larger systems.</p> </li> <li> <p>Timing Analysis: Understanding the timing characteristics of digital circuits, such as setup and hold times, clock skew, and propagation delay, is crucial but can be difficult due to the abstract nature of these concepts.</p> </li> <li> <p>Digital-to-Analog (DAC) and Analog-to-Digital Converters (ADC): Understanding how digital systems interface with the analog world through DACs and ADCs requires a good grasp of both digital and analog principles.</p> </li> <li> <p>Signal Integrity and Noise Issues: Learning about how noise affects digital signals and the techniques used to mitigate these effects can be challenging, especially in high-speed digital design.</p> </li> <li> <p>Microprocessor Architecture and Assembly Language Programming: The intricacies of microprocessor architecture and the details of assembly language programming are often complex for students new to these concepts.</p> </li> <li> <p>Memory Architecture: Understanding different types of memory (RAM, ROM, Cache, etc.) and their architecture can be intricate due to the details involved in how they store and retrieve data.</p> </li> <li> <p>VHDL/Verilog for FPGA Design: Learning hardware description languages like VHDL or Verilog for FPGA (Field-Programmable Gate Array) design can be daunting due to the need to think in terms of hardware rather than software.</p> </li> </ol> <p>These topics require a solid foundation in basic electronics and mathematics, along with the ability to think abstractly and logically. The difficulty often lies in the transition from theoretical knowledge to practical application and understanding how these concepts interconnect to form complex digital systems.</p>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"Digital Electronics","text":"<p>This is a sophomore-level digital electronics course that covers the ABET-aligned EE curricula for digital electronics. This course feeds upper-division computer architecture, VLSI, and embedded systems courses.</p> <p>Here are the topics covered roughly in the order they are taught.</p>"},{"location":"course-description/#intended-audience","title":"Intended Audience","text":"<p>College students that plan on becoming majors in electrical engineering or computer-related fields.</p>"},{"location":"course-description/#prerequisites","title":"Prerequisites","text":"<p>Calculus 1 is required for several of the advanced topics in this course.</p>"},{"location":"course-description/#1-foundations-boolean-algebra-binary-logic","title":"1. Foundations: Boolean Algebra &amp; Binary Logic","text":""},{"location":"course-description/#core-concepts","title":"Core concepts","text":"<ul> <li>Binary number system (review, but formalized)</li> <li>Boolean variables, constants (0, 1)</li> <li>Boolean operators: AND, OR, NOT</li> <li>Truth tables as formal specifications</li> <li>Boolean expressions vs Boolean functions</li> </ul>"},{"location":"course-description/#boolean-algebra-laws-memorized-applied","title":"Boolean algebra laws (memorized + applied)","text":"<ul> <li>Identity, Null, Idempotent</li> <li>Complement</li> <li>Commutative, Associative, Distributive</li> <li>Absorption</li> <li>De Morgan\u2019s Theorems (very important)</li> </ul>"},{"location":"course-description/#why-this-matters","title":"Why this matters","text":"<p>This is where logical reasoning becomes mathematical, and students learn that:</p> <p>Digital circuits are physical realizations of Boolean functions.</p>"},{"location":"course-description/#2-logic-gates-gate-level-modeling","title":"2. Logic Gates &amp; Gate-Level Modeling","text":""},{"location":"course-description/#primitive-gates","title":"Primitive gates","text":"<ul> <li>NOT, AND, OR</li> <li>NAND, NOR (emphasized as functionally complete)</li> <li>XOR, XNOR</li> </ul>"},{"location":"course-description/#gate-properties","title":"Gate properties","text":"<ul> <li>Functional completeness</li> <li>Gate delay (introductory timing intuition)</li> <li>Fan-in / fan-out (qualitative)</li> <li>Symbol conventions and schematics</li> </ul>"},{"location":"course-description/#gate-level-abstraction","title":"Gate-level abstraction","text":"<ul> <li>Mapping Boolean expressions \u2192 gates</li> <li>Understanding that NAND/NOR dominate real hardware</li> </ul>"},{"location":"course-description/#3-combinational-logic-design","title":"3. Combinational Logic Design","text":""},{"location":"course-description/#canonical-representations","title":"Canonical representations","text":"<ul> <li>Sum-of-Products (SOP)</li> <li>Product-of-Sums (POS)</li> <li>Canonical vs minimal forms</li> </ul>"},{"location":"course-description/#standard-combinational-blocks","title":"Standard combinational blocks","text":"<p>Students design and analyze:</p> <ul> <li>Multiplexers (MUX)</li> <li>Demultiplexers</li> <li>Encoders / Decoders</li> <li>Priority encoders</li> <li>Comparators</li> <li> <p>Adders</p> </li> <li> <p>Half adder</p> </li> <li>Full adder</li> <li>Ripple-carry adder (conceptual)</li> </ul>"},{"location":"course-description/#design-workflow","title":"Design workflow","text":"<ol> <li>Problem statement</li> <li>Truth table</li> <li>Boolean expression</li> <li>Simplification</li> <li>Gate-level implementation</li> <li>(Later) Verilog model</li> </ol>"},{"location":"course-description/#4-logic-simplification-optimization","title":"4. Logic Simplification &amp; Optimization","text":""},{"location":"course-description/#algebraic-simplification","title":"Algebraic simplification","text":"<ul> <li>Manual application of Boolean laws</li> <li>Factoring and common-term extraction</li> </ul>"},{"location":"course-description/#karnaugh-maps-k-maps","title":"Karnaugh Maps (K-maps)","text":"<ul> <li>2-, 3-, and 4-variable K-maps</li> <li>Grouping rules</li> <li>Don\u2019t-care conditions</li> <li>Minimal SOP / POS solutions</li> </ul>"},{"location":"course-description/#design-tradeoffs","title":"Design tradeoffs","text":"<ul> <li>Gate count vs clarity</li> <li>Depth vs width</li> <li>Cost, power, and delay (introductory, not transistor-level)</li> </ul>"},{"location":"course-description/#5-introduction-to-sequential-logic","title":"5. Introduction to Sequential Logic","text":"<p>This is the big conceptual leap of the course.</p>"},{"location":"course-description/#memory-state","title":"Memory &amp; state","text":"<ul> <li>Difference between combinational and sequential logic</li> <li>Concept of state</li> <li>Clocked vs unclocked systems</li> </ul>"},{"location":"course-description/#latches","title":"Latches","text":"<ul> <li>SR latch</li> <li>D latch</li> <li>Level-sensitive behavior</li> <li>Why latches are dangerous in large designs</li> </ul>"},{"location":"course-description/#6-flip-flops-clocked-storage","title":"6. Flip-Flops &amp; Clocked Storage","text":""},{"location":"course-description/#flip-flop-types","title":"Flip-flop types","text":"<ul> <li>D flip-flop (primary focus)</li> <li>JK, T flip-flops (often covered conceptually)</li> </ul>"},{"location":"course-description/#timing-concepts-qualitative","title":"Timing concepts (qualitative)","text":"<ul> <li>Clock edge</li> <li>Setup time</li> <li>Hold time</li> <li>Clock-to-Q delay</li> <li>Metastability (introduced, not deeply analyzed)</li> </ul>"},{"location":"course-description/#7-synchronous-sequential-logic-design","title":"7. Synchronous Sequential Logic Design","text":"<p>This is the heart of EE 2301.</p>"},{"location":"course-description/#finite-state-machines-fsms","title":"Finite State Machines (FSMs)","text":"<ul> <li>Moore machines</li> <li>Mealy machines</li> <li>State diagrams</li> <li>State tables</li> <li>State encoding (binary, one-hot \u2014 at least conceptually)</li> </ul>"},{"location":"course-description/#fsm-design-process","title":"FSM design process","text":"<ol> <li>Word problem \u2192 states</li> <li>State diagram</li> <li>State table</li> <li>Next-state equations</li> <li>Output equations</li> <li>Implementation with flip-flops + combinational logic</li> </ol>"},{"location":"course-description/#common-examples","title":"Common examples","text":"<ul> <li>Counters (mod-N, up/down)</li> <li>Sequence detectors</li> <li>Controllers (traffic light, vending machine-style problems)</li> </ul>"},{"location":"course-description/#8-registers-counters-and-datapath-elements","title":"8. Registers, Counters, and Datapath Elements","text":""},{"location":"course-description/#registers","title":"Registers","text":"<ul> <li>Parallel registers</li> <li>Enable signals</li> <li>Load vs hold behavior</li> </ul>"},{"location":"course-description/#counters","title":"Counters","text":"<ul> <li>Synchronous counters</li> <li>Reset (synchronous vs asynchronous)</li> <li>Modulus control</li> </ul>"},{"location":"course-description/#datapath-intuition","title":"Datapath intuition","text":"<ul> <li>Registers + combinational logic + control</li> <li>Early exposure to CPU-style thinking</li> </ul>"},{"location":"course-description/#9-verilog-hdl-modeling","title":"9. Verilog HDL Modeling","text":"<p>This is where software-thinking students shine.</p>"},{"location":"course-description/#verilog-basics","title":"Verilog basics","text":"<ul> <li>Modules</li> <li>Ports (input/output)</li> <li>Wire vs reg</li> <li>Continuous assignments (<code>assign</code>)</li> <li>Procedural blocks (<code>always</code>)</li> </ul>"},{"location":"course-description/#modeling-styles","title":"Modeling styles","text":"<ul> <li>Combinational logic (<code>always @(*)</code>)</li> <li>Sequential logic (<code>always @(posedge clk)</code>)</li> <li>Structural vs behavioral modeling</li> </ul>"},{"location":"course-description/#testbenches","title":"Testbenches","text":"<ul> <li>Stimulus generation</li> <li>Observing outputs</li> <li>Simulation as verification</li> </ul>"},{"location":"course-description/#key-learning-outcome","title":"Key learning outcome","text":"<p>Students learn that:</p> <p>HDLs describe hardware behavior, not software execution.</p>"},{"location":"course-description/#10-design-simulation-and-verification-flow","title":"10. Design, Simulation, and Verification Flow","text":""},{"location":"course-description/#typical-toolchain","title":"Typical toolchain","text":"<ul> <li>Verilog editor</li> <li>Simulator (ModelSim / Questa / similar)</li> <li>FPGA or logic lab hardware</li> </ul>"},{"location":"course-description/#concepts-emphasized","title":"Concepts emphasized","text":"<ul> <li>Separation of design and verification</li> <li>Debugging with waveforms</li> <li>Functional correctness before optimization</li> </ul>"},{"location":"course-description/#11-integral-laboratory-component","title":"11. Integral Laboratory Component","text":"<p>The lab is not optional or cosmetic.</p>"},{"location":"course-description/#labs","title":"Labs","text":"<ul> <li>Breadboarding simple gate circuits (early)</li> <li>Using logic analyzers or FPGA boards</li> <li>Implementing combinational logic modules</li> <li>FSM implementations in Verilog</li> <li>Testing with switches, LEDs, clocks</li> </ul>"},{"location":"course-description/#skills-developed","title":"Skills developed","text":"<ul> <li>Translating theory \u2192 working hardware</li> <li>Debugging timing and logic errors</li> <li>Working within constraints (pins, clocks, resets)</li> </ul>"},{"location":"course-description/#12-professional-programmatic-outcomes","title":"12. Professional &amp; Programmatic Outcomes","text":"<p>By the end of EE 2301, students can:</p> <ul> <li>Think in Boolean abstractions</li> <li>Design correct, clocked digital systems</li> <li>Read and write Verilog</li> <li>Understand how hardware differs fundamentally from software</li> <li> <p>Prepare for:</p> </li> <li> <p>Computer architecture</p> </li> <li>Embedded systems</li> <li>VLSI / FPGA design</li> <li>Operating systems (indirectly)</li> </ul>"},{"location":"course-description/#topics-not-covered","title":"Topics Not Covered","text":"<p>Important boundary clarification:</p> <ul> <li>\u274c No transistor-level CMOS design</li> <li>\u274c No asynchronous circuit theory</li> <li>\u274c No advanced timing closure or synthesis</li> <li>\u274c No CPU pipeline design</li> </ul> <p>These topics will come later \u2014 this course builds the mental scaffolding.</p>"},{"location":"course-description/#why-ee-2301-is-a-pivot-course","title":"Why EE 2301 Is a Pivot Course","text":"<p>This course is where students stop thinking:</p> <p>\"The computer just runs code\"</p> <p>\u2026and start thinking:</p> <p>\"The computer is a carefully synchronized state machine built from logic.\"</p>"},{"location":"course-description/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this course, students will be able to:</p>"},{"location":"course-description/#remember","title":"Remember","text":"<ul> <li>Recall the truth tables for all primitive logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR)</li> <li>List the fundamental Boolean algebra laws (Identity, Null, Idempotent, Complement, Commutative, Associative, Distributive, Absorption)</li> <li>State De Morgan's Theorems</li> <li>Identify the symbols for standard logic gates</li> <li>Name the timing parameters for flip-flops (setup time, hold time, clock-to-Q delay)</li> </ul>"},{"location":"course-description/#understand","title":"Understand","text":"<ul> <li>Explain the difference between combinational and sequential logic</li> <li>Describe how Boolean expressions map to physical gate implementations</li> <li>Interpret truth tables and state diagrams</li> <li>Distinguish between Moore and Mealy state machines</li> <li>Explain why NAND and NOR gates are functionally complete</li> <li>Describe the concept of metastability in digital systems</li> </ul>"},{"location":"course-description/#apply","title":"Apply","text":"<ul> <li>Use Karnaugh maps to simplify Boolean expressions up to 4 variables</li> <li>Apply Boolean algebra laws to reduce logic expressions</li> <li>Implement combinational circuits using standard blocks (MUX, decoders, adders)</li> <li>Design finite state machines from word problem specifications</li> <li>Write synthesizable Verilog code for combinational and sequential logic</li> <li>Use simulation tools to verify digital designs</li> </ul>"},{"location":"course-description/#analyze","title":"Analyze","text":"<ul> <li>Analyze timing diagrams to identify setup and hold violations</li> <li>Decompose complex digital systems into combinational and sequential components</li> <li>Trace signal propagation through multi-level logic circuits</li> <li>Debug logic errors using waveform analysis</li> <li>Examine FSM state transitions for correctness and completeness</li> </ul>"},{"location":"course-description/#evaluate","title":"Evaluate","text":"<ul> <li>Compare design tradeoffs between gate count, propagation delay, and power consumption</li> <li>Assess whether a circuit implementation meets functional specifications</li> <li>Critique state encoding choices (binary vs. one-hot) for specific applications</li> <li>Judge the quality of Verilog code for clarity and synthesizability</li> <li>Evaluate when to use latches versus flip-flops in a design</li> </ul>"},{"location":"course-description/#create","title":"Create","text":"<ul> <li>Design complete synchronous digital systems from specifications</li> <li>Construct testbenches to verify Verilog module functionality</li> <li>Develop FSM-based controllers for real-world applications (traffic lights, vending machines)</li> <li>Build working circuits on breadboards and FPGA platforms</li> <li>Synthesize optimized gate-level implementations from behavioral descriptions</li> </ul>"},{"location":"faq/","title":"Digital Electronics Frequently Asked Questions","text":"<p>This FAQ covers common questions about the Digital Electronics course, organized by category to help you find answers quickly.</p>"},{"location":"faq/#getting-started-questions","title":"Getting Started Questions","text":""},{"location":"faq/#what-is-this-course-about","title":"What is this course about?","text":"<p>This is a sophomore-level digital electronics course covering the ABET-aligned electrical engineering curriculum. You'll learn how digital circuits work, from basic logic gates to complete synchronous systems. The course bridges the gap between abstract Boolean algebra and physical hardware implementation, preparing you for upper-division courses in computer architecture, VLSI design, and embedded systems. See the course description for complete details.</p>"},{"location":"faq/#who-is-this-course-designed-for","title":"Who is this course designed for?","text":"<p>This course is designed for college students majoring in electrical engineering or computer-related fields. It's typically taken in the sophomore year after completing introductory circuits and Calculus 1. If you're curious about how computers actually work at the hardware level, this course will transform your understanding from \"the computer runs code\" to \"the computer is a carefully synchronized state machine built from logic.\"</p>"},{"location":"faq/#what-prerequisites-do-i-need","title":"What prerequisites do I need?","text":"<p>Calculus 1 is required for several advanced topics in this course. You should also have basic familiarity with algebra and logical reasoning. Prior programming experience is helpful but not required\u2014in fact, one key learning outcome is understanding how hardware description languages differ fundamentally from software programming.</p>"},{"location":"faq/#how-is-the-course-structured","title":"How is the course structured?","text":"<p>The course follows a carefully scaffolded progression through 15 chapters. You'll start with number systems and Boolean algebra, progress through logic gates and combinational circuits, then make the conceptual leap to sequential logic with flip-flops and state machines. The final chapters cover Verilog HDL, simulation, and hands-on FPGA implementation. See the chapter list for the complete outline.</p>"},{"location":"faq/#what-software-and-tools-will-i-need","title":"What software and tools will I need?","text":"<p>You'll need access to a Verilog simulator (such as ModelSim, Icarus Verilog, or similar), a text editor or IDE for writing Verilog code, and ideally an FPGA development board for the laboratory component. The specific tools may vary by institution. For schematic capture and analysis, any digital logic simulator will work.</p>"},{"location":"faq/#how-much-time-should-i-expect-to-spend-on-this-course","title":"How much time should I expect to spend on this course?","text":"<p>Plan for significant time investment beyond lecture hours. Digital electronics requires practice\u2014working through Boolean simplifications, designing state machines, and debugging Verilog code. The laboratory component alone involves substantial hands-on time. Most students find this course more time-intensive than typical sophomore courses due to its practical nature.</p>"},{"location":"faq/#what-makes-this-course-different-from-a-programming-course","title":"What makes this course different from a programming course?","text":"<p>This is perhaps the most important mindset shift. In programming, you write sequential instructions that execute one after another. In digital electronics, you're describing hardware that operates in parallel\u2014everything happens simultaneously. When you write Verilog, you're not writing a program; you're describing circuits. This fundamental difference catches many students off guard initially.</p>"},{"location":"faq/#how-does-this-course-connect-to-future-courses","title":"How does this course connect to future courses?","text":"<p>Digital Electronics is a pivot course that prepares you for computer architecture (how CPUs are built), embedded systems (interfacing hardware and software), VLSI design (custom chip design), and even operating systems (understanding hardware-software interaction). The concepts of clocked state machines and timing constraints appear throughout advanced EE curriculum.</p>"},{"location":"faq/#what-should-i-do-if-im-struggling-with-the-material","title":"What should I do if I'm struggling with the material?","text":"<p>Start by identifying whether you're struggling with concepts (understanding what something is), mathematics (Boolean algebra, timing calculations), or practical skills (Verilog coding, debugging). Each requires different approaches. Form study groups\u2014explaining concepts to others reinforces your own understanding. Use the glossary to ensure you understand terminology. Most importantly, practice: work through problems until the patterns become familiar.</p>"},{"location":"faq/#is-there-a-laboratory-component","title":"Is there a laboratory component?","text":"<p>Yes, and it's essential\u2014not optional. The lab is where theory meets reality. You'll build circuits on breadboards, program FPGAs, debug with logic analyzers, and experience firsthand why timing constraints matter. The skills developed in lab\u2014translating theory to hardware, debugging timing errors, working within physical constraints\u2014are what employers value most.</p>"},{"location":"faq/#core-concept-questions","title":"Core Concept Questions","text":""},{"location":"faq/#what-is-the-difference-between-combinational-and-sequential-logic","title":"What is the difference between combinational and sequential logic?","text":"<p>Combinational logic circuits produce outputs based solely on current inputs\u2014like a vending machine's price display responding to button presses. Sequential logic circuits have memory and produce outputs based on both current inputs AND past history\u2014like the vending machine tracking how much money you've inserted. This distinction is fundamental: combinational circuits are stateless, sequential circuits have state. See Chapter 4 for combinational logic and Chapter 7 for the sequential logic introduction.</p>"},{"location":"faq/#what-is-a-truth-table-and-why-is-it-important","title":"What is a truth table and why is it important?","text":"<p>A truth table is a complete specification of a logic function, listing every possible input combination and its corresponding output. It's important because it provides an unambiguous definition of circuit behavior\u2014there's no guessing about edge cases. Truth tables form the foundation for both circuit design (deriving Boolean expressions) and verification (checking that your implementation matches the specification). See Chapter 2 for truth table fundamentals.</p>"},{"location":"faq/#what-is-boolean-algebra","title":"What is Boolean algebra?","text":"<p>Boolean algebra is the mathematical system for manipulating logical expressions using AND, OR, and NOT operations. Unlike regular algebra with infinite real numbers, Boolean algebra works with just two values: 0 and 1. Its laws (identity, complement, De Morgan's, etc.) allow systematic simplification of logic expressions and form the theoretical foundation for all digital circuit design.</p>"},{"location":"faq/#what-are-de-morgans-theorems-and-why-are-they-important","title":"What are De Morgan's Theorems and why are they important?","text":"<p>De Morgan's theorems state that (A + B)' = A'B' and (AB)' = A' + B'. In words: the complement of an OR equals the AND of the complements, and vice versa. These theorems are critical because they allow conversion between AND/OR forms and enable implementing any circuit using only NAND gates or only NOR gates. You'll use De Morgan's constantly in simplification and design.</p>"},{"location":"faq/#what-is-a-logic-gate","title":"What is a logic gate?","text":"<p>A logic gate is a physical electronic circuit that implements a Boolean operation. Gates are the fundamental building blocks of digital systems. The basic gates\u2014AND, OR, NOT\u2014directly implement Boolean operations, while derived gates like NAND, NOR, XOR, and XNOR provide convenience and efficiency. Understanding gate symbols, behavior, and properties (delay, fan-in, fan-out) is essential. See Chapter 3 for complete coverage.</p>"},{"location":"faq/#why-are-nand-and-nor-gates-called-universal-gates","title":"Why are NAND and NOR gates called \"universal gates\"?","text":"<p>NAND and NOR are functionally complete, meaning any Boolean function can be implemented using only that one gate type. You can build an inverter, AND, OR\u2014any gate\u2014from NANDs alone or NORs alone. This is practically important because manufacturing a single gate type is simpler and cheaper than manufacturing multiple types. Real integrated circuits often use NAND-only or NOR-only designs.</p>"},{"location":"faq/#what-is-a-karnaugh-map","title":"What is a Karnaugh map?","text":"<p>A Karnaugh map (K-map) is a graphical method for simplifying Boolean expressions. It arranges truth table outputs in a grid where adjacent cells differ by exactly one variable, making grouping of terms visual and intuitive. K-maps work well for 2, 3, or 4 variables. For more variables, algorithmic methods like Quine-McCluskey are used. See Chapter 5 for K-map techniques.</p>"},{"location":"faq/#what-is-a-multiplexer","title":"What is a multiplexer?","text":"<p>A multiplexer (MUX) is a combinational circuit that selects one of several inputs to pass to the output, based on select lines. A 4-to-1 MUX has 4 data inputs, 2 select lines, and 1 output. Multiplexers are fundamental building blocks\u2014they can implement any Boolean function, route data in datapaths, and form the basis of programmable logic. See Chapter 6 for multiplexer design.</p>"},{"location":"faq/#what-is-a-flip-flop","title":"What is a flip-flop?","text":"<p>A flip-flop is an edge-triggered storage element that captures and holds one bit of data. Unlike latches (which are level-sensitive), flip-flops only change state at the clock edge\u2014either rising or falling. The D flip-flop is most common: on the active clock edge, Q takes the value present at D. Flip-flops are the building blocks of registers, counters, and state machines. See Chapter 8 for flip-flop details.</p>"},{"location":"faq/#what-is-the-difference-between-a-latch-and-a-flip-flop","title":"What is the difference between a latch and a flip-flop?","text":"<p>A latch is level-sensitive\u2014it's \"transparent\" and passes input to output while enabled. A flip-flop is edge-triggered\u2014it samples input only at the clock transition. This difference is crucial: latches can cause timing problems in complex designs because changes propagate through multiple stages within one clock period. Flip-flops provide predictable behavior by updating only at discrete clock edges.</p>"},{"location":"faq/#what-is-a-finite-state-machine-fsm","title":"What is a finite state machine (FSM)?","text":"<p>A finite state machine is a sequential circuit with a finite number of states, rules for transitioning between states, and outputs that depend on the current state (and possibly inputs). FSMs are the primary model for designing sequential logic. Common examples include counters, sequence detectors, and controllers. See Chapter 9 and Chapter 10 for FSM design.</p>"},{"location":"faq/#what-is-the-difference-between-moore-and-mealy-machines","title":"What is the difference between Moore and Mealy machines?","text":"<p>In a Moore machine, outputs depend only on the current state\u2014outputs are associated with states. In a Mealy machine, outputs depend on both the current state AND current inputs\u2014outputs are associated with transitions. Moore machines have more predictable timing (outputs change only with state), while Mealy machines can respond faster (outputs can change immediately with inputs).</p>"},{"location":"faq/#what-is-verilog","title":"What is Verilog?","text":"<p>Verilog is a hardware description language (HDL) used to model and design digital systems. Unlike programming languages that describe sequential execution, Verilog describes concurrent hardware behavior. It supports multiple abstraction levels: gate-level (explicit gates), RTL (register-transfer level), and behavioral (algorithmic). Verilog is used for both simulation and synthesis to actual hardware. See Chapter 12 for Verilog basics.</p>"},{"location":"faq/#what-is-the-difference-between-wire-and-reg-in-verilog","title":"What is the difference between wire and reg in Verilog?","text":"<p>Wire represents a physical connection driven by continuous assignment or module outputs. Reg represents a variable that holds a value and is assigned in procedural blocks (always, initial). Importantly, reg does NOT necessarily mean a physical register\u2014it's just Verilog syntax. A reg assigned in a combinational always block synthesizes to combinational logic, not a register.</p>"},{"location":"faq/#what-is-synthesis","title":"What is synthesis?","text":"<p>Synthesis is the process of converting HDL code (Verilog) into a netlist of logic gates and flip-flops that can be implemented in hardware. Synthesis tools interpret your behavioral description and produce an equivalent gate-level circuit. Not all Verilog constructs are synthesizable\u2014delays, initial blocks, and file I/O are simulation-only. See Chapter 14 for synthesis details.</p>"},{"location":"faq/#what-is-an-fpga","title":"What is an FPGA?","text":"<p>An FPGA (Field-Programmable Gate Array) is an integrated circuit designed to be configured after manufacturing. It contains an array of configurable logic blocks (CLBs), programmable routing, and I/O blocks. Unlike ASICs with fixed functionality, FPGAs can be reprogrammed to implement virtually any digital circuit. They're used for prototyping, low-volume production, and applications requiring reconfigurability. See Chapter 15 for FPGA architecture.</p>"},{"location":"faq/#technical-detail-questions","title":"Technical Detail Questions","text":""},{"location":"faq/#what-is-propagation-delay","title":"What is propagation delay?","text":"<p>Propagation delay is the time from when an input changes until the corresponding output change appears. Every gate and wire has propagation delay. In combinational circuits, total delay equals the sum of delays along the longest path. Propagation delay limits circuit speed\u2014the clock period must be longer than the worst-case path delay plus setup time.</p>"},{"location":"faq/#what-are-setup-time-and-hold-time","title":"What are setup time and hold time?","text":"<p>Setup time is the minimum time data must be stable BEFORE the clock edge. Hold time is the minimum time data must remain stable AFTER the clock edge. Violating these requirements causes unreliable operation\u2014the flip-flop may capture incorrect data or enter metastability. Meeting timing constraints is essential for correct synchronous design.</p>"},{"location":"faq/#what-is-metastability","title":"What is metastability?","text":"<p>Metastability occurs when a flip-flop samples an input that's changing at the exact moment of the clock edge, violating setup or hold time. The flip-flop enters an unstable intermediate state and takes unpredictable time to resolve to 0 or 1. This is particularly problematic for asynchronous inputs crossing clock domains. Synchronizer circuits (typically two flip-flops in series) mitigate metastability risk.</p>"},{"location":"faq/#what-is-the-difference-between-synchronous-and-asynchronous-reset","title":"What is the difference between synchronous and asynchronous reset?","text":"<p>Synchronous reset takes effect only at the clock edge\u2014the flip-flop resets on the next active edge after reset is asserted. Asynchronous reset takes effect immediately when asserted, regardless of the clock. Synchronous resets are easier to analyze for timing but require the clock to be running. Asynchronous resets provide immediate initialization but can cause timing issues.</p>"},{"location":"faq/#what-are-blocking-and-non-blocking-assignments-in-verilog","title":"What are blocking and non-blocking assignments in Verilog?","text":"<p>Blocking assignments (=) execute immediately and in order\u2014each completes before the next begins. Non-blocking assignments (&lt;=) schedule updates for the end of the time step\u2014all right-hand sides are evaluated before any updates occur. Use blocking for combinational logic, non-blocking for sequential logic. Mixing them incorrectly causes simulation/synthesis mismatches.</p>"},{"location":"faq/#what-is-twos-complement","title":"What is two's complement?","text":"<p>Two's complement is the standard representation for signed integers in digital systems. Positive numbers have a leading 0; negative numbers are formed by inverting all bits and adding 1. The key advantage: addition and subtraction use the same hardware regardless of sign. In 8-bit two's complement, values range from -128 to +127.</p>"},{"location":"faq/#what-is-a-dont-care-condition","title":"What is a don't care condition?","text":"<p>A don't care condition occurs when an output value is unspecified for certain input combinations\u2014either because those inputs never occur (like BCD codes 1010-1111) or because the output is ignored. Don't cares are marked as X in truth tables and can be treated as either 0 or 1 during minimization, allowing more simplification.</p>"},{"location":"faq/#what-is-gray-code-and-when-is-it-used","title":"What is gray code and when is it used?","text":"<p>Gray code is a binary code where consecutive values differ by exactly one bit. This property eliminates multi-bit transition glitches. Gray code is used in rotary encoders (to prevent position errors), FSM state encoding (to reduce switching noise), and crossing clock domains (to prevent metastability from multiple bits changing).</p>"},{"location":"faq/#what-is-fan-in-and-fan-out","title":"What is fan-in and fan-out?","text":"<p>Fan-in is the number of inputs to a gate; fan-out is the number of gate inputs that a gate output can drive. Higher fan-in increases gate delay and power consumption. Exceeding fan-out limits degrades signal quality and timing. Both are important considerations for physical implementation.</p>"},{"location":"faq/#what-is-a-hazard-in-digital-circuits","title":"What is a hazard in digital circuits?","text":"<p>A hazard is a momentary incorrect output caused by unequal propagation delays through different paths. Static hazards produce a glitch when the output should remain constant. Dynamic hazards produce multiple glitches during a single transition. Hazards matter in asynchronous circuits and when outputs directly drive state machine inputs.</p>"},{"location":"faq/#what-is-rtl-register-transfer-level","title":"What is RTL (Register Transfer Level)?","text":"<p>RTL is a design abstraction describing data movement between registers through combinational logic. It specifies what happens each clock cycle: which registers update, what values they receive, what operations are performed. RTL is the primary design level for synthesizable digital circuits\u2014high enough to be readable, detailed enough for synthesis.</p>"},{"location":"faq/#what-is-a-testbench","title":"What is a testbench?","text":"<p>A testbench is Verilog code that tests a design by providing stimulus and checking responses. Testbenches instantiate the design under test, generate input sequences, and verify outputs. They use non-synthesizable constructs (delays, $display, $monitor) for simulation only. Self-checking testbenches automatically compare actual outputs to expected values.</p>"},{"location":"faq/#common-challenge-questions","title":"Common Challenge Questions","text":""},{"location":"faq/#why-does-my-combinational-always-block-infer-a-latch","title":"Why does my combinational always block infer a latch?","text":"<p>This happens when not all outputs are assigned for all input combinations. If you have an if-statement without an else, or a case statement without default, the synthesis tool infers a latch to hold the previous value for unspecified cases. Solution: ensure every path assigns every output, use else clauses, and include default in case statements.</p>"},{"location":"faq/#why-do-my-simulation-and-synthesis-results-differ","title":"Why do my simulation and synthesis results differ?","text":"<p>Common causes include: using blocking assignments in sequential logic or non-blocking in combinational logic; race conditions from improper sensitivity lists; delays in synthesizable code (synthesis ignores them); or incomplete case/if coverage. The synthesis tool interprets your code differently than the simulator. Always use @(*) for combinational logic and non-blocking assignments for sequential logic.</p>"},{"location":"faq/#how-do-i-debug-timing-violations","title":"How do I debug timing violations?","text":"<p>Timing violations mean signals don't meet setup or hold requirements. For setup violations: the combinational path is too long\u2014simplify logic, add pipeline stages, or reduce clock frequency. For hold violations: the path is too short\u2014add buffers to slow the signal. Use timing reports to identify the failing paths and their slack values.</p>"},{"location":"faq/#why-doesnt-my-state-machine-work-correctly","title":"Why doesn't my state machine work correctly?","text":"<p>Common FSM bugs include: incomplete state transitions (missing input conditions), incorrect output assignments, improper reset handling, or wrong state encoding assumptions. Debug systematically: verify the state diagram is correct, check that state registers reset properly, trace specific input sequences through your code, and use simulation waveforms to observe state transitions.</p>"},{"location":"faq/#what-causes-metastability-and-how-do-i-prevent-it","title":"What causes metastability and how do I prevent it?","text":"<p>Metastability occurs when flip-flops sample signals that violate setup/hold times\u2014typically asynchronous inputs or signals crossing clock domains. Prevention: use synchronizer circuits (two flip-flops in series) for all asynchronous inputs. The first flip-flop may go metastable, but it has a full clock period to resolve before the second flip-flop samples it.</p>"},{"location":"faq/#why-is-my-counter-skipping-states-or-glitching","title":"Why is my counter skipping states or glitching?","text":"<p>This usually indicates timing problems or incorrect logic. Check that outputs are registered (not combinational decodes of state bits which can glitch). Verify synchronous vs. asynchronous reset usage. Ensure the clock is clean and stable. For multi-bit comparisons used in terminal count detection, check for glitches during bit transitions.</p>"},{"location":"faq/#how-do-i-properly-debounce-a-mechanical-switch","title":"How do I properly debounce a mechanical switch?","text":"<p>Mechanical switches bounce\u2014the contacts make and break multiple times over 1-10ms. Without debouncing, a single press may register as many presses. Solutions: hardware (RC filter with Schmitt trigger) or digital (sample the input, wait for it to be stable for 10-20ms before accepting the new value). See the debouncing code in Chapter 15.</p>"},{"location":"faq/#why-wont-my-verilog-code-synthesize","title":"Why won't my Verilog code synthesize?","text":"<p>Common non-synthesizable constructs: #delays, initial blocks, \\(display/\\)monitor system tasks, file I/O operations, and divide/modulo by non-power-of-2 values. Also check for: latches from incomplete assignments, multiply-driven nets, unsupported operators, or feedback loops without registers. Read the synthesis tool's error messages carefully\u2014they usually identify the problem.</p>"},{"location":"faq/#how-do-i-choose-between-binary-and-one-hot-encoding-for-state-machines","title":"How do I choose between binary and one-hot encoding for state machines?","text":"<p>Binary encoding uses fewer flip-flops (log2 of state count) but requires more decoding logic for next-state and output equations. One-hot encoding uses one flip-flop per state but has simpler logic because each state is directly represented. In FPGAs with abundant flip-flops, one-hot is often preferred. For ASICs or when flip-flops are scarce, binary may be better.</p>"},{"location":"faq/#why-is-my-ripple-carry-adder-so-slow","title":"Why is my ripple-carry adder so slow?","text":"<p>Ripple-carry adders have delay proportional to bit width because the carry must propagate through all stages sequentially. For fast addition, use carry-lookahead techniques that compute all carries in parallel. Modern synthesis tools often automatically optimize adders, but understanding the fundamental tradeoff between area and delay is important.</p>"},{"location":"faq/#best-practice-questions","title":"Best Practice Questions","text":""},{"location":"faq/#what-makes-verilog-code-good-quality","title":"What makes Verilog code good quality?","text":"<p>Good Verilog is: consistent in style (naming conventions, indentation); well-documented with header comments explaining purpose, ports, and behavior; synthesizable where intended; thoroughly tested with self-checking testbenches; hierarchical with clean module interfaces; and parameterized for reuse. Avoid clever tricks that obscure intent\u2014clarity beats cleverness.</p>"},{"location":"faq/#when-should-i-use-structural-vs-behavioral-modeling","title":"When should I use structural vs. behavioral modeling?","text":"<p>Use behavioral modeling for most design work\u2014it's more readable and lets synthesis tools optimize implementation. Use structural modeling when you need explicit control over the circuit structure (instantiating specific modules, building hierarchies) or when connecting pre-defined blocks. Most real designs mix both styles appropriately.</p>"},{"location":"faq/#how-do-i-design-a-state-machine-from-a-word-problem","title":"How do I design a state machine from a word problem?","text":"<p>Follow this systematic process: (1) Identify the states\u2014what distinct conditions must the system remember? (2) Determine transitions\u2014what inputs cause changes between states? (3) Define outputs\u2014what does each state produce (Moore) or each transition produce (Mealy)? (4) Draw the state diagram. (5) Create the state table. (6) Choose encoding. (7) Derive next-state and output equations. (8) Implement and verify.</p>"},{"location":"faq/#how-should-i-approach-debugging-digital-circuits","title":"How should I approach debugging digital circuits?","text":"<p>Debug systematically: (1) Verify the simplest possible case works. (2) Add complexity incrementally. (3) Use simulation before hardware\u2014it's faster to iterate. (4) Examine waveforms to understand actual behavior. (5) Check reset and initialization. (6) Verify timing constraints are met. (7) Use assertions to catch unexpected conditions. (8) Divide and conquer\u2014isolate the problem to the smallest possible scope.</p>"},{"location":"faq/#what-are-common-pitfalls-when-learning-verilog","title":"What are common pitfalls when learning Verilog?","text":"<p>The biggest pitfall: thinking in software. Verilog describes parallel hardware, not sequential execution. Other common issues: confusing wire and reg usage; misusing blocking vs. non-blocking assignments; creating unintended latches; forgetting sensitivity list signals; assuming specific execution order in concurrent blocks; and ignoring synthesis warnings.</p>"},{"location":"faq/#how-should-i-organize-a-larger-verilog-project","title":"How should I organize a larger Verilog project?","text":"<p>Create a hierarchy matching the conceptual structure: top-level module instantiates major subsystems, which instantiate smaller modules. Keep modules focused on single responsibilities. Use consistent file naming (one module per file, filename matches module name). Maintain separate directories for source and testbenches. Use parameters for configurable values. Document interfaces clearly.</p>"},{"location":"faq/#when-should-i-add-pipeline-stages-to-a-design","title":"When should I add pipeline stages to a design?","text":"<p>Add pipeline stages when: the combinational path is too long to meet timing (setup violations); you need higher throughput even at the cost of latency; or the critical path analysis shows a clear bottleneck. Each pipeline stage adds one clock cycle of latency but can significantly increase maximum clock frequency. Balance throughput, latency, and complexity.</p>"},{"location":"faq/#how-do-i-make-designs-reusable","title":"How do I make designs reusable?","text":"<p>Parameterize everything that might vary: bit widths, depths, delays, thresholds. Use clear, generic port names. Document thoroughly: what the module does, port descriptions, parameter ranges, timing requirements. Include a testbench. Minimize dependencies on external signals or specific contexts. Make interfaces clean and standard. Test with various parameter values.</p>"},{"location":"faq/#laboratory-skills-questions","title":"Laboratory Skills Questions","text":""},{"location":"faq/#what-safety-precautions-should-i-take-in-the-digital-electronics-lab","title":"What safety precautions should I take in the digital electronics lab?","text":"<p>Digital circuits operate at low voltages (typically 3.3V or 5V), so electrical shock is minimal risk. However: never connect FPGA pins directly to voltages above their rating\u2014this can damage the chip. Use current-limiting resistors with LEDs. Handle ICs carefully to avoid static damage. Keep liquids away from equipment. Don't leave powered equipment unattended.</p>"},{"location":"faq/#how-do-i-read-a-breadboard-layout","title":"How do I read a breadboard layout?","text":"<p>Breadboards have internal connections: terminal strips have 5-hole rows connected horizontally, power rails run vertically along the edges. The center gap separates the two halves (important for IC placement\u2014pins span the gap). Plan your layout before building. Use color-coded wires (red for power, black for ground). Keep wires short and neat for easier debugging.</p>"},{"location":"faq/#how-do-i-use-a-logic-analyzer-effectively","title":"How do I use a logic analyzer effectively?","text":"<p>Set up triggers to capture the behavior you want to observe\u2014rising edge on a signal, specific patterns, etc. Adjust sample rate based on your clock frequency (sample at least 4x the highest frequency of interest). Use protocol decoders for standard interfaces (SPI, I2C, UART). Learn to set cursors for timing measurements. Save captures for documentation.</p>"},{"location":"faq/#what-should-i-check-first-when-a-circuit-doesnt-work","title":"What should I check first when a circuit doesn't work?","text":"<p>Check power and ground connections first\u2014many problems are simply missing or wrong power. Verify clock signal is present and at expected frequency. Check reset behavior. Measure actual voltages at key points\u2014don't assume they're correct. Look for obvious wiring errors. Test small portions independently. Compare expected vs. actual behavior systematically.</p>"},{"location":"faq/#how-do-i-connect-leds-properly-to-fpga-outputs","title":"How do I connect LEDs properly to FPGA outputs?","text":"<p>LEDs require current-limiting resistors (typically 220-330 ohms for standard LEDs at 3.3V). Connect in series: FPGA pin \u2192 resistor \u2192 LED \u2192 ground (active-high) or VCC \u2192 LED \u2192 resistor \u2192 FPGA pin (active-low). Check LED polarity (longer lead is anode/positive). Verify the FPGA output can sink or source sufficient current (usually not a problem for single LEDs).</p>"},{"location":"faq/#whats-the-proper-way-to-connect-buttons-to-fpga-inputs","title":"What's the proper way to connect buttons to FPGA inputs?","text":"<p>Use pull-up or pull-down resistors to ensure a defined logic level when the button is not pressed. Typical configuration: connect button between FPGA pin and ground, with 10K pull-up resistor from pin to VCC. When pressed: input is low. When released: input is high. Many FPGAs have internal pull-ups that can be enabled, eliminating the external resistor.</p>"},{"location":"faq/#how-do-i-create-proper-pin-constraints-for-my-fpga","title":"How do I create proper pin constraints for my FPGA?","text":"<p>Refer to your FPGA board's documentation for pin mappings to LEDs, buttons, and headers. Create a constraints file (XDC for Xilinx, SDC for Intel/Altera) specifying PACKAGE_PIN for each signal and IOSTANDARD for voltage compatibility. Verify bank voltage compatibility. Assign timing constraints for clocks. Double-check every assignment before programming.</p>"},{"location":"faq/#advanced-topics-questions","title":"Advanced Topics Questions","text":""},{"location":"faq/#what-happens-after-this-course","title":"What happens after this course?","text":"<p>This course prepares you for computer architecture (understanding CPU design), embedded systems (hardware-software co-design), VLSI design (custom chip design at transistor level), and FPGA-based system design. The concepts of synchronous design, state machines, and timing analysis apply throughout. Your Verilog skills transfer directly to industry tools.</p>"},{"location":"faq/#what-is-asic-design-and-how-does-it-differ-from-fpga-design","title":"What is ASIC design and how does it differ from FPGA design?","text":"<p>An ASIC (Application-Specific Integrated Circuit) is a custom chip manufactured for a specific purpose, unlike the reconfigurable FPGA. ASIC design involves similar RTL methodology but adds physical design steps (placement, routing, timing closure) and requires expensive manufacturing. ASICs offer higher performance, lower power, and lower unit cost at high volumes, but have high upfront costs and no reconfigurability.</p>"},{"location":"faq/#what-topics-are-beyond-the-scope-of-this-course","title":"What topics are beyond the scope of this course?","text":"<p>This course does not cover: transistor-level CMOS design (how gates are built from transistors), asynchronous circuit theory (clock-free design), advanced timing closure and physical design, or CPU pipeline architecture. These topics require the foundation this course provides and are covered in upper-division courses.</p>"},{"location":"faq/#how-do-clock-domain-crossings-work","title":"How do clock domain crossings work?","text":"<p>When signals move between different clock domains, careful synchronization is required to prevent metastability. Use synchronizer flip-flops for single-bit signals. For multi-bit data, use FIFOs with asynchronous read and write clocks, or use Gray code encoding to ensure only one bit changes per transition. Never pass unsynchronized signals between domains.</p>"},{"location":"faq/#what-is-formal-verification","title":"What is formal verification?","text":"<p>Formal verification uses mathematical techniques to prove that a design meets its specifications for all possible input sequences\u2014not just test cases. It can find bugs that simulation might miss. Techniques include model checking and equivalence checking. While powerful, formal verification requires expertise and computational resources, so it complements rather than replaces simulation.</p>"},{"location":"faq/#how-do-i-estimate-power-consumption-of-my-design","title":"How do I estimate power consumption of my design?","text":"<p>Power in digital circuits comes from: static power (leakage current) and dynamic power (switching activity). Dynamic power dominates in most designs: P = CV\u00b2f \u00d7 activity factor. Reduce power by: lowering voltage (quadratic effect), reducing clock frequency, minimizing switching activity (clock gating, operand isolation), and using low-power design techniques. Synthesis tools provide power estimates.</p>"},{"location":"faq/#what-is-design-for-testability-dft","title":"What is design for testability (DFT)?","text":"<p>DFT techniques make manufactured chips easier to test for defects. Scan chains allow internal flip-flops to be loaded and observed. Built-in self-test (BIST) adds on-chip test generation and checking. JTAG provides standardized debug access. DFT adds area overhead but is essential for manufacturing yield. Your synthesizable designs should follow DFT-friendly practices.</p>"},{"location":"faq/#how-does-high-level-synthesis-differ-from-traditional-rtl-design","title":"How does high-level synthesis differ from traditional RTL design?","text":"<p>High-level synthesis (HLS) converts C/C++ algorithms directly to hardware, automatically determining scheduling, allocation, and binding. It accelerates design but provides less control over implementation. Traditional RTL design requires explicitly describing cycle-by-cycle behavior but offers more optimization opportunities. Many designers use HLS for complex algorithms while using RTL for critical paths.</p>"},{"location":"glossary/","title":"Digital Electronics Glossary of Terms","text":"<p>This glossary contains definitions for key concepts in digital electronics, organized alphabetically. Each definition follows ISO 11179 standards: precise, concise, distinct, and non-circular.</p>"},{"location":"glossary/#absorption-law","title":"Absorption Law","text":"<p>A Boolean algebra simplification rule stating that a variable combined with its AND-product or OR-sum with another variable reduces to just the first variable.</p> <p>The absorption law helps eliminate redundant terms in Boolean expressions. The two forms are: A + AB = A and A(A + B) = A.</p> <p>Example: The expression X + XY simplifies to just X because if X is true, the entire expression is true regardless of Y.</p>"},{"location":"glossary/#adjacent-cells","title":"Adjacent Cells","text":"<p>Cells in a Karnaugh map that differ by exactly one variable, allowing them to be grouped for simplification.</p> <p>Adjacent cells share a common edge in the K-map grid. Groups of adjacent cells reduce to simpler product terms by eliminating the changing variable.</p> <p>Example: In a 3-variable K-map, cells for minterms m3 (011) and m7 (111) are adjacent because they differ only in variable A.</p>"},{"location":"glossary/#algebraic-simplification","title":"Algebraic Simplification","text":"<p>The process of reducing Boolean expressions using Boolean algebra laws and theorems.</p> <p>This manual technique applies rules like De Morgan's theorem, absorption, and distribution to minimize gate count before implementation.</p> <p>Example: ABC + ABC' can be simplified to AB by factoring out AB and applying the complement law.</p>"},{"location":"glossary/#alu-concept","title":"ALU Concept","text":"<p>An arithmetic logic unit that performs arithmetic and bitwise logical operations on binary data.</p> <p>The ALU is the computational heart of a processor, typically supporting operations like addition, subtraction, AND, OR, and comparison. Control signals select which operation to perform.</p> <p>Example: A simple 4-bit ALU might compute A + B, A - B, A AND B, or A XOR B based on a 2-bit operation selector.</p>"},{"location":"glossary/#always-block","title":"Always Block","text":"<p>A Verilog procedural block that executes whenever signals in its sensitivity list change.</p> <p>Always blocks model both combinational logic (using @(*) sensitivity) and sequential logic (using @(posedge clk) sensitivity). They contain procedural statements like if-else and case.</p> <p>Example: <code>always @(posedge clk) q &lt;= d;</code> describes a D flip-flop that captures d on each rising clock edge.</p>"},{"location":"glossary/#analog-vs-digital","title":"Analog vs Digital","text":"<p>The distinction between signals that vary continuously (analog) versus signals with discrete levels (digital).</p> <p>Analog signals can take any value within a range, while digital signals are restricted to defined logic levels (typically high and low). Digital systems offer better noise immunity and easier processing.</p> <p>Example: A microphone produces an analog voltage proportional to sound pressure, while a digital counter outputs discrete binary values.</p>"},{"location":"glossary/#and-gate","title":"AND Gate","text":"<p>A logic gate that outputs 1 only when all inputs are 1.</p> <p>The AND gate implements logical conjunction. For a 2-input AND, the output equals A AND B, written as Y = AB or Y = A \u00b7 B.</p> <p>Example: A 2-input AND gate with inputs A=1 and B=0 produces output Y=0.</p>"},{"location":"glossary/#and-operation","title":"AND Operation","text":"<p>A Boolean operation that yields true only when all operands are true.</p> <p>The AND operation is fundamental to Boolean algebra and digital logic. It corresponds to logical conjunction and multiplication in Boolean algebra.</p> <p>Example: In the expression F = AB, F equals 1 only when both A and B equal 1.</p>"},{"location":"glossary/#assign-statement","title":"Assign Statement","text":"<p>A Verilog statement that creates a continuous connection between an expression and a wire.</p> <p>Assign statements model combinational logic where the left-hand side continuously reflects changes in the right-hand expression with no storage.</p> <p>Example: <code>assign sum = a ^ b;</code> continuously drives sum with the XOR of a and b.</p>"},{"location":"glossary/#associative-law","title":"Associative Law","text":"<p>A Boolean algebra law stating that the grouping of variables in AND or OR operations does not affect the result.</p> <p>The associative law allows rearranging parentheses without changing the outcome: (A + B) + C = A + (B + C) and (AB)C = A(BC).</p> <p>Example: (X AND Y) AND Z equals X AND (Y AND Z), so parentheses can be removed.</p>"},{"location":"glossary/#asynchronous-input","title":"Asynchronous Input","text":"<p>A signal that can change at any time, independent of the system clock.</p> <p>Asynchronous inputs require synchronization before use in clocked logic to prevent metastability. Common examples include external button presses and sensor signals.</p> <p>Example: A reset button pressed by a user is asynchronous because it has no timing relationship to the system clock.</p>"},{"location":"glossary/#asynchronous-reset","title":"Asynchronous Reset","text":"<p>A reset signal that immediately forces a flip-flop to its initial state regardless of clock.</p> <p>Asynchronous resets take effect as soon as asserted, without waiting for a clock edge. They provide immediate initialization but can cause timing issues.</p> <p>Example: <code>always @(posedge clk or posedge reset) if (reset) q &lt;= 0; else q &lt;= d;</code></p>"},{"location":"glossary/#abstraction-levels","title":"Abstraction Levels","text":"<p>Hierarchical layers of design representation ranging from system behavior to physical implementation.</p> <p>Higher abstraction levels hide implementation details. Common levels include system, behavioral, RTL, gate, and physical. Designers work at the level appropriate for their task.</p> <p>Example: A designer specifies an adder behaviorally as C = A + B, while synthesis tools determine the gate-level implementation.</p>"},{"location":"glossary/#bcd-counter","title":"BCD Counter","text":"<p>A counter that counts in binary-coded decimal, cycling from 0 to 9.</p> <p>A BCD counter requires 4 bits but only uses states 0000 through 1001. It resets to 0 after reaching 9, making it ideal for decimal displays.</p> <p>Example: A decade counter driving a 7-segment display cycles through 0-1-2-3-4-5-6-7-8-9-0...</p>"},{"location":"glossary/#bcd-encoding","title":"BCD Encoding","text":"<p>A method of representing decimal digits where each digit is encoded as a 4-bit binary number.</p> <p>BCD simplifies decimal I/O operations by encoding each decimal digit (0-9) separately. It uses only 10 of the 16 possible 4-bit combinations.</p> <p>Example: The decimal number 47 is encoded in BCD as 0100 0111 (4 = 0100, 7 = 0111).</p>"},{"location":"glossary/#behavioral-modeling","title":"Behavioral Modeling","text":"<p>A Verilog modeling style that describes what a circuit does without specifying how it is built.</p> <p>Behavioral models use high-level constructs like if-else and arithmetic operators. Synthesis tools convert behavioral descriptions to gate-level implementations.</p> <p>Example: <code>always @(*) if (sel) y = a; else y = b;</code> behaviorally describes a 2-to-1 multiplexer.</p>"},{"location":"glossary/#bidirectional-shift","title":"Bidirectional Shift","text":"<p>A shift register operation that can shift data left or right based on a control signal.</p> <p>Bidirectional shift registers add flexibility for applications like multiplication/division by powers of 2 or serial data reversal.</p> <p>Example: A universal shift register with a direction input shifts left when DIR=0 and right when DIR=1.</p>"},{"location":"glossary/#binary-addition","title":"Binary Addition","text":"<p>The arithmetic operation of adding two binary numbers.</p> <p>Binary addition follows rules: 0+0=0, 0+1=1, 1+0=1, 1+1=10 (sum=0, carry=1). Carries propagate from right to left just as in decimal addition.</p> <p>Example: Adding 1011 + 0110: starting from the right, 1+0=1, 1+1=10 (write 0, carry 1), 0+1+1=10 (write 0, carry 1), 1+0+1=10. Result: 10001.</p>"},{"location":"glossary/#binary-comparator","title":"Binary Comparator","text":"<p>A circuit that compares two binary numbers and indicates their relative magnitude.</p> <p>Comparators output signals indicating whether A&gt;B, A&lt;B, or A=B. They form the basis of conditional operations in digital systems.</p> <p>Example: A 4-bit magnitude comparator comparing A=0101 and B=0011 asserts the A&gt;B output.</p>"},{"location":"glossary/#binary-counter","title":"Binary Counter","text":"<p>A counter that increments through all possible states of its bit width in binary sequence.</p> <p>An n-bit binary counter has 2^n states, counting from 0 to 2^n - 1 before wrapping to 0. Each flip-flop toggles at half the frequency of the previous stage.</p> <p>Example: A 3-bit binary counter sequences through 000, 001, 010, 011, 100, 101, 110, 111, 000...</p>"},{"location":"glossary/#binary-encoding","title":"Binary Encoding","text":"<p>A state encoding method that assigns sequential binary numbers to FSM states.</p> <p>Binary encoding uses the minimum number of flip-flops (ceiling of log2 of state count) but may require more complex next-state logic than one-hot encoding.</p> <p>Example: A 4-state FSM uses 2-bit binary encoding: S0=00, S1=01, S2=10, S3=11.</p>"},{"location":"glossary/#binary-number-system","title":"Binary Number System","text":"<p>A base-2 positional number system using only digits 0 and 1.</p> <p>Binary is the foundation of digital electronics because electronic circuits can reliably distinguish between two states. Each digit position represents a power of 2.</p> <p>Example: Binary 1101 equals decimal 13 (1\u00d78 + 1\u00d74 + 0\u00d72 + 1\u00d71).</p>"},{"location":"glossary/#binary-subtraction","title":"Binary Subtraction","text":"<p>The arithmetic operation of subtracting one binary number from another.</p> <p>Binary subtraction can use direct borrowing or, more commonly, two's complement addition. The latter avoids separate subtraction circuitry.</p> <p>Example: Computing 1010 - 0011 using two's complement: 1010 + 1101 = 10111, discarding the overflow gives 0111 (7).</p>"},{"location":"glossary/#binary-to-decimal-conversion","title":"Binary to Decimal Conversion","text":"<p>The process of calculating the decimal value of a binary number.</p> <p>Multiply each binary digit by its position weight (power of 2) and sum all products. This converts the base-2 representation to base-10.</p> <p>Example: Binary 10110 = 1\u00d716 + 0\u00d78 + 1\u00d74 + 1\u00d72 + 0\u00d71 = 22 in decimal.</p>"},{"location":"glossary/#bistable-element","title":"Bistable Element","text":"<p>A circuit with two stable states that can store one bit of information indefinitely.</p> <p>Bistable elements remain in their current state until an input forces a change. Cross-coupled inverters or gates create the feedback necessary for bistability.</p> <p>Example: Two inverters connected in a loop form the simplest bistable element, storing either 0 or 1 with no input.</p>"},{"location":"glossary/#blocking-assignment","title":"Blocking Assignment","text":"<p>A Verilog procedural assignment (=) that executes immediately and blocks subsequent statements.</p> <p>Blocking assignments execute in order, with each completing before the next begins. They model combinational logic within always blocks.</p> <p>Example: <code>a = b; c = a;</code> results in c getting b's value because a is updated before c is assigned.</p>"},{"location":"glossary/#boolean-algebra","title":"Boolean Algebra","text":"<p>A mathematical system for manipulating logical expressions using operations AND, OR, and NOT.</p> <p>Boolean algebra provides the theoretical foundation for digital circuit design. Its laws enable systematic simplification and optimization of logic functions.</p> <p>Example: The Boolean expression A + AB simplifies to A using the absorption law.</p>"},{"location":"glossary/#boolean-constant","title":"Boolean Constant","text":"<p>A fixed value in Boolean algebra, either 0 (false) or 1 (true).</p> <p>Boolean constants appear in expressions and truth tables. They interact with variables according to Boolean algebra laws like the identity and null laws.</p> <p>Example: In the expression F = A + 0, the constant 0 has no effect on the output (identity law).</p>"},{"location":"glossary/#boolean-expression","title":"Boolean Expression","text":"<p>A combination of Boolean variables, constants, and operators that evaluates to 0 or 1.</p> <p>Boolean expressions describe logic functions that can be implemented as circuits. They serve as the specification for digital design.</p> <p>Example: F = AB' + BC is a Boolean expression with two product terms combined by OR.</p>"},{"location":"glossary/#boolean-function","title":"Boolean Function","text":"<p>A mapping from Boolean input combinations to Boolean outputs.</p> <p>A Boolean function defines the input-output behavior of a logic circuit. It can be represented as an expression, truth table, or circuit diagram.</p> <p>Example: The XOR function outputs 1 when exactly one of two inputs is 1: F(A,B) = A'B + AB'.</p>"},{"location":"glossary/#boolean-proof-technique","title":"Boolean Proof Technique","text":"<p>A method for verifying Boolean identities by algebraic manipulation or truth table evaluation.</p> <p>Proofs demonstrate that two expressions are equivalent by transforming one into the other or by showing they have identical truth tables.</p> <p>Example: Proving A + AB = A: Factor to get A(1 + B) = A(1) = A.</p>"},{"location":"glossary/#boolean-to-gates-mapping","title":"Boolean to Gates Mapping","text":"<p>The process of converting a Boolean expression to a logic gate circuit.</p> <p>Each Boolean operator corresponds to a gate: AND for multiplication, OR for addition, NOT for complement. Multi-level expressions create cascaded gates.</p> <p>Example: F = AB + C maps to an AND gate feeding one input of an OR gate, with C feeding the other OR input.</p>"},{"location":"glossary/#boolean-variable","title":"Boolean Variable","text":"<p>A symbol representing a logical quantity that can be either 0 or 1.</p> <p>Boolean variables are named with single letters or descriptive identifiers. They represent inputs, intermediate signals, or outputs in digital systems.</p> <p>Example: In F = A AND B, both A and B are Boolean variables that can each be 0 or 1.</p>"},{"location":"glossary/#breadboard-prototyping","title":"Breadboard Prototyping","text":"<p>Building temporary circuits on a solderless breadboard for testing and experimentation.</p> <p>Breadboards allow rapid circuit construction without soldering. Their internal connection pattern (5-hole rows, power rails) must be understood for correct wiring.</p> <p>Example: A student builds a 4-bit adder on a breadboard using 74LS83 ICs, LEDs, and switches.</p>"},{"location":"glossary/#buffer-gate","title":"Buffer Gate","text":"<p>A logic gate that produces an output equal to its input, providing signal conditioning.</p> <p>Buffers add drive strength, restore signal levels, or introduce intentional delay. Tri-state buffers add an enable input for bus applications.</p> <p>Example: A buffer between a weak sensor output and a long wire ensures proper logic levels at the destination.</p>"},{"location":"glossary/#bus-architecture","title":"Bus Architecture","text":"<p>A shared communication pathway allowing multiple components to exchange data.</p> <p>Bus architectures use tri-state buffers to allow only one driver at a time. They reduce wire count compared to point-to-point connections.</p> <p>Example: An 8-bit data bus connects CPU, memory, and I/O devices, with each device enabled only when addressed.</p>"},{"location":"glossary/#canonical-form","title":"Canonical Form","text":"<p>A standard representation of a Boolean function using all variables in every term.</p> <p>Canonical forms include sum-of-minterms and product-of-maxterms. They directly correspond to truth table rows and provide a unique expression.</p> <p>Example: F = \u03a3(1,3,5,7) is the canonical SOP form listing the minterms where F=1.</p>"},{"location":"glossary/#carry-bit","title":"Carry Bit","text":"<p>The output bit generated when a binary addition exceeds the capacity of a single bit position.</p> <p>Carry bits propagate from less significant to more significant bit positions. Managing carry propagation is crucial for adder performance.</p> <p>Example: Adding 1+1 in binary produces sum=0 with carry=1 to the next position.</p>"},{"location":"glossary/#carry-lookahead-concept","title":"Carry Lookahead Concept","text":"<p>A fast addition technique that calculates all carry bits simultaneously using generate and propagate logic.</p> <p>Carry lookahead eliminates the ripple delay by computing carries in parallel. It trades increased logic complexity for reduced delay.</p> <p>Example: A 4-bit carry lookahead adder computes all carries in constant time using G and P signals from each bit position.</p>"},{"location":"glossary/#carry-propagation-delay","title":"Carry Propagation Delay","text":"<p>The time required for a carry to ripple through all stages of an adder.</p> <p>In ripple-carry adders, the worst-case delay grows linearly with bit width. Carry lookahead and other techniques reduce this bottleneck.</p> <p>Example: A 32-bit ripple-carry adder has 32 stages of carry propagation, making it much slower than a carry-lookahead design.</p>"},{"location":"glossary/#case-statement","title":"Case Statement","text":"<p>A Verilog construct that selects between multiple alternatives based on an expression value.</p> <p>Case statements efficiently implement multiplexers and decoders in behavioral Verilog. They must cover all possible cases to avoid inferred latches.</p> <p>Example: <code>case(sel) 2'b00: y = a; 2'b01: y = b; default: y = 0; endcase</code></p>"},{"location":"glossary/#clear-input","title":"Clear Input","text":"<p>A flip-flop control signal that forces the output to 0.</p> <p>Clear inputs reset flip-flops to a known state. They can be synchronous (effective on clock edge) or asynchronous (immediate effect).</p> <p>Example: A counter uses a clear input to initialize all flip-flops to 0 before counting begins.</p>"},{"location":"glossary/#clear-signal","title":"Clear Signal","text":"<p>A control signal that resets a register or counter to zero.</p> <p>Clear signals provide initialization capability essential for known starting conditions. The term is often used interchangeably with reset.</p> <p>Example: Asserting CLR on a 4-bit register forces all outputs Q3Q2Q1Q0 to 0000.</p>"},{"location":"glossary/#clock-edge","title":"Clock Edge","text":"<p>The moment when a clock signal transitions between logic levels.</p> <p>Edge-triggered devices respond only at clock transitions, either rising (0\u21921) or falling (1\u21920). This provides precise timing control.</p> <p>Example: A positive-edge-triggered flip-flop samples its D input at each 0-to-1 clock transition.</p>"},{"location":"glossary/#clock-frequency","title":"Clock Frequency","text":"<p>The number of clock cycles per second, measured in Hertz.</p> <p>Clock frequency determines system speed. Higher frequencies allow more operations per second but increase power consumption and timing challenges.</p> <p>Example: A 100 MHz clock completes 100 million cycles per second, with each cycle lasting 10 nanoseconds.</p>"},{"location":"glossary/#clock-generation","title":"Clock Generation","text":"<p>The creation of periodic timing signals in testbenches or circuits.</p> <p>Clock generation in testbenches uses always blocks with delays. In hardware, crystals, PLLs, or oscillator circuits produce stable clock signals.</p> <p>Example: <code>always #5 clk = ~clk;</code> generates a clock with 10-unit period in a Verilog testbench.</p>"},{"location":"glossary/#clock-period","title":"Clock Period","text":"<p>The time duration of one complete clock cycle.</p> <p>Clock period is the inverse of frequency. All timing constraints (setup, hold, propagation delay) must fit within the clock period.</p> <p>Example: A 50 MHz clock has a period of 20 nanoseconds (1/50,000,000 seconds).</p>"},{"location":"glossary/#clock-signal","title":"Clock Signal","text":"<p>A periodic waveform that synchronizes operations in a digital system.</p> <p>The clock provides a timing reference ensuring all flip-flops change state together. It is the heartbeat of synchronous digital systems.</p> <p>Example: A clock oscillating between 0V and 3.3V at 100 MHz synchronizes a microprocessor.</p>"},{"location":"glossary/#clock-to-q-delay","title":"Clock-to-Q Delay","text":"<p>The time from a clock edge until a flip-flop output becomes valid.</p> <p>Clock-to-Q delay is part of the timing path calculation. It adds to the combinational delay between flip-flops to determine maximum operating frequency.</p> <p>Example: If tCQ = 2ns, the flip-flop output becomes stable 2ns after the active clock edge.</p>"},{"location":"glossary/#cmos-logic","title":"CMOS Logic","text":"<p>A logic family using complementary pairs of p-type and n-type MOSFETs.</p> <p>CMOS offers low static power consumption because one transistor is always off. It dominates modern digital IC fabrication.</p> <p>Example: A CMOS inverter uses a PMOS transistor to pull output high and an NMOS transistor to pull output low.</p>"},{"location":"glossary/#combinational-always","title":"Combinational Always","text":"<p>A Verilog always block that models combinational logic using sensitivity to all inputs.</p> <p>Combinational always blocks use @(*) to trigger on any input change. They must assign outputs for all input combinations to avoid latches.</p> <p>Example: <code>always @(*) y = a &amp; b;</code> models an AND gate in behavioral Verilog.</p>"},{"location":"glossary/#combinational-logic","title":"Combinational Logic","text":"<p>Logic circuits whose outputs depend only on current input values.</p> <p>Combinational circuits have no memory or feedback. The same input always produces the same output, with changes appearing after propagation delay.</p> <p>Example: A full adder is combinational because its sum and carry outputs depend only on the three current inputs.</p>"},{"location":"glossary/#common-term-extraction","title":"Common Term Extraction","text":"<p>A simplification technique that factors out shared variables or terms from a Boolean expression.</p> <p>Common term extraction reduces redundancy by identifying terms appearing in multiple products. It can lead to fewer gates or levels of logic.</p> <p>Example: ABC + ABD factors to AB(C + D), reducing the implementation from 6 AND gates to 3 gates plus an OR.</p>"},{"location":"glossary/#commutative-law","title":"Commutative Law","text":"<p>A Boolean algebra law stating that the order of operands in AND or OR does not affect the result.</p> <p>The commutative law allows reordering variables: A + B = B + A and AB = BA. This flexibility aids in expression simplification.</p> <p>Example: XY = YX, so inputs to an AND gate can connect in either order.</p>"},{"location":"glossary/#complement-law","title":"Complement Law","text":"<p>A Boolean algebra law stating that a variable ORed with its complement equals 1, and ANDed equals 0.</p> <p>The complement law provides: A + A' = 1 and A \u00b7 A' = 0. It is fundamental for simplification and implementing logic functions.</p> <p>Example: In the expression A + A', the result is always 1 regardless of A's value.</p>"},{"location":"glossary/#consensus-theorem","title":"Consensus Theorem","text":"<p>A Boolean simplification rule allowing removal of redundant terms formed by consensus.</p> <p>The consensus of AB and A'C is BC. The consensus theorem states: AB + A'C + BC = AB + A'C, since BC is redundant.</p> <p>Example: XY + X'Z + YZ simplifies to XY + X'Z because YZ is the consensus term.</p>"},{"location":"glossary/#continuous-assignment","title":"Continuous Assignment","text":"<p>A Verilog construct that continuously drives a wire based on an expression.</p> <p>Continuous assignments model combinational logic. The left-hand side updates whenever right-hand side signals change.</p> <p>Example: <code>assign mux_out = sel ? a : b;</code> continuously selects between a and b based on sel.</p>"},{"location":"glossary/#control-unit","title":"Control Unit","text":"<p>The component of a processor that generates control signals based on instructions and state.</p> <p>The control unit orchestrates datapath operations by enabling registers, selecting ALU functions, and managing memory access.</p> <p>Example: A control unit asserts RegWrite and ALUOp signals based on decoding the current instruction opcode.</p>"},{"location":"glossary/#counter","title":"Counter","text":"<p>A sequential circuit that cycles through a predetermined sequence of states.</p> <p>Counters implement frequency division, event counting, and timing. They are fundamental building blocks in digital systems.</p> <p>Example: A 4-bit binary up-counter cycles through values 0 to 15, then wraps back to 0.</p>"},{"location":"glossary/#counter-overflow","title":"Counter Overflow","text":"<p>The condition when a counter reaches its maximum value and wraps to zero.</p> <p>Overflow detection indicates that the counter has completed a full cycle. It often generates a carry or terminal count output.</p> <p>Example: An 8-bit counter at 11111111 (255) overflows to 00000000 on the next increment.</p>"},{"location":"glossary/#counter-state-diagram","title":"Counter State Diagram","text":"<p>A graphical representation showing all counter states and their transitions.</p> <p>Counter state diagrams show the counting sequence and any reset or load behavior. They help verify counter design correctness.</p> <p>Example: A mod-6 counter state diagram shows six circles (0-5) connected in a ring with arrows showing the count sequence.</p>"},{"location":"glossary/#current-state","title":"Current State","text":"<p>The present stored value in a sequential circuit.</p> <p>Current state represents what the circuit \"remembers\" from past inputs. It is stored in flip-flops and determines output and next-state behavior.</p> <p>Example: If a 2-bit counter currently holds 10, its current state is state 2.</p>"},{"location":"glossary/#d-flip-flop","title":"D Flip-Flop","text":"<p>An edge-triggered storage element that captures its D input on the active clock edge.</p> <p>The D flip-flop is the most common sequential element in digital design. It eliminates the invalid state problem of SR flip-flops.</p> <p>Example: On a rising clock edge, Q takes the value present at D. Q' takes the complement.</p>"},{"location":"glossary/#d-latch","title":"D Latch","text":"<p>A level-sensitive storage element that follows its D input while enabled and holds when disabled.</p> <p>The D latch is transparent when enable is high, allowing input changes to pass through. When enable goes low, the last value is held.</p> <p>Example: With enable high, Q tracks D. When enable falls while D=1, Q remains 1 until enable goes high again.</p>"},{"location":"glossary/#datapath-concept","title":"Datapath Concept","text":"<p>The collection of registers, ALUs, and interconnections that process data in a digital system.</p> <p>The datapath performs arithmetic, logic, and data transfer operations under control unit direction. It is the \"worker\" while the control unit is the \"manager.\"</p> <p>Example: A simple datapath might include a register file, ALU, and multiplexers connecting them.</p>"},{"location":"glossary/#de-morgans-theorem","title":"De Morgan's Theorem","text":"<p>Two fundamental Boolean identities relating AND, OR, and NOT operations.</p> <p>De Morgan's theorem states: (A + B)' = A'B' and (AB)' = A' + B'. It enables conversion between AND/OR forms and is essential for NAND/NOR implementations.</p> <p>Example: The complement of A OR B equals (NOT A) AND (NOT B): (A+B)' = A'B'.</p>"},{"location":"glossary/#debouncing","title":"Debouncing","text":"<p>A technique that eliminates the spurious transitions caused by mechanical switch bounce.</p> <p>Mechanical contacts bounce for several milliseconds when pressed. Debouncing circuits or software filters ignore transitions until the signal stabilizes.</p> <p>Example: A digital debouncer waits 20ms after a transition before accepting the new switch state.</p>"},{"location":"glossary/#decade-counter","title":"Decade Counter","text":"<p>A counter that cycles through 10 states, typically 0 through 9.</p> <p>Decade counters are BCD counters used in decimal display applications. They use 4 bits but reset after reaching 1001 (9).</p> <p>Example: A cascaded pair of decade counters can count from 00 to 99 for a two-digit display.</p>"},{"location":"glossary/#decimal-to-binary-conversion","title":"Decimal to Binary Conversion","text":"<p>The process of converting a base-10 number to base-2 representation.</p> <p>Repeated division by 2 yields binary digits from least to most significant. The remainders form the binary number read bottom-to-top.</p> <p>Example: Converting 13: 13\u00f72=6 R1, 6\u00f72=3 R0, 3\u00f72=1 R1, 1\u00f72=0 R1. Reading remainders: 1101.</p>"},{"location":"glossary/#decoder","title":"Decoder","text":"<p>A combinational circuit that activates one of 2^n outputs based on an n-bit input code.</p> <p>Decoders convert binary codes to one-hot outputs. They are essential for address decoding and control signal generation.</p> <p>Example: A 2-to-4 decoder with input 10 asserts output Y2 and deasserts Y0, Y1, Y3.</p>"},{"location":"glossary/#decoder-enable","title":"Decoder Enable","text":"<p>An input that controls whether a decoder is active or outputs are all disabled.</p> <p>Enable inputs allow cascading decoders for larger address spaces and power-saving when the decoder is not needed.</p> <p>Example: A 3-to-8 decoder with enable low produces all outputs at 0 regardless of input.</p>"},{"location":"glossary/#demux-1-to-4","title":"DEMUX 1-to-4","text":"<p>A demultiplexer that routes one input to one of four outputs based on a 2-bit select.</p> <p>Demultiplexers are the inverse of multiplexers. The selected output receives the input; other outputs remain at 0 (or high-Z).</p> <p>Example: A 1-to-4 DEMUX with input D, select=10, routes D to output Y2 while Y0, Y1, Y3 are 0.</p>"},{"location":"glossary/#demultiplexer","title":"Demultiplexer","text":"<p>A circuit that routes a single input to one of multiple outputs based on select lines.</p> <p>Demultiplexers distribute data from one source to multiple destinations. They function as the inverse of multiplexers.</p> <p>Example: A serial-to-parallel converter uses a demultiplexer to route each bit to the appropriate parallel output.</p>"},{"location":"glossary/#design-documentation","title":"Design Documentation","text":"<p>Written descriptions of design intent, architecture, interfaces, and usage.</p> <p>Documentation enables maintenance, collaboration, and reuse. It should explain \"why\" not just \"what\" and include interface specifications.</p> <p>Example: A module header comment describes purpose, ports, parameters, timing, and an example instantiation.</p>"},{"location":"glossary/#design-hierarchy","title":"Design Hierarchy","text":"<p>The organization of a digital design into nested modules at multiple levels.</p> <p>Hierarchical design manages complexity by dividing systems into manageable pieces. Each module has a clear interface and single responsibility.</p> <p>Example: A processor hierarchy: top \u2192 CPU \u2192 ALU, register file, control unit \u2192 individual gates.</p>"},{"location":"glossary/#design-reuse","title":"Design Reuse","text":"<p>The practice of using existing verified modules in new designs.</p> <p>Reuse saves development time and reduces bugs. Reusable modules should be parameterized, documented, and thoroughly tested.</p> <p>Example: A parameterized FIFO module used across multiple SoC designs without modification.</p>"},{"location":"glossary/#design-verification","title":"Design Verification","text":"<p>The process of ensuring a design meets its specifications and functions correctly.</p> <p>Verification uses simulation, formal methods, and hardware testing. It typically consumes more effort than design itself.</p> <p>Example: Running thousands of test vectors through a testbench to verify an ALU handles all edge cases.</p>"},{"location":"glossary/#digital-signal","title":"Digital Signal","text":"<p>A signal that represents data as discrete voltage levels corresponding to binary values.</p> <p>Digital signals have defined high and low voltage ranges with an undefined region between. They offer noise immunity and easy processing.</p> <p>Example: A 3.3V CMOS signal is high above 2V, low below 0.8V, with values between being indeterminate.</p>"},{"location":"glossary/#digital-system-design","title":"Digital System Design","text":"<p>The complete process of creating digital circuits from specification through implementation.</p> <p>The design flow includes specification, architecture, RTL design, synthesis, verification, and hardware testing. Each stage produces deliverables.</p> <p>Example: Designing a traffic light controller from requirements through working FPGA implementation.</p>"},{"location":"glossary/#distributive-law","title":"Distributive Law","text":"<p>A Boolean algebra law that relates AND and OR operations through factoring.</p> <p>The distributive law provides: A(B + C) = AB + AC and A + BC = (A + B)(A + C). The second form differs from regular algebra.</p> <p>Example: X(Y + Z) = XY + XZ, allowing a product-of-sums to expand to sum-of-products.</p>"},{"location":"glossary/#dont-care-condition","title":"Don't Care Condition","text":"<p>An input combination for which the output value is unspecified and can be chosen for optimization.</p> <p>Don't cares arise when certain inputs never occur or when outputs are ignored for specific inputs. They are marked as X in truth tables.</p> <p>Example: In a BCD-to-7-segment decoder, inputs 1010-1111 are don't cares since they never occur with valid BCD.</p>"},{"location":"glossary/#double-flop-synchronizer","title":"Double Flop Synchronizer","text":"<p>A metastability mitigation circuit using two flip-flops in series.</p> <p>The double-flop synchronizer allows the first flip-flop time to resolve metastability before the output propagates. It introduces 1-2 clock cycles of latency.</p> <p>Example: An asynchronous button signal passes through two flip-flops before entering the main state machine logic.</p>"},{"location":"glossary/#down-counter","title":"Down Counter","text":"<p>A counter that decrements its value on each clock cycle.</p> <p>Down counters count from a starting value toward zero. They are used in countdown timers and decrementing applications.</p> <p>Example: A 4-bit down counter loaded with 1010 counts: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, then wraps to 15.</p>"},{"location":"glossary/#dual-expression","title":"Dual Expression","text":"<p>A Boolean expression obtained by interchanging AND/OR and 0/1.</p> <p>The dual of a valid identity is also valid. This principle doubles the number of useful theorems in Boolean algebra.</p> <p>Example: The dual of A + 0 = A (identity law) is A \u00b7 1 = A.</p>"},{"location":"glossary/#duty-cycle","title":"Duty Cycle","text":"<p>The percentage of time a periodic signal is in the high state.</p> <p>Duty cycle affects power and behavior in certain applications. A 50% duty cycle means equal high and low times.</p> <p>Example: A clock with 30ns high time and 70ns low time has a 30% duty cycle.</p>"},{"location":"glossary/#dynamic-hazard","title":"Dynamic Hazard","text":"<p>A hazard where multiple output transitions occur during a single input change.</p> <p>Dynamic hazards appear in multi-level logic circuits. They produce oscillations rather than a single glitch.</p> <p>Example: An output intended to stay at 1 might transition 1\u21920\u21921\u21920\u21921 due to unequal path delays.</p>"},{"location":"glossary/#edge-triggered","title":"Edge Triggered","text":"<p>A flip-flop that samples input only at the moment of a clock transition.</p> <p>Edge triggering eliminates the transparency problems of latches. Changes at other times have no effect on the output.</p> <p>Example: A positive-edge-triggered D flip-flop ignores D changes except at the exact instant of the clock's rising edge.</p>"},{"location":"glossary/#enable-signal","title":"Enable Signal","text":"<p>A control input that allows or prevents a circuit operation.</p> <p>Enable signals gate clock inputs, data loads, or output drives. When disabled, the circuit typically holds its current state.</p> <p>Example: A register with EN=0 ignores load commands and retains its stored value.</p>"},{"location":"glossary/#encoder","title":"Encoder","text":"<p>A combinational circuit that produces a binary code corresponding to its active input.</p> <p>Encoders compress one-hot inputs to binary codes. They are the inverse of decoders and require priority handling when multiple inputs are active.</p> <p>Example: An 8-to-3 encoder with input 5 active (00100000) outputs binary 101.</p>"},{"location":"glossary/#equality-comparator","title":"Equality Comparator","text":"<p>A circuit that determines whether two binary values are equal.</p> <p>Equality comparators output 1 when A equals B and 0 otherwise. They use XNOR gates to check each bit pair.</p> <p>Example: An 8-bit equality comparator outputs 1 when both inputs are 01101110.</p>"},{"location":"glossary/#error-detection","title":"Error Detection","text":"<p>A technique for identifying when data has been corrupted during transmission or storage.</p> <p>Error detection adds redundant bits (like parity) that allow detecting certain error patterns. It does not correct errors.</p> <p>Example: A byte with even parity has a parity bit added so the total number of 1s is even.</p>"},{"location":"glossary/#essential-prime-implicant","title":"Essential Prime Implicant","text":"<p>A prime implicant that covers at least one minterm not covered by any other prime implicant.</p> <p>Essential prime implicants must be included in any minimal cover. Finding them is a key step in K-map simplification.</p> <p>Example: If minterm m5 is covered only by prime implicant AB', then AB' is essential.</p>"},{"location":"glossary/#factoring","title":"Factoring","text":"<p>A Boolean simplification technique that extracts common factors from terms.</p> <p>Factoring applies the distributive law in reverse to reduce gate count or logic levels.</p> <p>Example: WX + WY + WZ factors to W(X + Y + Z), reducing from 3 AND gates to 1 AND and 1 OR.</p>"},{"location":"glossary/#fall-time","title":"Fall Time","text":"<p>The time for a signal to transition from high to low logic level.</p> <p>Fall time affects propagation delay and switching speed. It depends on transistor characteristics and load capacitance.</p> <p>Example: A fall time specification of 3ns means the output takes 3ns to fall from 90% to 10% of its swing.</p>"},{"location":"glossary/#falling-edge","title":"Falling Edge","text":"<p>The transition of a digital signal from high to low.</p> <p>Falling edge-triggered circuits change state at the 1-to-0 transition. The falling edge is also called the negative edge.</p> <p>Example: A negative-edge-triggered flip-flop samples D at the instant the clock transitions from 1 to 0.</p>"},{"location":"glossary/#fan-in","title":"Fan-In","text":"<p>The number of inputs to a logic gate.</p> <p>Fan-in affects gate delay and drive capability. Higher fan-in gates are slower and consume more power.</p> <p>Example: A 4-input NAND gate has a fan-in of 4.</p>"},{"location":"glossary/#fan-out","title":"Fan-Out","text":"<p>The number of gate inputs that a gate output can drive.</p> <p>Fan-out is limited by the output drive current and input loading. Exceeding fan-out degrades signal quality and timing.</p> <p>Example: If a gate has fan-out of 10, it can reliably drive up to 10 standard gate inputs.</p>"},{"location":"glossary/#feedback-loop","title":"Feedback Loop","text":"<p>A signal path from a circuit's output back to its input.</p> <p>Feedback creates memory by allowing outputs to influence future states. It is essential for sequential circuits but can cause oscillation if uncontrolled.</p> <p>Example: Cross-coupled NAND gates form an SR latch through feedback from each gate's output to the other's input.</p>"},{"location":"glossary/#finite-state-machine","title":"Finite State Machine","text":"<p>A sequential circuit model with a finite number of states, transitions, and outputs.</p> <p>FSMs are the primary design model for sequential logic. They can be Moore machines (output depends on state) or Mealy machines (output depends on state and input).</p> <p>Example: A traffic light controller FSM has states like Green, Yellow, Red with timed transitions.</p>"},{"location":"glossary/#flip-flop-symbol","title":"Flip-Flop Symbol","text":"<p>The standard graphical representation of a flip-flop in circuit diagrams.</p> <p>Flip-flop symbols show a rectangle with labeled inputs (D, CLK, RST) and outputs (Q, Q'). Clock inputs have triangular edge indicators.</p> <p>Example: A D flip-flop symbol shows D input on left, Q/Q' outputs on right, and clock with triangle on bottom.</p>"},{"location":"glossary/#fpga-architecture","title":"FPGA Architecture","text":"<p>The internal structure of an FPGA including logic blocks, routing, and I/O.</p> <p>FPGA architecture determines capacity, speed, and power characteristics. Understanding it helps optimize designs for the target device.</p> <p>Example: Xilinx 7-series FPGAs contain CLBs with LUT6 elements, flip-flops, and carry chains.</p>"},{"location":"glossary/#fpga-flip-flop","title":"FPGA Flip-Flop","text":"<p>A configurable storage element within an FPGA logic block.</p> <p>FPGA flip-flops are typically D-type with optional clock enable, set, and reset. They work with LUTs to implement sequential logic.</p> <p>Example: Each Xilinx CLB slice contains 8 flip-flops that can be used for registers and state storage.</p>"},{"location":"glossary/#fpga-implementation","title":"FPGA Implementation","text":"<p>The process of mapping, placing, and routing a design onto an FPGA.</p> <p>Implementation transforms synthesized netlists to bitstreams that configure FPGA resources. It includes optimization and timing closure.</p> <p>Example: Running Vivado implementation converts Verilog to a bitfile that programs the FPGA.</p>"},{"location":"glossary/#fpga-lut","title":"FPGA LUT","text":"<p>A look-up table that implements combinational logic by storing truth table values.</p> <p>FPGA LUTs can implement any Boolean function of their inputs. Modern FPGAs typically use 6-input LUTs.</p> <p>Example: A LUT6 stores 64 bits representing all outputs for a 6-input function like F = ABC + DEF.</p>"},{"location":"glossary/#fpga-routing","title":"FPGA Routing","text":"<p>The programmable interconnection resources that connect logic blocks in an FPGA.</p> <p>Routing resources consume significant FPGA area and affect timing. Congestion can prevent timing closure.</p> <p>Example: Switch boxes and routing channels connect LUT outputs to flip-flop inputs across the FPGA fabric.</p>"},{"location":"glossary/#fsm-design-process","title":"FSM Design Process","text":"<p>The systematic procedure for designing finite state machines from specifications.</p> <p>The process includes: define states, draw state diagram, create state table, choose encoding, derive next-state and output equations, implement with flip-flops.</p> <p>Example: Designing a coin-operated lock: identify states, transitions for correct/wrong combinations, output to unlock.</p>"},{"location":"glossary/#fsm-state","title":"FSM State","text":"<p>A distinct condition of a finite state machine representing stored information.</p> <p>Each FSM state corresponds to a unique flip-flop combination. States represent what the machine \"remembers\" about input history.</p> <p>Example: A vending machine FSM has states for 0\u00a2, 25\u00a2, 50\u00a2, 75\u00a2 representing accumulated payment.</p>"},{"location":"glossary/#fsm-verification","title":"FSM Verification","text":"<p>The process of ensuring a finite state machine correctly implements its specification.</p> <p>Verification checks all state transitions, outputs, and edge cases. It uses simulation, formal verification, and test vectors.</p> <p>Example: Testing a sequence detector by applying all possible input patterns and checking outputs.</p>"},{"location":"glossary/#full-adder","title":"Full Adder","text":"<p>A combinational circuit that adds three input bits and produces a sum and carry output.</p> <p>Full adders handle the carry from a previous stage, enabling multi-bit addition. They chain together to form ripple-carry adders.</p> <p>Example: A full adder with inputs A=1, B=1, Cin=1 produces Sum=1 and Cout=1.</p>"},{"location":"glossary/#functional-completeness","title":"Functional Completeness","text":"<p>The property of a gate set being able to implement any Boolean function.</p> <p>A functionally complete set can express all possible logic functions. NAND alone and NOR alone are each functionally complete.</p> <p>Example: Any circuit can be built using only NAND gates because NAND is functionally complete.</p>"},{"location":"glossary/#functional-verification","title":"Functional Verification","text":"<p>Verification that a design produces correct outputs for all valid inputs.</p> <p>Functional verification ignores timing and focuses on logical correctness. It typically uses simulation with comprehensive test vectors.</p> <p>Example: Verifying an ALU produces correct results for all opcodes across a range of operand values.</p>"},{"location":"glossary/#gate-delay","title":"Gate Delay","text":"<p>The time for a signal change to propagate through a single logic gate.</p> <p>Gate delay limits circuit speed and causes timing hazards. It varies with gate type, technology, and loading.</p> <p>Example: A NAND gate with 2ns delay produces its output 2ns after inputs change.</p>"},{"location":"glossary/#gate-symbol","title":"Gate Symbol","text":"<p>The standardized graphical shape representing a logic gate in schematics.</p> <p>Gate symbols convey function at a glance. Different standards (ANSI, IEEE, IEC) use different shapes.</p> <p>Example: The AND gate uses a flat-backed D shape; OR uses a curved back with pointed output.</p>"},{"location":"glossary/#gate-level-design","title":"Gate-Level Design","text":"<p>Creating circuits by interconnecting individual logic gates.</p> <p>Gate-level design is the lowest abstraction above transistors. It maps directly to physical implementation.</p> <p>Example: Drawing an XOR gate as two ANDs, two inverters, and an OR gate connected together.</p>"},{"location":"glossary/#gate-level-verilog","title":"Gate-Level Verilog","text":"<p>Verilog code that explicitly instantiates primitive gate components.</p> <p>Gate-level modeling directly represents the physical circuit structure. It is generated by synthesis tools or used for small designs.</p> <p>Example: <code>and g1(y, a, b);</code> instantiates a 2-input AND gate with output y and inputs a, b.</p>"},{"location":"glossary/#gated-sr-latch","title":"Gated SR Latch","text":"<p>An SR latch with an enable input that controls when changes can occur.</p> <p>The gate (enable) input prevents state changes when low, providing a form of clock control. It is a precursor to flip-flops.</p> <p>Example: A gated SR latch with E=0 ignores S and R inputs, holding its current Q value.</p>"},{"location":"glossary/#gray-code","title":"Gray Code","text":"<p>A binary code where consecutive values differ by exactly one bit.</p> <p>Gray code eliminates multi-bit transitions, preventing glitches in position encoders and reducing errors in asynchronous domain crossings.</p> <p>Example: 3-bit Gray code sequence: 000, 001, 011, 010, 110, 111, 101, 100.</p>"},{"location":"glossary/#gray-code-encoding","title":"Gray Code Encoding","text":"<p>Using Gray code values to represent FSM states.</p> <p>Gray encoding ensures only one flip-flop changes per transition, reducing power and glitches. It is useful for asynchronous interfaces.</p> <p>Example: A 4-state FSM using Gray encoding: S0=00, S1=01, S2=11, S3=10.</p>"},{"location":"glossary/#half-adder","title":"Half Adder","text":"<p>A combinational circuit that adds two input bits and produces a sum and carry.</p> <p>Half adders handle single-bit addition without an incoming carry. They serve as the first stage of ripple-carry adders.</p> <p>Example: A half adder with A=1 and B=1 produces Sum=0 and Carry=1.</p>"},{"location":"glossary/#hardware-software-boundary","title":"Hardware-Software Boundary","text":"<p>The interface between hardware logic and software processing in a digital system.</p> <p>The boundary determines what functionality is implemented in FPGA/ASIC versus processor code. It affects performance, flexibility, and development time.</p> <p>Example: Video decompression in hardware for speed, user interface in software for flexibility.</p>"},{"location":"glossary/#hazard","title":"Hazard","text":"<p>A momentary incorrect output caused by unequal propagation delays in a circuit.</p> <p>Hazards create glitches that can cause problems in asynchronous circuits or when outputs directly drive state machines.</p> <p>Example: An output that should remain at 1 glitches to 0 briefly due to different path delays.</p>"},{"location":"glossary/#hazard-free-design","title":"Hazard-Free Design","text":"<p>Circuit design techniques that eliminate or mask unwanted glitches.</p> <p>Hazard elimination adds redundant terms to cover transition boundaries. Hazard-free design is critical for asynchronous circuits.</p> <p>Example: Adding term AC to F = AB + B'C eliminates the hazard when B transitions.</p>"},{"location":"glossary/#hdl-vs-programming","title":"HDL vs Programming","text":"<p>The distinction between hardware description languages and software programming languages.</p> <p>HDLs describe hardware structure and behavior; they do not execute sequentially. Understanding this difference is critical for digital designers.</p> <p>Example: In Verilog, two always blocks execute concurrently, unlike sequential function calls in C.</p>"},{"location":"glossary/#hex-to-binary-conversion","title":"Hex to Binary Conversion","text":"<p>Converting hexadecimal digits to their 4-bit binary equivalents.</p> <p>Each hex digit directly maps to 4 binary bits, making conversion straightforward. This is faster than decimal conversion.</p> <p>Example: Hex A3 converts to binary 1010 0011 (A=1010, 3=0011).</p>"},{"location":"glossary/#hexadecimal-numbers","title":"Hexadecimal Numbers","text":"<p>A base-16 number system using digits 0-9 and letters A-F.</p> <p>Hexadecimal provides a compact representation of binary values. Each hex digit represents exactly 4 bits.</p> <p>Example: The 8-bit binary 11101010 is written as hex EA.</p>"},{"location":"glossary/#hierarchical-design","title":"Hierarchical Design","text":"<p>Organizing complex systems as nested modules at multiple abstraction levels.</p> <p>Hierarchical design enables divide-and-conquer approaches, code reuse, and team collaboration. Each module has defined interfaces.</p> <p>Example: A CPU module contains submodules for ALU, registers, and control, each defined separately.</p>"},{"location":"glossary/#hold-time","title":"Hold Time","text":"<p>The minimum time a flip-flop input must remain stable after the clock edge.</p> <p>Hold violations cause data to be captured incorrectly. They typically result from fast paths between flip-flops.</p> <p>Example: With a hold time of 0.5ns, the D input must remain stable for 0.5ns after the clock edge.</p>"},{"location":"glossary/#idempotent-law","title":"Idempotent Law","text":"<p>A Boolean law stating that applying an operation to identical operands yields the same operand.</p> <p>The idempotent law gives: A + A = A and A \u00b7 A = A. It eliminates redundant terms in expressions.</p> <p>Example: In X + X + X, the idempotent law reduces this to simply X.</p>"},{"location":"glossary/#identity-law","title":"Identity Law","text":"<p>A Boolean law stating that a variable combined with the identity element remains unchanged.</p> <p>For OR, the identity is 0: A + 0 = A. For AND, the identity is 1: A \u00b7 1 = A.</p> <p>Example: X AND 1 = X, so ANDing with 1 has no effect on the value.</p>"},{"location":"glossary/#ieee-gate-symbols","title":"IEEE Gate Symbols","text":"<p>Logic gate symbols following IEEE/IEC 60617 standard using rectangular shapes.</p> <p>IEEE symbols use rectangles with function indicators (&amp; for AND, \u22651 for OR). They differ from the curved ANSI symbols.</p> <p>Example: An IEEE AND gate is a rectangle with \"&amp;\" inside and inputs on the left.</p>"},{"location":"glossary/#if-else-in-verilog","title":"If-Else in Verilog","text":"<p>A conditional construct for selecting between alternatives in procedural blocks.</p> <p>If-else statements model priority encoders and conditional logic. Incomplete coverage can infer latches.</p> <p>Example: <code>if (sel) y = a; else y = b;</code> implements a 2-to-1 multiplexer.</p>"},{"location":"glossary/#implicant-cover","title":"Implicant Cover","text":"<p>A set of product terms whose OR equals a Boolean function.</p> <p>Finding a minimal cover (fewest terms) is the goal of logic minimization. K-maps and Quine-McCluskey find minimum covers.</p> <p>Example: For F = \u03a3(0,1,2,3), the cover {A'B', A'B, AB', AB} reduces to just {1}.</p>"},{"location":"glossary/#initial-block","title":"Initial Block","text":"<p>A Verilog procedural block that executes once at time zero.</p> <p>Initial blocks set up testbench conditions and are not synthesizable. They initialize signals and launch stimulus generation.</p> <p>Example: <code>initial begin clk = 0; reset = 1; #10 reset = 0; end</code></p>"},{"location":"glossary/#inout-port","title":"Inout Port","text":"<p>A Verilog port declaration for bidirectional signals.</p> <p>Inout ports connect to tri-state drivers for bus interfaces. They require careful handling to avoid driver conflicts.</p> <p>Example: <code>inout wire [7:0] data_bus;</code> declares an 8-bit bidirectional bus.</p>"},{"location":"glossary/#input-port","title":"Input Port","text":"<p>A Verilog port that receives signals from outside the module.</p> <p>Input ports are read-only within the module. They connect to wires or expressions in instantiating modules.</p> <p>Example: <code>input wire clk, reset;</code> declares clock and reset as input signals.</p>"},{"location":"glossary/#invalid-state-problem","title":"Invalid State Problem","text":"<p>The condition in an SR latch where both set and reset are active simultaneously.</p> <p>When S=R=1, an SR latch produces Q=Q'=0, violating the complementary relationship. This state is forbidden.</p> <p>Example: An SR latch with S=1, R=1 followed by S=0, R=0 produces an unpredictable output.</p>"},{"location":"glossary/#jk-flip-flop","title":"JK Flip-Flop","text":"<p>A flip-flop with J and K inputs that provides set, reset, hold, and toggle functions.</p> <p>The JK flip-flop eliminates the invalid state of SR latches. When J=K=1, it toggles on each clock edge.</p> <p>Example: JK flip-flop: J=0,K=0 holds; J=1,K=0 sets; J=0,K=1 resets; J=1,K=1 toggles.</p>"},{"location":"glossary/#jk-toggle-mode","title":"JK Toggle Mode","text":"<p>The operating mode of a JK flip-flop when both J and K are high.</p> <p>Toggle mode inverts the output on each clock edge. It enables frequency division and counter design.</p> <p>Example: A JK flip-flop with J=K=1 toggles: 0\u21921\u21920\u21921 on successive clock edges.</p>"},{"location":"glossary/#johnson-counter","title":"Johnson Counter","text":"<p>A shift register counter that produces overlapping decoded outputs.</p> <p>A Johnson (twisted ring) counter shifts inverted feedback, creating 2n states from n flip-flops. States are easily decoded.</p> <p>Example: A 4-bit Johnson counter sequences: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000...</p>"},{"location":"glossary/#k-map-2-variable","title":"K-Map 2 Variable","text":"<p>A Karnaugh map with 4 cells for minimizing 2-variable Boolean functions.</p> <p>The 2x2 grid arranges cells by Gray code ordering. Adjacent cells differ by one variable.</p> <p>Example: A 2-variable K-map has cells for A'B', A'B, AB', AB arranged in a 2x2 square.</p>"},{"location":"glossary/#k-map-3-variable","title":"K-Map 3 Variable","text":"<p>A Karnaugh map with 8 cells for minimizing 3-variable Boolean functions.</p> <p>The 2x4 grid maintains adjacency including wraparound. Groups of 1, 2, 4, or 8 cells form simplified terms.</p> <p>Example: A 3-variable K-map covers minterms m0-m7 in cells arranged by Gray code for AB (columns) and C (rows).</p>"},{"location":"glossary/#k-map-4-variable","title":"K-Map 4 Variable","text":"<p>A Karnaugh map with 16 cells for minimizing 4-variable Boolean functions.</p> <p>The 4x4 grid provides adjacency in both dimensions with wraparound. It is the largest K-map size commonly used manually.</p> <p>Example: A 4-variable K-map arranges 16 minterms by Gray code for AB (rows) and CD (columns).</p>"},{"location":"glossary/#k-map-grouping-rules","title":"K-Map Grouping Rules","text":"<p>The rules for forming valid groups of cells in a Karnaugh map.</p> <p>Groups must be rectangular, contain 2^n cells, and include only 1s (for SOP) or 0s (for POS). Larger groups yield simpler terms.</p> <p>Example: Valid groups are 1, 2, 4, 8, or 16 cells. Groups can wrap around edges and corners.</p>"},{"location":"glossary/#karnaugh-map","title":"Karnaugh Map","text":"<p>A graphical method for simplifying Boolean expressions using a grid of cells.</p> <p>K-maps arrange minterms so adjacent cells differ by one variable. Grouping adjacent 1s visually identifies simplified product terms.</p> <p>Example: In a K-map, grouping four adjacent cells eliminates two variables from the product term.</p>"},{"location":"glossary/#latch-timing-problem","title":"Latch Timing Problem","text":"<p>Difficulties arising from the level-sensitive behavior of latches.</p> <p>Transparent latches allow input changes to propagate during enable, causing race conditions and timing unpredictability.</p> <p>Example: A D latch enabled during logic changes may capture an intermediate value rather than the intended final value.</p>"},{"location":"glossary/#led-indicator","title":"LED Indicator","text":"<p>A light-emitting diode used to display digital output states.</p> <p>LEDs provide visual feedback for debugging and status display. They require current-limiting resistors to prevent damage.</p> <p>Example: An FPGA output drives an LED through a 220\u03a9 resistor to indicate when a signal is high.</p>"},{"location":"glossary/#level-sensitive","title":"Level Sensitive","text":"<p>Storage element behavior where output tracks input while enable is active.</p> <p>Level-sensitive latches are transparent when enabled. Changes at input pass directly to output without waiting for a clock edge.</p> <p>Example: A D latch with enable high shows any D changes immediately at Q.</p>"},{"location":"glossary/#load-signal","title":"Load Signal","text":"<p>A control input that commands a register to capture new data.</p> <p>Load signals, when asserted with the clock, cause registers to store the value at their data inputs. Otherwise the register holds its value.</p> <p>Example: With LD=1, a register captures input data on the clock edge; with LD=0, it retains its value.</p>"},{"location":"glossary/#logic-analyzer","title":"Logic Analyzer","text":"<p>A test instrument that captures and displays multiple digital signals over time.</p> <p>Logic analyzers show timing relationships between signals and can decode protocols. They are essential for debugging digital systems.</p> <p>Example: A 16-channel logic analyzer captures SPI bus transactions showing clock, data, and chip select timing.</p>"},{"location":"glossary/#logic-family","title":"Logic Family","text":"<p>A group of integrated circuits with compatible electrical characteristics.</p> <p>Logic families (TTL, CMOS, etc.) define voltage levels, speed, and power characteristics. Interfacing between families may require level conversion.</p> <p>Example: 74HC series is a CMOS logic family compatible with TTL input levels.</p>"},{"location":"glossary/#logic-gate","title":"Logic Gate","text":"<p>A fundamental circuit element that implements a Boolean operation.</p> <p>Logic gates are the building blocks of digital circuits. They combine to form all digital functions from simple AND to complex processors.</p> <p>Example: A NAND gate implements the function Y = (AB)', outputting 0 only when both inputs are 1.</p>"},{"location":"glossary/#logic-levels","title":"Logic Levels","text":"<p>The defined voltage ranges representing logic 0 and logic 1.</p> <p>Logic levels specify valid high and low voltage ranges. The gap between them provides noise margin.</p> <p>Example: 3.3V CMOS defines logic low as 0-0.8V and logic high as 2.0-3.3V.</p>"},{"location":"glossary/#logic-minimization","title":"Logic Minimization","text":"<p>The process of reducing a Boolean expression to fewer terms or literals.</p> <p>Minimization reduces gate count, improving cost, speed, and power. K-maps and Quine-McCluskey are common methods.</p> <p>Example: F = AB + AB' + A'B minimizes to F = A + A'B = A + B.</p>"},{"location":"glossary/#logic-probe","title":"Logic Probe","text":"<p>A simple test tool that indicates the logic level at a circuit point.</p> <p>Logic probes show high, low, or pulsing conditions. They provide quick verification without complex instruments.</p> <p>Example: Touching a logic probe to a clock pin shows a blinking LED indicating oscillation.</p>"},{"location":"glossary/#magnitude-comparator","title":"Magnitude Comparator","text":"<p>A circuit that determines whether A is greater than, less than, or equal to B.</p> <p>Magnitude comparators produce three outputs (A&gt;B, A&lt;B, A=B) for complete ordering. They cascade for wider comparisons.</p> <p>Example: A 4-bit magnitude comparator outputs A&gt;B=1 when A=1010 and B=0111.</p>"},{"location":"glossary/#master-slave-flip-flop","title":"Master-Slave Flip-Flop","text":"<p>A flip-flop constructed from two latches where one captures while the other holds.</p> <p>The master latch captures input during one clock phase while the slave latch output remains stable. Roles swap on the clock edge.</p> <p>Example: In a master-slave D flip-flop, the master captures D when CLK is high; the slave updates Q when CLK falls.</p>"},{"location":"glossary/#maxterm","title":"Maxterm","text":"<p>A sum term in which each variable appears exactly once in true or complemented form.</p> <p>Maxterms are the product-of-sums equivalent of minterms. A maxterm equals 0 for exactly one input combination.</p> <p>Example: For 3 variables ABC, maxterm M5 (for 101) is A'+B+C' = 0 only when A=1, B=0, C=1.</p>"},{"location":"glossary/#mealy-machine","title":"Mealy Machine","text":"<p>A finite state machine whose outputs depend on both current state and current inputs.</p> <p>Mealy machines can react faster than Moore machines because outputs can change immediately with inputs, not just at state transitions.</p> <p>Example: A Mealy sequence detector outputs 1 as soon as the final pattern bit arrives, not on the next clock.</p>"},{"location":"glossary/#mealy-output","title":"Mealy Output","text":"<p>An FSM output that depends on both current state and current inputs.</p> <p>Mealy outputs can change asynchronously with inputs within a clock cycle. They enable faster response but may have glitches.</p> <p>Example: In a Mealy machine, output Z = state \u00d7 input means Z can change when input changes, even mid-cycle.</p>"},{"location":"glossary/#memory-element","title":"Memory Element","text":"<p>A circuit capable of storing one bit of information.</p> <p>Memory elements form the foundation of sequential logic. They retain their state until explicitly changed by inputs or power loss.</p> <p>Example: A D flip-flop is a memory element that stores one bit, captured on each clock edge.</p>"},{"location":"glossary/#metastability","title":"Metastability","text":"<p>An unstable intermediate state when a flip-flop samples a transitioning input.</p> <p>Metastability produces an unpredictable output that takes random time to resolve. It occurs when setup/hold times are violated.</p> <p>Example: Sampling an asynchronous signal may cause the flip-flop output to hover between 0 and 1 momentarily.</p>"},{"location":"glossary/#minimal-form","title":"Minimal Form","text":"<p>A Boolean expression with the fewest possible terms and literals.</p> <p>Minimal forms reduce implementation cost. They are found through K-maps, Quine-McCluskey, or synthesis tools.</p> <p>Example: F = AB + AB' + A'B has minimal form F = A + B.</p>"},{"location":"glossary/#minimal-pos","title":"Minimal POS","text":"<p>The simplified product-of-sums form of a Boolean function.</p> <p>Minimal POS is derived by grouping 0s in a K-map. It may use fewer gates than minimal SOP for some functions.</p> <p>Example: F(A,B,C) with 0s at m0,m2,m4 has minimal POS form (A+B)(A+C).</p>"},{"location":"glossary/#minimal-sop","title":"Minimal SOP","text":"<p>The simplified sum-of-products form of a Boolean function.</p> <p>Minimal SOP has the fewest possible product terms. It is derived by grouping 1s in a K-map.</p> <p>Example: F = A'BC + AB'C + ABC' + ABC minimizes to F = AC + BC + AB.</p>"},{"location":"glossary/#minterm","title":"Minterm","text":"<p>A product term in which each variable appears exactly once in true or complemented form.</p> <p>Minterms correspond to single rows in a truth table. A minterm equals 1 for exactly one input combination.</p> <p>Example: For 3 variables ABC, minterm m5 (for 101) is AB'C.</p>"},{"location":"glossary/#mod-n-counter","title":"Mod-N Counter","text":"<p>A counter that cycles through exactly N states before repeating.</p> <p>Mod-N counters divide frequency by N. They use N states regardless of the number of flip-flops.</p> <p>Example: A mod-6 counter counts 0,1,2,3,4,5,0,1,2,3,4,5... using 3 flip-flops.</p>"},{"location":"glossary/#module-definition","title":"Module Definition","text":"<p>The Verilog construct that encapsulates a design unit with ports and internal logic.</p> <p>Modules define interface (ports) and implementation (statements). They are the basic unit of hierarchy in Verilog.</p> <p>Example: <code>module adder(input a, b, output sum, cout);</code> begins a 1-bit adder module definition.</p>"},{"location":"glossary/#module-instantiation","title":"Module Instantiation","text":"<p>Creating an instance of a module within another module in Verilog.</p> <p>Instantiation connects module ports to signals in the parent module. It enables hierarchical design and component reuse.</p> <p>Example: <code>adder u1(.a(x), .b(y), .sum(s), .cout(c));</code> instantiates adder module u1.</p>"},{"location":"glossary/#moore-machine","title":"Moore Machine","text":"<p>A finite state machine whose outputs depend only on the current state.</p> <p>Moore machine outputs are associated with states, not transitions. They change only when state changes, providing more predictable timing.</p> <p>Example: A Moore traffic light controller output (Green/Yellow/Red) depends only on which state it's in.</p>"},{"location":"glossary/#moore-output","title":"Moore Output","text":"<p>An FSM output that depends solely on the current state.</p> <p>Moore outputs are stable throughout a state and change only with state transitions. This simplifies timing analysis.</p> <p>Example: In a Moore FSM, output Z is assigned to states, so Z only changes at clock edges when state changes.</p>"},{"location":"glossary/#mtbf-concept","title":"MTBF Concept","text":"<p>Mean Time Between Failures, used to quantify metastability risk.</p> <p>MTBF for synchronizers depends on clock frequency, data rate, and flip-flop characteristics. Higher MTBF means better reliability.</p> <p>Example: A synchronizer with MTBF of 100 years is expected to fail from metastability once per century on average.</p>"},{"location":"glossary/#multi-level-logic","title":"Multi-Level Logic","text":"<p>Logic circuits with more than two levels of gates between inputs and outputs.</p> <p>Multi-level logic trades delay for reduced gate count. It can implement complex functions more efficiently than two-level forms.</p> <p>Example: F = (A + B)(C + D) is two-level; F = ((A + B) \u00b7 C) + D is three-level.</p>"},{"location":"glossary/#multiplexer","title":"Multiplexer","text":"<p>A combinational circuit that selects one of multiple inputs to pass to the output.</p> <p>Multiplexers route data based on select signals. An n-input MUX requires log2(n) select lines.</p> <p>Example: A 4-to-1 MUX with select=10 passes input I2 to output Y.</p>"},{"location":"glossary/#mux-2-to-1","title":"MUX 2-to-1","text":"<p>A multiplexer that selects between two inputs based on one select line.</p> <p>The simplest multiplexer, 2-to-1 MUX outputs I0 when S=0 and I1 when S=1.</p> <p>Example: <code>assign y = sel ? i1 : i0;</code> implements a 2-to-1 MUX in Verilog.</p>"},{"location":"glossary/#mux-4-to-1","title":"MUX 4-to-1","text":"<p>A multiplexer that selects one of four inputs based on a 2-bit select code.</p> <p>A 4-to-1 MUX uses two select bits to choose among I0-I3.</p> <p>Example: MUX 4-to-1 with S1S0=10 outputs I2.</p>"},{"location":"glossary/#mux-8-to-1","title":"MUX 8-to-1","text":"<p>A multiplexer that selects one of eight inputs based on a 3-bit select code.</p> <p>An 8-to-1 MUX uses three select bits to choose among I0-I7.</p> <p>Example: MUX 8-to-1 with S2S1S0=101 outputs I5.</p>"},{"location":"glossary/#mux-as-logic-function","title":"MUX as Logic Function","text":"<p>Using a multiplexer to implement any Boolean function directly.</p> <p>A 2^n-to-1 MUX with variables on select lines and constants on data inputs implements an n-variable function without other gates.</p> <p>Example: A 4-to-1 MUX implements F(A,B) by connecting truth table outputs to data inputs and AB to select.</p>"},{"location":"glossary/#mux-tree","title":"MUX Tree","text":"<p>A cascade of multiplexers used to select from many inputs.</p> <p>MUX trees build large multiplexers from smaller ones. They enable efficient implementation of wide select functions.</p> <p>Example: Two 4-to-1 MUXes feeding a 2-to-1 MUX create an 8-to-1 MUX tree.</p>"},{"location":"glossary/#nand-gate","title":"NAND Gate","text":"<p>A logic gate that outputs 0 only when all inputs are 1.</p> <p>NAND implements the complement of AND. It is functionally complete, meaning any circuit can be built from NAND gates alone.</p> <p>Example: A 2-input NAND with A=1, B=1 outputs Y=0; any other input combination outputs Y=1.</p>"},{"location":"glossary/#nand-only-design","title":"NAND-Only Design","text":"<p>Implementing a circuit using exclusively NAND gates.</p> <p>Since NAND is functionally complete, any Boolean function can be realized with NAND gates only. This simplifies manufacturing.</p> <p>Example: An inverter using NAND: connect both inputs of a 2-input NAND together.</p>"},{"location":"glossary/#negedge-keyword","title":"Negedge Keyword","text":"<p>The Verilog keyword specifying sensitivity to falling clock edges.</p> <p>Negedge triggers always blocks on the 1-to-0 transition, enabling negative-edge-triggered sequential logic.</p> <p>Example: <code>always @(negedge clk) q &lt;= d;</code> creates a falling-edge-triggered flip-flop.</p>"},{"location":"glossary/#negative-edge-triggered","title":"Negative Edge Triggered","text":"<p>A flip-flop that samples input at the falling clock transition.</p> <p>Negative edge triggering uses the 1-to-0 clock transition as the sampling point.</p> <p>Example: A negative-edge D flip-flop captures D when clock falls from 1 to 0.</p>"},{"location":"glossary/#next-state","title":"Next State","text":"<p>The state a sequential circuit will enter on the next clock edge.</p> <p>Next state is computed from current state and inputs. Next-state logic is the combinational circuitry that determines it.</p> <p>Example: In state S1 with input X=1, the next state might be S3 based on state transition rules.</p>"},{"location":"glossary/#next-state-equation","title":"Next State Equation","text":"<p>A Boolean equation defining the next-state value for each flip-flop.</p> <p>Next-state equations drive flip-flop D inputs. They implement the state transition table in combinational logic.</p> <p>Example: For a 2-bit counter, D1 = Q1 XOR Q0 (next state of bit 1 depends on current state).</p>"},{"location":"glossary/#next-state-logic","title":"Next State Logic","text":"<p>The combinational circuit that computes the next state from current state and inputs.</p> <p>Next-state logic implements the state transition function. Its complexity depends on encoding and FSM structure.</p> <p>Example: In a Moore FSM, next-state logic takes current state flip-flop outputs and inputs to produce D inputs.</p>"},{"location":"glossary/#noise-margin","title":"Noise Margin","text":"<p>The voltage difference between worst-case output and worst-case input thresholds.</p> <p>Larger noise margins provide better immunity to electrical interference. They define how much noise a signal can tolerate.</p> <p>Example: If output-low max is 0.4V and input-low max is 0.8V, the low noise margin is 0.4V.</p>"},{"location":"glossary/#non-blocking-assignment","title":"Non-Blocking Assignment","text":"<p>A Verilog procedural assignment (&lt;=) that schedules updates for the end of the time step.</p> <p>Non-blocking assignments model synchronous register transfers. All right-hand sides are evaluated before any updates occur.</p> <p>Example: <code>a &lt;= b; b &lt;= a;</code> swaps a and b because both read old values before updating.</p>"},{"location":"glossary/#non-overlapping-detection","title":"Non-Overlapping Detection","text":"<p>A sequence detection mode where a pattern cannot share bits with the next instance.</p> <p>Non-overlapping detectors reset fully after finding a pattern. The detector must see an entirely new pattern before triggering again.</p> <p>Example: Detecting \"101\" non-overlapping in \"10101\" triggers only once, not twice.</p>"},{"location":"glossary/#non-synthesizable-code","title":"Non-Synthesizable Code","text":"<p>Verilog constructs that cannot be converted to hardware by synthesis tools.</p> <p>Delays, initial blocks, and $display are simulation-only. Using them in synthesizable code causes errors or is ignored.</p> <p>Example: <code>#10 x = 1;</code> is non-synthesizable because hardware cannot implement arbitrary time delays.</p>"},{"location":"glossary/#nor-gate","title":"NOR Gate","text":"<p>A logic gate that outputs 1 only when all inputs are 0.</p> <p>NOR implements the complement of OR. Like NAND, it is functionally complete.</p> <p>Example: A 2-input NOR with A=0, B=0 outputs Y=1; any input being 1 outputs Y=0.</p>"},{"location":"glossary/#nor-only-design","title":"NOR-Only Design","text":"<p>Implementing a circuit using exclusively NOR gates.</p> <p>NOR gates alone can implement any Boolean function. This provides manufacturing flexibility similar to NAND-only design.</p> <p>Example: An inverter using NOR: connect both inputs of a 2-input NOR together.</p>"},{"location":"glossary/#not-gate","title":"NOT Gate","text":"<p>A logic gate that outputs the complement of its input.</p> <p>NOT implements logical negation. It is also called an inverter.</p> <p>Example: A NOT gate with input A=1 outputs Y=0.</p>"},{"location":"glossary/#not-operation","title":"NOT Operation","text":"<p>A Boolean operation that inverts its operand.</p> <p>NOT is a unary operation returning the complement: 0 becomes 1, 1 becomes 0.</p> <p>Example: NOT 1 = 0; NOT 0 = 1.</p>"},{"location":"glossary/#null-law","title":"Null Law","text":"<p>A Boolean law stating that combining a variable with a null element yields the null element.</p> <p>For OR with 1 (null for OR): A + 1 = 1. For AND with 0 (null for AND): A \u00b7 0 = 0.</p> <p>Example: X OR 1 always equals 1, regardless of X.</p>"},{"location":"glossary/#octal-numbers","title":"Octal Numbers","text":"<p>A base-8 number system using digits 0-7.</p> <p>Octal groups binary digits in threes, providing more compact notation than binary. It was historically important but less common than hexadecimal today.</p> <p>Example: Binary 110100 is octal 64 (110=6, 100=4).</p>"},{"location":"glossary/#one-hot-encoding","title":"One-Hot Encoding","text":"<p>A state encoding method using one flip-flop per state, with exactly one flip-flop active.</p> <p>One-hot simplifies state decoding and next-state logic at the cost of more flip-flops. It is often efficient in FPGAs.</p> <p>Example: A 4-state FSM uses 4 flip-flops: S0=0001, S1=0010, S2=0100, S3=1000.</p>"},{"location":"glossary/#or-gate","title":"OR Gate","text":"<p>A logic gate that outputs 1 when any input is 1.</p> <p>The OR gate implements logical disjunction. Its output is 0 only when all inputs are 0.</p> <p>Example: A 2-input OR with A=0, B=1 outputs Y=1.</p>"},{"location":"glossary/#or-operation","title":"OR Operation","text":"<p>A Boolean operation that yields true when any operand is true.</p> <p>The OR operation is fundamental to Boolean algebra, corresponding to logical disjunction and addition in Boolean algebra.</p> <p>Example: In the expression F = A + B, F equals 1 when A or B (or both) equal 1.</p>"},{"location":"glossary/#output-equation","title":"Output Equation","text":"<p>A Boolean equation defining FSM outputs as a function of state (and inputs for Mealy).</p> <p>Output equations implement the output function. Moore outputs depend only on state; Mealy outputs also use inputs.</p> <p>Example: For a Moore machine, output Z = Q1 AND Q0' means Z is high in state 01.</p>"},{"location":"glossary/#output-logic","title":"Output Logic","text":"<p>The combinational circuit that generates FSM outputs from state (and inputs).</p> <p>Output logic produces external signals based on internal state. Its complexity depends on the number and nature of outputs.</p> <p>Example: A traffic light controller's output logic decodes state bits to drive red, yellow, and green lights.</p>"},{"location":"glossary/#output-port","title":"Output Port","text":"<p>A Verilog port that sends signals outside the module.</p> <p>Output ports can be wire (continuous) or reg (procedural) type depending on how they are driven.</p> <p>Example: <code>output reg [7:0] data_out;</code> declares an 8-bit output driven by procedural statements.</p>"},{"location":"glossary/#overflow-detection","title":"Overflow Detection","text":"<p>Identifying when an arithmetic result exceeds the representable range.</p> <p>Overflow in two's complement occurs when the sign of the result is incorrect. It is detected by comparing carry-in and carry-out of the MSB.</p> <p>Example: Adding 0111 (7) + 0001 (1) = 1000 (-8 in two's complement) overflows because positive + positive = negative.</p>"},{"location":"glossary/#overflow-in-addition","title":"Overflow in Addition","text":"<p>The condition when the sum of two numbers exceeds the bit width's representable range.</p> <p>Unsigned overflow is detected by carry-out; signed overflow requires comparing carries into and out of the sign bit.</p> <p>Example: 8-bit unsigned addition of 255 + 1 = 0 with overflow.</p>"},{"location":"glossary/#parallel-in-parallel-out","title":"Parallel In Parallel Out","text":"<p>A register configuration where all bits are loaded and read simultaneously.</p> <p>PIPO registers provide simple storage with parallel access. They form the basis for CPU registers and data latches.</p> <p>Example: A PIPO register loads 8 bits on one clock edge and makes all 8 available simultaneously.</p>"},{"location":"glossary/#parallel-in-serial-out","title":"Parallel In Serial Out","text":"<p>A shift register configuration that loads parallel data and shifts it out serially.</p> <p>PISO registers convert parallel data to serial format for transmission. They are essential for serial communication transmitters.</p> <p>Example: A PISO register loads a byte, then shifts out one bit per clock for serial transmission.</p>"},{"location":"glossary/#parallel-load-register","title":"Parallel Load Register","text":"<p>A register that captures all input bits simultaneously on the active clock edge.</p> <p>Parallel load registers store data words for processing. An enable or load signal controls when updates occur.</p> <p>Example: An 8-bit parallel load register captures D[7:0] when LOAD is asserted at the clock edge.</p>"},{"location":"glossary/#parameter","title":"Parameter","text":"<p>A Verilog constant that makes modules configurable at instantiation.</p> <p>Parameters allow reusable modules with different bit widths, delay values, or other configurable aspects.</p> <p>Example: <code>module counter #(parameter WIDTH = 8)</code> creates a counter with configurable bit width.</p>"},{"location":"glossary/#parity-bit","title":"Parity Bit","text":"<p>An extra bit added to data to make the total number of 1s even or odd.</p> <p>Parity provides single-bit error detection. Even parity makes the total count of 1s even; odd parity makes it odd.</p> <p>Example: Data 1011 with even parity adds 1, giving 10111 (four 1s, which is even).</p>"},{"location":"glossary/#parity-checker","title":"Parity Checker","text":"<p>A circuit that verifies whether received data maintains correct parity.</p> <p>Parity checkers XOR all bits including the parity bit. For even parity, the result should be 0 if no errors occurred.</p> <p>Example: Checking 10111 with even parity: XOR all bits = 0, indicating no detectable error.</p>"},{"location":"glossary/#parity-generator","title":"Parity Generator","text":"<p>A circuit that computes the parity bit for a data word.</p> <p>Parity generators XOR all data bits to produce a parity bit that achieves the desired even or odd parity.</p> <p>Example: For data 1011 with even parity, the generator produces 1 (since 1 XOR 0 XOR 1 XOR 1 = 1).</p>"},{"location":"glossary/#pattern-recognition-fsm","title":"Pattern Recognition FSM","text":"<p>A finite state machine designed to detect specific input sequences.</p> <p>Pattern recognition FSMs track progress through a target sequence, triggering an output when the pattern completes.</p> <p>Example: An FSM detecting \"1101\" has states tracking how much of the pattern has been seen.</p>"},{"location":"glossary/#pin-assignment","title":"Pin Assignment","text":"<p>Mapping design signals to specific physical FPGA pins.</p> <p>Pin assignment considers I/O standards, voltage banks, timing, and PCB layout. Constraints specify these mappings.</p> <p>Example: <code>set_property PACKAGE_PIN W5 [get_ports clk]</code> assigns the clock to pin W5.</p>"},{"location":"glossary/#port-declaration","title":"Port Declaration","text":"<p>Specifying the direction and type of module interface signals in Verilog.</p> <p>Port declarations define how modules communicate. They specify input, output, or inout direction and optionally width.</p> <p>Example: <code>input wire [7:0] data, output reg valid</code> declares ports with different types and widths.</p>"},{"location":"glossary/#posedge-keyword","title":"Posedge Keyword","text":"<p>The Verilog keyword specifying sensitivity to rising clock edges.</p> <p>Posedge triggers always blocks on the 0-to-1 transition, enabling positive-edge-triggered sequential logic.</p> <p>Example: <code>always @(posedge clk)</code> executes the block contents on each rising clock edge.</p>"},{"location":"glossary/#positive-edge-triggered","title":"Positive Edge Triggered","text":"<p>A flip-flop that samples input at the rising clock transition.</p> <p>Positive edge triggering is the most common clocking scheme. Inputs are captured when clock rises from 0 to 1.</p> <p>Example: A positive-edge D flip-flop captures D when clock rises from 0 to 1.</p>"},{"location":"glossary/#preset-input","title":"Preset Input","text":"<p>A flip-flop control signal that forces the output to 1.</p> <p>Preset inputs initialize flip-flops to the set state. They can be synchronous or asynchronous.</p> <p>Example: A flip-flop with asynchronous preset goes to Q=1 immediately when PRE is asserted.</p>"},{"location":"glossary/#prime-implicant","title":"Prime Implicant","text":"<p>A product term that covers one or more minterms and cannot be further combined.</p> <p>Prime implicants are the largest possible groups in a K-map. They form the candidate terms for minimal covers.</p> <p>Example: In a 3-variable K-map, covering m3 and m7 produces prime implicant BC.</p>"},{"location":"glossary/#priority-encoder","title":"Priority Encoder","text":"<p>An encoder that outputs the code for the highest-priority active input.</p> <p>When multiple inputs are active, priority encoders select one based on predetermined ranking. They include a valid output.</p> <p>Example: A 4-to-2 priority encoder with inputs 0110 outputs 10 (for I2, the highest active input).</p>"},{"location":"glossary/#product-of-sums","title":"Product of Sums","text":"<p>A Boolean expression format as an AND of OR terms.</p> <p>POS form consists of maxterms or simplified sum terms ANDed together. It is the dual of sum-of-products.</p> <p>Example: F = (A+B)(A+C)(B'+C) is in product-of-sums form.</p>"},{"location":"glossary/#propagation-delay","title":"Propagation Delay","text":"<p>The time from an input change until the corresponding output change.</p> <p>Propagation delay limits circuit speed. It includes both gate delays and routing delays.</p> <p>Example: A gate with 5ns propagation delay shows output changes 5ns after input changes.</p>"},{"location":"glossary/#quine-mccluskey-method","title":"Quine-McCluskey Method","text":"<p>An algorithmic approach to finding minimal Boolean expressions.</p> <p>Quine-McCluskey systematically finds all prime implicants and selects a minimal cover. It works for any number of variables.</p> <p>Example: For a 5-variable function too large for K-maps, Quine-McCluskey finds the minimal expression.</p>"},{"location":"glossary/#race-condition","title":"Race Condition","text":"<p>A situation where circuit behavior depends on which signal changes first.</p> <p>Race conditions cause unpredictable results in asynchronous circuits. Proper synchronous design eliminates races.</p> <p>Example: In an SR latch, releasing S and R simultaneously can produce different results depending on slight timing differences.</p>"},{"location":"glossary/#reg-data-type","title":"Reg Data Type","text":"<p>A Verilog data type for signals assigned in procedural blocks.</p> <p>Reg variables hold values between assignments. Despite the name, they don't always imply registers\u2014they can model combinational logic.</p> <p>Example: <code>reg [7:0] count;</code> declares an 8-bit variable for procedural assignment.</p>"},{"location":"glossary/#register","title":"Register","text":"<p>A group of flip-flops that store a multi-bit value.</p> <p>Registers hold data words for processing. They include control inputs like load, clear, and clock enable.</p> <p>Example: An 8-bit register stores one byte of data, updated on clock edges when load is enabled.</p>"},{"location":"glossary/#register-file","title":"Register File","text":"<p>An array of registers with address-based read and write access.</p> <p>Register files provide fast, multi-port storage for CPU architectures. They typically support multiple simultaneous reads.</p> <p>Example: A 32x32 register file stores 32 registers of 32 bits each, with two read ports and one write port.</p>"},{"location":"glossary/#register-transfer-level","title":"Register Transfer Level","text":"<p>A design abstraction describing data movement between registers through combinational logic.</p> <p>RTL is the primary design level for synthesizable digital circuits. It describes what happens each clock cycle.</p> <p>Example: RTL statement \"R1 \u2190 R2 + R3\" means register 1 receives the sum of registers 2 and 3.</p>"},{"location":"glossary/#ring-counter","title":"Ring Counter","text":"<p>A shift register where the output feeds back to the input in a ring.</p> <p>Ring counters have n states for n flip-flops. They require initialization and produce decoded outputs directly.</p> <p>Example: A 4-bit ring counter sequences: 1000, 0100, 0010, 0001, 1000...</p>"},{"location":"glossary/#ripple-carry-adder","title":"Ripple Carry Adder","text":"<p>A multi-bit adder built by cascading full adders.</p> <p>The carry output of each stage feeds the carry input of the next. Delay increases linearly with bit width.</p> <p>Example: A 4-bit ripple carry adder chains four full adders, with total delay of 4 \u00d7 (carry propagation delay).</p>"},{"location":"glossary/#rise-time","title":"Rise Time","text":"<p>The time for a signal to transition from low to high logic level.</p> <p>Rise time affects propagation delay and signal integrity. Fast rise times reduce delay but may increase noise.</p> <p>Example: A rise time of 2ns means output takes 2ns to rise from 10% to 90% of its swing.</p>"},{"location":"glossary/#rising-edge","title":"Rising Edge","text":"<p>The transition of a digital signal from low to high.</p> <p>Rising edge-triggered circuits change state at the 0-to-1 transition. The rising edge is also called the positive edge.</p> <p>Example: A positive-edge-triggered flip-flop samples D at the instant the clock transitions from 0 to 1.</p>"},{"location":"glossary/#rtl-notation","title":"RTL Notation","text":"<p>A symbolic notation for describing register transfers and operations.</p> <p>RTL notation specifies data movement concisely. Common forms use arrows (\u2190) or assignment operators.</p> <p>Example: \"PC \u2190 PC + 1\" means the program counter is incremented.</p>"},{"location":"glossary/#rtl-verilog","title":"RTL Verilog","text":"<p>Verilog code at the register transfer level, suitable for synthesis.</p> <p>RTL Verilog describes behavior in terms of registers and combinational logic. It avoids non-synthesizable constructs.</p> <p>Example: <code>always @(posedge clk) if (load) reg_out &lt;= data_in;</code> is RTL Verilog describing a loadable register.</p>"},{"location":"glossary/#self-checking-testbench","title":"Self-Checking Testbench","text":"<p>A testbench that automatically verifies design outputs against expected values.</p> <p>Self-checking testbenches compare actual outputs to golden references, reporting errors without manual waveform inspection.</p> <p>Example: <code>if (actual !== expected) $error(\"Mismatch at time %t\", $time);</code></p>"},{"location":"glossary/#sensitivity-list","title":"Sensitivity List","text":"<p>The list of signals that trigger execution of a Verilog always block.</p> <p>Sensitivity lists specify when procedural blocks execute. Using @(*) automatically includes all read signals.</p> <p>Example: <code>always @(a or b or sel)</code> triggers when a, b, or sel change.</p>"},{"location":"glossary/#sequence-detector","title":"Sequence Detector","text":"<p>A finite state machine that identifies specific patterns in an input stream.</p> <p>Sequence detectors output a signal when a target bit pattern is received. They can use overlapping or non-overlapping detection.</p> <p>Example: A sequence detector for \"1011\" outputs 1 after receiving that four-bit pattern.</p>"},{"location":"glossary/#sequential-always","title":"Sequential Always","text":"<p>A Verilog always block triggered by clock edges for sequential logic.</p> <p>Sequential always blocks model flip-flops and registers. They use non-blocking assignments for proper hardware semantics.</p> <p>Example: <code>always @(posedge clk) q &lt;= d;</code> describes a D flip-flop.</p>"},{"location":"glossary/#sequential-logic","title":"Sequential Logic","text":"<p>Logic circuits whose outputs depend on current inputs and stored state.</p> <p>Sequential circuits have memory and feedback. Their behavior depends on input history, not just current inputs.</p> <p>Example: A counter is sequential because its output depends on how many clock pulses have occurred.</p>"},{"location":"glossary/#serial-in-parallel-out","title":"Serial In Parallel Out","text":"<p>A shift register configuration that receives bits serially and outputs them in parallel.</p> <p>SIPO registers convert serial data streams to parallel format. They are essential for serial communication receivers.</p> <p>Example: A SIPO register receives 8 bits one at a time, then presents all 8 simultaneously.</p>"},{"location":"glossary/#serial-in-serial-out","title":"Serial In Serial Out","text":"<p>A shift register configuration that shifts data through sequentially.</p> <p>SISO registers introduce delay and can form delay lines. Data enters serially and exits serially after n clock cycles.</p> <p>Example: A 4-bit SISO register delays input by 4 clock cycles.</p>"},{"location":"glossary/#setup-time","title":"Setup Time","text":"<p>The minimum time a flip-flop input must be stable before the clock edge.</p> <p>Setup time violations cause unreliable data capture. Meeting setup time is critical for correct operation.</p> <p>Example: With a setup time of 2ns, D must be stable at least 2ns before the clock edge.</p>"},{"location":"glossary/#shift-register","title":"Shift Register","text":"<p>A register that shifts stored bits by one position on each clock.</p> <p>Shift registers support serial-to-parallel conversion, delay lines, and rotation operations.</p> <p>Example: A 4-bit right-shift register changes 1100 to 0110 on one clock edge.</p>"},{"location":"glossary/#signal-integrity","title":"Signal Integrity","text":"<p>The quality of electrical signals in maintaining proper logic levels and timing.</p> <p>Signal integrity issues include crosstalk, reflections, and power supply noise. They can cause functional failures.</p> <p>Example: A long PCB trace without proper termination may ring, causing false clock edges.</p>"},{"location":"glossary/#signed-binary-numbers","title":"Signed Binary Numbers","text":"<p>Binary representation of both positive and negative integers.</p> <p>Signed binary typically uses two's complement where the MSB indicates sign. Operations work correctly for both signs.</p> <p>Example: In 8-bit two's complement, 11111111 represents -1 and 00000001 represents +1.</p>"},{"location":"glossary/#simulation","title":"Simulation","text":"<p>Running a design model to observe behavior without physical implementation.</p> <p>Simulation verifies functionality before hardware implementation. It uses testbenches to provide stimulus and check responses.</p> <p>Example: Simulating a counter in ModelSim shows waveforms of clock, reset, and count output.</p>"},{"location":"glossary/#simulation-time","title":"Simulation Time","text":"<p>The virtual time tracked during simulation, advanced by delay statements.</p> <p>Simulation time is controlled by #delay constructs and does not correspond to real time.</p> <p>Example: <code>#100</code> in Verilog advances simulation time by 100 time units.</p>"},{"location":"glossary/#sr-latch","title":"SR Latch","text":"<p>A bistable element with set and reset inputs.</p> <p>The SR latch stores one bit. S=1 sets Q=1, R=1 sets Q=0. The S=R=1 condition is forbidden.</p> <p>Example: An SR latch made from cross-coupled NOR gates has active-high S and R inputs.</p>"},{"location":"glossary/#sr-latch-truth-table","title":"SR Latch Truth Table","text":"<p>The input-output table showing SR latch behavior.</p> <p>The truth table shows: S=0,R=0 (hold); S=1,R=0 (set); S=0,R=1 (reset); S=1,R=1 (invalid).</p> <p>Example: SR latch with S=1, R=0: Q becomes 1, Q' becomes 0.</p>"},{"location":"glossary/#standard-form","title":"Standard Form","text":"<p>A Boolean expression in sum-of-products or product-of-sums format without necessarily using all variables.</p> <p>Standard forms simplify implementation but may not be unique. They differ from canonical forms which include all variables.</p> <p>Example: F = AB + C is in standard SOP form with the second term having only one variable.</p>"},{"location":"glossary/#state-assignment","title":"State Assignment","text":"<p>Choosing binary codes for FSM states.</p> <p>State assignment affects next-state logic complexity and power consumption. Options include binary, Gray, and one-hot encoding.</p> <p>Example: Assigning states S0=00, S1=01, S2=11, S3=10 uses Gray code to minimize transitions.</p>"},{"location":"glossary/#state-concept","title":"State Concept","text":"<p>The internal condition of a sequential circuit that influences its future behavior.</p> <p>State represents what a circuit \"remembers\" about its input history. It is stored in flip-flops and determines response to inputs.</p> <p>Example: A traffic light controller's state indicates which light is currently on.</p>"},{"location":"glossary/#state-diagram","title":"State Diagram","text":"<p>A graphical representation of FSM states and transitions.</p> <p>State diagrams show states as circles and transitions as arrows labeled with conditions. They visualize FSM behavior.</p> <p>Example: A state diagram for a counter shows numbered circles connected by arrows in sequence.</p>"},{"location":"glossary/#state-diagram-notation","title":"State Diagram Notation","text":"<p>The conventions for drawing and labeling state diagrams.</p> <p>Notation includes state names in circles, transition labels showing input/output (Mealy) or just input (Moore), and Moore outputs inside states.</p> <p>Example: A Mealy transition labeled \"X/Z\" means on input X, output Z and take this transition.</p>"},{"location":"glossary/#state-encoding","title":"State Encoding","text":"<p>The binary representation chosen for FSM states.</p> <p>Encoding choices include binary (fewest flip-flops), one-hot (simplest logic), and Gray code (minimum transitions).</p> <p>Example: 8 states need 3 bits with binary encoding but 8 flip-flops with one-hot encoding.</p>"},{"location":"glossary/#state-minimization","title":"State Minimization","text":"<p>Reducing the number of FSM states while preserving input-output behavior.</p> <p>State minimization combines equivalent states that have identical outputs and transitions. It reduces flip-flops needed.</p> <p>Example: Two states producing identical outputs for all input sequences can be merged into one.</p>"},{"location":"glossary/#state-table","title":"State Table","text":"<p>A tabular representation of FSM behavior showing next state and output for each state-input combination.</p> <p>State tables provide a systematic format for implementing FSMs. They contain current state, input, next state, and output columns.</p> <p>Example: A state table row might show: State=S1, Input=1, NextState=S3, Output=0.</p>"},{"location":"glossary/#state-transition","title":"State Transition","text":"<p>The change from one FSM state to another.</p> <p>Transitions occur on clock edges when input conditions are met. They are shown as arrows in state diagrams.</p> <p>Example: In a sequence detector, receiving the correct bit transitions from \"matched 2 bits\" to \"matched 3 bits\" state.</p>"},{"location":"glossary/#static-hazard","title":"Static Hazard","text":"<p>A hazard where an output should remain constant but glitches momentarily.</p> <p>Static hazards occur when two paths to an output have different delays. Adding redundant terms can eliminate them.</p> <p>Example: In F = AB + A'C, changing A when B=C=1 causes a glitch as one term turns off before the other turns on.</p>"},{"location":"glossary/#stimulus-generation","title":"Stimulus Generation","text":"<p>Creating input patterns to test a design during simulation.</p> <p>Stimulus generation in testbenches provides inputs that exercise design functionality. It should cover normal and edge cases.</p> <p>Example: <code>initial begin a = 0; b = 0; #10 a = 1; #10 b = 1; end</code> generates simple stimulus.</p>"},{"location":"glossary/#structural-modeling","title":"Structural Modeling","text":"<p>A Verilog modeling style that explicitly instantiates and connects components.</p> <p>Structural models describe how modules interconnect. They specify the design hierarchy explicitly.</p> <p>Example: Instantiating AND and OR gates and connecting them with wires is structural modeling.</p>"},{"location":"glossary/#sum-bit","title":"Sum Bit","text":"<p>The lower bit of a binary addition result.</p> <p>The sum bit of A+B+Cin equals the XOR of the three inputs. It represents the single-bit result of addition.</p> <p>Example: A full adder with A=1, B=1, Cin=0 produces Sum=0.</p>"},{"location":"glossary/#sum-of-products","title":"Sum of Products","text":"<p>A Boolean expression format as an OR of AND terms.</p> <p>SOP form consists of minterms or simplified product terms ORed together. It maps directly to AND-OR circuit implementations.</p> <p>Example: F = AB + A'C + BC is in sum-of-products form.</p>"},{"location":"glossary/#switch-input","title":"Switch Input","text":"<p>A mechanical switch used to provide digital input signals.</p> <p>Switch inputs require pull resistors for defined logic levels and debouncing for clean transitions.</p> <p>Example: A push button with a pull-up resistor provides logic 1 when released and logic 0 when pressed.</p>"},{"location":"glossary/#synchronizer-circuit","title":"Synchronizer Circuit","text":"<p>A circuit that safely transfers signals between asynchronous clock domains.</p> <p>Synchronizers reduce metastability risk by allowing time for unstable signals to resolve. They add latency.</p> <p>Example: A two-flop synchronizer delays an asynchronous signal by two clock cycles while resolving metastability.</p>"},{"location":"glossary/#synchronous-reset","title":"Synchronous Reset","text":"<p>A reset that takes effect only on the active clock edge.</p> <p>Synchronous resets are easier to time than asynchronous resets but require the clock to be running.</p> <p>Example: <code>always @(posedge clk) if (reset) q &lt;= 0; else q &lt;= d;</code> implements synchronous reset.</p>"},{"location":"glossary/#synchronous-system","title":"Synchronous System","text":"<p>A digital system where all state changes occur on clock edges.</p> <p>Synchronous design simplifies timing analysis by ensuring all flip-flops change together. It is the dominant design methodology.</p> <p>Example: A synchronous processor updates all registers on the same clock edge.</p>"},{"location":"glossary/#synthesis","title":"Synthesis","text":"<p>The process of converting HDL code to a gate-level netlist.</p> <p>Synthesis tools interpret Verilog behaviorally and produce equivalent logic. The result can be mapped to specific technologies.</p> <p>Example: Synthesizing <code>assign y = a &amp; b;</code> produces an AND gate.</p>"},{"location":"glossary/#synthesizable-code","title":"Synthesizable Code","text":"<p>Verilog constructs that synthesis tools can convert to hardware.</p> <p>Synthesizable code avoids delays, file I/O, and other simulation-only features. It describes implementable hardware.</p> <p>Example: <code>always @(posedge clk) count &lt;= count + 1;</code> is synthesizable as a counter.</p>"},{"location":"glossary/#t-flip-flop","title":"T Flip-Flop","text":"<p>A flip-flop that toggles its output when the T input is high.</p> <p>T flip-flops simplify counter design. With T=1, output inverts each clock; with T=0, output holds.</p> <p>Example: A T flip-flop with T=1 changes: Q=0\u21921\u21920\u21921 on successive clock edges.</p>"},{"location":"glossary/#testbench","title":"Testbench","text":"<p>A Verilog module that provides stimulus to and observes responses from a design under test.</p> <p>Testbenches simulate designs by generating inputs and checking outputs. They are not synthesizable.</p> <p>Example: A testbench instantiates a module, generates clock and test vectors, and reports results.</p>"},{"location":"glossary/#test-vector","title":"Test Vector","text":"<p>A set of input values applied to a circuit for testing.</p> <p>Test vectors exercise design functionality. Complete testing requires vectors that achieve high coverage of possible behaviors.</p> <p>Example: Test vector A=0,B=1,C=1 applied to an AND gate should produce output 0.</p>"},{"location":"glossary/#timing-constraint","title":"Timing Constraint","text":"<p>A specification of required timing relationships in a digital design.</p> <p>Timing constraints define clock periods, input/output delays, and false paths. They guide synthesis and implementation.</p> <p>Example: <code>create_clock -period 10 [get_ports clk]</code> constrains the clock to 100 MHz.</p>"},{"location":"glossary/#timing-diagram","title":"Timing Diagram","text":"<p>A graphical display of signal values over time.</p> <p>Timing diagrams show digital waveforms and their relationships. They verify timing requirements and debug sequential behavior.</p> <p>Example: A timing diagram shows clock, input, and output signals aligned vertically with time on the horizontal axis.</p>"},{"location":"glossary/#timing-verification","title":"Timing Verification","text":"<p>Verification that a design meets timing constraints at all flip-flops.</p> <p>Timing analysis checks setup and hold times for all paths. Violations must be fixed for reliable operation.</p> <p>Example: Static timing analysis reports slack on every path, flagging negative slack as timing violations.</p>"},{"location":"glossary/#timing-violation","title":"Timing Violation","text":"<p>Failure to meet setup or hold time requirements at a flip-flop.</p> <p>Timing violations cause unpredictable behavior. Setup violations occur when data arrives too late; hold violations when it changes too early.</p> <p>Example: A path with 12ns delay to a flip-flop with 10ns clock period and 2ns setup time violates setup time.</p>"},{"location":"glossary/#traffic-light-controller","title":"Traffic Light Controller","text":"<p>A common FSM example implementing traffic signal sequencing.</p> <p>Traffic light controllers demonstrate FSM design with multiple states, timed transitions, and multiple outputs.</p> <p>Example: A traffic light FSM has states for green, yellow, red with timer-based transitions.</p>"},{"location":"glossary/#transparent-latch","title":"Transparent Latch","text":"<p>A latch whose output follows its input while enabled.</p> <p>Transparency allows changes to propagate through immediately. This differs from edge-triggered behavior.</p> <p>Example: A D latch with enable high is transparent: Q changes whenever D changes.</p>"},{"location":"glossary/#tri-state-buffer","title":"Tri-State Buffer","text":"<p>A buffer with an enable input that can disconnect its output.</p> <p>Tri-state buffers create high-impedance outputs when disabled, allowing multiple drivers on a shared bus.</p> <p>Example: <code>assign bus = enable ? data : 8'bz;</code> implements a tri-state buffer in Verilog.</p>"},{"location":"glossary/#truth-table","title":"Truth Table","text":"<p>A tabular listing of all input combinations and their corresponding outputs.</p> <p>Truth tables completely specify combinational functions. They serve as specifications for circuit design.</p> <p>Example: A 2-input AND truth table has 4 rows: 00\u21920, 01\u21920, 10\u21920, 11\u21921.</p>"},{"location":"glossary/#ttl-logic","title":"TTL Logic","text":"<p>A logic family using bipolar junction transistors.</p> <p>TTL (Transistor-Transistor Logic) defined voltage standards still referenced today. It has been largely replaced by CMOS.</p> <p>Example: 74LS series ICs are TTL logic with low-power Schottky technology.</p>"},{"location":"glossary/#two-level-logic","title":"Two-Level Logic","text":"<p>Logic circuits with exactly two levels of gates between inputs and outputs.</p> <p>Two-level logic directly implements SOP (AND-OR) or POS (OR-AND) forms. It minimizes delay but may require many gates.</p> <p>Example: F = AB + CD is two-level: AND gates at level 1, OR gate at level 2.</p>"},{"location":"glossary/#twos-complement","title":"Two's Complement","text":"<p>A method for representing signed integers where negative values are the complement plus one.</p> <p>Two's complement allows addition/subtraction using the same hardware. The MSB indicates sign (0=positive, 1=negative).</p> <p>Example: In 8-bit two's complement, -5 is represented as 11111011 (invert 00000101 and add 1).</p>"},{"location":"glossary/#universal-gate","title":"Universal Gate","text":"<p>A gate from which all other gates can be constructed.</p> <p>NAND and NOR are universal gates. Any Boolean function can be implemented using only one type of universal gate.</p> <p>Example: An AND gate is made from a NAND followed by another NAND used as an inverter.</p>"},{"location":"glossary/#universal-shift-register","title":"Universal Shift Register","text":"<p>A shift register with selectable modes: hold, shift left, shift right, and parallel load.</p> <p>Universal shift registers combine all shift register functions in one device. A 2-bit mode select chooses the operation.</p> <p>Example: The 74194 is a 4-bit universal shift register with all four modes.</p>"},{"location":"glossary/#up-counter","title":"Up Counter","text":"<p>A counter that increments its value on each clock cycle.</p> <p>Up counters increase from 0 toward their maximum value, then wrap to 0. They are the most common counter type.</p> <p>Example: A 4-bit up counter sequences: 0000, 0001, 0010, 0011, ..., 1111, 0000...</p>"},{"location":"glossary/#up-down-counter","title":"Up-Down Counter","text":"<p>A counter that can count in either direction based on a control input.</p> <p>Up-down counters increment or decrement based on a direction signal. They are useful for bidirectional position tracking.</p> <p>Example: With UP=1, counter increments; with UP=0, counter decrements.</p>"},{"location":"glossary/#vending-machine-fsm","title":"Vending Machine FSM","text":"<p>A common FSM example implementing a coin-operated dispenser.</p> <p>Vending machine FSMs track accumulated payment and dispense when sufficient coins are inserted. They demonstrate state-based control.</p> <p>Example: A vending machine FSM has states for 0\u00a2, 25\u00a2, 50\u00a2, with transitions for nickel, dime, quarter inputs.</p>"},{"location":"glossary/#verilog-hdl","title":"Verilog HDL","text":"<p>A hardware description language for modeling and designing digital systems.</p> <p>Verilog describes both behavior and structure of digital circuits. It is used for simulation and synthesis.</p> <p>Example: <code>assign y = a &amp; b;</code> describes an AND gate in Verilog.</p>"},{"location":"glossary/#voltage-threshold","title":"Voltage Threshold","text":"<p>The input voltage level at which a gate transitions between logic states.</p> <p>Threshold voltages define the boundary between high and low inputs. They affect noise margins and switching behavior.</p> <p>Example: A CMOS gate with VDD=3.3V might have a threshold around 1.65V.</p>"},{"location":"glossary/#waveform-viewer","title":"Waveform Viewer","text":"<p>A software tool that displays signal values over time from simulation.</p> <p>Waveform viewers show digital and analog traces. They enable visual debugging of timing and logic.</p> <p>Example: GTKWave displays VCD files showing all signals over simulation time.</p>"},{"location":"glossary/#weighted-codes","title":"Weighted Codes","text":"<p>Binary codes where each bit position has an assigned weight contributing to the total value.</p> <p>Weighted codes enable direct arithmetic interpretation. BCD and regular binary are weighted; Gray code is not.</p> <p>Example: BCD uses weights 8-4-2-1, so 0110 represents 6 (0\u00d78 + 1\u00d74 + 1\u00d72 + 0\u00d71).</p>"},{"location":"glossary/#wire-data-type","title":"Wire Data Type","text":"<p>A Verilog data type for signals driven by continuous assignments or module outputs.</p> <p>Wires represent physical connections without storage. They continuously reflect the value of their drivers.</p> <p>Example: <code>wire [7:0] sum;</code> declares an 8-bit wire that can be driven by an assign statement.</p>"},{"location":"glossary/#xnor-gate","title":"XNOR Gate","text":"<p>A logic gate that outputs 1 when inputs have the same value.</p> <p>XNOR is the complement of XOR. It functions as an equality detector for two bits.</p> <p>Example: A 2-input XNOR with A=1, B=1 outputs Y=1.</p>"},{"location":"glossary/#xor-gate","title":"XOR Gate","text":"<p>A logic gate that outputs 1 when an odd number of inputs are 1.</p> <p>XOR (exclusive OR) outputs 1 when inputs differ. It is essential for arithmetic, parity, and comparison circuits.</p> <p>Example: A 2-input XOR with A=1, B=0 outputs Y=1.</p>"},{"location":"glossary/#2-to-4-decoder","title":"2-to-4 Decoder","text":"<p>A decoder that activates one of four outputs based on a 2-bit input.</p> <p>The 2-to-4 decoder converts 2 binary bits to 4 one-hot outputs. With input 10, output Y2 is active.</p> <p>Example: A 2-to-4 decoder with A1A0=01 asserts output Y1 and deasserts Y0, Y2, Y3.</p>"},{"location":"glossary/#3-to-8-decoder","title":"3-to-8 Decoder","text":"<p>A decoder that activates one of eight outputs based on a 3-bit input.</p> <p>The 3-to-8 decoder expands 3 binary bits to 8 one-hot outputs. It is commonly used for address decoding.</p> <p>Example: A 3-to-8 decoder with A2A1A0=101 asserts output Y5.</p>"},{"location":"glossary/#7-segment-decoder","title":"7-Segment Decoder","text":"<p>A circuit that converts a binary code to signals for displaying a digit.</p> <p>7-segment decoders drive the seven LED segments to show digits 0-9. They take BCD input and output segment enables.</p> <p>Example: BCD input 0111 (7) activates segments a, b, c to display the digit 7.</p>"},{"location":"glossary/#7-segment-display","title":"7-Segment Display","text":"<p>An electronic display using seven LED segments to show digits.</p> <p>Each segment is labeled a-g. Different combinations display digits 0-9 and some letters.</p> <p>Example: Segments a, b, c, d, e, f lit with g off displays the digit 0.</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#python","title":"Python","text":"<p>MicroSims are about how we use generative AI to create animations and simulations.  The language of AI is Python.  So we wanted to create a site that could be easily understood by Python developers.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"references/","title":"References for Digital Electronics","text":""},{"location":"references/#commercial-tools","title":"Commercial Tools","text":"<p>Logicly - Logicly is a $50 digital circuit simulator.  It has components for the standard logic gates and flip-flops.</p>"},{"location":"chapters/","title":"Chapters","text":"<p>This textbook is organized into 15 chapters covering 300 concepts in digital electronics.</p>"},{"location":"chapters/#chapter-overview","title":"Chapter Overview","text":"<ol> <li> <p>Number Systems and Binary Arithmetic - Covers binary, hexadecimal, and octal number systems along with arithmetic operations and encoding schemes.</p> </li> <li> <p>Boolean Algebra Fundamentals - Introduces Boolean variables, operations, expressions, functions, truth tables, and Boolean algebra laws.</p> </li> <li> <p>Logic Gates and Digital Signal Properties - Covers primitive logic gates, functional completeness, timing parameters, and signal characteristics.</p> </li> <li> <p>Combinational Logic Design Fundamentals - Introduces combinational vs sequential logic, gate-level design, and canonical forms.</p> </li> <li> <p>Logic Minimization and Karnaugh Maps - Covers K-maps, grouping rules, prime implicants, and hazard-free design.</p> </li> <li> <p>Combinational Building Blocks - Covers multiplexers, decoders, comparators, adders, and ALU concepts.</p> </li> <li> <p>Introduction to Sequential Logic - Introduces memory elements, latches, and clock signals.</p> </li> <li> <p>Flip-Flops and Timing - Covers edge-triggered flip-flops, timing parameters, and synchronization.</p> </li> <li> <p>Finite State Machine Fundamentals - Introduces FSMs, Moore and Mealy machines, state diagrams, and encoding methods.</p> </li> <li> <p>FSM Design and Applications - Covers the FSM design process and practical applications.</p> </li> <li> <p>Registers, Counters, and Datapath - Covers registers, shift registers, counters, and datapath concepts.</p> </li> <li> <p>Verilog HDL Fundamentals - Introduces Verilog modules, ports, data types, and assignments.</p> </li> <li> <p>Verilog Behavioral and Structural Modeling - Covers always blocks, modeling styles, and hierarchical design.</p> </li> <li> <p>Testbenches and Simulation - Covers testbench creation, simulation, and synthesis concepts.</p> </li> <li> <p>FPGA Implementation and Laboratory Skills - Covers FPGA architecture, implementation, and laboratory practices.</p> </li> </ol>"},{"location":"chapters/#how-to-use-this-textbook","title":"How to Use This Textbook","text":"<p>This textbook is designed with a careful progression of concepts where each chapter builds on the knowledge from previous chapters. The learning graph ensures that all prerequisite concepts are covered before they are needed. Students should work through chapters sequentially, as later chapters assume familiarity with earlier material.</p> <p>Note: Each chapter includes a list of concepts covered from the learning graph. Make sure to complete prerequisites before moving to advanced chapters.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/","title":"Number Systems and Binary Arithmetic","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#summary","title":"Summary","text":"<p>This chapter establishes the mathematical foundation for digital electronics by introducing number systems used in digital design. Students will learn to convert between binary, decimal, hexadecimal, and octal representations, perform binary arithmetic operations, understand signed number representation using two's complement, and work with specialized encoding schemes like BCD and Gray code. These skills are essential for all subsequent work in digital circuit design.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>Binary Number System</li> <li>Decimal to Binary Conversion</li> <li>Binary to Decimal Conversion</li> <li>Hexadecimal Numbers</li> <li>Hex to Binary Conversion</li> <li>Octal Numbers</li> <li>Binary Addition</li> <li>Binary Subtraction</li> <li>Two's Complement</li> <li>Signed Binary Numbers</li> <li>Overflow Detection</li> <li>BCD Encoding</li> <li>Gray Code</li> <li>Weighted Codes</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#prerequisites","title":"Prerequisites","text":"<p>This chapter assumes only the prerequisites listed in the course description. Students should have a basic understanding of arithmetic and number representation from prior mathematics courses.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#introduction-why-computers-dont-count-like-we-do","title":"Introduction: Why Computers Don't Count Like We Do","text":"<p>Here's a fun fact to start your journey into digital electronics: computers are terrible at counting to ten. It's not that they're lazy or didn't pay attention in kindergarten\u2014it's that they physically can't. Deep inside every processor, every memory chip, and every digital circuit, there are billions of tiny switches that can only be in one of two states: on or off. That's it. No \"sort of on\" or \"mostly off.\" Just on and off.</p> <p>This fundamental limitation (which, as you'll discover, is actually a superpower) means that computers think in binary\u2014a number system with only two digits. If you've ever wondered why computer scientists seem obsessed with powers of 2, or why your hard drive has weird capacities like 256 GB instead of a nice round 250 GB, this chapter will give you the answers.</p> <p>Think of it this way: if you only had two fingers, you'd probably count differently too. Welcome to the world of binary arithmetic, where 10 + 10 = 100, and that's not a typo\u2014it's just how things work around here.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-binary-number-system","title":"The Binary Number System","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#understanding-positional-notation","title":"Understanding Positional Notation","text":"<p>Before diving into binary, let's remind ourselves how our familiar decimal system works. When you write the number 347, each digit's position tells you what it's worth:</p> <ul> <li>The 3 is in the \"hundreds\" place: \\(3 \\times 100 = 300\\)</li> <li>The 4 is in the \"tens\" place: \\(4 \\times 10 = 40\\)</li> <li>The 7 is in the \"ones\" place: \\(7 \\times 1 = 7\\)</li> </ul> <p>Add them up: \\(300 + 40 + 7 = 347\\). Simple enough, right?</p> <p>Notice that each position is a power of 10:</p> Position 3rd 2nd 1st 0th Power \\(10^3\\) \\(10^2\\) \\(10^1\\) \\(10^0\\) Value 1000 100 10 1 <p>This is called positional notation with base 10 (or radix 10). The magic insight is that we can use any base we want\u2014we just happened to evolve with 10 fingers.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-base-2","title":"Binary: Base 2","text":"<p>In binary, we use base 2 instead of base 10. This means:</p> <ul> <li>We only have two digits: 0 and 1 (called bits, short for \"binary digits\")</li> <li>Each position represents a power of 2</li> </ul> <p>Here's the binary equivalent of our position table:</p> Position 7th 6th 5th 4th 3rd 2nd 1st 0th Power \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) Value 128 64 32 16 8 4 2 1 <p>Memorize These Powers of 2</p> <p>Knowing the first 8-10 powers of 2 by heart will make your life in digital electronics much easier: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024...</p> <p>Let's decode the binary number \\(10110101_2\\) (the subscript 2 tells us it's binary):</p> Bit 1 0 1 1 0 1 0 1 Position value 128 64 32 16 8 4 2 1 Contribution 128 0 32 16 0 4 0 1 <p>Sum: \\(128 + 32 + 16 + 4 + 1 = 181_{10}\\)</p> <p>That's binary to decimal conversion in a nutshell\u2014just add up the position values wherever there's a 1.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-binary-place-value-visualizer","title":"Diagram: Binary Place Value Visualizer","text":"Binary Place Value Visualizer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: interpret, explain</p> <p>Learning Objective: Students will be able to explain how positional notation works in binary by interactively toggling bits and observing the resulting decimal value.</p> <p>Canvas Layout: - Width: 700px, Height: 400px - Top section: 8 large toggle buttons representing bits (positions 7 through 0) - Middle section: Display showing power of 2 labels under each bit (\\(2^7\\), \\(2^6\\), etc.) - Bottom section: Running calculation showing which position values are \"active\" and the total decimal result</p> <p>Visual Elements: - 8 square toggle buttons (80x80px each) arranged horizontally - Each button shows \"0\" or \"1\" in large font - Active bits (1s) highlighted in bright blue, inactive bits (0s) in gray - Position values displayed beneath each button - Calculation line shows: \"128 + 32 + 16 + 4 + 1 = 181\" - Large decimal result display at bottom</p> <p>Interactive Controls: - Click any bit to toggle between 0 and 1 - \"Clear All\" button sets all bits to 0 - \"Random\" button generates a random 8-bit number - \"Challenge Mode\" button shows a target decimal for student to create</p> <p>Behavior: - When a bit is toggled, immediately recalculate and display the new decimal value - Active bits visually \"light up\" with animation - Calculation line updates dynamically to show only active terms</p> <p>Instructional Rationale: Toggle-based exploration with immediate feedback is appropriate because students need to see the concrete relationship between bit positions and values. The step-by-step calculation display makes the addition process explicit.</p> <p>Implementation: p5.js with responsive canvas</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-binary-matters","title":"Why Binary Matters","text":"<p>You might be thinking, \"This seems inconvenient. Why not just use decimal?\" Great question! Here's why binary is perfect for computers:</p> <ol> <li>Reliability: It's easy to distinguish between \"on\" and \"off,\" but hard to reliably distinguish between 10 different voltage levels</li> <li>Noise immunity: If electrical noise corrupts a signal slightly, a 1 is still a 1</li> <li>Simple logic: AND, OR, NOT operations map directly to physical circuits</li> <li>Mathematical elegance: Boolean algebra makes circuit design systematic</li> </ol> <p>As we'll see in later chapters, this binary foundation enables everything from adding two numbers to running complex operating systems.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#converting-between-binary-and-decimal","title":"Converting Between Binary and Decimal","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-to-decimal-the-position-value-method","title":"Binary to Decimal: The Position-Value Method","text":"<p>We already saw this method in action. Here's the systematic process:</p> <ol> <li>Write out the binary number</li> <li>Label each bit with its position value (right to left, starting at 1)</li> <li>Multiply each bit by its position value</li> <li>Sum the results</li> </ol> <p>Example: Convert \\(1101011_2\\) to decimal.</p> Bit position 6 5 4 3 2 1 0 Position value 64 32 16 8 4 2 1 Binary digit 1 1 0 1 0 1 1 Contribution 64 32 0 8 0 2 1 <p>Result: \\(64 + 32 + 8 + 2 + 1 = 107_{10}\\)</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#decimal-to-binary-the-repeated-division-method","title":"Decimal to Binary: The Repeated Division Method","text":"<p>Going the other direction requires a different approach. The most reliable method is repeated division by 2:</p> <ol> <li>Divide the decimal number by 2</li> <li>Record the remainder (0 or 1)</li> <li>Use the quotient as the new dividend</li> <li>Repeat until the quotient is 0</li> <li>Read the remainders from bottom to top</li> </ol> <p>Example: Convert \\(107_{10}\\) to binary.</p> Division Quotient Remainder 107 \u00f7 2 53 1 53 \u00f7 2 26 1 26 \u00f7 2 13 0 13 \u00f7 2 6 1 6 \u00f7 2 3 0 3 \u00f7 2 1 1 1 \u00f7 2 0 1 <p>Reading remainders from bottom to top: \\(1101011_2\\) \u2713</p> <p>The Remainder Trick</p> <p>Why does this work? Each remainder tells you whether that power of 2 \"fits\" into the remaining value. The first remainder tells you if the number is odd (needs a \\(2^0 = 1\\)), the second tells you about \\(2^1\\), and so on.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-decimal-to-binary-conversion-stepper","title":"Diagram: Decimal to Binary Conversion Stepper","text":"Decimal to Binary Conversion Stepper <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: execute, calculate</p> <p>Learning Objective: Students will be able to apply the repeated division method to convert any decimal number to binary by stepping through the algorithm interactively.</p> <p>Canvas Layout: - Width: 700px, Height: 450px - Left side: Input field for decimal number - Center: Step-by-step division display showing quotient and remainder at each step - Right side: Growing binary result (built from remainders)</p> <p>Visual Elements: - Large input field for decimal number (0-255) - Division steps displayed as rows: \"107 \u00f7 2 = 53 remainder 1\" - Arrow pointing to remainder at each step - Binary result building from right to left as remainders are collected - Final result highlighted in a bordered box</p> <p>Interactive Controls: - Text input for decimal number (with validation 0-255) - \"Step\" button advances to next division - \"Complete\" button shows all steps at once - \"Reset\" button clears and starts over - Speed slider for auto-step mode</p> <p>Behavior: - Each click of \"Step\" performs one division and highlights the new remainder - Remainders stack up to form the binary representation - Visual animation shows remainder \"moving\" to binary result area - Auto-step mode animates through all steps with adjustable delay</p> <p>Data Visibility Requirements: - Stage 1: Show decimal input value - Stage 2: Show first division with quotient and remainder highlighted - Stage 3-N: Show successive divisions with running binary result - Final: Show complete binary number with verification (convert back)</p> <p>Instructional Rationale: Step-by-step progression allows students to predict each remainder before revealing it, reinforcing understanding of the algorithm rather than just memorizing results.</p> <p>Implementation: p5.js</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#hexadecimal-binarys-best-friend","title":"Hexadecimal: Binary's Best Friend","text":"<p>Typing out long strings of 1s and 0s gets tedious fast. Imagine debugging a 32-bit value: \\(11010110111010001001010011110000_2\\). Your eyes are already glazing over, aren't they?</p> <p>Enter hexadecimal (hex for short): base 16. Hex uses digits 0-9 plus letters A-F to represent values 0-15:</p> Decimal Binary Hex 0 0000 0 1 0001 1 2 0010 2 3 0011 3 4 0100 4 5 0101 5 6 0110 6 7 0111 7 8 1000 8 9 1001 9 10 1010 A 11 1011 B 12 1100 C 13 1101 D 14 1110 E 15 1111 F"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-hex-works-so-well","title":"Why Hex Works So Well","text":"<p>Here's the clever bit: \\(16 = 2^4\\). This means every hex digit corresponds exactly to four binary digits. That messy 32-bit number from earlier? In hex, it's just:</p> <p>\\(11010110111010001001010011110000_2 = \\text{D6E894F0}_{16}\\)</p> <p>Much more manageable! Here's how the conversion works:</p> <ol> <li>Group binary digits into sets of 4 (from the right)</li> <li>Convert each group to its hex equivalent</li> </ol> <p>Example: Convert \\(10110111_2\\) to hex.</p> Group 1011 0111 Hex digit B 7 <p>Result: \\(\\text{B7}_{16}\\)</p> <p>To go back to binary, just reverse the process\u2014each hex digit becomes four binary digits.</p> <p>Hex Notation Conventions</p> <p>You'll see hex numbers written in several ways:</p> <ul> <li>With subscript: \\(\\text{B7}_{16}\\)</li> <li>With 0x prefix: 0xB7 (common in programming)</li> <li>With h suffix: B7h (common in assembly language)</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-number-base-converter","title":"Diagram: Number Base Converter","text":"Number Base Converter <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: calculate, use</p> <p>Learning Objective: Students will be able to convert between binary, decimal, and hexadecimal representations fluently by practicing with an interactive converter that shows equivalent representations simultaneously.</p> <p>Canvas Layout: - Width: 700px, Height: 350px - Three large display panels arranged horizontally: Binary, Decimal, Hex - Input mode selector to choose which base to type in - Grouped binary digits with hex alignment indicators</p> <p>Visual Elements: - Binary display: 8 bits shown with grouping lines every 4 bits - Decimal display: numeric value with leading zeros option - Hex display: 2 hex digits with 0x prefix - Visual grouping lines connecting binary groups to hex digits - Active input field highlighted with cursor</p> <p>Interactive Controls: - Radio buttons to select input mode (Binary, Decimal, or Hex) - Text input field for entering numbers in selected base - \"Random\" button generates a random 8-bit value - Bit width selector: 4, 8, 16, or 32 bits</p> <p>Behavior: - Entering a value in one base immediately updates the other two - Invalid input (non-binary digits in binary mode, etc.) shows error highlight - Grouping lines animate to show correspondence between bases - Overflow warning if value exceeds selected bit width</p> <p>Implementation: p5.js with responsive layout</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#octal-the-retro-alternative","title":"Octal: The Retro Alternative","text":"<p>While we're on alternative bases, let's briefly cover octal (base 8). Octal uses digits 0-7, and since \\(8 = 2^3\\), each octal digit represents exactly three binary digits.</p> Decimal Binary Octal 0 000 0 1 001 1 2 010 2 3 011 3 4 100 4 5 101 5 6 110 6 7 111 7 <p>Example: Convert \\(10110111_2\\) to octal.</p> <p>First, group into threes from the right (adding a leading zero if needed):</p> Group 010 110 111 Octal digit 2 6 7 <p>Result: \\(267_8\\)</p> <p>Octal was popular in early computing when machines used 12-bit, 24-bit, or 36-bit words (all divisible by 3). Today, hex dominates because 8-bit bytes (divisible by 4) are universal. However, you'll still encounter octal in Unix file permissions (chmod 755, anyone?) and some programming contexts.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-addition-the-foundation-of-arithmetic","title":"Binary Addition: The Foundation of Arithmetic","text":"<p>Now that we can represent numbers in binary, let's learn to do math with them. Binary addition follows the same principles as decimal addition, but with simpler rules because there are only two digits.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-four-addition-rules","title":"The Four Addition Rules","text":"<p>Here's everything you need to know about adding two binary digits:</p> A B Sum Carry 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 <p>The last row is the interesting one: \\(1 + 1 = 10_2\\) (which is 2 in decimal). We write down 0 and carry the 1, just like in decimal when \\(5 + 5 = 10\\).</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#multi-bit-addition","title":"Multi-Bit Addition","text":"<p>Let's add \\(1011_2 + 1101_2\\) step by step:</p> <pre><code>  Carries:  1 1 1\n            1 0 1 1\n          + 1 1 0 1\n          ---------\n          1 1 0 0 0\n</code></pre> <p>Working from right to left:</p> <ol> <li>Position 0: \\(1 + 1 = 10_2\\), write 0, carry 1</li> <li>Position 1: \\(1 + 0 + 1 = 10_2\\), write 0, carry 1</li> <li>Position 2: \\(1 + 1 + 1 = 11_2\\), write 1, carry 1</li> <li>Position 3: \\(1 + 1 + 1 = 11_2\\), write 1, carry 1</li> <li>Carry out becomes the 5th bit</li> </ol> <p>Verification: \\(11_{10} + 13_{10} = 24_{10}\\), and \\(11000_2 = 24_{10}\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-binary-addition-practice-tool","title":"Diagram: Binary Addition Practice Tool","text":"Binary Addition Practice Tool <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: calculate, practice</p> <p>Learning Objective: Students will be able to perform binary addition correctly, including managing carries, by practicing with immediate feedback and step-by-step visualization.</p> <p>Canvas Layout: - Width: 700px, Height: 450px - Center: Traditional vertical addition layout with carry row, two operands, and result - Right side: Feedback panel showing current step and hints - Bottom: Score tracker for practice mode</p> <p>Visual Elements: - Carry row at top (initially hidden, revealed as carries occur) - Two 8-bit operand rows with editable fields in practice mode - Sum row where student enters answers (or shows result in demo mode) - Column highlighting to show current position being calculated - Green checkmarks for correct digits, red X for incorrect</p> <p>Interactive Controls: - \"Demo Mode\" / \"Practice Mode\" toggle - In Demo: \"Step\" button advances column by column, \"Auto\" button animates - In Practice: Student clicks on result bits to toggle them, \"Check\" validates - \"New Problem\" button generates random addends - Difficulty slider: 4-bit, 8-bit, or 16-bit problems</p> <p>Behavior: - Demo mode: Steps through addition column by column, showing carry logic - Practice mode: Student fills in carries and sum bits, gets immediate feedback - Incorrect answers highlight red with hint about what went wrong - Score tracks correct/incorrect for gamification</p> <p>Data Visibility Requirements: - Stage 1: Show two operands - Stage 2-N: Highlight current column, show addition of two bits plus carry - Show carry-out when it occurs - Final: Complete sum with all carries visible</p> <p>Instructional Rationale: Immediate feedback during practice helps students self-correct errors in carry handling, the most common mistake in binary addition.</p> <p>Implementation: p5.js</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#binary-subtraction-and-twos-complement","title":"Binary Subtraction and Two's Complement","text":"<p>Subtraction in binary is where things get interesting. While you can do it with borrowing (just like decimal subtraction), computers use a clever trick that lets them subtract using the same addition circuits. This trick is called two's complement.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-concept-of-complements","title":"The Concept of Complements","text":"<p>A complement is basically the \"opposite\" of a number within a given range. For example, if we're working with single decimal digits (0-9), the complement of 3 is 7, because \\(3 + 7 = 10\\).</p> <p>In binary, we have two useful complements:</p> <ul> <li>One's complement: Flip all the bits (0 becomes 1, 1 becomes 0)</li> <li>Two's complement: One's complement plus 1</li> </ul> <p>Example: Find the two's complement of \\(01011001_2\\)</p> <ol> <li>Original: \\(01011001\\)</li> <li>One's complement (flip bits): \\(10100110\\)</li> <li>Two's complement (add 1): \\(10100111\\)</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-magic-of-twos-complement","title":"The Magic of Two's Complement","text":"<p>Here's the beautiful trick: if you want to calculate \\(A - B\\), you can instead calculate \\(A + (\\text{two's complement of } B)\\). The hardware that does addition can also do subtraction!</p> <p>Example: Calculate \\(10010110_2 - 01011001_2\\)</p> <p>Instead of subtracting, we'll add the two's complement of \\(01011001_2\\):</p> <ol> <li>Two's complement of \\(01011001_2 = 10100111_2\\) (from above)</li> <li>Add: \\(10010110_2 + 10100111_2\\)</li> </ol> <pre><code>    Carries: 1 1 1 1 1 1 1\n             1 0 0 1 0 1 1 0\n           + 1 0 1 0 0 1 1 1\n           -----------------\n           1 0 0 1 1 1 1 0 1\n</code></pre> <ol> <li>Discard the carry-out (overflow bit): \\(00111101_2\\)</li> <li>Check: \\(150_{10} - 89_{10} = 61_{10}\\), and \\(00111101_2 = 61_{10}\\) \u2713</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-twos-complement-visualizer","title":"Diagram: Two's Complement Visualizer","text":"Two's Complement Visualizer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, interpret</p> <p>Learning Objective: Students will be able to explain how two's complement representation works and why it enables subtraction using addition hardware.</p> <p>Canvas Layout: - Width: 700px, Height: 430px - Top: Original binary number display (8 bits) - Middle: Step-by-step transformation showing one's complement and two's complement - Bottom: Decimal interpretation panel showing signed vs unsigned values</p> <p>Visual Elements: - 8-bit binary display with bit position labels - Arrow showing transformation from original to one's complement - Arrow showing +1 step to two's complement - Color coding: original bits in blue, flipped bits in orange, final +1 in green - Number line visualization showing negative number position</p> <p>Interactive Controls: - 8 toggle buttons for inputting a binary number - \"Calculate Complement\" button triggers step-by-step animation - \"Show Number Line\" checkbox reveals circular number line representation - Signed/Unsigned toggle for decimal display</p> <p>Behavior: - Clicking \"Calculate Complement\" animates bit flipping one position at a time - The +1 step shows carry propagation if applicable - Number line view shows how positive and negative numbers wrap around</p> <p>Data Visibility Requirements: - Stage 1: Show original 8-bit value with decimal equivalent - Stage 2: Show one's complement (all bits flipped) with intermediate value - Stage 3: Show two's complement (after +1) with final value - Stage 4: Show verification that original + complement = 0 (with overflow discarded)</p> <p>Instructional Rationale: Seeing each step separately helps students understand WHY two's complement works, not just HOW to calculate it.</p> <p>Implementation: p5.js</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#signed-binary-numbers","title":"Signed Binary Numbers","text":"<p>So far, we've only represented positive numbers (unsigned values). But real-world computation needs negative numbers too. How do we represent -42 in binary?</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#the-sign-magnitude-approach-not-used-much","title":"The Sign-Magnitude Approach (Not Used Much)","text":"<p>The obvious approach: reserve one bit for the sign (0 = positive, 1 = negative) and use the rest for magnitude.</p> <p>\\(+5 = 0000 0101\\) \\(-5 = 1000 0101\\)</p> <p>This seems intuitive, but it causes problems:</p> <ul> <li>We have two representations of zero (+0 and -0)</li> <li>Addition hardware doesn't work directly\u2014we need to check signs first</li> <li>It's wasteful and complicated</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#twos-complement-representation-the-standard","title":"Two's Complement Representation (The Standard)","text":"<p>Modern computers use two's complement for signed integers. The most significant bit (MSB) indicates sign:</p> <ul> <li>MSB = 0: positive number (interpret normally)</li> <li>MSB = 1: negative number (value is \\(-2^{n-1} + \\text{remaining bits}\\))</li> </ul> <p>For 8-bit two's complement:</p> Binary Unsigned Value Signed Value 0000 0000 0 0 0000 0001 1 +1 0111 1111 127 +127 1000 0000 128 -128 1111 1111 255 -1 <p>The Asymmetry</p> <p>Notice something odd? With 8 bits, we can represent -128 through +127. There's one more negative number than positive! This is because we \"use up\" the all-zeros pattern for zero itself. In n-bit two's complement:</p> <ul> <li>Minimum value: \\(-2^{n-1}\\)</li> <li>Maximum value: \\(2^{n-1} - 1\\)</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-twos-complement-is-brilliant","title":"Why Two's Complement Is Brilliant","text":"<p>The beauty of two's complement is that addition works the same whether numbers are signed or unsigned. The hardware doesn't need to know which interpretation you're using! This is why it became the universal standard for integer arithmetic.</p> <p>Example: \\((-3) + 5\\) in 8-bit two's complement</p> <p>\\(-3_{10} = 11111101_2\\) (two's complement of 3) \\(+5_{10} = 00000101_2\\)</p> <pre><code>    11111101\n  + 00000101\n  ----------\n  1 00000010\n</code></pre> <p>Discarding the carry-out: \\(00000010_2 = 2_{10}\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#overflow-detection","title":"Overflow Detection","text":"<p>When arithmetic results exceed the range a given number of bits can represent, we get overflow. This is one of the sneakiest bugs in digital systems\u2014everything looks normal, but the answer is completely wrong.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#unsigned-overflow","title":"Unsigned Overflow","text":"<p>For unsigned numbers, overflow occurs when a carry-out propagates beyond the most significant bit. Adding \\(11111111_2 + 00000001_2\\) (255 + 1) gives \\(100000000_2\\), which needs 9 bits. If we only have 8, the result wraps around to 0.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#signed-overflow","title":"Signed Overflow","text":"<p>For signed numbers, overflow is trickier. It occurs when:</p> <ul> <li>Adding two positive numbers gives a negative result</li> <li>Adding two negative numbers gives a positive result</li> </ul> <p>The key insight: signed overflow occurs when the carry into the MSB differs from the carry out of the MSB.</p> <p>Example of signed overflow: \\(01111111_2 + 00000001_2\\) (+127 + 1)</p> <pre><code>    Carries: 1 1 1 1 1 1 1 0\n             0 1 1 1 1 1 1 1   (+127)\n           + 0 0 0 0 0 0 0 1   (+1)\n           -----------------\n             1 0 0 0 0 0 0 0   (-128 ???)\n</code></pre> <p>The result \\(10000000_2\\) is interpreted as -128 in signed representation. That's clearly wrong! The carry into the MSB was 1, but the carry out was 0\u2014they differ, signaling overflow.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-overflow-detection-simulator","title":"Diagram: Overflow Detection Simulator","text":"Overflow Detection Simulator <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: differentiate, examine</p> <p>Learning Objective: Students will be able to differentiate between situations that cause overflow and those that don't by examining carry patterns in signed addition.</p> <p>Canvas Layout: - Width: 700px, Height: 450px - Top: Two 8-bit input panels for operands with signed decimal display - Middle: Addition visualization with carry chain highlighted - Bottom: Result panel with overflow indicator and explanation</p> <p>Visual Elements: - 8-bit operand displays with MSB visually emphasized (larger, colored differently) - Carry chain showing all 9 carry bits explicitly - Carry-in to MSB and carry-out from MSB specially highlighted - XOR gate icon between the two critical carries - Overflow LED: green (no overflow) or red (overflow) - Explanation text describing why overflow did/didn't occur</p> <p>Interactive Controls: - Toggle buttons for each operand bit - Quick-select buttons for interesting cases: \"+127 + 1\", \"-128 + (-1)\", \"50 + 50\" - Signed/Unsigned interpretation toggle - \"Test Random\" button for practice</p> <p>Behavior: - Changing any operand bit immediately recalculates everything - Carry chain animates to show propagation - Overflow detection shows carry-in vs carry-out comparison - Explanation updates based on current numbers</p> <p>Data Visibility Requirements: - Show both operands with signed decimal interpretation - Highlight carry-in to bit 7 and carry-out from bit 7 - Show XOR of these two carries - Display overflow flag result</p> <p>Instructional Rationale: By explicitly showing the two critical carries and their XOR, students can verify the overflow detection rule rather than just memorizing it.</p> <p>Implementation: p5.js</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#bcd-encoding-when-decimal-display-matters","title":"BCD Encoding: When Decimal Display Matters","text":"<p>Binary-Coded Decimal (BCD) represents each decimal digit separately in 4 bits. Instead of converting the whole number to binary, we convert each digit independently.</p> <p>Example: Encode \\(47_{10}\\) in BCD</p> <ul> <li>4 in binary: 0100</li> <li>7 in binary: 0111</li> <li>BCD result: 0100 0111</li> </ul> <p>Compare to pure binary: \\(47_{10} = 00101111_2\\)</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#why-bcd-exists","title":"Why BCD Exists","text":"<p>BCD seems wasteful (we're using 8 bits to store a number that fits in 6), so why use it? Several practical reasons:</p> <ol> <li>Easy decimal display: Each 4-bit group directly maps to a display digit</li> <li>Exact decimal arithmetic: No binary rounding errors for financial calculations</li> <li>Legacy hardware: Seven-segment displays, calculators, and some industrial equipment expect BCD</li> </ol> <p>BCD addition requires special handling when a group exceeds 9. If adding two BCD digits produces a result from 10-15, we add 6 to \"fix\" it:</p> <p>Example: \\(27_{BCD} + 35_{BCD}\\)</p> <pre><code>    0010 0111\n  + 0011 0101\n  -----------\n    0101 1100\n</code></pre> <p>The second group is \\(1100_2 = 12_{10}\\), which is invalid BCD. Add 6:</p> <pre><code>    0101 1100\n  + 0000 0110\n  -----------\n    0110 0010\n</code></pre> <p>Result: \\(0110 0010_{BCD} = 62_{10}\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#gray-code-when-only-one-bit-should-change","title":"Gray Code: When Only One Bit Should Change","text":"<p>Here's a puzzle: what happens if you're reading a binary counter right at the moment it transitions from 0111 to 1000? All four bits change simultaneously\u2014but in real hardware, they don't change at exactly the same instant. For a brief moment, you might read garbage like 0000 or 1111.</p> <p>Gray code solves this by ensuring only one bit changes between consecutive values:</p> Decimal Binary Gray Code 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 <p>Notice how each step changes exactly one bit. This makes Gray code perfect for:</p> <ul> <li>Position encoders (rotary and linear)</li> <li>Analog-to-digital converters</li> <li>State machine encoding to avoid glitches</li> <li>Communication systems where bit errors should be minimized</li> </ul>"},{"location":"chapters/01-number-systems-binary-arithmetic/#converting-binary-to-gray-code","title":"Converting Binary to Gray Code","text":"<p>The conversion is surprisingly simple using XOR:</p> <p>\\(G_n = B_n\\) (copy the MSB) \\(G_i = B_{i+1} \\oplus B_i\\) (XOR each bit with the one above it)</p> <p>Example: Convert \\(1011_2\\) to Gray code</p> <ul> <li>\\(G_3 = B_3 = 1\\)</li> <li>\\(G_2 = B_3 \\oplus B_2 = 1 \\oplus 0 = 1\\)</li> <li>\\(G_1 = B_2 \\oplus B_1 = 0 \\oplus 1 = 1\\)</li> <li>\\(G_0 = B_1 \\oplus B_0 = 1 \\oplus 1 = 0\\)</li> </ul> <p>Gray code: \\(1110\\)</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-gray-code-vs-binary-counter-animation","title":"Diagram: Gray Code vs Binary Counter Animation","text":"Gray Code vs Binary Counter Animation <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, contrast</p> <p>Learning Objective: Students will be able to contrast Gray code and binary counting by observing how many bits change during each transition in both systems.</p> <p>Canvas Layout: - Width: 700px, Height: 400px - Left side: 4-bit binary counter display - Right side: 4-bit Gray code counter display - Bottom: Bit-change histogram and transition indicators</p> <p>Visual Elements: - Two columns of 4 large bits each, showing binary and Gray code - Bits that will change on next count highlighted in yellow - Counter showing decimal value (0-15) - Bar graph showing \"bits changed\" history for each encoding - Transition arrows between bit patterns</p> <p>Interactive Controls: - \"Step\" button advances both counters by one - \"Auto\" toggle for continuous counting with speed slider - \"Reset\" button returns to zero - \"Show Hazard\" checkbox simulates what happens during transitions</p> <p>Behavior: - Each step highlights which bits are about to change BEFORE the transition - Animation shows bits flipping (binary often has cascading effect, Gray has single flip) - Hazard mode shows how binary can produce brief invalid outputs during multi-bit transitions - Histogram tracks average bits changed over time</p> <p>Data Visibility Requirements: - Current value in both encodings with decimal equivalent - Highlighted bits that will change on next increment - Count of bits changing per transition - Running average comparison</p> <p>Instructional Rationale: Side-by-side comparison makes the single-bit-change property of Gray code immediately visible and memorable.</p> <p>Implementation: p5.js</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#weighted-codes-and-other-representations","title":"Weighted Codes and Other Representations","text":"<p>Binary and Gray code are just two of many possible codes. A weighted code is one where each bit position has a specific \"weight\" that determines its contribution to the value.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#standard-binary-8-4-2-1-weighted","title":"Standard Binary: 8-4-2-1 Weighted","text":"<p>Regular binary is a weighted code with weights 8, 4, 2, 1 for a 4-bit number. But other weight combinations are possible and sometimes useful.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#2-4-2-1-code","title":"2-4-2-1 Code","text":"<p>This code uses weights 2, 4, 2, 1 (notice the repeated weights). It's useful because it's self-complementing: to get the 9's complement of a BCD digit, just flip all bits.</p> Decimal 2-4-2-1 0 0000 1 0001 2 0010 3 0011 4 0100 5 1011 6 1100 7 1101 8 1110 9 1111 <p>To find the 9's complement of 3 (which is 6): flip \\(0011 \\rightarrow 1100\\) \u2713</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#excess-3-code","title":"Excess-3 Code","text":"<p>Excess-3 is BCD with 3 added to each value. It's also self-complementing and was popular in early computers.</p> Decimal BCD Excess-3 0 0000 0011 1 0001 0100 2 0010 0101 3 0011 0110 4 0100 0111 5 0101 1000 6 0110 1001 7 0111 1010 8 1000 1011 9 1001 1100"},{"location":"chapters/01-number-systems-binary-arithmetic/#diagram-weighted-codes-comparison-table","title":"Diagram: Weighted Codes Comparison Table","text":"Weighted Codes Comparison Table <p>Type: infographic</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, list</p> <p>Learning Objective: Students will be able to identify different weighted code representations for decimal digits by comparing multiple encoding schemes in an interactive table.</p> <p>Canvas Layout: - Width: 700px, Height: 350px - Interactive table showing multiple encoding schemes - Header row with column selectors - Hover reveals calculation for each code</p> <p>Visual Elements: - Table with columns: Decimal, 8-4-2-1 BCD, 2-4-2-1, Excess-3, Gray - Each cell shows 4-bit value - Hover on cell shows calculation breakdown (e.g., \"2\u00d71 + 4\u00d70 + 2\u00d70 + 1\u00d71 = 3\") - Self-complement pairs highlighted with matching colors</p> <p>Interactive Controls: - Column visibility checkboxes to show/hide encoding schemes - Decimal digit selector (0-9) to highlight a specific row - \"Show Complements\" toggle to highlight 9's complement pairs - \"Verify Weight\" mode: click any cell to see weight calculation</p> <p>Behavior: - Hovering a cell shows how the weights produce the decimal value - Clicking a row highlights it across all visible columns - Complement mode draws lines connecting 0\u21949, 1\u21948, 2\u21947, etc.</p> <p>Implementation: HTML/CSS table with JavaScript interactivity</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#practical-applications","title":"Practical Applications","text":"<p>Let's tie these concepts together with real-world examples you'll encounter in digital design.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#memory-addressing","title":"Memory Addressing","text":"<p>Computer memory is addressed using binary numbers. A 16-bit address bus can access \\(2^{16} = 65,536\\) memory locations. This is why you see memory sizes like 64K, 256K, or 4G\u2014they're all powers of 2.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#color-representation","title":"Color Representation","text":"<p>RGB colors use 8 bits per channel (red, green, blue), giving 24-bit color with over 16 million possibilities. That's \\(2^{24} = 16,777,216\\) colors. Web colors like #FF5733 are just three hex values packed together.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#digital-signal-processing","title":"Digital Signal Processing","text":"<p>Audio samples are typically 16-bit signed integers, ranging from -32,768 to +32,767. This gives enough precision for high-quality sound while fitting nicely into 2 bytes.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#error-detection","title":"Error Detection","text":"<p>Parity bits add a single bit to detect single-bit errors in transmission. Even parity means the total number of 1s (including the parity bit) is always even. It's a simple application of binary counting.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#key-takeaways","title":"Key Takeaways","text":"<p>As we wrap up this chapter, let's summarize the essential concepts:</p> <ol> <li>Binary is the language of digital circuits because it maps directly to physical on/off states</li> <li>Positional notation works the same regardless of base\u2014only the base value changes</li> <li>Hexadecimal is binary's shorthand, with each hex digit representing exactly 4 bits</li> <li>Two's complement enables subtraction using addition, simplifying hardware design</li> <li>Overflow must be detected to avoid silent calculation errors</li> <li>Gray code prevents glitches during counter transitions</li> <li>Different codes serve different purposes\u2014there's no single \"best\" representation</li> </ol> <p>These fundamentals will appear constantly throughout your digital electronics journey. When you're debugging a circuit and see 0xDEADBEEF in memory, you'll know exactly what you're looking at (and appreciate the programmer's sense of humor).</p> Self-Check: Can you convert 200 to binary using repeated division? <p>\\(200 \\div 2 = 100\\) remainder 0 \\(100 \\div 2 = 50\\) remainder 0 \\(50 \\div 2 = 25\\) remainder 0 \\(25 \\div 2 = 12\\) remainder 1 \\(12 \\div 2 = 6\\) remainder 0 \\(6 \\div 2 = 3\\) remainder 0 \\(3 \\div 2 = 1\\) remainder 1 \\(1 \\div 2 = 0\\) remainder 1</p> <p>Reading bottom to top: \\(11001000_2\\)</p> Self-Check: What is the 8-bit two's complement of 100? <p>Original: \\(01100100_2\\) One's complement: \\(10011011_2\\) Two's complement (add 1): \\(10011100_2\\)</p> <p>Interpretation: This represents \\(-100\\) in signed 8-bit format.</p> <p>In the next chapter, we'll put these number systems to work as we explore Boolean algebra\u2014the mathematical framework that governs all digital logic.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/","title":"Quiz: Number Systems and Binary Arithmetic","text":"<p>Test your understanding of number systems, binary arithmetic, and encoding schemes with these questions.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#1-what-is-the-decimal-equivalent-of-the-binary-number-10110","title":"1. What is the decimal equivalent of the binary number 10110?","text":"<ol> <li>18</li> <li>22</li> <li>26</li> <li>30</li> </ol> Show Answer <p>The correct answer is B. To convert binary 10110 to decimal, add the position values where there is a 1: 16 + 4 + 2 = 22. The positions are (from right to left): 2\u2070=1, 2\u00b9=2, 2\u00b2=4, 2\u00b3=8, 2\u2074=16.</p> <p>Concept Tested: Binary to Decimal Conversion</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#2-which-number-system-uses-base-16-and-digits-0-9-plus-a-f","title":"2. Which number system uses base 16 and digits 0-9 plus A-F?","text":"<ol> <li>Binary</li> <li>Octal</li> <li>Hexadecimal</li> <li>BCD</li> </ol> Show Answer <p>The correct answer is C. Hexadecimal (hex) is a base-16 number system that uses digits 0-9 for values 0-9 and letters A-F for values 10-15. It provides a compact way to represent binary values since each hex digit corresponds to exactly 4 binary bits.</p> <p>Concept Tested: Hexadecimal Numbers</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#3-what-is-the-result-of-the-binary-addition-1011-0110","title":"3. What is the result of the binary addition 1011 + 0110?","text":"<ol> <li>10001</li> <li>10010</li> <li>10011</li> <li>10101</li> </ol> Show Answer <p>The correct answer is A. Adding 1011 (11) + 0110 (6) = 10001 (17). Working right to left: 1+0=1, 1+1=10 (write 0, carry 1), 0+1+1=10 (write 0, carry 1), 1+0+1=10 (write 0, carry 1), carry 1.</p> <p>Concept Tested: Binary Addition</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#4-in-twos-complement-representation-using-8-bits-what-decimal-value-does-11111111-represent","title":"4. In two's complement representation using 8 bits, what decimal value does 11111111 represent?","text":"<ol> <li>255</li> <li>-1</li> <li>-127</li> <li>0</li> </ol> Show Answer <p>The correct answer is B. In two's complement, 11111111 represents -1. The MSB (leftmost bit) being 1 indicates a negative number. To find the magnitude, invert all bits (00000000) and add 1 (00000001 = 1), so the value is -1.</p> <p>Concept Tested: Two's Complement</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#5-what-is-the-primary-advantage-of-gray-code-over-standard-binary","title":"5. What is the primary advantage of Gray code over standard binary?","text":"<ol> <li>It uses fewer bits to represent the same values</li> <li>Only one bit changes between consecutive values</li> <li>It can represent larger numbers</li> <li>It is easier to convert to decimal</li> </ol> Show Answer <p>The correct answer is B. Gray code is designed so that consecutive values differ by exactly one bit. This property eliminates multi-bit transition errors in applications like rotary encoders and reduces glitches when crossing clock domains.</p> <p>Concept Tested: Gray Code</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#6-how-would-you-convert-decimal-45-to-binary-using-repeated-division-by-2","title":"6. How would you convert decimal 45 to binary using repeated division by 2?","text":"<ol> <li>Divide by 2 repeatedly and read remainders top to bottom</li> <li>Divide by 2 repeatedly and read remainders bottom to top</li> <li>Multiply by 2 repeatedly and record the integer parts</li> <li>Subtract powers of 2 starting from the largest</li> </ol> Show Answer <p>The correct answer is B. To convert decimal to binary, repeatedly divide by 2 and record the remainders. The remainders, read from bottom to top (last to first), form the binary number. For 45: 45\u00f72=22 R1, 22\u00f72=11 R0, 11\u00f72=5 R1, 5\u00f72=2 R1, 2\u00f72=1 R0, 1\u00f72=0 R1. Reading bottom to top: 101101.</p> <p>Concept Tested: Decimal to Binary Conversion</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#7-in-bcd-binary-coded-decimal-how-is-the-decimal-number-59-represented","title":"7. In BCD (Binary-Coded Decimal), how is the decimal number 59 represented?","text":"<ol> <li>00111011</li> <li>0101 1001</li> <li>111011</li> <li>0011 1011</li> </ol> Show Answer <p>The correct answer is B. In BCD, each decimal digit is encoded separately using 4 bits. Decimal 5 = 0101 and decimal 9 = 1001, so 59 in BCD is 0101 1001. BCD is not a direct binary conversion\u2014it encodes each digit independently.</p> <p>Concept Tested: BCD Encoding</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#8-what-condition-indicates-overflow-in-signed-binary-addition","title":"8. What condition indicates overflow in signed binary addition?","text":"<ol> <li>The result has more bits than the operands</li> <li>The carry out of the MSB is 1</li> <li>Two positive numbers produce a negative result (or vice versa)</li> <li>The sum equals zero</li> </ol> Show Answer <p>The correct answer is C. Overflow in signed addition occurs when the sign of the result is incorrect\u2014specifically, when adding two positive numbers yields a negative result, or adding two negative numbers yields a positive result. This happens when the result exceeds the representable range.</p> <p>Concept Tested: Overflow Detection</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#9-what-is-the-hexadecimal-equivalent-of-binary-11010110","title":"9. What is the hexadecimal equivalent of binary 11010110?","text":"<ol> <li>D6</li> <li>B6</li> <li>6D</li> <li>DA</li> </ol> Show Answer <p>The correct answer is A. To convert binary to hex, group bits into sets of 4 from the right: 1101 0110. Then convert each group: 1101 = D (13), 0110 = 6. So 11010110 binary = D6 hexadecimal.</p> <p>Concept Tested: Hex to Binary Conversion</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/quiz/#10-which-statement-correctly-describes-the-relationship-between-octal-and-binary","title":"10. Which statement correctly describes the relationship between octal and binary?","text":"<ol> <li>Each octal digit represents 2 binary bits</li> <li>Each octal digit represents 3 binary bits</li> <li>Each octal digit represents 4 binary bits</li> <li>Octal and binary have no direct relationship</li> </ol> Show Answer <p>The correct answer is B. Octal is base 8, and since 8 = 2\u00b3, each octal digit represents exactly 3 binary bits. For example, octal 7 = binary 111, octal 5 = binary 101. This makes conversion between octal and binary straightforward by grouping bits in threes.</p> <p>Concept Tested: Octal Numbers</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/","title":"Boolean Algebra Fundamentals","text":""},{"location":"chapters/02-boolean-algebra-fundamentals/#summary","title":"Summary","text":"<p>This chapter transforms logical reasoning into a mathematical framework that forms the theoretical foundation of all digital circuits. Students will learn about Boolean variables, constants, and the three fundamental operations (AND, OR, NOT), how to construct and interpret Boolean expressions and functions, the role of truth tables as formal specifications, and all essential Boolean algebra laws including De Morgan's theorem. Mastering these concepts enables students to analyze and simplify digital logic mathematically.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>Boolean Variable</li> <li>Boolean Constant</li> <li>Boolean Expression</li> <li>Boolean Function</li> <li>Truth Table</li> <li>AND Operation</li> <li>OR Operation</li> <li>NOT Operation</li> <li>Boolean Algebra</li> <li>Identity Law</li> <li>Null Law</li> <li>Idempotent Law</li> <li>Complement Law</li> <li>Commutative Law</li> <li>Associative Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>De Morgan's Theorem</li> <li>Dual Expression</li> <li>Consensus Theorem</li> <li>Boolean Proof Technique</li> </ol>"},{"location":"chapters/02-boolean-algebra-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Number Systems and Binary Arithmetic</li> </ul>"},{"location":"chapters/02-boolean-algebra-fundamentals/#introduction-welcome-to-the-world-of-true-and-false","title":"Introduction: Welcome to the World of True and False","text":"<p>Have you ever had an argument that was so simple it could only end with a \"yes\" or \"no\"? Welcome to Boolean algebra, where every argument ends that way. Named after mathematician George Boole (who presumably never had to answer \"maybe\" to dinner plans), Boolean algebra is a mathematical system where there are only two possible values: true and false, or as we electrical engineers prefer to call them, 1 and 0.</p> <p>Here's the thing that makes Boolean algebra so powerful: those same rules that govern simple true/false logic are exactly the rules that govern how billions of transistors in your computer make decisions every nanosecond. When you type a key, scroll a page, or run a program, you're ultimately relying on circuits that evaluate Boolean expressions. Digital circuits are, quite literally, Boolean functions made physical.</p> <p>Think of Boolean algebra as the \"grammar\" of digital logic. Just as you need to understand English grammar before writing a novel, you need to understand Boolean algebra before designing digital circuits. The good news? This grammar has far fewer exceptions than English. (No \"i before e except after c\" nonsense here!)</p> <p>By the end of this chapter, you'll be able to manipulate logical expressions with the same confidence that you manipulate algebraic equations\u2014and you'll understand why a law discovered in 1847 by a self-taught mathematician became the foundation for the digital revolution.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-variables-and-constants-the-building-blocks","title":"Boolean Variables and Constants: The Building Blocks","text":""},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-constants","title":"Boolean Constants","text":"<p>Let's start with the simplest possible idea: in the Boolean world, there are exactly two constants:</p> <ul> <li>0 (false, low, off)</li> <li>1 (true, high, on)</li> </ul> <p>That's it. No decimals, no fractions, no irrational numbers lurking about. Zero and one. Off and on. False and true. If regular algebra is an all-you-can-eat buffet of numbers, Boolean algebra is a very exclusive restaurant with exactly two items on the menu.</p> <p>These constants correspond directly to physical voltage levels in digital circuits. Typically, 0 represents a low voltage (near ground) and 1 represents a high voltage (near the power supply). But we'll worry about those physical details later\u2014for now, just remember: two values, and two values only.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-variables","title":"Boolean Variables","text":"<p>A Boolean variable is a symbol that can hold one of the two Boolean constants. We typically use uppercase letters like A, B, C, X, Y, or Z to represent Boolean variables. Sometimes you'll see lowercase letters or descriptive names like <code>enable</code>, <code>reset</code>, or <code>clock</code>\u2014especially in hardware description languages.</p> <p>Here's the key insight: a Boolean variable is like a light switch. At any given moment, it's either ON (1) or OFF (0). It can't be \"kind of on\" or \"mostly off.\" This binary nature is what makes digital systems so reliable\u2014there's no ambiguity about what state a signal is in.</p> Symbol Possible Values Physical Analogy A 0 or 1 Light switch B 0 or 1 Door (open/closed) X 0 or 1 Valve (open/closed) enable 0 or 1 Permission granted <p>Why Binary?</p> <p>Binary isn't just simpler\u2014it's more robust. When you only need to distinguish between two states (high vs. low voltage), you can tolerate a lot of electrical noise. Trying to distinguish between 10 different voltage levels? That's much harder to get right reliably.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#the-three-fundamental-operations","title":"The Three Fundamental Operations","text":"<p>With only two values to work with, you might think Boolean algebra would be boring. But here's where it gets interesting: we can combine Boolean values using operations (also called operators or gates). There are three fundamental operations that form the basis of all Boolean logic.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#not-operation-inversion","title":"NOT Operation (Inversion)","text":"<p>The NOT operation is the simplest: it flips the value. Give it a 0, it returns 1. Give it a 1, it returns 0. In mathematical notation, we write the NOT of A as:</p> <ul> <li>\\(\\overline{A}\\) (A with a bar over it)</li> <li>\\(A'\\) (A prime)</li> <li>\\(\\neg A\\) (logical negation symbol)</li> </ul> <p>Think of NOT as a contrarian friend who always disagrees with you. You say \"yes,\" they say \"no.\" You say \"no,\" they say \"yes.\"</p> A \\(\\overline{A}\\) 0 1 1 0 <p>In circuit terms, NOT is implemented by an inverter\u2014a simple gate that inverts its input.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#and-operation-conjunction","title":"AND Operation (Conjunction)","text":"<p>The AND operation takes two inputs and produces an output of 1 only if both inputs are 1. If either input (or both) is 0, the output is 0. We write A AND B as:</p> <ul> <li>\\(A \\cdot B\\) (A dot B)</li> <li>\\(AB\\) (just written together, like multiplication)</li> <li>\\(A \\land B\\) (logical AND symbol)</li> </ul> <p>Here's a great way to think about AND: imagine two switches in series controlling a light. The light only turns on if both Switch A AND Switch B are closed. Open either one, and the light goes off.</p> A B \\(A \\cdot B\\) 0 0 0 0 1 0 1 0 0 1 1 1 <p>Memory trick: AND is like multiplication in regular algebra. In fact, if you treat 0 and 1 as regular numbers, \\(A \\cdot B\\) works exactly like multiplication: \\(0 \\times 0 = 0\\), \\(0 \\times 1 = 0\\), \\(1 \\times 0 = 0\\), \\(1 \\times 1 = 1\\). This isn't a coincidence!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#or-operation-disjunction","title":"OR Operation (Disjunction)","text":"<p>The OR operation produces an output of 1 if at least one input is 1. Only when both inputs are 0 does the output become 0. We write A OR B as:</p> <ul> <li>\\(A + B\\) (A plus B)</li> <li>\\(A \\lor B\\) (logical OR symbol)</li> </ul> <p>Think of OR as two switches in parallel controlling a light. The light turns on if Switch A OR Switch B (or both!) are closed. The light only goes off if both switches are open.</p> A B \\(A + B\\) 0 0 0 0 1 1 1 0 1 1 1 1 <p>Wait, 1 + 1 = 1? Yes! This is Boolean addition, not regular arithmetic. In Boolean algebra, \\(1 + 1 = 1\\), not 2. Remember, there are only two values allowed. If the output is \"true,\" it stays true\u2014it doesn't become \"extra true.\"</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-three-fundamental-operations","title":"Diagram: Three Fundamental Operations","text":"Three Fundamental Operations Interactive <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Demonstrate</p> <p>Learning Objective: Demonstrate how the three fundamental Boolean operations (AND, OR, NOT) transform input values into output values through interactive exploration.</p> <p>Instructional Rationale: Interactive toggle switches allow students to immediately see the cause-and-effect relationship between inputs and outputs, reinforcing the truth table patterns through hands-on experimentation.</p> <p>Canvas Layout:</p> <ul> <li>Three panels side by side showing NOT, AND, and OR operations</li> <li>Each panel has clickable input toggles (squares that show 0 or 1)</li> <li>NOT panel: one input, one output</li> <li>AND/OR panels: two inputs, one output</li> <li>Operation symbol and name displayed in each panel</li> <li>Output displays prominently with color coding (0=gray, 1=green)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click on input squares to toggle between 0 and 1</li> <li>Outputs update immediately when inputs change</li> <li>Visual connection lines from inputs through operation symbol to output</li> </ul> <p>Visual Style:</p> <ul> <li>Clean, modern design with rounded rectangles for inputs/outputs</li> <li>Color scheme: inputs in blue tones, outputs green when 1, gray when 0</li> <li>Operation symbols clearly labeled (NOT: inverter triangle, AND: D-shape, OR: curved shape)</li> </ul> <p>Data Visibility:</p> <ul> <li>Current input values always visible</li> <li>Current output value always visible</li> <li>Expression shown below each operation (e.g., \"A AND B = 1\")</li> </ul> <p>Implementation: p5.js with canvas-based toggle buttons</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-expressions-building-more-complex-logic","title":"Boolean Expressions: Building More Complex Logic","text":"<p>Now that we have our three fundamental operations, we can combine them to create Boolean expressions\u2014formulas that describe more complex logical relationships.</p> <p>A Boolean expression is any valid combination of:</p> <ul> <li>Boolean constants (0, 1)</li> <li>Boolean variables (A, B, C, ...)</li> <li>Boolean operators (AND, OR, NOT)</li> <li>Parentheses (for grouping)</li> </ul> <p>Here are some examples of Boolean expressions:</p> <ul> <li>\\(\\overline{A}\\) \u2014 \"NOT A\"</li> <li>\\(A \\cdot B\\) \u2014 \"A AND B\"</li> <li>\\(A + B\\) \u2014 \"A OR B\"</li> <li>\\(\\overline{A} + B\\) \u2014 \"NOT A OR B\"</li> <li>\\(A \\cdot (B + C)\\) \u2014 \"A AND (B OR C)\"</li> <li>\\(\\overline{A \\cdot B}\\) \u2014 \"NOT (A AND B)\"</li> </ul>"},{"location":"chapters/02-boolean-algebra-fundamentals/#order-of-operations-precedence","title":"Order of Operations (Precedence)","text":"<p>Just like in regular algebra where multiplication happens before addition, Boolean algebra has its own precedence rules:</p> <ol> <li>Parentheses \u2014 highest priority, evaluated first</li> <li>NOT \u2014 evaluated next</li> <li>AND \u2014 evaluated before OR</li> <li>OR \u2014 evaluated last</li> </ol> <p>So the expression \\(A + B \\cdot C\\) means \\(A + (B \\cdot C)\\), not \\((A + B) \\cdot C\\). The AND happens first, just like multiplication happens before addition in regular algebra.</p> <p>Precedence Example</p> <p>Evaluate \\(\\overline{A} + B \\cdot C\\) when \\(A=1\\), \\(B=1\\), \\(C=0\\):</p> <ol> <li>First, NOT: \\(\\overline{A} = \\overline{1} = 0\\)</li> <li>Next, AND: \\(B \\cdot C = 1 \\cdot 0 = 0\\)</li> <li>Finally, OR: \\(0 + 0 = 0\\)</li> </ol> <p>Result: 0</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-functions-expressions-with-a-name","title":"Boolean Functions: Expressions with a Name","text":"<p>A Boolean function is simply a Boolean expression that has been given a name and explicitly shows its input variables. We write it as:</p> \\[F(A, B, C) = A \\cdot B + \\overline{C}\\] <p>This function, named \\(F\\), takes three inputs (\\(A\\), \\(B\\), \\(C\\)) and produces one output based on the expression \\(A \\cdot B + \\overline{C}\\).</p> <p>The distinction between expressions and functions is subtle but useful:</p> <ul> <li>An expression is the formula itself: \\(A \\cdot B + \\overline{C}\\)</li> <li>A function wraps that expression with a name and declares its inputs: \\(F(A, B, C) = A \\cdot B + \\overline{C}\\)</li> </ul> <p>Think of it this way: the expression is the recipe, and the function is the recipe with a title and ingredient list at the top.</p> <p>Every Boolean function with \\(n\\) input variables can be thought of as a mapping from \\(2^n\\) possible input combinations to output values. A function of 3 variables has \\(2^3 = 8\\) possible input combinations. A function of 4 variables has \\(2^4 = 16\\) combinations. This exponential growth is why simplifying Boolean functions becomes increasingly important as the number of variables grows.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#truth-tables-the-complete-picture","title":"Truth Tables: The Complete Picture","text":"<p>A truth table is a systematic way to show all possible input combinations for a Boolean function and its corresponding output for each combination. It's like a lookup table for your function\u2014give me any inputs, and I'll tell you the output.</p> <p>For a function with \\(n\\) variables, the truth table has \\(2^n\\) rows. Let's build a truth table for \\(F(A, B) = A \\cdot B + \\overline{B}\\):</p> Row A B \\(\\overline{B}\\) \\(A \\cdot B\\) \\(A \\cdot B + \\overline{B}\\) 0 0 0 1 0 1 1 0 1 0 0 0 2 1 0 1 0 1 3 1 1 0 1 1 <p>Notice that we included intermediate columns to show our work. This makes it easier to verify the calculation and catch errors. The rightmost column gives us our final answer: the function outputs 1 for inputs (0,0), (1,0), and (1,1), and outputs 0 only for input (0,1).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#truth-tables-as-specifications","title":"Truth Tables as Specifications","text":"<p>Here's a powerful idea: truth tables can serve as specifications for digital circuits. If someone gives you a truth table, you have a complete, unambiguous definition of what the circuit should do. There's no interpretation needed\u2014every possible input has a defined output.</p> <p>This is why truth tables are so important in digital design:</p> <ul> <li>Designers use them to specify what a circuit should do</li> <li>Verifiers use them to check if a circuit works correctly</li> <li>Optimizers use them to find simpler implementations</li> </ul>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-truth-table-builder","title":"Diagram: Truth Table Builder","text":"Truth Table Builder MicroSim <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Enable students to build truth tables for Boolean expressions by entering expressions and seeing the complete truth table generated automatically.</p> <p>Instructional Rationale: Active construction of truth tables reinforces understanding of how Boolean expressions map inputs to outputs. The immediate feedback helps students verify their mental model.</p> <p>Canvas Layout:</p> <ul> <li>Top section: Expression input area with example expressions shown</li> <li>Variable selector: Choose 2, 3, or 4 variables</li> <li>Main area: Generated truth table with all rows</li> <li>Highlight feature: Click any row to highlight input-output path</li> </ul> <p>Interactive Elements:</p> <ul> <li>Text input field for Boolean expression using notation: AND (*), OR (+), NOT (!)</li> <li>Dropdown to select number of variables (2-4)</li> <li>\"Generate\" button to create truth table</li> <li>Clickable rows to highlight and explain the evaluation</li> <li>Example expressions as clickable chips to auto-populate</li> </ul> <p>Visual Style:</p> <ul> <li>Table with alternating row colors for readability</li> <li>Output column color-coded: green for 1, gray for 0</li> <li>Expression parsing feedback (valid/invalid indicator)</li> <li>Current row highlighted when clicked</li> </ul> <p>Error Handling:</p> <ul> <li>Display helpful message for invalid expressions</li> <li>Suggest corrections for common syntax errors</li> </ul> <p>Implementation: p5.js with string parsing for expression evaluation</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#introduction-to-boolean-algebra-laws","title":"Introduction to Boolean Algebra Laws","text":"<p>Now we arrive at the heart of this chapter: the laws of Boolean algebra. These laws are your toolkit for manipulating and simplifying Boolean expressions. Learn them well, and you'll be able to transform complex, gate-hungry expressions into elegant, minimal circuits.</p> <p>Why do we care about simplification? Because simpler expressions mean:</p> <ul> <li>Fewer gates \u2014 less hardware, lower cost</li> <li>Lower power consumption \u2014 fewer transistors switching</li> <li>Faster circuits \u2014 fewer gate delays in the path</li> <li>Easier debugging \u2014 simpler designs are easier to understand</li> </ul> <p>The laws we're about to explore are theorems that have been proven to always hold true for Boolean algebra. Unlike regular algebra where \\(x \\cdot x = x^2\\), in Boolean algebra \\(A \\cdot A = A\\). Different system, different rules!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#identity-law","title":"Identity Law","text":"<p>The Identity Law tells us what happens when you combine a variable with the \"identity elements\" 0 and 1:</p> <p>[A + 0 = A] [A \\cdot 1 = A]</p> <p>In words:</p> <ul> <li>OR-ing anything with 0 leaves it unchanged</li> <li>AND-ing anything with 1 leaves it unchanged</li> </ul> <p>This makes intuitive sense: adding false to something doesn't change its truth value, and multiplying by true doesn't change anything either.</p> <p>Analogy: Think of 0 as \"adding zero\" in regular math (\\(x + 0 = x\\)) and 1 as \"multiplying by one\" (\\(x \\times 1 = x\\)).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#null-law-annulment-law","title":"Null Law (Annulment Law)","text":"<p>The Null Law (also called the Annulment Law) describes the \"dominating\" elements:</p> <p>[A + 1 = 1] [A \\cdot 0 = 0]</p> <p>In words:</p> <ul> <li>OR-ing anything with 1 always gives 1</li> <li>AND-ing anything with 0 always gives 0</li> </ul> <p>These are the \"override\" cases. If one input is already at the dominating value, the other input doesn't matter.</p> <p>Analogy: It's like multiplying by zero in regular math\u2014no matter what else is there, the result is zero. Similarly, if you already know something is definitely true (1), OR-ing it with anything else keeps it true.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#idempotent-law","title":"Idempotent Law","text":"<p>The Idempotent Law tells us what happens when we combine a variable with itself:</p> <p>[A + A = A] [A \\cdot A = A]</p> <p>\"Idempotent\" comes from Latin meaning \"same power\"\u2014applying the operation multiple times has the same effect as applying it once.</p> <p>This is one of those laws that makes Boolean algebra different from regular algebra. In regular algebra, \\(x + x = 2x\\) and \\(x \\cdot x = x^2\\). But in Boolean algebra, there are no 2's or squares\u2014only 0 and 1. Combining something with itself doesn't make it \"more true\" or \"more false.\"</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#complement-law","title":"Complement Law","text":"<p>The Complement Law describes what happens when you combine a variable with its own complement (NOT):</p> <p>[A + \\overline{A} = 1] [A \\cdot \\overline{A} = 0]</p> <p>In words:</p> <ul> <li>A variable OR its complement is always 1</li> <li>A variable AND its complement is always 0</li> </ul> <p>This should feel right: something is either true or not true (always true as a disjunction), but it can't be both true and not true at the same time (always false as a conjunction).</p> <p>Analogy: It's like asking \"Is the light on OR off?\" The answer is always yes. But \"Is the light on AND off simultaneously?\" The answer is always no.</p> <p>Also, applying NOT twice returns you to the original value:</p> \\[\\overline{\\overline{A}} = A\\] <p>Double negation cancels out, just like in regular logic: \"I'm not not going to the party\" means you're going.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#commutative-law","title":"Commutative Law","text":"<p>The Commutative Law says that the order of operands doesn't matter for AND and OR:</p> <p>[A + B = B + A] [A \\cdot B = B \\cdot A]</p> <p>You can swap the inputs around freely. Just like in regular algebra where \\(3 + 5 = 5 + 3\\).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#associative-law","title":"Associative Law","text":"<p>The Associative Law says that grouping doesn't matter when you have multiple AND or multiple OR operations:</p> <p>[A + (B + C) = (A + B) + C] [A \\cdot (B \\cdot C) = (A \\cdot B) \\cdot C]</p> <p>This means you can remove parentheses when you have a chain of the same operation: \\(A + B + C\\) is unambiguous, as is \\(A \\cdot B \\cdot C\\).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#distributive-law","title":"Distributive Law","text":"<p>The Distributive Law is where things get interesting. Like regular algebra, AND distributes over OR:</p> \\[A \\cdot (B + C) = A \\cdot B + A \\cdot C\\] <p>But here's a twist\u2014in Boolean algebra, OR also distributes over AND!</p> \\[A + (B \\cdot C) = (A + B) \\cdot (A + C)\\] <p>This second form has no counterpart in regular algebra. In ordinary algebra, \\(a + (b \\times c) \\neq (a + b) \\times (a + c)\\). But in Boolean algebra, it works! This is one of the surprising and powerful features of Boolean algebra.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-boolean-algebra-laws-explorer","title":"Diagram: Boolean Algebra Laws Explorer","text":"Boolean Algebra Laws Interactive Explorer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how each Boolean algebra law transforms expressions by stepping through concrete examples with specific values.</p> <p>Instructional Rationale: Seeing the same law applied with different variable values helps students generalize the pattern. Step-through interaction ensures they can't skip ahead without seeing the transformation.</p> <p>Canvas Layout:</p> <ul> <li>Law selector at top (dropdown or tabs): Identity, Null, Idempotent, Complement, Commutative, Associative, Distributive</li> <li>Left side: Original expression with variable value toggles</li> <li>Center: Transformation arrow with law name</li> <li>Right side: Equivalent simplified expression</li> <li>Bottom: Evaluation showing both sides equal the same result</li> </ul> <p>Interactive Elements:</p> <ul> <li>Dropdown/tabs to select which law to explore</li> <li>Toggle buttons for variable values (A=0/1, B=0/1, C=0/1)</li> <li>\"Step\" button to show transformation step by step</li> <li>Visual highlighting of which part of expression is being transformed</li> </ul> <p>Data Visibility:</p> <ul> <li>Original expression: A + 0 = A (with current value of A shown)</li> <li>After applying law: Result shown</li> <li>Verification: Both sides evaluated to show equality</li> </ul> <p>Visual Style:</p> <ul> <li>Clean mathematical notation</li> <li>Transformation arrows between equivalent forms</li> <li>Color coding: variables in blue, constants in gray, result in green</li> <li>Law name and formula shown prominently</li> </ul> <p>Implementation: p5.js with canvas-based controls</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#absorption-law","title":"Absorption Law","text":"<p>The Absorption Law lets you simplify expressions where a term \"absorbs\" a more complex term:</p> <p>[A + A \\cdot B = A] [A \\cdot (A + B) = A]</p> <p>At first glance, this might seem strange. Let's think through the first one: \\(A + A \\cdot B = A\\).</p> <ul> <li>If \\(A = 0\\): \\(0 + 0 \\cdot B = 0 + 0 = 0 = A\\) \u2713</li> <li>If \\(A = 1\\): \\(1 + 1 \\cdot B = 1 + B = 1 = A\\) \u2713 (by the null law)</li> </ul> <p>The term \\(A\\) \"absorbs\" the \\(A \\cdot B\\) term because if \\(A\\) is already true, who cares about \\(A \\cdot B\\)? And if \\(A\\) is false, then \\(A \\cdot B\\) is also false.</p> <p>Analogy: Imagine you're at a buffet. You take item A. Then someone offers you \"A along with B.\" If you already have A, taking \"A with B\" doesn't add anything useful\u2014you still just have A (you already took it!).</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#de-morgans-theorem","title":"De Morgan's Theorem","text":"<p>De Morgan's Theorem is arguably the most important theorem in Boolean algebra for practical circuit design. It provides a way to convert between AND and OR operations:</p> <p>[\\overline{A \\cdot B} = \\overline{A} + \\overline{B}] [\\overline{A + B} = \\overline{A} \\cdot \\overline{B}]</p> <p>In words:</p> <ul> <li>The complement of an AND is the OR of the complements</li> <li>The complement of an OR is the AND of the complements</li> </ul> <p>These theorems are incredibly useful because they let you:</p> <ol> <li>Convert between gate types \u2014 Transform an AND expression into an OR expression (with inversions)</li> <li>Push inversions inward \u2014 Move NOT operations closer to the variables</li> <li>Implement logic with different gate types \u2014 Crucial when you only have certain gates available</li> </ol> <p>Memory trick: \"Break the bar, change the sign.\" When you \"break\" the NOT bar over an expression, you change AND to OR (or OR to AND) and apply NOT to each individual term.</p> <p>Let's verify the first form with a truth table:</p> A B \\(A \\cdot B\\) \\(\\overline{A \\cdot B}\\) \\(\\overline{A}\\) \\(\\overline{B}\\) \\(\\overline{A} + \\overline{B}\\) 0 0 0 1 1 1 1 0 1 0 1 1 0 1 1 0 0 1 0 1 1 1 1 1 0 0 0 0 <p>The columns \\(\\overline{A \\cdot B}\\) and \\(\\overline{A} + \\overline{B}\\) are identical\u2014the theorem holds!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-de-morgans-theorem-visualizer","title":"Diagram: De Morgan's Theorem Visualizer","text":"De Morgan's Theorem Interactive Visualizer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Interpret</p> <p>Learning Objective: Students will be able to interpret De Morgan's theorem by seeing how expressions with the bar broken and unbroken produce identical outputs for all input combinations.</p> <p>Instructional Rationale: Visualizing both forms of an expression side-by-side with the same inputs creates a strong mental link between the equivalent forms. The \"break the bar\" animation reinforces the transformation rule.</p> <p>Canvas Layout:</p> <ul> <li>Two-column display showing both forms of De Morgan's theorem</li> <li>Left column: Original form (e.g., \\(\\overline{A \\cdot B}\\))</li> <li>Right column: Transformed form (e.g., \\(\\overline{A} + \\overline{B}\\))</li> <li>Shared input toggles at top for A and B values</li> <li>Gate diagram below each expression showing equivalent circuits</li> <li>Animation showing \"break the bar\" transformation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for A and B inputs</li> <li>\"Break the Bar\" button triggers animation showing transformation</li> <li>Tab selector for: \\(\\overline{A \\cdot B}\\) form vs \\(\\overline{A + B}\\) form</li> <li>Both sides update simultaneously when inputs change</li> </ul> <p>Visual Style:</p> <ul> <li>Expression notation with proper overlines</li> <li>Circuit symbols shown below expressions</li> <li>Color-coded: inputs blue, intermediate values yellow, outputs green</li> <li>Animation shows bar \"breaking\" and operation symbol changing</li> </ul> <p>Data Visibility:</p> <ul> <li>Input values prominently displayed</li> <li>Intermediate computation steps shown</li> <li>Final outputs shown with equality check (both should always match)</li> </ul> <p>Implementation: p5.js with animation for bar-breaking effect</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#dual-expression","title":"Dual Expression","text":"<p>Every Boolean expression has a dual expression obtained by:</p> <ol> <li>Swapping all AND operators with OR operators</li> <li>Swapping all OR operators with AND operators</li> <li>Swapping all 0s with 1s</li> <li>Swapping all 1s with 0s</li> <li>Keeping the variables unchanged</li> </ol> <p>For example:</p> <ul> <li>The dual of \\(A + B \\cdot C\\) is \\(A \\cdot (B + C)\\)</li> <li>The dual of \\(A + 0\\) is \\(A \\cdot 1\\)</li> <li>The dual of \\(A \\cdot \\overline{B}\\) is \\(A + \\overline{B}\\)</li> </ul> <p>The Principle of Duality: If a Boolean equation is valid, its dual is also valid. This is why Boolean algebra laws often come in pairs\u2014each law has a dual.</p> <p>Look back at our laws:</p> Law One Form Dual Form Identity \\(A + 0 = A\\) \\(A \\cdot 1 = A\\) Null \\(A + 1 = 1\\) \\(A \\cdot 0 = 0\\) Idempotent \\(A + A = A\\) \\(A \\cdot A = A\\) Complement \\(A + \\overline{A} = 1\\) \\(A \\cdot \\overline{A} = 0\\) Absorption \\(A + A \\cdot B = A\\) \\(A \\cdot (A + B) = A\\) De Morgan \\(\\overline{A + B} = \\overline{A} \\cdot \\overline{B}\\) \\(\\overline{A \\cdot B} = \\overline{A} + \\overline{B}\\) <p>Notice how each pair is just the dual of the other! This duality principle means you only need to memorize half the laws\u2014you can derive the other half by taking the dual.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#consensus-theorem","title":"Consensus Theorem","text":"<p>The Consensus Theorem is a more advanced law that helps eliminate redundant terms:</p> \\[A \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot C\\] <p>The term \\(B \\cdot C\\) is the \"consensus term\"\u2014it's redundant because it's implied by the other two terms. Here's the intuition:</p> <ul> <li>If \\(A = 1\\), then \\(A \\cdot B = B\\) covers the case where \\(B = 1\\)</li> <li>If \\(A = 0\\), then \\(\\overline{A} \\cdot C = C\\) covers the case where \\(C = 1\\)</li> <li>The term \\(B \\cdot C\\) only matters when both \\(B = 1\\) and \\(C = 1\\), but in that case, either \\(A = 1\\) (first term covers it) or \\(A = 0\\) (second term covers it)</li> </ul> <p>The dual form is:</p> \\[(A + B) \\cdot (\\overline{A} + C) \\cdot (B + C) = (A + B) \\cdot (\\overline{A} + C)\\] <p>The Consensus Theorem is particularly useful in Karnaugh map simplification (covered in a later chapter) and in finding minimal expressions.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#boolean-proof-techniques","title":"Boolean Proof Techniques","text":"<p>Now that we have a toolkit of laws, how do we prove that two Boolean expressions are equivalent or simplify a complex expression? There are several approaches.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#method-1-truth-table-verification","title":"Method 1: Truth Table Verification","text":"<p>Create truth tables for both expressions. If the output columns are identical for all input combinations, the expressions are equivalent.</p> <p>Pros: Guaranteed to work, very systematic Cons: Gets tedious for many variables (\\(2^n\\) rows), doesn't show why they're equivalent</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#method-2-algebraic-manipulation","title":"Method 2: Algebraic Manipulation","text":"<p>Start with one expression and apply Boolean laws step-by-step until you reach the other expression (or a simpler form).</p> <p>Example: Prove that \\(\\overline{A} \\cdot B + A \\cdot B = B\\)</p> <p>[\\overline{A} \\cdot B + A \\cdot B] [= B \\cdot (\\overline{A} + A) \\text{ ... Distributive Law (factoring)}] [= B \\cdot 1 \\text{ ... Complement Law}] [= B \\text{ ... Identity Law}]</p> <p>This method requires practice and familiarity with the laws, but it's faster than truth tables for complex expressions.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#method-3-reducing-to-canonical-forms","title":"Method 3: Reducing to Canonical Forms","text":"<p>Convert both expressions to the same canonical form (like Sum-of-Products or Product-of-Sums\u2014covered in the next chapter). If the canonical forms match, the expressions are equivalent.</p> <p>Let's work through a more complex example.</p> <p>Example: Simplify \\(F = A \\cdot B + A \\cdot \\overline{B} + \\overline{A} \\cdot B\\)</p> <p>[F = A \\cdot B + A \\cdot \\overline{B} + \\overline{A} \\cdot B] [= A \\cdot (B + \\overline{B}) + \\overline{A} \\cdot B \\text{ ... Distributive (factor A)}] [= A \\cdot 1 + \\overline{A} \\cdot B \\text{ ... Complement Law}] [= A + \\overline{A} \\cdot B \\text{ ... Identity Law}] [= (A + \\overline{A}) \\cdot (A + B) \\text{ ... Distributive Law (OR over AND)}] [= 1 \\cdot (A + B) \\text{ ... Complement Law}] [= A + B \\text{ ... Identity Law}]</p> <p>We simplified a three-term expression down to just \\(A + B\\)!</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#diagram-boolean-simplification-stepper","title":"Diagram: Boolean Simplification Stepper","text":"Boolean Simplification Stepper MicroSim <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Apply</p> <p>Learning Objective: Students will be able to apply Boolean algebra laws to simplify expressions step-by-step, with immediate feedback on which laws are applicable at each stage.</p> <p>Instructional Rationale: Guided step-through with law identification helps students internalize the simplification process. Seeing which laws apply at each step builds pattern recognition skills.</p> <p>Canvas Layout:</p> <ul> <li>Expression display area at top showing current state</li> <li>List of applicable laws (clickable buttons)</li> <li>History panel showing steps taken</li> <li>Final simplified result with gate count comparison</li> <li>Reset and example expression buttons</li> </ul> <p>Interactive Elements:</p> <ul> <li>Current expression displayed prominently</li> <li>Buttons for each Boolean law that can be applied</li> <li>Clicking a law shows preview of transformation</li> <li>\"Apply\" button to confirm and advance</li> <li>\"Undo\" button to step back</li> <li>\"Hint\" button suggests next good step</li> </ul> <p>Data Visibility:</p> <ul> <li>Starting expression</li> <li>Current expression after each step</li> <li>Law applied at each step</li> <li>Running count of gates/terms</li> </ul> <p>Example Problems:</p> <ul> <li>\\(\\overline{A} \\cdot B + A \\cdot B\\) (simplifies to \\(B\\))</li> <li>\\(A + A \\cdot B\\) (simplifies to \\(A\\))</li> <li>\\(A \\cdot B + A \\cdot \\overline{B} + \\overline{A} \\cdot B\\) (simplifies to \\(A + B\\))</li> </ul> <p>Visual Style:</p> <ul> <li>Laws color-coded by type (identity=blue, complement=green, De Morgan=orange)</li> <li>Transformation preview in lighter color before applying</li> <li>History shows crossed-out terms and applied law names</li> </ul> <p>Implementation: p5.js with expression parsing and law matching</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's walk through a complete example that uses multiple concepts from this chapter.</p> <p>Problem: A digital lock should open when:</p> <ul> <li>The correct 2-bit code is entered (both bits A and B must be 1), OR</li> <li>The master override switch M is activated</li> </ul> <p>Express this as a Boolean function, create its truth table, and simplify if possible.</p> <p>Step 1: Define the function</p> \\[F(A, B, M) = (A \\cdot B) + M\\] <p>Step 2: Create the truth table</p> A B M \\(A \\cdot B\\) \\((A \\cdot B) + M\\) 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 <p>Step 3: Analysis</p> <p>The function is already in a simple form. The lock opens in 4 out of 8 cases:</p> <ul> <li>Rows 1, 3, 5: M=1 (master override)</li> <li>Row 6: A=1, B=1 (correct code)</li> <li>Row 7: Both conditions satisfied</li> </ul> <p>The expression \\(F = A \\cdot B + M\\) is already minimal for this specification.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you practice Boolean algebra, watch out for these common pitfalls:</p> <ol> <li> <p>Forgetting that \\(1 + 1 = 1\\): This isn't regular arithmetic!</p> </li> <li> <p>Mixing up De Morgan's: Remember, you change the operation AND swap complements. Don't do just one or the other.</p> </li> <li> <p>Forgetting precedence: \\(A + B \\cdot C\\) is \\(A + (B \\cdot C)\\), not \\((A + B) \\cdot C\\).</p> </li> <li> <p>Applying regular algebra rules: \\(A + A \\neq 2A\\) and \\(A \\cdot A \\neq A^2\\).</p> </li> <li> <p>Skipping verification: After simplifying, check your work with a truth table. It catches errors!</p> </li> </ol>"},{"location":"chapters/02-boolean-algebra-fundamentals/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've completed your first deep dive into Boolean algebra. Here's what you've learned:</p> <ul> <li>Boolean variables can only be 0 or 1, true or false</li> <li>Three fundamental operations: NOT (inverts), AND (both true), OR (at least one true)</li> <li>Boolean expressions combine variables and operators</li> <li>Truth tables completely specify a Boolean function's behavior</li> <li>Boolean laws let you simplify expressions:</li> <li>Identity, Null, Idempotent, Complement</li> <li>Commutative, Associative, Distributive</li> <li>Absorption</li> <li>De Morgan's Theorem</li> <li>Consensus Theorem</li> <li>Duality means laws come in pairs\u2014swap AND/OR and 0/1</li> <li>Proof techniques include truth tables and algebraic manipulation</li> </ul> <p>These concepts form the mathematical foundation for everything else in digital electronics. In the next chapter, we'll see how these Boolean expressions map directly to logic gates\u2014the physical building blocks of digital circuits.</p> <p>Key Insight</p> <p>Boolean algebra bridges the gap between logical thinking and electronic circuits. Every Boolean expression can be implemented in hardware, and every digital circuit implements a Boolean function. Master these fundamentals, and you've mastered the language of digital design.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Simplify using Boolean laws <p>Simplify \\(F = A \\cdot \\overline{A} + B\\)</p> <p>Solution: \\(F = A \\cdot \\overline{A} + B\\) \\(= 0 + B\\) (Complement Law) \\(= B\\) (Identity Law)</p> Problem 2: Apply De Morgan's Theorem <p>Express \\(\\overline{A + B + C}\\) using only AND operations and individual complements.</p> <p>Solution: \\(\\overline{A + B + C} = \\overline{A} \\cdot \\overline{B} \\cdot \\overline{C}\\) (De Morgan's extended to three variables)</p> Problem 3: Verify with truth table <p>Prove that \\(A + \\overline{A} \\cdot B = A + B\\)</p> <p>Solution: | A | B | \\(\\overline{A}\\) | \\(\\overline{A} \\cdot B\\) | \\(A + \\overline{A} \\cdot B\\) | \\(A + B\\) | |---|---|----------------|------------------------|---------------------------|---------| | 0 | 0 | 1 | 0 | 0 | 0 | | 0 | 1 | 1 | 1 | 1 | 1 | | 1 | 0 | 0 | 0 | 1 | 1 | | 1 | 1 | 0 | 0 | 1 | 1 |</p> <p>The last two columns match \u2713</p> Problem 4: Find the dual <p>What is the dual of \\(A \\cdot (B + C) = A \\cdot B + A \\cdot C\\)?</p> <p>Solution: Swap AND\u2194OR and 0\u21941 (no constants here): \\(A + (B \\cdot C) = (A + B) \\cdot (A + C)\\) (This is the OR-over-AND distributive law!)</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/","title":"Quiz: Boolean Algebra Fundamentals","text":"<p>Test your understanding of Boolean algebra, logic operations, and simplification laws with these questions.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#1-what-is-the-result-of-the-boolean-expression-a-1","title":"1. What is the result of the Boolean expression A + 1?","text":"<ol> <li>A</li> <li>1</li> <li>0</li> <li>A'</li> </ol> Show Answer <p>The correct answer is B. According to the Null Law (also called the Dominance Law), any variable ORed with 1 equals 1. This makes sense because if either input to an OR is true, the output is true\u2014and 1 is always true.</p> <p>Concept Tested: Null Law</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#2-which-boolean-law-states-that-a-ab-a","title":"2. Which Boolean law states that A + AB = A?","text":"<ol> <li>Identity Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>Complement Law</li> </ol> Show Answer <p>The correct answer is C. The Absorption Law states that A + AB = A and A(A + B) = A. It allows us to \"absorb\" redundant terms. The intuition: if A is true, the whole expression is true regardless of B.</p> <p>Concept Tested: Absorption Law</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#3-what-does-de-morgans-theorem-state-about-a-b","title":"3. What does De Morgan's Theorem state about (A + B)'?","text":"<ol> <li>(A + B)' = A' + B'</li> <li>(A + B)' = A'B'</li> <li>(A + B)' = AB'</li> <li>(A + B)' = A'B</li> </ol> Show Answer <p>The correct answer is B. De Morgan's Theorem states that the complement of a sum equals the product of the complements: (A + B)' = A'B'. Similarly, (AB)' = A' + B'. This theorem is fundamental for converting between AND/OR forms and implementing circuits with NAND/NOR gates.</p> <p>Concept Tested: De Morgan's Theorem</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#4-in-a-truth-table-for-a-3-input-boolean-function-how-many-rows-are-required","title":"4. In a truth table for a 3-input Boolean function, how many rows are required?","text":"<ol> <li>3</li> <li>6</li> <li>8</li> <li>16</li> </ol> Show Answer <p>The correct answer is C. A truth table must include all possible input combinations. For n inputs, there are 2\u207f combinations. With 3 inputs, there are 2\u00b3 = 8 rows, covering all combinations from 000 to 111.</p> <p>Concept Tested: Truth Table</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#5-which-expression-is-equivalent-to-a-b-xor","title":"5. Which expression is equivalent to A \u2295 B (XOR)?","text":"<ol> <li>AB + A'B'</li> <li>A'B + AB'</li> <li>(A + B)'</li> <li>A'B'</li> </ol> Show Answer <p>The correct answer is B. XOR (exclusive OR) outputs 1 when exactly one input is 1. The expression A'B + AB' captures this: either A is 0 and B is 1, or A is 1 and B is 0. Option A describes XNOR (equivalence), not XOR.</p> <p>Concept Tested: Boolean Expression</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#6-what-is-the-commutative-law-of-boolean-algebra","title":"6. What is the Commutative Law of Boolean algebra?","text":"<ol> <li>A + (B + C) = (A + B) + C</li> <li>A + B = B + A</li> <li>A + A = A</li> <li>A + 0 = A</li> </ol> Show Answer <p>The correct answer is B. The Commutative Law states that the order of operands doesn't matter: A + B = B + A and AB = BA. Option A is the Associative Law, option C is the Idempotent Law, and option D is the Identity Law.</p> <p>Concept Tested: Commutative Law</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#7-simplify-the-expression-abc-abc-using-boolean-algebra","title":"7. Simplify the expression ABC + ABC' using Boolean algebra.","text":"<ol> <li>ABC</li> <li>AB</li> <li>AC</li> <li>A</li> </ol> Show Answer <p>The correct answer is B. Factor out AB: ABC + ABC' = AB(C + C'). By the Complement Law, C + C' = 1. Therefore, AB(1) = AB. This is a common simplification pattern where a variable and its complement appear in adjacent terms.</p> <p>Concept Tested: Algebraic Simplification</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#8-what-is-a-boolean-function","title":"8. What is a Boolean function?","text":"<ol> <li>A circuit made of logic gates</li> <li>A mapping from Boolean input combinations to Boolean outputs</li> <li>A variable that can only be 0 or 1</li> <li>A type of arithmetic operation</li> </ol> Show Answer <p>The correct answer is B. A Boolean function is a mathematical mapping that takes Boolean input combinations (each variable being 0 or 1) and produces a Boolean output (0 or 1). It defines the relationship between inputs and outputs, which can then be implemented as a circuit.</p> <p>Concept Tested: Boolean Function</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#9-according-to-the-distributive-law-what-is-ab-c","title":"9. According to the Distributive Law, what is A(B + C)?","text":"<ol> <li>AB + C</li> <li>AB + AC</li> <li>A + BC</li> <li>ABC</li> </ol> Show Answer <p>The correct answer is B. The Distributive Law states A(B + C) = AB + AC. This is similar to distribution in regular algebra. Boolean algebra also has a unique dual form: A + BC = (A + B)(A + C), which differs from standard algebra.</p> <p>Concept Tested: Distributive Law</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/quiz/#10-what-does-the-complement-law-state-about-a-a","title":"10. What does the Complement Law state about A \u00b7 A'?","text":"<ol> <li>A \u00b7 A' = 1</li> <li>A \u00b7 A' = 0</li> <li>A \u00b7 A' = A</li> <li>A \u00b7 A' = A'</li> </ol> Show Answer <p>The correct answer is B. The Complement Law states that A \u00b7 A' = 0 (a variable ANDed with its complement is always 0) and A + A' = 1 (a variable ORed with its complement is always 1). This makes sense: A and A' can never both be true simultaneously.</p> <p>Concept Tested: Complement Law</p>"},{"location":"chapters/03-logic-gates-digital-signals/","title":"Logic Gates and Digital Signal Properties","text":""},{"location":"chapters/03-logic-gates-digital-signals/#summary","title":"Summary","text":"<p>This chapter bridges the gap between Boolean algebra theory and physical circuit implementation by introducing logic gates as the building blocks of digital systems. Students will learn about all primitive gates (AND, OR, NOT, NAND, NOR, XOR, XNOR), the concept of functional completeness and universal gates, gate timing characteristics including propagation delay, fan-in and fan-out considerations, logic families (TTL and CMOS), and digital signal properties. Understanding these concepts is essential for designing real hardware that correctly implements Boolean functions.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 30 concepts from the learning graph:</p> <ol> <li>Logic Gate</li> <li>AND Gate</li> <li>OR Gate</li> <li>NOT Gate</li> <li>Buffer Gate</li> <li>NAND Gate</li> <li>NOR Gate</li> <li>XOR Gate</li> <li>XNOR Gate</li> <li>Gate Symbol</li> <li>IEEE Gate Symbols</li> <li>Functional Completeness</li> <li>Universal Gate</li> <li>NAND-Only Design</li> <li>NOR-Only Design</li> <li>Gate Delay</li> <li>Propagation Delay</li> <li>Rise Time</li> <li>Fall Time</li> <li>Fan-In</li> <li>Fan-Out</li> <li>Logic Levels</li> <li>Noise Margin</li> <li>Voltage Threshold</li> <li>Logic Family</li> <li>TTL Logic</li> <li>CMOS Logic</li> <li>Digital Signal</li> <li>Analog vs Digital</li> <li>Signal Integrity</li> </ol>"},{"location":"chapters/03-logic-gates-digital-signals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Boolean Algebra Fundamentals</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#introduction-from-symbols-to-silicon","title":"Introduction: From Symbols to Silicon","text":"<p>In the last chapter, you learned to speak the language of Boolean algebra\u2014AND, OR, NOT, truth tables, and all those elegant mathematical laws. But here's the thing: equations don't compute anything by themselves. You can't power your laptop with De Morgan's theorem (though wouldn't that be nice for your electricity bill?).</p> <p>This chapter is where the rubber meets the road\u2014or more accurately, where the math meets the metal. We're going to transform those abstract Boolean operations into logic gates: physical electronic components that actually do the computation. These tiny circuits are the atoms of the digital universe, and everything from your smartphone to a supercomputer is built from combinations of these fundamental building blocks.</p> <p>Think of it this way: Boolean algebra is like sheet music, describing what notes should be played. Logic gates are the actual instruments that produce the sound. You can't have a symphony without both.</p> <p>By the end of this chapter, you'll understand not just what logic gates do (that's the easy part\u2014they implement Boolean functions), but how they behave in the real world: their timing quirks, their voltage requirements, their limitations, and why engineers sometimes spend weeks worrying about a few nanoseconds of delay. Welcome to the physical reality of digital design!</p>"},{"location":"chapters/03-logic-gates-digital-signals/#what-is-a-logic-gate","title":"What is a Logic Gate?","text":"<p>A logic gate is an electronic circuit that implements a Boolean operation. It takes one or more binary inputs (0s and 1s represented as voltage levels) and produces a binary output based on a specific logical function.</p> <p>Here's the fundamental insight that makes digital electronics possible:</p> <p>A logic gate is a Boolean function built from transistors.</p> <p>Every logic gate you'll ever encounter is essentially an arrangement of transistors configured to produce the correct output for each possible input combination. The transistors act as electronic switches, and their clever arrangement makes Boolean logic physically real.</p> <p>Logic gates have several key characteristics:</p> <ul> <li>Binary inputs and outputs: Each signal is either HIGH (1) or LOW (0)</li> <li>Deterministic behavior: For any given set of inputs, the output is always the same</li> <li>Finite response time: Outputs don't change instantaneously (more on this later)</li> <li>Power consumption: Gates need energy to operate\u2014there's no free computation!</li> </ul> Property Description Function The Boolean operation performed (AND, OR, NOT, etc.) Inputs Number and type of binary input signals Output Resulting binary signal based on the function Symbol Standardized graphical representation Physical Realization Transistor-level implementation"},{"location":"chapters/03-logic-gates-digital-signals/#gate-symbols-the-visual-language","title":"Gate Symbols: The Visual Language","text":"<p>Before we dive into each gate type, let's talk about gate symbols\u2014the standardized graphical representations used in circuit diagrams (called schematics). These symbols are your visual vocabulary for reading and drawing digital circuits.</p> <p>There are two main standards for gate symbols:</p> <ol> <li>Distinctive-shape symbols: Each gate type has a unique shape that makes it instantly recognizable</li> <li>IEEE rectangular symbols: All gates use rectangles with function labels inside</li> </ol> <p>Throughout this textbook (and in most of industry), we use the distinctive-shape symbols because they're faster to recognize at a glance. When you see that curved back of an OR gate or the flat back of an AND gate, you immediately know what operation is happening.</p> <p>Symbol Recognition is a Superpower</p> <p>Experienced digital designers can \"read\" a complex schematic as quickly as you read text, because the gate shapes become second nature. Invest time in learning these symbols now, and circuit diagrams will speak to you.</p> <p>Let's meet the gates!</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-buffer-gate-the-simplest-gate","title":"The Buffer Gate: The Simplest Gate","text":"<p>We'll start with the buffer gate, which seems almost too simple to exist. A buffer takes one input and produces an output that's... exactly the same as the input.</p> <p>Wait, what? Why would we need a gate that does nothing?</p> <p>Actually, buffers do several important things:</p> <ul> <li>Signal restoration: They boost weakened signals back to full strength</li> <li>Impedance matching: They provide proper drive capability for subsequent circuits</li> <li>Timing adjustment: They add controlled delays when needed</li> <li>Isolation: They prevent one part of a circuit from affecting another</li> </ul> <p>Think of a buffer like a relay runner in a race\u2014they receive the baton and pass it on unchanged, but they provide fresh energy and proper form for the handoff.</p> <p>Truth Table:</p> A Y 0 0 1 1 <p>Boolean Expression: \\(Y = A\\)</p> <p>The buffer symbol is a triangle pointing to the right:</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-buffer-gate-symbol","title":"Diagram: Buffer Gate Symbol","text":"Buffer Gate Interactive <p>Type: microsim</p> <p>Bloom Level: Remember (L1) Bloom Verb: Identify</p> <p>Learning Objective: Students will be able to identify the buffer gate symbol and verify that its output equals its input.</p> <p>Instructional Rationale: Interactive visualization helps cement the visual symbol in memory while demonstrating the trivial but important input-output relationship.</p> <p>Canvas Layout:</p> <ul> <li>Center: Buffer gate symbol (triangle) with animated input/output</li> <li>Left side: Input toggle showing 0 or 1</li> <li>Right side: Output display showing 0 or 1</li> <li>Signal flow animation from input through gate to output</li> <li>Truth table shown below the gate</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click on input to toggle between 0 and 1</li> <li>Visual signal flow (colored line) shows signal propagation</li> <li>Output updates to match input</li> </ul> <p>Visual Style:</p> <ul> <li>Clean gate symbol with proper proportions</li> <li>Color coding: input wire blue, output wire green when 1, gray when 0</li> <li>Input/output values displayed in circles at wire endpoints</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js for gate drawing</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-not-gate-inverter-the-contrarian","title":"The NOT Gate (Inverter): The Contrarian","text":"<p>The NOT gate, also called an inverter, is the simplest gate that actually changes its input. It implements the Boolean NOT operation, flipping 0 to 1 and 1 to 0.</p> <p>If the buffer is a relay runner who passes the baton unchanged, the inverter is a relay runner who switches teams mid-race. Give it HIGH, get LOW. Give it LOW, get HIGH. It's the contrarian of the logic gate family.</p> <p>Truth Table:</p> A Y 0 1 1 0 <p>Boolean Expression: \\(Y = \\overline{A}\\)</p> <p>The inverter symbol is a triangle (like the buffer) with a small circle at the output. That circle is called a bubble and universally indicates inversion in digital logic. Remember this\u2014bubbles mean NOT!</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-not-gate-inverter-interactive","title":"Diagram: NOT Gate (Inverter) Interactive","text":"NOT Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Remember (L1) Bloom Verb: Identify</p> <p>Learning Objective: Students will be able to identify the inverter symbol and predict that its output is always the opposite of its input.</p> <p>Instructional Rationale: The inversion bubble is a critical symbol element that appears on many gates. Early exposure with interactive feedback builds recognition.</p> <p>Canvas Layout:</p> <ul> <li>Center: Inverter symbol (triangle with bubble) with animated input/output</li> <li>Left side: Input toggle showing 0 or 1</li> <li>Right side: Output display showing inverted value</li> <li>Emphasis on the \"bubble\" with tooltip explanation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click on input to toggle between 0 and 1</li> <li>Output automatically shows inverted value</li> <li>Highlight bubble when mouse hovers over it with explanation \"bubble = inversion\"</li> </ul> <p>Visual Style:</p> <ul> <li>Gate symbol with emphasized inversion bubble</li> <li>Complementary colors for input/output to reinforce inversion concept</li> <li>Animation: color \"flip\" when value changes</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-and-gate-both-must-be-true","title":"The AND Gate: Both Must Be True","text":"<p>The AND gate implements Boolean AND, producing a HIGH output only when all inputs are HIGH. For a 2-input AND gate:</p> <p>Truth Table:</p> A B Y 0 0 0 0 1 0 1 0 0 1 1 1 <p>Boolean Expression: \\(Y = A \\cdot B\\)</p> <p>Here's a memorable analogy: An AND gate is like a security door with two locks. Both locks must be unlocked (both inputs = 1) for the door to open (output = 1). If either lock is still locked, the door stays shut.</p> <p>The AND gate symbol has a flat back and a curved front (like the letter D):</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-and-gate-interactive","title":"Diagram: AND Gate Interactive","text":"AND Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate that the AND gate outputs 1 only when both inputs are 1.</p> <p>Instructional Rationale: Two-input toggle interaction allows students to explore all four input combinations and internalize the \"both must be true\" rule.</p> <p>Canvas Layout:</p> <ul> <li>Center: AND gate symbol (D-shape) with two inputs and one output</li> <li>Left side: Two input toggles stacked vertically</li> <li>Right side: Output display</li> <li>Truth table shown below with current row highlighted</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click on either input to toggle its value</li> <li>Gate output updates immediately</li> <li>Current input combination highlighted in truth table</li> <li>Visual indication (glow effect) when output is HIGH</li> </ul> <p>Visual Style:</p> <ul> <li>Standard AND gate symbol with proper D-shape</li> <li>Wire colors: blue for inputs, green for HIGH output, gray for LOW</li> <li>Connection lines from inputs through gate body to output</li> <li>Highlighted row in truth table matches current state</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p> <p>AND gates can have more than two inputs. A 3-input AND gate outputs 1 only when A AND B AND C are all 1. The principle extends to any number of inputs: all must be HIGH.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-or-gate-at-least-one-must-be-true","title":"The OR Gate: At Least One Must Be True","text":"<p>The OR gate implements Boolean OR, producing a HIGH output when at least one input is HIGH. Only when all inputs are LOW does the output become LOW.</p> <p>Truth Table:</p> A B Y 0 0 0 0 1 1 1 0 1 1 1 1 <p>Boolean Expression: \\(Y = A + B\\)</p> <p>If the AND gate is a security door with two locks, the OR gate is like an automatic door with two motion sensors. If either sensor (or both!) detects motion, the door opens. Only when both sensors see nothing does the door stay closed.</p> <p>The OR gate symbol has a curved back (looking like a shield or curved arrow):</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-or-gate-interactive","title":"Diagram: OR Gate Interactive","text":"OR Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate that the OR gate outputs 1 when at least one input is 1.</p> <p>Instructional Rationale: Contrasting OR behavior with AND (learned previously) helps students distinguish between the two operations. Side-by-side truth table comparison reinforces the difference.</p> <p>Canvas Layout:</p> <ul> <li>Center: OR gate symbol (curved shield shape) with two inputs and one output</li> <li>Left side: Two input toggles stacked vertically</li> <li>Right side: Output display</li> <li>Truth table shown below with current row highlighted</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click on either input to toggle its value</li> <li>Gate output updates immediately</li> <li>Current input combination highlighted in truth table</li> <li>Compare mode: Optional toggle to show AND gate result alongside for contrast</li> </ul> <p>Visual Style:</p> <ul> <li>Standard OR gate symbol with proper curves</li> <li>Wire colors consistent with AND gate for pattern recognition</li> <li>Curved input lines entering gate at proper positions</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p> <p>Like AND gates, OR gates can have more than two inputs. A 3-input OR gate outputs 1 when A OR B OR C (at least one) is 1.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-nand-gate-not-and-combined","title":"The NAND Gate: NOT-AND Combined","text":"<p>The NAND gate (pronounced \"nand,\" not \"N-A-N-D\") is an AND gate with an inverted output. Its name is a contraction of \"NOT-AND.\"</p> <p>Truth Table:</p> A B Y 0 0 1 0 1 1 1 0 1 1 1 0 <p>Boolean Expression: \\(Y = \\overline{A \\cdot B}\\)</p> <p>Notice that the NAND output is exactly opposite of the AND output\u2014every 0 becomes 1 and vice versa. The NAND gate is represented by the AND symbol with a bubble at the output.</p> <p>Here's something remarkable about the NAND gate:</p> <p>The NAND gate is called a \"universal gate\" because you can build any other logic function using only NAND gates.</p> <p>We'll explore this superpower in depth later, but it's why NAND gates are so important in real digital circuits. Engineers love gates that can do everything!</p> <p>Analogy: If AND is \"both must be true,\" then NAND is \"they can't both be true.\" It outputs LOW only when both inputs are HIGH\u2014the \"veto\" condition.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nand-gate-interactive","title":"Diagram: NAND Gate Interactive","text":"NAND Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare NAND output with AND output and explain that NAND is the complement of AND.</p> <p>Instructional Rationale: Showing NAND alongside AND in a comparison view helps students see the inversion relationship. The bubble on the symbol connects visually to the inversion concept from the NOT gate.</p> <p>Canvas Layout:</p> <ul> <li>Split view: NAND gate on left, AND gate on right (for comparison)</li> <li>Shared input toggles control both gates simultaneously</li> <li>Both outputs displayed with their values</li> <li>Inversion relationship shown with visual indicator</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click inputs to toggle values</li> <li>Both gates update simultaneously</li> <li>Visual highlight showing output values are always opposite</li> <li>Emphasis on the inversion bubble's role</li> </ul> <p>Visual Style:</p> <ul> <li>NAND: AND symbol + bubble (emphasized)</li> <li>Side-by-side comparison layout</li> <li>Color scheme: NAND output red/green, AND output gray/green</li> <li>Annotation showing \\(\\overline{AND}\\) relationship</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-nor-gate-not-or-combined","title":"The NOR Gate: NOT-OR Combined","text":"<p>The NOR gate is an OR gate with an inverted output. Its name is a contraction of \"NOT-OR.\"</p> <p>Truth Table:</p> A B Y 0 0 1 0 1 0 1 0 0 1 1 0 <p>Boolean Expression: \\(Y = \\overline{A + B}\\)</p> <p>The NOR output is the opposite of OR\u2014it outputs HIGH only when neither input is HIGH. The NOR gate is represented by the OR symbol with a bubble at the output.</p> <p>Like NAND, the NOR gate is also a universal gate. You can build any logic function using only NOR gates! Early computers actually used NOR gates extensively\u2014the Apollo Guidance Computer that landed humans on the Moon was built entirely from NOR gates.</p> <p>Analogy: If OR is \"at least one must be true,\" then NOR is \"neither can be true.\" It's like having two security guards who both have to be off duty for the building to be accessible.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nor-gate-interactive","title":"Diagram: NOR Gate Interactive","text":"NOR Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare NOR output with OR output and explain that NOR is the complement of OR.</p> <p>Instructional Rationale: Parallel structure to the NAND visualization reinforces the pattern of inverted gates. Students see both universal gates in the same comparative format.</p> <p>Canvas Layout:</p> <ul> <li>Split view: NOR gate on left, OR gate on right (for comparison)</li> <li>Shared input toggles control both gates simultaneously</li> <li>Both outputs displayed with their values</li> <li>Label \"Universal Gate\" badge on NOR</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click inputs to toggle values</li> <li>Both gates update simultaneously</li> <li>Visual highlight showing output values are always opposite</li> <li>Badge/callout indicating NOR is a universal gate</li> </ul> <p>Visual Style:</p> <ul> <li>NOR: OR symbol + bubble (emphasized)</li> <li>Side-by-side comparison layout</li> <li>Consistent styling with NAND comparison view</li> <li>\"Universal Gate\" badge for NOR</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p>"},{"location":"chapters/03-logic-gates-digital-signals/#the-xor-gate-the-odd-one-out","title":"The XOR Gate: The Odd One Out","text":"<p>The XOR gate (exclusive OR) outputs HIGH when an odd number of inputs are HIGH. For a 2-input XOR gate, this means the output is HIGH when the inputs are different:</p> <p>Truth Table:</p> A B Y 0 0 0 0 1 1 1 0 1 1 1 0 <p>Boolean Expression: \\(Y = A \\oplus B = A \\cdot \\overline{B} + \\overline{A} \\cdot B\\)</p> <p>Notice that unlike OR, XOR outputs LOW when both inputs are HIGH. It's \"exclusive\"\u2014it excludes the case where both are true.</p> <p>Analogy: XOR is like a light switch controlled from two locations (like at the top and bottom of stairs). Flipping either switch changes the light state. If both switches are in the same position (both up or both down), the light is off. If they're in opposite positions, the light is on. The output indicates \"are these different?\"</p> <p>The XOR gate symbol is the OR gate symbol with an extra curved line on the input side:</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-xor-gate-interactive","title":"Diagram: XOR Gate Interactive","text":"XOR Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Contrast</p> <p>Learning Objective: Students will be able to contrast XOR with OR and explain that XOR outputs 1 when inputs differ.</p> <p>Instructional Rationale: The \"difference detector\" framing helps students remember XOR behavior. Comparing with OR directly shows the critical difference in the (1,1) case.</p> <p>Canvas Layout:</p> <ul> <li>Main: XOR gate with interactive inputs</li> <li>Comparison panel: OR gate showing difference in (1,1) case</li> <li>Below: Visual \"difference detector\" representation (two values with = vs \u2260 symbol)</li> <li>Truth table with \"different?\" column added for clarity</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click inputs to toggle values</li> <li>\"Different?\" indicator changes with inputs</li> <li>Special animation when both inputs are 1 showing XOR = 0, OR = 1</li> <li>Highlight the distinguishing row in truth table</li> </ul> <p>Visual Style:</p> <ul> <li>XOR symbol with distinctive extra curve</li> <li>\"\u2260\" and \"=\" symbols to reinforce difference detection</li> <li>Red/green for match/mismatch indication</li> <li>Callout: \"XOR = Are they different?\"</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p> <p>XOR Applications</p> <p>XOR gates are incredibly useful:</p> <ul> <li>Parity checking: Detect transmission errors</li> <li>Encryption: XOR with a key scrambles data</li> <li>Addition: The sum bit in a binary adder is XOR</li> <li>Comparison: Detect if two values are different</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#the-xnor-gate-same-or-different","title":"The XNOR Gate: Same or Different?","text":"<p>The XNOR gate (exclusive NOR) is an XOR gate with an inverted output. It outputs HIGH when the inputs are the same:</p> <p>Truth Table:</p> A B Y 0 0 1 0 1 0 1 0 0 1 1 1 <p>Boolean Expression: \\(Y = \\overline{A \\oplus B} = A \\cdot B + \\overline{A} \\cdot \\overline{B}\\)</p> <p>If XOR is the \"difference detector,\" XNOR is the \"equality detector.\" It asks \"are these the same?\" and outputs 1 if yes, 0 if no.</p> <p>The XNOR gate symbol is the XOR symbol with a bubble at the output (following the pattern of NAND and NOR):</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-xnor-gate-interactive","title":"Diagram: XNOR Gate Interactive","text":"XNOR Gate Interactive Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain that XNOR outputs 1 when both inputs are the same (both 0 or both 1).</p> <p>Instructional Rationale: Presenting XNOR as \"equality detector\" provides a memorable mental model. The truth table pattern (1 on the diagonal) reinforces this visually.</p> <p>Canvas Layout:</p> <ul> <li>Main: XNOR gate with interactive inputs</li> <li>\"Same?\" indicator prominently displayed</li> <li>Truth table with diagonal pattern highlighted</li> <li>Comparison with XOR to show inversion relationship</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click inputs to toggle values</li> <li>\"Same?\" indicator with checkmark or X</li> <li>Diagonal pattern in truth table lights up when inputs match</li> <li>Output color matches \"same\" status</li> </ul> <p>Visual Style:</p> <ul> <li>XNOR symbol: XOR + bubble</li> <li>\"=\" symbol when inputs match, \"\u2260\" when different</li> <li>Green glow on diagonal entries of truth table</li> <li>Clean, symmetrical layout emphasizing the equality function</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p>"},{"location":"chapters/03-logic-gates-digital-signals/#summary-the-complete-gate-family","title":"Summary: The Complete Gate Family","text":"<p>Let's take a moment to see all the primitive gates together. This is your complete toolkit for building any digital circuit:</p> Gate Symbol Expression Output = 1 When... Buffer Triangle \\(Y = A\\) Input is 1 NOT Triangle + bubble \\(Y = \\overline{A}\\) Input is 0 AND D-shape \\(Y = A \\cdot B\\) Both inputs are 1 OR Shield \\(Y = A + B\\) At least one input is 1 NAND D-shape + bubble \\(Y = \\overline{A \\cdot B}\\) Not both inputs are 1 NOR Shield + bubble \\(Y = \\overline{A + B}\\) Neither input is 1 XOR Shield + extra curve \\(Y = A \\oplus B\\) Inputs are different XNOR XOR + bubble \\(Y = \\overline{A \\oplus B}\\) Inputs are the same"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-all-logic-gates-gallery","title":"Diagram: All Logic Gates Gallery","text":"Complete Logic Gate Gallery <p>Type: microsim</p> <p>Bloom Level: Remember (L1) Bloom Verb: Recognize</p> <p>Learning Objective: Students will be able to recognize all eight primitive logic gate symbols and associate each with its name and function.</p> <p>Instructional Rationale: A visual gallery view reinforces symbol recognition through repeated exposure. Interactive elements encourage exploration of each gate type.</p> <p>Canvas Layout:</p> <ul> <li>Grid of all 8 gate types (4x2 arrangement)</li> <li>Each gate cell shows: symbol, name, and Boolean expression</li> <li>Hover/click to see truth table for each gate</li> <li>Visual grouping: basic gates, inverted gates, XOR family</li> </ul> <p>Interactive Elements:</p> <ul> <li>Hover over any gate to see its truth table</li> <li>Click to select and show enlarged view</li> <li>Quiz mode: Show symbol, guess the name</li> <li>Filter buttons: All, Basic, Inverted, XOR family</li> </ul> <p>Visual Style:</p> <ul> <li>Consistent sizing and spacing for all gates</li> <li>Color-coded by family (blue=basic, orange=inverted, purple=XOR)</li> <li>Clean labels with proper mathematical notation</li> <li>Responsive grid layout</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js, using grid layout</p>"},{"location":"chapters/03-logic-gates-digital-signals/#ieee-gate-symbols","title":"IEEE Gate Symbols","text":"<p>While the distinctive-shape symbols are most common in industry and academia, you should also be aware of IEEE rectangular symbols (also called IEC symbols). In this notation, all gates are rectangles with a function label inside.</p> Gate IEEE Symbol Label Buffer 1 NOT 1 (with bubble) AND &amp; OR \u22651 NAND &amp; (with bubble) NOR \u22651 (with bubble) XOR =1 XNOR =1 (with bubble) <p>The IEEE symbols are more consistent (all rectangles) but less intuitive (you have to read the label). You'll encounter them in some textbooks and CAD tools, so it's worth being able to recognize them.</p> <p>Symbol Conventions</p> <p>In this textbook, we use distinctive-shape symbols exclusively. If you encounter IEEE symbols elsewhere, just look for the function label and the presence or absence of the output bubble.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#functional-completeness-the-universal-building-block","title":"Functional Completeness: The Universal Building Block","text":"<p>Now we arrive at one of the most elegant ideas in digital logic: functional completeness. A set of logic gates is functionally complete if you can build any Boolean function using only gates from that set.</p> <p>The set {AND, OR, NOT} is functionally complete. Given these three gate types, you can implement any Boolean expression. This makes intuitive sense\u2014these are the three fundamental Boolean operations.</p> <p>But here's the twist: you don't actually need all three. Some single gate types are functionally complete by themselves!</p> <p>A gate that can implement any Boolean function by itself is called a universal gate.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#universal-gates-one-gate-to-rule-them-all","title":"Universal Gates: One Gate to Rule Them All","text":"<p>Both NAND and NOR are universal gates. Using only NAND gates (or only NOR gates), you can build any digital circuit. This is a profound result with enormous practical implications.</p> <p>Why does this matter? In integrated circuit manufacturing:</p> <ul> <li>Using a single gate type simplifies the manufacturing process</li> <li>All gates have identical characteristics (delay, power, etc.)</li> <li>Design becomes more regular and predictable</li> <li>Testing and verification are simplified</li> </ul> <p>Let's see how NAND can implement the basic operations.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#nand-only-design","title":"NAND-Only Design","text":"<p>Building NOT from NAND:</p> <p>Connect both inputs of a NAND gate together: [Y = \\overline{A \\cdot A} = \\overline{A}]</p> <p>A NAND gate with tied inputs is an inverter!</p> <p>Building AND from NAND:</p> <p>Use two NAND gates\u2014one as the actual NAND, and one configured as a NOT to invert the output: [Y = \\overline{\\overline{A \\cdot B}} = A \\cdot B]</p> <p>Building OR from NAND:</p> <p>Use three NAND gates\u2014first invert each input (using NAND as NOT), then NAND the results: [Y = \\overline{\\overline{A} \\cdot \\overline{B}} = A + B]</p> <p>This last one uses De Morgan's theorem: \\(\\overline{\\overline{A} \\cdot \\overline{B}} = A + B\\)</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nand-universal-gate-builder","title":"Diagram: NAND Universal Gate Builder","text":"NAND Universal Gate Builder MicroSim <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Implement</p> <p>Learning Objective: Students will be able to implement NOT, AND, and OR operations using only NAND gates.</p> <p>Instructional Rationale: Building other gates from NAND reinforces both the universality concept and the underlying Boolean algebra (especially De Morgan's theorem for OR).</p> <p>Canvas Layout:</p> <ul> <li>Three sections: NOT from NAND, AND from NAND, OR from NAND</li> <li>Each section shows the NAND-only circuit implementation</li> <li>Input toggles for each circuit</li> <li>Truth table verification for each implementation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle inputs for each demonstration circuit</li> <li>Watch signal propagation through NAND gates</li> <li>Truth table fills in as user explores all combinations</li> <li>\"Verify\" button confirms the implementation matches the target function</li> </ul> <p>Data Visibility:</p> <ul> <li>Each intermediate NAND output labeled with its value</li> <li>Final output compared to expected gate behavior</li> <li>Signal path highlighted as it propagates</li> </ul> <p>Visual Style:</p> <ul> <li>Clean circuit diagrams with multiple NAND gates</li> <li>Color-coded signals (blue input, yellow intermediate, green output)</li> <li>NAND gates clearly drawn with distinctive symbols</li> <li>Grouping boxes around each implementation</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js, signal propagation animation</p>"},{"location":"chapters/03-logic-gates-digital-signals/#nor-only-design","title":"NOR-Only Design","text":"<p>NOR can also build everything! The process is similar, but uses De Morgan's theorem in the other direction.</p> <p>Building NOT from NOR:</p> \\[Y = \\overline{A + A} = \\overline{A}\\] <p>Building OR from NOR:</p> \\[Y = \\overline{\\overline{A + B}} = A + B\\] <p>Building AND from NOR:</p> \\[Y = \\overline{\\overline{A} + \\overline{B}} = A \\cdot B\\]"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-nor-universal-gate-builder","title":"Diagram: NOR Universal Gate Builder","text":"NOR Universal Gate Builder MicroSim <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Implement</p> <p>Learning Objective: Students will be able to implement NOT, AND, and OR operations using only NOR gates.</p> <p>Instructional Rationale: Parallel structure to NAND demonstration reinforces the dual nature of the universal gates and strengthens De Morgan's theorem understanding.</p> <p>Canvas Layout:</p> <ul> <li>Three sections: NOT from NOR, OR from NOR, AND from NOR</li> <li>Each section shows the NOR-only circuit implementation</li> <li>Input toggles for each circuit</li> <li>Truth table verification for each implementation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle inputs for each demonstration circuit</li> <li>Watch signal propagation through NOR gates</li> <li>Truth table fills in as user explores all combinations</li> <li>Compare button to show NAND equivalent side-by-side</li> </ul> <p>Visual Style:</p> <ul> <li>Circuit diagrams with multiple NOR gates</li> <li>Consistent color scheme with NAND demonstration</li> <li>NOR gates with distinctive OR shape + bubble</li> <li>Clear labeling of intermediate signals</li> </ul> <p>Implementation: p5.js with logic-gate-lib.js</p> <p>Historical Note</p> <p>The Apollo Guidance Computer, which navigated astronauts to the Moon and back, was built using approximately 5,600 NOR gates and nothing else. The simplicity of using a single gate type was crucial for reliability in the hostile environment of space.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#gate-delay-nothing-happens-instantly","title":"Gate Delay: Nothing Happens Instantly","text":"<p>Now let's talk about something that separates theoretical Boolean algebra from real physical circuits: time.</p> <p>In Boolean algebra, if you change an input, the output changes instantly. In real circuits, that's not true. Every logic gate takes some time to respond to input changes. This time is called gate delay or propagation delay.</p> <p>Propagation delay is the time between when an input changes and when the output responds. Typical propagation delays range from:</p> <ul> <li>Sub-nanosecond for modern high-speed logic</li> <li>A few nanoseconds for standard CMOS logic</li> <li>Tens of nanoseconds for older technology</li> </ul> <p>Why does delay matter?</p> <ul> <li>It limits how fast your circuit can operate</li> <li>Multiple gates in series accumulate delay (critical path)</li> <li>Timing violations can cause incorrect behavior</li> <li>Clock speeds are ultimately limited by propagation delay</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-propagation-delay-visualizer","title":"Diagram: Propagation Delay Visualizer","text":"Propagation Delay Visualizer MicroSim <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain that logic gates have non-zero propagation delay, and that this delay accumulates in multi-gate paths.</p> <p>Instructional Rationale: Time-domain visualization of signal propagation through gates makes the abstract concept of delay tangible. Adjustable parameters allow exploration of how delay affects circuit timing.</p> <p>Canvas Layout:</p> <ul> <li>Top: Timing diagram showing input signal and output response</li> <li>Middle: Gate symbol with propagation delay labeled</li> <li>Bottom: Multi-gate chain showing accumulated delay</li> <li>Time axis with nanosecond scale</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input pulse generator (click to trigger)</li> <li>Slider to adjust propagation delay value</li> <li>View single gate delay vs. multi-gate chain</li> <li>Play/pause animation control</li> <li>Speed control for animation</li> </ul> <p>Data Visibility:</p> <ul> <li>Input transition time clearly marked</li> <li>Output transition time clearly marked</li> <li>Propagation delay value displayed in ns</li> <li>Total path delay for multi-gate circuits</li> </ul> <p>Visual Style:</p> <ul> <li>Timing diagram with clean waveforms</li> <li>Delay shown as horizontal gap between transitions</li> <li>Color coding: input blue, output green</li> <li>Accumulated delay highlighted in chain view</li> </ul> <p>Implementation: p5.js with animation for signal propagation</p>"},{"location":"chapters/03-logic-gates-digital-signals/#rise-time-and-fall-time","title":"Rise Time and Fall Time","text":"<p>When a digital signal changes from LOW to HIGH, it doesn't happen instantaneously\u2014the voltage ramps up over time. Similarly, going from HIGH to LOW takes time.</p> <ul> <li>Rise time (\\(t_r\\)): Time for signal to go from 10% to 90% of full voltage</li> <li>Fall time (\\(t_f\\)): Time for signal to go from 90% to 10% of full voltage</li> </ul> <p>Rise and fall times are typically measured between 10% and 90% of the voltage swing because real signals have gradual transitions, not perfect vertical edges.</p> Parameter Symbol Description Propagation delay (low-to-high) \\(t_{pLH}\\) Delay when output goes from LOW to HIGH Propagation delay (high-to-low) \\(t_{pHL}\\) Delay when output goes from HIGH to LOW Rise time \\(t_r\\) Time for signal to rise from 10% to 90% Fall time \\(t_f\\) Time for signal to fall from 90% to 10%"},{"location":"chapters/03-logic-gates-digital-signals/#fan-in-and-fan-out-how-many-connections","title":"Fan-In and Fan-Out: How Many Connections?","text":"<p>When designing circuits, you need to consider how many inputs and outputs each gate can handle.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#fan-in","title":"Fan-In","text":"<p>Fan-in is the number of inputs a gate has. A 2-input AND gate has a fan-in of 2. An 8-input NAND gate has a fan-in of 8.</p> <p>Why does fan-in matter?</p> <ul> <li>Propagation delay increases with fan-in: More inputs mean more transistors in the signal path</li> <li>Physical size increases: More inputs require more silicon area</li> <li>Power consumption increases: More transistors switching</li> </ul> <p>In practice, gates with very high fan-in (like 16 or 32 inputs) are rarely used. Instead, designers cascade lower fan-in gates.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#fan-out","title":"Fan-Out","text":"<p>Fan-out is the number of gate inputs that one output can drive reliably. If a gate output is connected to the inputs of 5 other gates, its fan-out is 5.</p> <p>Why does fan-out matter?</p> <ul> <li>Each driven input presents an electrical load</li> <li>Driving too many gates weakens the signal</li> <li>Exceeding fan-out limits causes incorrect logic levels</li> <li>High fan-out increases propagation delay</li> </ul> <p>Fan-Out Limits</p> <p>Every logic family has a maximum fan-out specification. Exceeding this can cause:</p> <ul> <li>Logic levels that don't reach valid HIGH or LOW thresholds</li> <li>Increased propagation delay</li> <li>Unreliable circuit operation</li> <li>Marginal failures that are hard to debug</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-fan-in-and-fan-out-explorer","title":"Diagram: Fan-In and Fan-Out Explorer","text":"Fan-In and Fan-Out Interactive Explorer <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how increasing fan-in affects gate delay and how excessive fan-out can degrade signal quality.</p> <p>Instructional Rationale: Interactive parameter adjustment helps students develop intuition about the engineering tradeoffs involved in gate connections.</p> <p>Canvas Layout:</p> <ul> <li>Left panel: Fan-in demonstration with adjustable gate inputs (2-8)</li> <li>Right panel: Fan-out demonstration showing one gate driving multiple loads</li> <li>Metrics display: delay increase, signal quality indicator</li> <li>Warning indicators when limits exceeded</li> </ul> <p>Interactive Elements:</p> <ul> <li>Slider to adjust fan-in (2 to 8 inputs)</li> <li>Slider to adjust fan-out (1 to 15 load gates)</li> <li>Toggle to show/hide delay effects</li> <li>Warning animation when fan-out exceeds safe limit</li> <li>Reset button to return to defaults</li> </ul> <p>Visual Effects:</p> <ul> <li>Gate grows to accommodate more inputs (fan-in)</li> <li>Output branches to multiple gates (fan-out)</li> <li>Signal quality meter (green/yellow/red)</li> <li>Delay bar graph showing relative timing</li> </ul> <p>Visual Style:</p> <ul> <li>Clean schematic representation</li> <li>Color-coded warning levels</li> <li>Animated signal propagation</li> <li>Metrics displayed as bar graphs</li> </ul> <p>Implementation: p5.js with dynamic gate rendering</p>"},{"location":"chapters/03-logic-gates-digital-signals/#logic-levels-what-counts-as-0-or-1","title":"Logic Levels: What Counts as 0 or 1?","text":"<p>So far, we've talked about 0 and 1 as if they were absolute values. In real circuits, we're dealing with voltages, and there's a range of voltages that count as \"logic LOW\" (0) and a range that count as \"logic HIGH\" (1).</p> <p>Logic levels define the voltage ranges for valid 0 and 1 values. For a typical 5V logic family:</p> Level Symbol Voltage Range Logic LOW (input) \\(V_{IL}\\) 0V to 0.8V Logic LOW (output) \\(V_{OL}\\) 0V to 0.4V Logic HIGH (input) \\(V_{IH}\\) 2.0V to 5.0V Logic HIGH (output) \\(V_{OH}\\) 2.4V to 5.0V Undefined/Forbidden - 0.8V to 2.0V <p>Notice that:</p> <ul> <li>Outputs have tighter specifications than inputs</li> <li>There's a \"forbidden zone\" in the middle</li> <li>This creates noise margin\u2014room for signals to degrade slightly without errors</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#voltage-thresholds","title":"Voltage Thresholds","text":"<p>Voltage thresholds are the decision points where a gate interprets a signal as HIGH vs. LOW:</p> <ul> <li>\\(V_{IL}\\): Maximum voltage guaranteed to be recognized as LOW (input)</li> <li>\\(V_{IH}\\): Minimum voltage guaranteed to be recognized as HIGH (input)</li> <li>\\(V_{OL}\\): Maximum voltage output when driving LOW</li> <li>\\(V_{OH}\\): Minimum voltage output when driving HIGH</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#noise-margin-room-for-error","title":"Noise Margin: Room for Error","text":"<p>Noise margin is the amount by which a signal can be corrupted and still be correctly interpreted. It's the difference between what one gate outputs and what the next gate needs to reliably recognize.</p> <p>[\\text{Noise Margin LOW} = V_{IL} - V_{OL}] [\\text{Noise Margin HIGH} = V_{OH} - V_{IH}]</p> <p>For our 5V example:</p> <ul> <li>Low noise margin: 0.8V - 0.4V = 0.4V</li> <li>High noise margin: 2.4V - 2.0V = 0.4V</li> </ul> <p>This means the signal can pick up 0.4V of noise and still be correctly recognized. Higher noise margins make circuits more robust in noisy environments.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-logic-levels-and-noise-margin","title":"Diagram: Logic Levels and Noise Margin","text":"Logic Levels and Noise Margin Visualizer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Interpret</p> <p>Learning Objective: Students will be able to interpret voltage level diagrams and identify the noise margin that allows reliable signal transmission between gates.</p> <p>Instructional Rationale: Visual representation of voltage ranges with adjustable noise injection helps students understand how digital signals remain reliable despite analog imperfections.</p> <p>Canvas Layout:</p> <ul> <li>Left: Voltage scale (0V to 5V) with colored zones for LOW, FORBIDDEN, HIGH</li> <li>Center: Two gates (driver and receiver) showing signal transmission</li> <li>Right: Noise margin visualization as a bar</li> <li>Bottom: Noise injection slider to see effect on signal</li> </ul> <p>Interactive Elements:</p> <ul> <li>Slider to inject noise into signal</li> <li>Toggle between different logic families (5V TTL, 3.3V CMOS, etc.)</li> <li>Watch signal degrade as noise increases</li> <li>Warning when signal enters forbidden zone</li> <li>Success indicator when signal correctly received</li> </ul> <p>Data Visibility:</p> <ul> <li>Current voltage level displayed numerically</li> <li>Noise margin remaining shown as percentage</li> <li>Threshold values labeled on voltage scale</li> <li>Output and input specs clearly differentiated</li> </ul> <p>Visual Style:</p> <ul> <li>Voltage scale with colored bands (green=valid, red=forbidden)</li> <li>Arrow showing signal path from output to input</li> <li>Noise shown as jagged overlay on signal line</li> <li>Clean gradient transitions between zones</li> </ul> <p>Implementation: p5.js with interactive noise simulation</p>"},{"location":"chapters/03-logic-gates-digital-signals/#logic-families-ttl-and-cmos","title":"Logic Families: TTL and CMOS","text":"<p>A logic family is a group of logic devices that share common electrical characteristics and are designed to work together. The two most important families historically are TTL and CMOS.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#ttl-logic-transistor-transistor-logic","title":"TTL Logic (Transistor-Transistor Logic)","text":"<p>TTL was the dominant logic family from the 1960s through the 1980s. Key characteristics:</p> <ul> <li>Uses bipolar junction transistors (BJTs)</li> <li>5V power supply</li> <li>Fast switching speeds (for its era)</li> <li>Higher power consumption than CMOS</li> <li>Robust noise immunity</li> <li>Multiple subfamilies (74LS, 74S, 74F, etc.)</li> </ul> <p>TTL part numbers typically start with \"74\" (commercial grade) or \"54\" (military grade). The 7400 is a quad 2-input NAND gate\u2014one of the most famous ICs ever made.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#cmos-logic-complementary-metal-oxide-semiconductor","title":"CMOS Logic (Complementary Metal-Oxide-Semiconductor)","text":"<p>CMOS dominates modern digital electronics. Key characteristics:</p> <ul> <li>Uses MOSFETs (field-effect transistors)</li> <li>Wide supply voltage range (3V to 15V typically)</li> <li>Extremely low static power consumption</li> <li>Higher speed than TTL in modern processes</li> <li>More sensitive to static electricity</li> <li>Dominates all modern integrated circuits</li> </ul> Feature TTL CMOS Transistor Type BJT MOSFET Typical Supply 5V 1.8V to 5V Static Power Higher Very low Speed Fast (historical) Faster (modern) Noise Immunity Good Excellent Dominance Era 1960s-1980s 1990s-present <p>Why CMOS Won</p> <p>CMOS's extremely low static power consumption became crucial as chip density increased. A chip with millions of TTL gates would consume enormous power and generate excessive heat. CMOS only consumes significant power when switching, making modern processors possible.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-logic-family-comparison","title":"Diagram: Logic Family Comparison","text":"TTL vs CMOS Logic Family Comparison <p>Type: infographic</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare TTL and CMOS logic families across key parameters including power consumption, speed, noise immunity, and voltage levels.</p> <p>Instructional Rationale: Side-by-side comparison with interactive parameter exploration helps students understand the engineering tradeoffs that led to CMOS dominance.</p> <p>Canvas Layout:</p> <ul> <li>Two-column layout: TTL on left, CMOS on right</li> <li>Comparison bars for: power, speed, noise margin, supply voltage</li> <li>Interactive toggle to simulate circuit behavior under each family</li> <li>Historical timeline showing technology evolution</li> </ul> <p>Interactive Elements:</p> <ul> <li>Hover over each parameter for detailed explanation</li> <li>Toggle switch to select 5V or 3.3V CMOS variant</li> <li>Click on timeline to see key milestones</li> <li>Power consumption animation when switching</li> </ul> <p>Visual Style:</p> <ul> <li>Bar graphs for quantitative comparisons</li> <li>Color scheme: TTL in orange, CMOS in blue</li> <li>Icons representing transistor types</li> <li>Clean, modern infographic style</li> </ul> <p>Implementation: p5.js with hover interactions and animated comparisons</p>"},{"location":"chapters/03-logic-gates-digital-signals/#digital-signals-the-analog-reality","title":"Digital Signals: The Analog Reality","text":"<p>Here's a truth that might surprise you: digital signals don't actually exist.</p> <p>At the physical level, every signal is analog\u2014a continuous voltage that varies over time. \"Digital\" is an abstraction we impose by defining threshold voltages and ignoring the messy analog behavior in between.</p> <p>A digital signal is an analog voltage that we interpret as having discrete states (0 and 1) based on threshold levels. This interpretation gives us:</p> <ul> <li>Noise immunity: Small voltage variations are ignored</li> <li>Reliable regeneration: Each gate restores signal quality</li> <li>Predictable logic: Boolean algebra applies</li> </ul>"},{"location":"chapters/03-logic-gates-digital-signals/#analog-vs-digital","title":"Analog vs Digital","text":"Aspect Analog Digital Values Continuous Discrete (0 or 1) Noise Accumulates Cleaned up at each stage Processing Linear circuits Logic gates Representation Direct physical quantity Encoded binary Degradation Gradual Cliff effect <p>The genius of digital systems is that even though the underlying physics is analog, the abstraction layers let us reason about discrete 0s and 1s with mathematical precision.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#signal-integrity-keeping-signals-clean","title":"Signal Integrity: Keeping Signals Clean","text":"<p>Signal integrity refers to the ability of a signal to maintain valid logic levels as it travels through a circuit. Poor signal integrity causes logic errors that are notoriously difficult to debug.</p> <p>Factors affecting signal integrity:</p> <ul> <li>Transmission line effects: Long wires behave like transmission lines</li> <li>Crosstalk: Signals on adjacent wires interfere with each other</li> <li>Ground bounce: Switching noise on the ground connection</li> <li>Power supply noise: Fluctuations in power delivery</li> <li>Reflections: Signal bouncing at impedance discontinuities</li> </ul> <p>Good signal integrity practices:</p> <ul> <li>Keep trace lengths short when possible</li> <li>Use proper power supply decoupling (capacitors near IC power pins)</li> <li>Maintain proper termination for high-speed signals</li> <li>Separate noisy signals from sensitive ones</li> <li>Use ground planes and proper PCB layout techniques</li> </ul> <p>Why Signal Integrity Matters</p> <p>As clock speeds increase, signal integrity becomes more critical. What worked fine at 1 MHz may fail catastrophically at 1 GHz. Digital designers must understand analog effects to build reliable high-speed circuits.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-signal-integrity-issues","title":"Diagram: Signal Integrity Issues","text":"Signal Integrity Problems Visualizer <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how various physical effects (noise, reflections, crosstalk) degrade digital signal quality and potentially cause logic errors.</p> <p>Instructional Rationale: Visualizing signal degradation helps students understand why clean signals matter and connects abstract concepts to physical reality.</p> <p>Canvas Layout:</p> <ul> <li>Top: Ideal digital signal waveform</li> <li>Middle: Same signal with selected degradation applied</li> <li>Bottom: Logic interpretation showing correct vs. incorrect readings</li> <li>Side panel: Controls for different signal integrity issues</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for: Noise, Ringing, Crosstalk, Ground bounce</li> <li>Severity slider for each effect</li> <li>Threshold lines showing where logic errors occur</li> <li>Error counter tracking logic interpretation mistakes</li> </ul> <p>Visual Effects:</p> <ul> <li>Ideal signal as clean square wave</li> <li>Degraded signal with realistic effects</li> <li>Threshold zones highlighted</li> <li>Error moments flashing when signal crosses wrong threshold</li> </ul> <p>Visual Style:</p> <ul> <li>Oscilloscope-like display with grid</li> <li>Green for clean signal, red for degraded</li> <li>Yellow warning zones around thresholds</li> <li>Professional, technical appearance</li> </ul> <p>Implementation: p5.js with signal waveform rendering and noise simulation</p>"},{"location":"chapters/03-logic-gates-digital-signals/#putting-it-all-together-from-theory-to-practice","title":"Putting It All Together: From Theory to Practice","text":"<p>Let's trace the journey from Boolean algebra to physical circuits:</p> <ol> <li>Boolean Expression: \\(F = A \\cdot B + C\\)</li> <li>Truth Table: Define output for all 8 input combinations</li> <li>Gate Selection: Choose AND, OR gates to implement</li> <li>Logic Family: Pick CMOS at 3.3V</li> <li>Timing Analysis: Calculate propagation delay through critical path</li> <li>Fan-Out Check: Ensure each gate can drive its loads</li> <li>Layout Considerations: Plan for signal integrity</li> </ol> <p>This workflow connects the abstract mathematics you learned in Chapter 2 to the physical reality of electronic circuits.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#diagram-boolean-to-gates-workflow","title":"Diagram: Boolean to Gates Workflow","text":"Boolean Expression to Gate Circuit Workflow <p>Type: workflow</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute the workflow of transforming a Boolean expression into a gate-level circuit implementation.</p> <p>Instructional Rationale: Step-by-step visualization of the design process helps students understand how theoretical Boolean algebra becomes physical circuits.</p> <p>Canvas Layout:</p> <ul> <li>Vertical workflow diagram with 5 stages</li> <li>Left: Boolean expression input</li> <li>Center: Step-by-step transformation visualization</li> <li>Right: Final gate circuit</li> <li>Bottom: Truth table verification</li> </ul> <p>Workflow Steps:</p> <ol> <li>Enter Boolean expression</li> <li>Parse expression into operation tree</li> <li>Map operations to gates (AND, OR, NOT symbols)</li> <li>Connect gates into circuit diagram</li> <li>Verify with truth table</li> </ol> <p>Interactive Elements:</p> <ul> <li>Text input for Boolean expression</li> <li>Step-through buttons (Next, Previous)</li> <li>Expression examples as clickable chips</li> <li>Final circuit is interactive (can toggle inputs)</li> </ul> <p>Visual Style:</p> <ul> <li>Clean workflow arrows between stages</li> <li>Gate symbols drawn progressively</li> <li>Connection wires animate as they're drawn</li> <li>Verification checkmark when complete</li> </ul> <p>Implementation: p5.js with expression parsing and circuit rendering</p>"},{"location":"chapters/03-logic-gates-digital-signals/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you work with logic gates, watch out for these pitfalls:</p> <ol> <li> <p>Confusing NAND and AND: Remember, the bubble inverts! NAND outputs 1 when AND would output 0.</p> </li> <li> <p>Ignoring propagation delay: In fast circuits, accumulated gate delays matter enormously.</p> </li> <li> <p>Exceeding fan-out: Just because you can connect 20 gates doesn't mean you should. Check the specifications!</p> </li> <li> <p>Mixing logic families: Connecting TTL outputs to CMOS inputs (or vice versa) requires level shifting.</p> </li> <li> <p>Forgetting about the forbidden zone: Voltages in the undefined region can cause unpredictable behavior.</p> </li> <li> <p>Assuming ideal behavior: Real gates have real limitations\u2014delays, power consumption, noise sensitivity.</p> </li> </ol>"},{"location":"chapters/03-logic-gates-digital-signals/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've bridged the gap between Boolean algebra and physical circuits. Here's what you've learned:</p> <ul> <li>Logic gates implement Boolean operations in hardware</li> <li>Primitive gates: Buffer, NOT, AND, OR, NAND, NOR, XOR, XNOR</li> <li>Gate symbols provide visual vocabulary for circuit diagrams</li> <li>NAND and NOR are universal gates\u2014each can implement any function alone</li> <li>Propagation delay limits circuit speed</li> <li>Rise/fall time describes signal transition speed</li> <li>Fan-in is the number of gate inputs</li> <li>Fan-out is the number of gates one output can drive</li> <li>Logic levels define voltage ranges for valid 0 and 1</li> <li>Noise margin provides tolerance for signal degradation</li> <li>TTL and CMOS are major logic families (CMOS dominates today)</li> <li>Signal integrity keeps signals clean in real circuits</li> </ul> <p>These concepts form the foundation for everything that follows\u2014combinational logic design, sequential circuits, and beyond. You now understand that Boolean algebra isn't just mathematical abstraction; it's the language of the physical circuits that power our digital world.</p> <p>Key Insight</p> <p>Logic gates are where mathematics meets physics. Every gate implements a Boolean function using transistors, and understanding both the logical behavior and physical characteristics is essential for designing reliable digital systems.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#practice-problems","title":"Practice Problems","text":"Problem 1: Gate Identification <p>Match each truth table to its gate type:</p> <p>Table A: | A | B | Y | |---|---|---| | 0 | 0 | 1 | | 0 | 1 | 0 | | 1 | 0 | 0 | | 1 | 1 | 0 |</p> <p>Solution: This is a NOR gate. Output is 1 only when both inputs are 0.</p> Problem 2: NAND Universality <p>Show how to implement an OR gate using only NAND gates.</p> <p>Solution:</p> <ol> <li>Create NOT gates from NAND by tying inputs together</li> <li>Invert input A: \\(\\overline{A}\\) using NAND(A,A)</li> <li>Invert input B: \\(\\overline{B}\\) using NAND(B,B)</li> <li>NAND the results: \\(\\overline{\\overline{A} \\cdot \\overline{B}} = A + B\\) (De Morgan's)</li> </ol> <p>Total: 3 NAND gates</p> Problem 3: Timing Calculation <p>A circuit has three gates in series, each with a propagation delay of 5 ns. What is the minimum time from input change to valid output?</p> <p>Solution: Total delay = 3 \u00d7 5 ns = 15 ns</p> <p>This is the critical path delay\u2014the output isn't valid until 15 ns after the input changes.</p> Problem 4: Fan-Out Analysis <p>A gate output is connected to 8 other gate inputs. If the maximum fan-out specification is 10, is this design safe?</p> <p>Solution: Yes, the design is within specification (8 &lt; 10). However, operating close to the limit may increase propagation delay and reduce noise margin. It would be prudent to use a buffer if more loads are added later.</p> Problem 5: Noise Margin <p>Given \\(V_{OH} = 2.4V\\), \\(V_{IH} = 2.0V\\), \\(V_{OL} = 0.4V\\), and \\(V_{IL} = 0.8V\\), calculate both noise margins.</p> <p>Solution:</p> <ul> <li>High noise margin: \\(V_{OH} - V_{IH} = 2.4V - 2.0V = 0.4V\\)</li> <li>Low noise margin: \\(V_{IL} - V_{OL} = 0.8V - 0.4V = 0.4V\\)</li> </ul> <p>Both noise margins are 0.4V, meaning signals can tolerate up to 0.4V of noise in either direction.</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/","title":"Quiz: Logic Gates and Digital Signals","text":"<p>Test your understanding of logic gates, digital signal properties, and gate characteristics with these questions.</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#1-which-logic-gate-outputs-1-only-when-all-inputs-are-1","title":"1. Which logic gate outputs 1 only when ALL inputs are 1?","text":"<ol> <li>OR gate</li> <li>AND gate</li> <li>NAND gate</li> <li>NOR gate</li> </ol> Show Answer <p>The correct answer is B. The AND gate implements logical conjunction\u2014it outputs 1 only when all inputs are 1. If any input is 0, the output is 0. This corresponds to the Boolean AND operation.</p> <p>Concept Tested: AND Gate</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#2-what-makes-nand-and-nor-gates-universal","title":"2. What makes NAND and NOR gates \"universal\"?","text":"<ol> <li>They can operate at any voltage level</li> <li>They are faster than other gates</li> <li>Any Boolean function can be implemented using only that gate type</li> <li>They use less power than other gates</li> </ol> Show Answer <p>The correct answer is C. NAND and NOR gates are called universal (or functionally complete) because any Boolean function can be implemented using only NAND gates or only NOR gates. You can build AND, OR, NOT, and any other gate from NANDs alone or NORs alone.</p> <p>Concept Tested: Universal Gate</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#3-what-is-the-output-of-an-xor-gate-when-both-inputs-are-1","title":"3. What is the output of an XOR gate when both inputs are 1?","text":"<ol> <li>1</li> <li>0</li> <li>Undefined</li> <li>High impedance</li> </ol> Show Answer <p>The correct answer is B. XOR (exclusive OR) outputs 1 when the inputs are different and 0 when they are the same. With both inputs at 1, they are the same, so the output is 0. XOR can be thought of as a \"difference detector.\"</p> <p>Concept Tested: XOR Gate</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#4-what-is-propagation-delay-in-a-logic-gate","title":"4. What is propagation delay in a logic gate?","text":"<ol> <li>The time to manufacture the gate</li> <li>The time from input change to output change</li> <li>The maximum operating frequency</li> <li>The power consumption during switching</li> </ol> Show Answer <p>The correct answer is B. Propagation delay is the time between when an input changes and when the corresponding output change appears. It's a fundamental timing characteristic that limits how fast a circuit can operate and must be considered in timing analysis.</p> <p>Concept Tested: Propagation Delay</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#5-what-is-fan-out-in-digital-circuits","title":"5. What is fan-out in digital circuits?","text":"<ol> <li>The number of inputs a gate can have</li> <li>The number of gate inputs an output can drive</li> <li>The power dissipation of a gate</li> <li>The speed at which a gate operates</li> </ol> Show Answer <p>The correct answer is B. Fan-out is the number of gate inputs that one gate output can reliably drive. Exceeding the fan-out limit degrades signal quality and timing. Fan-in, by contrast, is the number of inputs to a gate.</p> <p>Concept Tested: Fan-Out</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#6-which-gate-produces-the-complement-of-an-or-operation","title":"6. Which gate produces the complement of an OR operation?","text":"<ol> <li>AND gate</li> <li>NAND gate</li> <li>NOR gate</li> <li>XOR gate</li> </ol> Show Answer <p>The correct answer is C. A NOR gate produces the complement of OR: Y = (A + B)'. It outputs 1 only when all inputs are 0. The name NOR comes from \"NOT OR.\"</p> <p>Concept Tested: NOR Gate</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#7-what-determines-the-noise-margin-in-a-digital-circuit","title":"7. What determines the noise margin in a digital circuit?","text":"<ol> <li>The clock frequency</li> <li>The difference between output and input voltage thresholds</li> <li>The number of gates in series</li> <li>The power supply voltage only</li> </ol> Show Answer <p>The correct answer is B. Noise margin is the voltage difference between the worst-case output levels and the input thresholds. It determines how much noise a signal can tolerate without being misinterpreted. Larger noise margins provide better immunity to electrical interference.</p> <p>Concept Tested: Noise Margin</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#8-how-would-you-implement-an-inverter-not-gate-using-only-a-nand-gate","title":"8. How would you implement an inverter (NOT gate) using only a NAND gate?","text":"<ol> <li>Connect both inputs to the signal to be inverted</li> <li>Connect one input to logic 1, the other to the signal</li> <li>Use two NAND gates in series</li> <li>It cannot be done with a single NAND gate</li> </ol> Show Answer <p>The correct answer is A. To create an inverter from a NAND gate, connect both inputs together. With inputs A and A, the NAND output is (A\u00b7A)' = A' (since A\u00b7A = A by the Idempotent Law). This is the fundamental building block for NAND-only designs.</p> <p>Concept Tested: NAND-Only Design</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#9-what-is-the-primary-difference-between-ttl-and-cmos-logic-families","title":"9. What is the primary difference between TTL and CMOS logic families?","text":"<ol> <li>TTL uses transistors, CMOS uses resistors</li> <li>TTL uses bipolar transistors, CMOS uses MOSFETs</li> <li>TTL is faster than CMOS in all cases</li> <li>CMOS cannot operate at 5V</li> </ol> Show Answer <p>The correct answer is B. TTL (Transistor-Transistor Logic) uses bipolar junction transistors, while CMOS (Complementary Metal-Oxide-Semiconductor) uses MOSFETs. CMOS offers lower static power consumption and dominates modern digital IC design.</p> <p>Concept Tested: Logic Family</p>"},{"location":"chapters/03-logic-gates-digital-signals/quiz/#10-an-xnor-gate-outputs-1-when","title":"10. An XNOR gate outputs 1 when:","text":"<ol> <li>At least one input is 1</li> <li>Exactly one input is 1</li> <li>Both inputs are the same</li> <li>Both inputs are different</li> </ol> Show Answer <p>The correct answer is C. XNOR (exclusive NOR) is the complement of XOR. It outputs 1 when both inputs are the same (both 0 or both 1) and 0 when they differ. XNOR is also called an equivalence gate because it tests whether inputs are equal.</p> <p>Concept Tested: XNOR Gate</p>"},{"location":"chapters/04-combinational-logic-design/","title":"Combinational Logic Design Fundamentals","text":""},{"location":"chapters/04-combinational-logic-design/#summary","title":"Summary","text":"<p>This chapter introduces the systematic methodology for designing combinational logic circuits where outputs depend only on current inputs. Students will learn the distinction between combinational and sequential logic, how to map Boolean expressions to gate-level implementations, canonical representations including Sum of Products (SOP) and Product of Sums (POS), minterms and maxterms, and the foundations of logic minimization including an introduction to Karnaugh maps. These design techniques form the core workflow for creating digital circuits from specifications.</p>"},{"location":"chapters/04-combinational-logic-design/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>Gate-Level Design</li> <li>Boolean to Gates Mapping</li> <li>Multi-Level Logic</li> <li>Two-Level Logic</li> <li>Sum of Products</li> <li>Product of Sums</li> <li>Minterm</li> <li>Maxterm</li> <li>Canonical Form</li> <li>Standard Form</li> <li>Minimal Form</li> <li>Logic Minimization</li> <li>Algebraic Simplification</li> <li>Factoring</li> <li>Common Term Extraction</li> <li>Karnaugh Map</li> <li>K-Map 2 Variable</li> <li>K-Map 3 Variable</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Boolean Algebra Fundamentals</li> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> </ul>"},{"location":"chapters/04-combinational-logic-design/#introduction-the-art-of-digital-construction","title":"Introduction: The Art of Digital Construction","text":"<p>Imagine you're an architect, but instead of designing buildings, you're designing the logic that powers everything from coffee makers to spacecraft. You've learned the \"words\" (Boolean variables) and the \"grammar\" (Boolean algebra laws). You've met the \"building materials\" (logic gates). Now it's time to learn how to actually construct something.</p> <p>Welcome to combinational logic design\u2014the art and science of turning \"what I want the circuit to do\" into \"here's exactly how to build it.\" This is where you stop being a tourist in Digital Logic Land and become a licensed contractor.</p> <p>Here's the exciting part: by the end of this chapter, you'll have a systematic process that can turn any truth table into a working circuit. Give me any input-output specification, and you'll know exactly how to implement it. No guessing, no magic\u2014just methodical engineering.</p> <p>But before we start building, we need to understand what makes combinational logic special, and how it differs from its more complicated cousin: sequential logic.</p>"},{"location":"chapters/04-combinational-logic-design/#combinational-vs-sequential-logic-the-great-divide","title":"Combinational vs. Sequential Logic: The Great Divide","text":"<p>The world of digital logic is divided into two kingdoms, and understanding the boundary between them is crucial.</p>"},{"location":"chapters/04-combinational-logic-design/#combinational-logic-the-amnesiac","title":"Combinational Logic: The Amnesiac","text":"<p>Combinational logic circuits have a simple rule: the outputs depend only on the current inputs. Nothing else matters\u2014not what happened a nanosecond ago, not what might happen next. Combinational circuits have no memory, no state, no history. They're like that friend who genuinely can't remember what they were talking about five seconds ago.</p> <p>Change the inputs? The outputs change accordingly. Remove the inputs? The outputs have no idea what they were doing before.</p> <p>Think of a combinational circuit like a vending machine price display. Put in a candy bar code, it shows $1.50. Put in a soda code, it shows $2.00. The display doesn't remember what the last item was\u2014it just responds to the current input.</p> <p>Examples of combinational circuits:</p> <ul> <li>Adders (compute A + B)</li> <li>Multiplexers (select one of many inputs)</li> <li>Decoders (convert binary code to one-hot)</li> <li>Comparators (is A &gt; B?)</li> </ul>"},{"location":"chapters/04-combinational-logic-design/#sequential-logic-the-historian","title":"Sequential Logic: The Historian","text":"<p>Sequential logic circuits, by contrast, have memory. Their outputs depend on both the current inputs AND the history of past inputs. They remember things. They have state.</p> <p>A sequential circuit is like a combination lock. Entering \"5\" doesn't open it\u2014you need to have entered the correct sequence of numbers in the right order. The lock \"remembers\" your previous entries.</p> <p>We'll explore sequential logic in depth in later chapters. For now, just understand the distinction:</p> Feature Combinational Sequential Memory None Has state Output depends on Current inputs only Current inputs + history Time dependency None (instantaneous*) Clock-dependent Examples Adders, MUX, decoders Counters, registers, FSMs <p>*Well, instantaneous after propagation delay, as we learned!</p>"},{"location":"chapters/04-combinational-logic-design/#diagram-combinational-vs-sequential-logic","title":"Diagram: Combinational vs Sequential Logic","text":"Combinational vs Sequential Logic Comparison <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Contrast</p> <p>Learning Objective: Students will be able to contrast combinational and sequential circuits by observing that combinational outputs respond only to current inputs while sequential outputs depend on input history.</p> <p>Instructional Rationale: Side-by-side comparison with the same input sequence applied to both circuit types makes the fundamental difference concrete and memorable.</p> <p>Canvas Layout:</p> <ul> <li>Split view: Combinational circuit on left, Sequential circuit on right</li> <li>Each side has: input controls, circuit symbol, and output display</li> <li>Sequence of inputs shown as timeline at bottom</li> <li>Clear labels: \"No Memory\" vs \"Has Memory\"</li> </ul> <p>Interactive Elements:</p> <ul> <li>Shared input buttons that apply to both circuits</li> <li>\"Apply Input\" button triggers input change</li> <li>Combinational side: output changes immediately based on current input</li> <li>Sequential side: output depends on sequence of previous inputs</li> <li>History display showing past inputs for sequential side</li> <li>Reset button to clear sequential state</li> </ul> <p>Data Visibility:</p> <ul> <li>Current input prominently displayed</li> <li>Current output for each circuit type</li> <li>Input history log for sequential circuit</li> <li>State indicator for sequential circuit</li> </ul> <p>Visual Style:</p> <ul> <li>Combinational: simple gate symbol (cloud shape)</li> <li>Sequential: gate symbol with feedback loop and state bubble</li> <li>Color coding: inputs blue, combinational output green, sequential output purple</li> <li>Timeline showing input history</li> </ul> <p>Implementation: p5.js with state tracking for sequential demonstration</p> <p>Why This Matters</p> <p>This distinction is fundamental. When someone shows you a circuit and asks \"Is it combinational or sequential?\", look for memory elements (latches, flip-flops, feedback loops). If there are none, it's combinational. If the output can be different for the same current input (depending on what happened before), it's sequential.</p>"},{"location":"chapters/04-combinational-logic-design/#gate-level-design-from-equations-to-circuits","title":"Gate-Level Design: From Equations to Circuits","text":"<p>Now let's talk about the core skill of this chapter: gate-level design\u2014the process of implementing Boolean functions using actual logic gates.</p> <p>The good news is that this is remarkably straightforward once you understand the mapping. Every Boolean operation corresponds to a logic gate:</p> Boolean Operation Gate Symbol Description \\(\\overline{A}\\) NOT Triangle with bubble \\(A \\cdot B\\) AND D-shape \\(A + B\\) OR Shield shape \\(\\overline{A \\cdot B}\\) NAND D-shape with bubble \\(\\overline{A + B}\\) NOR Shield with bubble"},{"location":"chapters/04-combinational-logic-design/#boolean-to-gates-mapping","title":"Boolean to Gates Mapping","text":"<p>Here's the systematic process for converting any Boolean expression to a gate circuit:</p> <ol> <li>Identify the operations in the expression</li> <li>Draw gates for each operation</li> <li>Connect inputs according to the expression structure</li> <li>Wire the outputs to create the final output</li> </ol> <p>Let's walk through an example. Consider the expression:</p> \\[F = A \\cdot B + \\overline{C}\\] <p>This expression has:</p> <ul> <li>An AND operation: \\(A \\cdot B\\)</li> <li>A NOT operation: \\(\\overline{C}\\)</li> <li>An OR operation: combining the two results</li> </ul> <p>So we need: one AND gate, one NOT gate (inverter), and one OR gate.</p> <p>The wiring flows from left to right:</p> <ol> <li>A and B feed into the AND gate \u2192 produces \\(A \\cdot B\\)</li> <li>C feeds into the NOT gate \u2192 produces \\(\\overline{C}\\)</li> <li>Both results feed into the OR gate \u2192 produces \\(F\\)</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#diagram-boolean-to-gates-mapper","title":"Diagram: Boolean to Gates Mapper","text":"Boolean Expression to Gate Circuit Mapper <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute the transformation from a Boolean expression to a gate-level circuit by parsing the expression and selecting appropriate gates.</p> <p>Instructional Rationale: Interactive mapping with step-by-step visualization helps students internalize the direct correspondence between Boolean operations and physical gates.</p> <p>Canvas Layout:</p> <ul> <li>Top: Text input for Boolean expression with example buttons</li> <li>Middle: Parse tree visualization showing operation hierarchy</li> <li>Bottom: Resulting gate circuit with labeled connections</li> <li>Side panel: Legend showing operation-to-gate mapping</li> </ul> <p>Interactive Elements:</p> <ul> <li>Text input field accepting expressions (*, +, ! for NOT)</li> <li>Example expression buttons: \"AB\", \"A+B\", \"!A\", \"AB+!C\", \"(A+B)*C\"</li> <li>Step-through mode: see expression parsed into operations, then gates placed</li> <li>Final circuit is interactive\u2014toggle inputs to verify output</li> <li>Clear button to start over</li> </ul> <p>Data Visibility:</p> <ul> <li>Original expression displayed</li> <li>Parsed operations highlighted in sequence</li> <li>Each gate labeled with its Boolean sub-expression</li> <li>Truth table verification for the expression</li> </ul> <p>Visual Style:</p> <ul> <li>Clean gate symbols using logic-gate-lib style</li> <li>Connection wires animated as they're drawn</li> <li>Color coding: AND gates blue, OR gates orange, NOT gates gray</li> <li>Parse tree with rounded boxes for operations</li> </ul> <p>Implementation: p5.js with expression parser and gate layout algorithm</p>"},{"location":"chapters/04-combinational-logic-design/#two-level-vs-multi-level-logic","title":"Two-Level vs. Multi-Level Logic","text":"<p>When designing circuits, you have a choice about how to organize your gates. This choice affects cost, speed, and complexity.</p>"},{"location":"chapters/04-combinational-logic-design/#two-level-logic","title":"Two-Level Logic","text":"<p>Two-level logic implementations have at most two levels of gates between inputs and output (not counting inverters on inputs). This typically means:</p> <ul> <li>First level: AND gates (computing product terms)</li> <li>Second level: One OR gate (combining the products)</li> </ul> <p>Or the dual:</p> <ul> <li>First level: OR gates (computing sum terms)</li> <li>Second level: One AND gate (combining the sums)</li> </ul> <p>Two-level logic has a major advantage: predictable and minimal delay. Every signal path goes through exactly two gates (plus any input inversions). This makes timing analysis simple.</p>"},{"location":"chapters/04-combinational-logic-design/#multi-level-logic","title":"Multi-Level Logic","text":"<p>Multi-level logic uses more than two levels of gates. This usually results from factoring an expression to reduce the total gate count.</p> <p>Consider the expression:</p> \\[F = A \\cdot C + A \\cdot D + B \\cdot C + B \\cdot D\\] <p>In two-level form, this needs four AND gates and one OR gate\u20145 gates total with 8 inputs.</p> <p>But wait! We can factor:</p> \\[F = A \\cdot (C + D) + B \\cdot (C + D) = (A + B) \\cdot (C + D)\\] <p>Now we need only two OR gates and one AND gate\u20143 gates with 4 inputs. That's a significant savings!</p> <p>The tradeoff? The factored version might have three levels of gates (OR \u2192 OR \u2192 AND), which could mean more delay.</p> Approach Advantages Disadvantages Two-Level Predictable delay, simple timing May need more gates Multi-Level Often fewer gates Variable delay, harder timing <p>Designer's Choice</p> <p>In practice, designers choose based on constraints. Need fastest possible circuit? Favor two-level. Need minimum chip area? Favor multi-level with factoring. Modern synthesis tools explore many options automatically.</p>"},{"location":"chapters/04-combinational-logic-design/#diagram-two-level-vs-multi-level-comparison","title":"Diagram: Two-Level vs Multi-Level Comparison","text":"Two-Level vs Multi-Level Logic Comparison <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare two-level and multi-level implementations of the same function, analyzing the tradeoffs in gate count and propagation delay.</p> <p>Instructional Rationale: Side-by-side comparison with metrics display helps students develop intuition for the engineering tradeoffs in circuit design.</p> <p>Canvas Layout:</p> <ul> <li>Top: Shared Boolean expression display</li> <li>Left panel: Two-level implementation</li> <li>Right panel: Multi-level (factored) implementation</li> <li>Bottom: Metrics comparison (gate count, input count, max delay)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Expression selector with examples that can be factored</li> <li>Toggle inputs to verify both circuits produce same output</li> <li>Highlight critical path (longest delay path) in each implementation</li> <li>Metrics update automatically when expression changes</li> <li>Animation showing signal propagation through both circuits</li> </ul> <p>Data Visibility:</p> <ul> <li>Gate count for each implementation</li> <li>Total inputs (fan-in sum)</li> <li>Critical path delay (in gate delays)</li> <li>Verification: both outputs should always match</li> </ul> <p>Visual Style:</p> <ul> <li>Clean circuit diagrams with aligned outputs</li> <li>Critical path highlighted in orange</li> <li>Metrics displayed as comparison bars</li> <li>Expression shown with original and factored forms</li> </ul> <p>Implementation: p5.js with dual circuit rendering and delay calculation</p>"},{"location":"chapters/04-combinational-logic-design/#canonical-forms-the-standard-representations","title":"Canonical Forms: The Standard Representations","text":"<p>When we specify a Boolean function, we need a standard way to represent it\u2014a \"canonical form\" that's unique for each function. This makes comparison, simplification, and implementation straightforward.</p> <p>There are two main canonical forms, and they're duals of each other.</p>"},{"location":"chapters/04-combinational-logic-design/#sum-of-products-sop","title":"Sum of Products (SOP)","text":"<p>Sum of Products (SOP) is an OR of AND terms. In Boolean notation, \"sum\" means OR and \"product\" means AND. So SOP is:</p> \\[F = (\\text{product}_1) + (\\text{product}_2) + (\\text{product}_3) + ...\\] <p>Each product term is an AND of literals (variables or their complements).</p> <p>Example SOP expression:</p> \\[F = A \\cdot \\overline{B} \\cdot C + A \\cdot B \\cdot \\overline{C} + \\overline{A} \\cdot B \\cdot C\\] <p>This has three product terms, OR-ed together. Each product term has all three variables (either normal or complemented).</p> <p>SOP leads to a two-level AND-OR implementation:</p> <ul> <li>Level 1: AND gates compute each product term</li> <li>Level 2: OR gate combines the products</li> </ul>"},{"location":"chapters/04-combinational-logic-design/#product-of-sums-pos","title":"Product of Sums (POS)","text":"<p>Product of Sums (POS) is an AND of OR terms. It's the dual of SOP:</p> \\[F = (\\text{sum}_1) \\cdot (\\text{sum}_2) \\cdot (\\text{sum}_3) \\cdot ...\\] <p>Each sum term is an OR of literals.</p> <p>Example POS expression:</p> \\[F = (A + \\overline{B} + C) \\cdot (A + B + \\overline{C}) \\cdot (\\overline{A} + B + C)\\] <p>This has three sum terms, AND-ed together.</p> <p>POS leads to a two-level OR-AND implementation:</p> <ul> <li>Level 1: OR gates compute each sum term</li> <li>Level 2: AND gate combines the sums</li> </ul> <p>Here's the beautiful thing: any Boolean function can be expressed in either SOP or POS form. They're both complete representations. Which one you choose often depends on which leads to a simpler expression.</p>"},{"location":"chapters/04-combinational-logic-design/#minterms-and-maxterms-the-building-blocks","title":"Minterms and Maxterms: The Building Blocks","text":"<p>To fully understand canonical forms, we need to meet minterms and maxterms\u2014the fundamental building blocks.</p>"},{"location":"chapters/04-combinational-logic-design/#minterms","title":"Minterms","text":"<p>A minterm is a product term that includes every variable exactly once (either normal or complemented). For a function of variables A, B, C, a minterm might be:</p> <ul> <li>\\(A \\cdot B \\cdot C\\) (all normal)</li> <li>\\(A \\cdot \\overline{B} \\cdot C\\) (B complemented)</li> <li>\\(\\overline{A} \\cdot \\overline{B} \\cdot \\overline{C}\\) (all complemented)</li> </ul> <p>The key property of a minterm: it equals 1 for exactly one input combination and 0 for all others.</p> <p>For example, \\(A \\cdot \\overline{B} \\cdot C\\) equals 1 only when A=1, B=0, C=1.</p> <p>We name minterms using subscript notation based on the binary value they represent:</p> A B C Minterm Symbol 0 0 0 \\(\\overline{A} \\cdot \\overline{B} \\cdot \\overline{C}\\) \\(m_0\\) 0 0 1 \\(\\overline{A} \\cdot \\overline{B} \\cdot C\\) \\(m_1\\) 0 1 0 \\(\\overline{A} \\cdot B \\cdot \\overline{C}\\) \\(m_2\\) 0 1 1 \\(\\overline{A} \\cdot B \\cdot C\\) \\(m_3\\) 1 0 0 \\(A \\cdot \\overline{B} \\cdot \\overline{C}\\) \\(m_4\\) 1 0 1 \\(A \\cdot \\overline{B} \\cdot C\\) \\(m_5\\) 1 1 0 \\(A \\cdot B \\cdot \\overline{C}\\) \\(m_6\\) 1 1 1 \\(A \\cdot B \\cdot C\\) \\(m_7\\) <p>Memory trick: The minterm \\(m_i\\) equals 1 when the inputs spell out the binary number \\(i\\). So \\(m_5\\) (which is 101 in binary) equals 1 when A=1, B=0, C=1.</p>"},{"location":"chapters/04-combinational-logic-design/#maxterms","title":"Maxterms","text":"<p>A maxterm is the dual concept\u2014a sum term that includes every variable exactly once. For variables A, B, C:</p> <ul> <li>\\(A + B + C\\) (all normal)</li> <li>\\(A + \\overline{B} + C\\) (B complemented)</li> </ul> <p>The key property of a maxterm: it equals 0 for exactly one input combination and 1 for all others.</p> <p>Maxterms are named \\(M_i\\), but with a twist: the complement is applied oppositely compared to minterms. Maxterm \\(M_i\\) equals 0 when the inputs spell binary \\(i\\).</p> A B C Maxterm Symbol 0 0 0 \\(A + B + C\\) \\(M_0\\) 0 0 1 \\(A + B + \\overline{C}\\) \\(M_1\\) 0 1 0 \\(A + \\overline{B} + C\\) \\(M_2\\) 1 1 1 \\(\\overline{A} + \\overline{B} + \\overline{C}\\) \\(M_7\\) <p>Notice the pattern: in a maxterm, a variable appears complemented if its corresponding input bit is 1, and normal if its bit is 0. (This is opposite of minterms!)</p>"},{"location":"chapters/04-combinational-logic-design/#diagram-minterm-and-maxterm-explorer","title":"Diagram: Minterm and Maxterm Explorer","text":"Interactive Minterm and Maxterm Explorer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how minterms and maxterms are constructed from input combinations and how they relate to truth table rows.</p> <p>Instructional Rationale: Interactive exploration with immediate feedback helps students see the pattern in minterm/maxterm construction without memorization.</p> <p>Canvas Layout:</p> <ul> <li>Left: Input variable selectors (A, B, C values)</li> <li>Center: Visual construction showing how minterm/maxterm is built</li> <li>Right: Truth table with current combination highlighted</li> <li>Bottom: Symbol notation and the constructed expression</li> </ul> <p>Interactive Elements:</p> <ul> <li>Three toggle buttons for A, B, C input values</li> <li>Live construction showing variable \u2192 literal transformation</li> <li>Toggle between minterm and maxterm view</li> <li>Truth table row highlighting matching current selection</li> <li>Animation showing \"why\" the term equals 1/0 for that input</li> </ul> <p>Data Visibility:</p> <ul> <li>Current input combination prominently displayed</li> <li>Step-by-step construction of the term</li> <li>Resulting minterm/maxterm with proper notation</li> <li>Evaluation verification (term = 1 or 0)</li> </ul> <p>Visual Style:</p> <ul> <li>Variables shown with overline or normal based on rules</li> <li>Arrow diagram: input bit \u2192 how variable appears in term</li> <li>Highlighted truth table cell</li> <li>Clear minterm (m) vs maxterm (M) labeling</li> </ul> <p>Implementation: p5.js with dynamic expression construction</p>"},{"location":"chapters/04-combinational-logic-design/#canonical-sop-and-pos-forms","title":"Canonical SOP and POS Forms","text":"<p>Now we can define the true canonical forms:</p>"},{"location":"chapters/04-combinational-logic-design/#canonical-sop-sum-of-minterms","title":"Canonical SOP (Sum of Minterms)","text":"<p>The canonical SOP is the OR of all minterms for which the function equals 1. If a function F(A,B,C) equals 1 for inputs (0,1,1), (1,0,1), and (1,1,0), then:</p> \\[F = m_3 + m_5 + m_6 = \\sum m(3, 5, 6)\\] <p>The \\(\\sum m\\) notation is shorthand for \"sum of minterms.\"</p>"},{"location":"chapters/04-combinational-logic-design/#canonical-pos-product-of-maxterms","title":"Canonical POS (Product of Maxterms)","text":"<p>The canonical POS is the AND of all maxterms for which the function equals 0. For the same function:</p> \\[F = M_0 \\cdot M_1 \\cdot M_2 \\cdot M_4 \\cdot M_7 = \\prod M(0, 1, 2, 4, 7)\\] <p>The \\(\\prod M\\) notation means \"product of maxterms.\"</p> <p>Here's the magic: these two forms represent the same function! SOP tells us \"when is it 1?\" POS tells us \"when is it not 0?\"</p> <p>Converting a Truth Table to Canonical Forms</p> <p>Given this truth table:</p> A B C F 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 1 1 1 0 0 1 1 1 0 <p>Canonical SOP: F=1 for rows 1, 3, 4, 5: [F = m_1 + m_3 + m_4 + m_5 = \\overline{A}\\overline{B}C + \\overline{A}BC + A\\overline{B}\\overline{C} + A\\overline{B}C]</p> <p>Canonical POS: F=0 for rows 0, 2, 6, 7: [F = M_0 \\cdot M_2 \\cdot M_6 \\cdot M_7 = (A+B+C)(A+\\overline{B}+C)(\\overline{A}+\\overline{B}+C)(\\overline{A}+\\overline{B}+\\overline{C})]</p>"},{"location":"chapters/04-combinational-logic-design/#standard-form-vs-canonical-form-vs-minimal-form","title":"Standard Form vs. Canonical Form vs. Minimal Form","text":"<p>These terms can be confusing, so let's clarify:</p>"},{"location":"chapters/04-combinational-logic-design/#canonical-form","title":"Canonical Form","text":"<p>Canonical form is the \"complete\" representation where every term contains all variables. There's exactly one canonical SOP and one canonical POS for each function. It's unique but usually not minimal.</p>"},{"location":"chapters/04-combinational-logic-design/#standard-form","title":"Standard Form","text":"<p>Standard form is a relaxed version\u2014an SOP or POS where terms don't need to contain all variables. Standard form is usually simpler than canonical but still systematic.</p> <p>Examples of standard SOP:</p> <ul> <li>\\(A + BC\\) (first term has one variable, second has two)</li> <li>\\(AB + C\\) (different term sizes)</li> </ul>"},{"location":"chapters/04-combinational-logic-design/#minimal-form","title":"Minimal Form","text":"<p>Minimal form has the fewest literals (variable occurrences) possible while still being in SOP or POS form. Finding the minimal form is the goal of logic minimization.</p> Form Description Example for same function Canonical SOP All minterms where F=1 \\(\\overline{A}BC + A\\overline{B}C + AB\\overline{C} + ABC\\) Standard SOP Any valid SOP \\(BC + AC + AB\\) Minimal SOP Fewest literals \\(AB + BC + AC\\) or simpler"},{"location":"chapters/04-combinational-logic-design/#logic-minimization-why-and-how","title":"Logic Minimization: Why and How","text":"<p>Why do we want to minimize logic? Several reasons:</p> <ul> <li>Fewer gates = less hardware cost</li> <li>Fewer inputs = smaller chip area</li> <li>Shorter paths = less power consumption</li> <li>Simpler circuits = easier debugging</li> </ul> <p>Logic minimization finds the simplest expression that implements a given function. There are two main approaches.</p>"},{"location":"chapters/04-combinational-logic-design/#algebraic-simplification","title":"Algebraic Simplification","text":"<p>Algebraic simplification uses the Boolean algebra laws you learned in Chapter 2 to reduce an expression. This is an art as much as a science\u2014you need experience to spot which laws to apply.</p> <p>Let's work through an example:</p> \\[F = A\\overline{B}C + A\\overline{B}\\overline{C} + \\overline{A}BC\\] <p>Step 1: Factor \\(A\\overline{B}\\) from the first two terms: [F = A\\overline{B}(C + \\overline{C}) + \\overline{A}BC]</p> <p>Step 2: Apply complement law (\\(C + \\overline{C} = 1\\)): [F = A\\overline{B}(1) + \\overline{A}BC]</p> <p>Step 3: Apply identity law: [F = A\\overline{B} + \\overline{A}BC]</p> <p>We reduced from 9 literals to 5 literals. Not bad!</p>"},{"location":"chapters/04-combinational-logic-design/#common-simplification-techniques","title":"Common Simplification Techniques","text":"<p>Here are the most useful techniques:</p> <p>Factoring: Pull out common terms [AB + AC = A(B + C)]</p> <p>Common Term Extraction: Identify shared sub-expressions [ABC + \\overline{A}BC = BC(A + \\overline{A}) = BC]</p> <p>Absorption: Remove redundant terms [A + AB = A]</p> <p>Consensus: Remove the consensus term [AB + \\overline{A}C + BC = AB + \\overline{A}C]</p>"},{"location":"chapters/04-combinational-logic-design/#diagram-algebraic-simplification-stepper","title":"Diagram: Algebraic Simplification Stepper","text":"Algebraic Simplification Step-by-Step Demonstrator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Apply</p> <p>Learning Objective: Students will be able to apply Boolean algebra laws to simplify expressions step by step, identifying which law is used at each stage.</p> <p>Instructional Rationale: Guided step-through with law identification helps students internalize the simplification process and recognize simplification opportunities.</p> <p>Canvas Layout:</p> <ul> <li>Top: Starting expression and current expression display</li> <li>Middle: Applicable laws shown as clickable options</li> <li>Bottom: History panel showing all steps taken</li> <li>Sidebar: Gate count comparison (before/after)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Select from applicable simplification laws</li> <li>Click to apply selected law</li> <li>Undo button to step back</li> <li>Hint button to suggest next step</li> <li>Reset to start with new expression</li> <li>Example expressions as quick-start buttons</li> </ul> <p>Data Visibility:</p> <ul> <li>Original expression preserved at top</li> <li>Current simplified expression highlighted</li> <li>Each step logged with the law applied</li> <li>Running literal count</li> </ul> <p>Visual Style:</p> <ul> <li>Laws color-coded by type (factoring, absorption, De Morgan, etc.)</li> <li>Current simplification highlighted</li> <li>Reduction shown as crossed-out terms</li> <li>Progress indicator showing simplification percentage</li> </ul> <p>Implementation: p5.js with expression parsing and law matching engine</p>"},{"location":"chapters/04-combinational-logic-design/#karnaugh-maps-visual-simplification","title":"Karnaugh Maps: Visual Simplification","text":"<p>Algebraic simplification is powerful but requires insight and experience. Is there a more systematic approach?</p> <p>Enter the Karnaugh Map (K-map), invented by Maurice Karnaugh in 1953. A K-map is a visual tool that makes simplification almost mechanical. Instead of algebraically manipulating expressions, you spot patterns in a grid.</p> <p>The key insight: adjacent cells in a K-map differ by exactly one variable. This means adjacent 1s can always be combined using the simplification rule \\(XY + X\\overline{Y} = X\\).</p>"},{"location":"chapters/04-combinational-logic-design/#k-map-structure","title":"K-Map Structure","text":"<p>A K-map is a grid where:</p> <ul> <li>Each cell represents one minterm</li> <li>Cells are arranged so adjacent cells differ by one variable</li> <li>The edges \"wrap around\" (left connects to right, top to bottom)</li> </ul>"},{"location":"chapters/04-combinational-logic-design/#k-map-2-variable","title":"K-Map 2 Variable","text":"<p>The simplest K-map has 2 variables and 4 cells:</p> <pre><code>        B=0   B=1\n      +-----+-----+\nA=0   |  0  |  1  |\n      +-----+-----+\nA=1   |  2  |  3  |\n      +-----+-----+\n</code></pre> <p>Each cell corresponds to a minterm: cell 0 is \\(m_0 = \\overline{A}\\overline{B}\\), cell 1 is \\(m_1 = \\overline{A}B\\), etc.</p> <p>To use the K-map:</p> <ol> <li>Fill in 1s for each minterm where F=1</li> <li>Group adjacent 1s into rectangles of size 1, 2, or 4</li> <li>Each group becomes one term in the simplified expression</li> <li>Larger groups = simpler terms</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#diagram-2-variable-k-map-interactive","title":"Diagram: 2-Variable K-Map Interactive","text":"2-Variable Karnaugh Map Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use a 2-variable K-map to find simplified SOP expressions by identifying and grouping adjacent 1s.</p> <p>Instructional Rationale: Starting with 2 variables allows students to focus on the grouping concept without the complexity of larger maps. Interactive grouping with immediate feedback builds correct technique.</p> <p>Canvas Layout:</p> <ul> <li>Main: 2x2 K-map grid with clickable cells</li> <li>Left: Variable labels (A rows, B columns)</li> <li>Right: Current expression display (updates as groups are made)</li> <li>Bottom: Grouping tools and verification</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click cells to toggle between 0, 1, and don't care (X)</li> <li>Draw rectangles to create groups</li> <li>Automatic group validation (must be power of 2, rectangular)</li> <li>Show resulting term for each valid group</li> <li>\"Check\" button verifies grouping is optimal</li> <li>\"Auto-solve\" to demonstrate correct grouping</li> </ul> <p>Data Visibility:</p> <ul> <li>Cell values clearly displayed</li> <li>Group outlines in distinct colors</li> <li>Each group's simplified term shown</li> <li>Final combined expression</li> </ul> <p>Visual Style:</p> <ul> <li>Clean grid with clear cell boundaries</li> <li>Groups shown as colored overlays</li> <li>Variable labels on all edges</li> <li>Gray-code ordering visualization option</li> </ul> <p>Implementation: p5.js with group detection and expression generation</p>"},{"location":"chapters/04-combinational-logic-design/#k-map-3-variable","title":"K-Map 3 Variable","text":"<p>A 3-variable K-map has 8 cells arranged in a 2\u00d74 grid:</p> <pre><code>          BC=00  BC=01  BC=11  BC=10\n        +------+------+------+------+\nA=0     |  0   |  1   |  3   |  2   |\n        +------+------+------+------+\nA=1     |  4   |  5   |  7   |  6   |\n        +------+------+------+------+\n</code></pre> <p>Important: The columns are in Gray code order (00, 01, 11, 10), not binary order! This ensures adjacent columns differ by only one bit.</p> <p>The wrap-around principle: the leftmost column is adjacent to the rightmost column. This can create groups that span the \"edges\" of the map.</p> <p>Grouping rules for 3-variable K-maps:</p> <ul> <li>Groups must be rectangular (1\u00d71, 1\u00d72, 1\u00d74, 2\u00d71, 2\u00d72, 2\u00d74)</li> <li>Group size must be a power of 2 (1, 2, 4, 8)</li> <li>Larger groups are better (fewer literals in the term)</li> <li>Each 1 must be covered by at least one group</li> <li>Overlapping groups are allowed (and often necessary)</li> </ul>"},{"location":"chapters/04-combinational-logic-design/#diagram-3-variable-k-map-interactive","title":"Diagram: 3-Variable K-Map Interactive","text":"3-Variable Karnaugh Map Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Solve</p> <p>Learning Objective: Students will be able to solve 3-variable minimization problems using K-maps, correctly applying Gray code ordering and wrap-around grouping.</p> <p>Instructional Rationale: The 3-variable K-map introduces Gray code ordering and wrap-around grouping\u2014key concepts that must be mastered before tackling 4-variable maps.</p> <p>Canvas Layout:</p> <ul> <li>Main: 2\u00d74 K-map grid with Gray code column labels</li> <li>Left: Row variable label (A)</li> <li>Top: Column variable labels (BC)</li> <li>Right: Expression builder showing terms</li> <li>Bottom: Control panel and verification</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click cells to set values (0, 1, X for don't care)</li> <li>Draw groups by clicking and dragging</li> <li>Wrap-around highlight when group spans edges</li> <li>Auto-complete: suggest optimal grouping</li> <li>Step-through mode: watch optimal grouping process</li> <li>Example problems with known solutions</li> </ul> <p>Data Visibility:</p> <ul> <li>Cell values and minterm numbers</li> <li>Gray code labels on columns</li> <li>Groups with color coding</li> <li>Each group's simplified term</li> <li>Final minimized expression</li> <li>Comparison with canonical form (literal count)</li> </ul> <p>Visual Style:</p> <ul> <li>Clear Gray code ordering visual</li> <li>Wrap-around groups shown with matching colors on both edges</li> <li>Group expressions labeled</li> <li>\"Optimal\" indicator when best grouping achieved</li> </ul> <p>Implementation: p5.js with Gray code layout and wrap-around detection</p>"},{"location":"chapters/04-combinational-logic-design/#k-map-grouping-rules-summary","title":"K-Map Grouping Rules Summary","text":"<p>Here are the rules for valid K-map groups:</p> <ol> <li>Groups must contain 1, 2, 4, 8, 16... cells (powers of 2)</li> <li>Groups must be rectangular (including squares)</li> <li>Groups can wrap around edges (left\u2194right, top\u2194bottom)</li> <li>Every 1 must be in at least one group</li> <li>Groups can overlap (same cell in multiple groups is fine)</li> <li>Larger groups are preferable (they produce simpler terms)</li> <li>Fewer groups are preferable (fewer terms in final expression)</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#reading-terms-from-groups","title":"Reading Terms from Groups","text":"<p>Once you've identified groups, read the simplified term:</p> <ol> <li>Look at which variables are constant across the entire group</li> <li>If a variable is always 0 in the group \u2192 include as \\(\\overline{X}\\)</li> <li>If a variable is always 1 in the group \u2192 include as \\(X\\)</li> <li>If a variable is both 0 and 1 in the group \u2192 omit it (it's been simplified away!)</li> </ol> <p>K-Map Example</p> <p>For the function \\(F = \\sum m(0, 1, 2, 5, 7)\\) with variables A, B, C:</p> <pre><code>      BC=00  BC=01  BC=11  BC=10\n    +------+------+------+------+\nA=0 |  1   |  1   |  0   |  1   |\n    +------+------+------+------+\nA=1 |  0   |  1   |  1   |  0   |\n    +------+------+------+------+\n</code></pre> <p>Groups:</p> <ul> <li>Cells 0, 1 (group of 2): A=0, C varies, B=0 \u2192 term: \\(\\overline{A}\\overline{B}\\)</li> <li>Cells 1, 5, 3, 7 (group of 4? No\u2014cells 3 is 0): Invalid</li> <li>Let's try: cells 1, 5 (column 01): B=0, C=1, A varies \u2192 term: \\(\\overline{B}C\\)</li> <li>Cell 0, 2 (wrap around columns 00 and 10): A=0, C=0, B varies \u2192 term: \\(\\overline{A}\\overline{C}\\)</li> <li>Wait, let me reconsider for optimal grouping...</li> </ul> <p>The optimal solution is: [F = \\overline{A}\\overline{C} + \\overline{B}C]</p>"},{"location":"chapters/04-combinational-logic-design/#putting-it-all-together-the-design-workflow","title":"Putting It All Together: The Design Workflow","text":"<p>Let's consolidate everything into a systematic design workflow for combinational logic:</p> <ol> <li>Start with the specification (truth table or word description)</li> <li>Write the canonical SOP (from the truth table)</li> <li>Simplify using K-maps (or algebraic methods)</li> <li>Draw the gate-level circuit</li> <li>Verify (trace through with test inputs)</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#diagram-complete-design-flow","title":"Diagram: Complete Design Flow","text":"Complete Combinational Logic Design Workflow <p>Type: workflow</p> <p>Bloom Level: Create (L6) Bloom Verb: Design</p> <p>Learning Objective: Students will be able to design combinational logic circuits from specification to implementation by following the systematic workflow.</p> <p>Instructional Rationale: A complete end-to-end example reinforces how all the concepts connect and provides a template students can follow for their own designs.</p> <p>Workflow Steps:</p> <ol> <li>Specification: Enter truth table or word description</li> <li>Canonical Form: Generate SOP from truth table</li> <li>K-Map: Visualize function in K-map format</li> <li>Simplification: Group terms for minimal expression</li> <li>Gate Circuit: Map simplified expression to gates</li> <li>Verification: Test circuit against truth table</li> </ol> <p>Canvas Layout:</p> <ul> <li>Vertical workflow with expandable panels for each step</li> <li>Left: Progress indicator showing current step</li> <li>Center: Active step content</li> <li>Right: Running example maintained throughout</li> </ul> <p>Interactive Elements:</p> <ul> <li>Editable truth table input</li> <li>Automatic canonical SOP generation</li> <li>Interactive K-map grouping</li> <li>Gate circuit auto-generated from expression</li> <li>Input toggles on final circuit for verification</li> <li>Navigation: Next/Previous step buttons</li> </ul> <p>Data Visibility:</p> <ul> <li>Truth table visible throughout</li> <li>Expression at each stage of simplification</li> <li>K-map with final groupings</li> <li>Gate count and literal count metrics</li> <li>Verification results for all input combinations</li> </ul> <p>Visual Style:</p> <ul> <li>Workflow arrows connecting steps</li> <li>Each step in distinct colored panel</li> <li>Current step highlighted/expanded</li> <li>Checkmarks for completed steps</li> <li>Final circuit prominently displayed</li> </ul> <p>Implementation: p5.js with multi-stage state management</p>"},{"location":"chapters/04-combinational-logic-design/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you practice combinational logic design, watch out for these pitfalls:</p> <ol> <li> <p>Confusing canonical and minimal forms: Canonical is complete (all variables in each term), minimal is simplest. They're usually different!</p> </li> <li> <p>Wrong Gray code order in K-maps: Columns must be 00, 01, 11, 10\u2014not 00, 01, 10, 11. Getting this wrong means adjacent cells don't differ by one bit, and your groupings will be invalid.</p> </li> <li> <p>Forgetting wrap-around: The edges of K-maps connect! A group can span from the leftmost to rightmost column.</p> </li> <li> <p>Invalid group sizes: Groups must be powers of 2. You can't make a group of 3 cells.</p> </li> <li> <p>Missing 1s: Every 1 in the K-map must be covered by at least one group.</p> </li> <li> <p>Not using largest possible groups: Larger groups give simpler terms. Always try to make groups as large as possible.</p> </li> <li> <p>Confusing SOP and POS: SOP groups 1s and uses minterms. POS groups 0s and uses maxterms. Don't mix them up!</p> </li> </ol>"},{"location":"chapters/04-combinational-logic-design/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've learned the systematic methodology for designing combinational logic circuits. Here's what you've mastered:</p> <p>Core Concepts:</p> <ul> <li>Combinational logic has no memory\u2014outputs depend only on current inputs</li> <li>Sequential logic has memory and state (we'll tackle this later)</li> <li>Gate-level design maps Boolean operations directly to physical gates</li> </ul> <p>Canonical Forms:</p> <ul> <li>Sum of Products (SOP) = OR of AND terms (minterms)</li> <li>Product of Sums (POS) = AND of OR terms (maxterms)</li> <li>Minterms (\\(m_i\\)) equal 1 for exactly one input combination</li> <li>Maxterms (\\(M_i\\)) equal 0 for exactly one input combination</li> </ul> <p>Circuit Structures:</p> <ul> <li>Two-level logic has predictable delay (AND-OR or OR-AND)</li> <li>Multi-level logic can reduce gate count through factoring</li> </ul> <p>Simplification:</p> <ul> <li>Algebraic simplification applies Boolean laws manually</li> <li>Karnaugh maps provide visual, systematic simplification</li> <li>Grouping rules: powers of 2, rectangular, wrap-around allowed</li> <li>Larger groups = simpler terms</li> </ul> <p>The Design Workflow:</p> <ol> <li>Specification \u2192 Truth table</li> <li>Truth table \u2192 Canonical SOP</li> <li>Canonical SOP \u2192 K-map</li> <li>K-map grouping \u2192 Minimal expression</li> <li>Minimal expression \u2192 Gate circuit</li> <li>Verify!</li> </ol> <p>Key Insight</p> <p>Combinational logic design is fundamentally about translation: from what you want (truth table) to how to build it (gates). The canonical forms give you a starting point, and simplification techniques help you find the most efficient implementation. Master this workflow, and you can implement any Boolean function.</p> Graphic Novel Suggestion <p>A compelling graphic novel could tell the story of Maurice Karnaugh, a Bell Labs engineer in the 1950s who was frustrated watching his colleagues struggle with algebraic simplification. The visual medium would perfectly capture the \"aha moment\" when Karnaugh realized that arranging a truth table spatially\u2014where adjacent cells differ by one bit\u2014would make simplification patterns visible at a glance. The climax could show the K-map technique spreading through the engineering world, revolutionizing digital design education and practice.</p>"},{"location":"chapters/04-combinational-logic-design/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Identify the Type <p>Is a 4-bit binary adder combinational or sequential? Explain your reasoning.</p> <p>Solution: A 4-bit binary adder is combinational. The outputs (sum and carry) depend only on the current input values (the two 4-bit numbers to be added). There's no memory of previous additions\u2014change the inputs, and the outputs immediately reflect the new sum. No clock is needed, and no state is maintained.</p> Problem 2: Write Canonical SOP <p>Given the truth table where F(A,B,C) = 1 for inputs (0,0,1), (0,1,1), (1,1,0), and (1,1,1), write the canonical SOP expression.</p> <p>Solution: The function equals 1 for minterms 1, 3, 6, and 7: [F = m_1 + m_3 + m_6 + m_7] [F = \\overline{A}\\overline{B}C + \\overline{A}BC + AB\\overline{C} + ABC]</p> Problem 3: Simplify Using a K-Map <p>Simplify \\(F(A,B) = \\sum m(0, 1, 2)\\) using a 2-variable K-map.</p> <p>Solution: <pre><code>        B=0   B=1\n      +-----+-----+\nA=0   |  1  |  1  |  \u2190 Group (cells 0,1): term = \u0100\n      +-----+-----+\nA=1   |  1  |  0  |\n      +-----+-----+\n</code></pre> Group cells 0, 2 (column B=0): term = \\(\\overline{B}\\) Group cells 0, 1 (row A=0): term = \\(\\overline{A}\\)</p> <p>Minimal SOP: \\(F = \\overline{A} + \\overline{B}\\)</p> Problem 4: Multi-Level vs Two-Level <p>The expression \\(F = AC + AD + BC + BD\\) can be factored to \\(F = (A+B)(C+D)\\). Compare the two implementations in terms of gate count and maximum delay (in gate delays).</p> <p>Solution:</p> <p>Two-level (unfactored):</p> <ul> <li>4 AND gates (for AC, AD, BC, BD)</li> <li>1 OR gate with 4 inputs</li> <li>Total: 5 gates, 2 levels of delay</li> </ul> <p>Multi-level (factored):</p> <ul> <li>2 OR gates (for A+B and C+D)</li> <li>1 AND gate</li> <li>Total: 3 gates, 2 levels of delay</li> </ul> <p>The factored version uses 2 fewer gates with the same delay. In this case, multi-level wins on both metrics.</p> Problem 5: Convert Between Forms <p>If \\(F = \\sum m(1, 4, 5, 6, 7)\\) for a 3-variable function, write the equivalent \\(\\prod M\\) expression.</p> <p>Solution: If F=1 for minterms 1, 4, 5, 6, 7, then F=0 for minterms 0, 2, 3.</p> <p>The POS uses maxterms for where F=0: [F = \\prod M(0, 2, 3) = M_0 \\cdot M_2 \\cdot M_3] [F = (A+B+C)(A+\\overline{B}+C)(A+\\overline{B}+\\overline{C})]</p>"},{"location":"chapters/04-combinational-logic-design/quiz/","title":"Quiz: Combinational Logic Design","text":"<p>Test your understanding of combinational circuit design, canonical forms, and standard representations with these questions.</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#1-what-defines-a-combinational-logic-circuit","title":"1. What defines a combinational logic circuit?","text":"<ol> <li>It uses only NAND and NOR gates</li> <li>Its outputs depend only on current inputs, with no memory</li> <li>It requires a clock signal to operate</li> <li>It can store data between clock cycles</li> </ol> Show Answer <p>The correct answer is B. Combinational logic circuits produce outputs based solely on the current input values. They have no memory or feedback\u2014the same inputs always produce the same outputs. This contrasts with sequential logic, which depends on input history.</p> <p>Concept Tested: Combinational Logic</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#2-what-is-a-minterm","title":"2. What is a minterm?","text":"<ol> <li>The smallest possible Boolean expression</li> <li>A product term where each variable appears exactly once</li> <li>A sum term where each variable appears exactly once</li> <li>The simplified form of a Boolean function</li> </ol> Show Answer <p>The correct answer is B. A minterm is a product (AND) term in which every variable of the function appears exactly once, either in true or complemented form. Each minterm corresponds to exactly one row of the truth table where the output is 1.</p> <p>Concept Tested: Minterm</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#3-in-sum-of-products-sop-form-what-operation-connects-the-product-terms","title":"3. In Sum of Products (SOP) form, what operation connects the product terms?","text":"<ol> <li>AND</li> <li>OR</li> <li>XOR</li> <li>NAND</li> </ol> Show Answer <p>The correct answer is B. In Sum of Products form, individual product terms (ANDs) are combined using OR operations. The name reflects this structure: \"sum\" refers to OR (Boolean addition), and \"products\" are AND terms.</p> <p>Concept Tested: Sum of Products</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#4-what-is-the-canonical-sop-form-for-a-function-with-minterms-m1-m3-and-m7","title":"4. What is the canonical SOP form for a function with minterms m1, m3, and m7?","text":"<ol> <li>F = \u03a3(1, 3, 7)</li> <li>F = \u03a0(1, 3, 7)</li> <li>F = m1 \u00b7 m3 \u00b7 m7</li> <li>F = \u03a3(0, 2, 4, 5, 6)</li> </ol> Show Answer <p>The correct answer is A. Canonical SOP is written as F = \u03a3(list of minterms). The sigma (\u03a3) notation indicates a sum (OR) of the specified minterms. Option B uses \u03a0, which is Product of Sums notation for maxterms.</p> <p>Concept Tested: Canonical Form</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#5-how-does-a-two-level-logic-implementation-differ-from-multi-level","title":"5. How does a two-level logic implementation differ from multi-level?","text":"<ol> <li>Two-level uses only two gates total</li> <li>Two-level has at most two gates between input and output</li> <li>Two-level is always slower than multi-level</li> <li>Two-level cannot implement all functions</li> </ol> Show Answer <p>The correct answer is B. Two-level logic has at most two gates between any input and the output (typically AND-OR for SOP or OR-AND for POS). Multi-level logic uses more gate stages, which can reduce total gate count at the cost of increased delay.</p> <p>Concept Tested: Two-Level Logic</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#6-what-is-the-relationship-between-minterms-and-maxterms-for-the-same-function","title":"6. What is the relationship between minterms and maxterms for the same function?","text":"<ol> <li>They are identical</li> <li>Minterms list where F=1; maxterms list where F=0</li> <li>Minterms use AND; maxterms use XOR</li> <li>There is no relationship</li> </ol> Show Answer <p>The correct answer is B. Minterms identify input combinations where the function equals 1 (for SOP form), while maxterms identify combinations where the function equals 0 (for POS form). For a given function, if minterm mi makes F=1, then maxterm Mi makes F=0.</p> <p>Concept Tested: Maxterm</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#7-what-is-the-first-step-in-the-standard-combinational-design-workflow","title":"7. What is the first step in the standard combinational design workflow?","text":"<ol> <li>Draw the K-map</li> <li>Write the Verilog code</li> <li>Create the truth table from the problem specification</li> <li>Build the circuit on a breadboard</li> </ol> Show Answer <p>The correct answer is C. The standard workflow begins with understanding the problem and creating a complete truth table that specifies outputs for all input combinations. This formal specification then guides Boolean expression derivation, simplification, and implementation.</p> <p>Concept Tested: Gate-Level Design</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#8-in-product-of-sums-form-what-are-the-individual-sum-terms-called","title":"8. In Product of Sums form, what are the individual sum terms called?","text":"<ol> <li>Minterms</li> <li>Maxterms</li> <li>Prime implicants</li> <li>Implicant covers</li> </ol> Show Answer <p>The correct answer is B. In POS form, the individual sum (OR) terms are called maxterms. Each maxterm contains every variable once, and the maxterms are combined using AND. A maxterm equals 0 for exactly one input combination.</p> <p>Concept Tested: Product of Sums</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#9-what-distinguishes-a-minimal-form-from-a-canonical-form","title":"9. What distinguishes a minimal form from a canonical form?","text":"<ol> <li>Minimal form uses more gates</li> <li>Minimal form may not include all variables in each term</li> <li>Canonical form is always incorrect</li> <li>There is no difference</li> </ol> Show Answer <p>The correct answer is B. Canonical forms include every variable in each term (minterms or maxterms), while minimal forms eliminate redundant variables through simplification. Minimal forms use fewer gates but express the same function.</p> <p>Concept Tested: Minimal Form</p>"},{"location":"chapters/04-combinational-logic-design/quiz/#10-when-mapping-a-boolean-expression-to-gates-which-gate-type-implements-a-product-term","title":"10. When mapping a Boolean expression to gates, which gate type implements a product term?","text":"<ol> <li>OR gate</li> <li>AND gate</li> <li>XOR gate</li> <li>NOR gate</li> </ol> Show Answer <p>The correct answer is B. A product term (variables combined with AND) is implemented using AND gates. In SOP implementations, AND gates create the products, and an OR gate sums them. Variables with complements require inverters.</p> <p>Concept Tested: Boolean to Gates Mapping</p>"},{"location":"chapters/05-logic-minimization-kmaps/","title":"Logic Minimization and Karnaugh Maps","text":""},{"location":"chapters/05-logic-minimization-kmaps/#summary","title":"Summary","text":"<p>This chapter provides advanced techniques for optimizing Boolean functions to create efficient circuit implementations. Students will master 4-variable Karnaugh maps and their grouping rules, learn to identify prime implicants and essential prime implicants, handle don't-care conditions for further optimization, derive minimal SOP and POS expressions, understand the Quine-McCluskey method for larger functions, and design hazard-free circuits. These optimization skills are critical for creating practical, cost-effective digital systems.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>K-Map 4 Variable</li> <li>K-Map Grouping Rules</li> <li>Adjacent Cells</li> <li>Don't Care Condition</li> <li>Prime Implicant</li> <li>Essential Prime Implicant</li> <li>Implicant Cover</li> <li>Minimal SOP</li> <li>Minimal POS</li> <li>Quine-McCluskey Method</li> <li>Hazard</li> <li>Static Hazard</li> <li>Dynamic Hazard</li> <li>Hazard-Free Design</li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul>"},{"location":"chapters/05-logic-minimization-kmaps/#introduction-the-quest-for-the-perfect-circuit","title":"Introduction: The Quest for the Perfect Circuit","text":"<p>In Chapter 4, you learned to read the K-map like a treasure map\u2014finding gold (simplified expressions) by grouping adjacent 1s. But here's the thing: we only showed you the small maps. A 2-variable K-map has 4 cells. A 3-variable map has 8. That's cute, but real circuits often have 4, 5, or even more input variables.</p> <p>Welcome to the big leagues.</p> <p>This chapter is about becoming a master of logic minimization. We're talking 4-variable K-maps with 16 cells, wrap-around groupings that would make a pretzel jealous, and fancy concepts like \"prime implicants\" that sound like characters from a sci-fi movie but are actually just helpful tools for finding the absolute best circuit.</p> <p>Why does minimization matter so much? Consider this: a chip with one million gates could potentially be reduced to 600,000 gates with proper optimization. That's 40% less silicon, 40% less power, and 40% less heat. In mobile devices and data centers, that's not just nice\u2014it's essential.</p> <p>By the end of this chapter, you'll be able to look at a 16-cell K-map, spot the optimal groupings like a hawk spotting a mouse, and confidently declare \"this is the minimal expression.\" Let's level up your optimization game!</p>"},{"location":"chapters/05-logic-minimization-kmaps/#k-map-4-variable-the-full-size-map","title":"K-Map 4 Variable: The Full-Size Map","text":"<p>A 4-variable K-map has \\(2^4 = 16\\) cells, arranged in a 4\u00d74 grid. This is the workhorse of manual logic minimization\u2014large enough to handle real problems, but small enough to work with on paper.</p> <p>The layout follows Gray code ordering on both axes:</p> <pre><code>            CD\n           00   01   11   10\n        +----+----+----+----+\nAB  00  |  0 |  1 |  3 |  2 |\n        +----+----+----+----+\n    01  |  4 |  5 |  7 |  6 |\n        +----+----+----+----+\n    11  | 12 | 13 | 15 | 14 |\n        +----+----+----+----+\n    10  |  8 |  9 | 11 | 10 |\n        +----+----+----+----+\n</code></pre> <p>Each cell number corresponds to the minterm with that decimal value. Cell 13, for instance, is minterm \\(m_{13}\\), which is \\(ABCD\\) with A=1, B=1, C=0, D=1 (binary 1101 = 13).</p> <p>Critical observation: Both axes use Gray code order (00, 01, 11, 10). This ensures that every adjacent cell\u2014horizontally, vertically, and including wrap-around\u2014differs by exactly one variable.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#the-wrap-around-nature","title":"The Wrap-Around Nature","text":"<p>Here's where it gets interesting. In a 4-variable K-map:</p> <ul> <li>The top row is adjacent to the bottom row (cells 0-3 are adjacent to cells 8-11)</li> <li>The left column is adjacent to the right column (cells 0,4,12,8 are adjacent to cells 2,6,14,10)</li> <li>Even the corners are all mutually adjacent!</li> </ul> <p>Think of the K-map as a torus (a donut shape). If you rolled it up left-to-right and then top-to-bottom, adjacent cells would touch. This wrap-around property is essential for finding the largest possible groups.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-4-variable-k-map-interactive","title":"Diagram: 4-Variable K-Map Interactive","text":"4-Variable Karnaugh Map Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Implement</p> <p>Learning Objective: Students will be able to implement 4-variable K-map simplification by correctly identifying and grouping adjacent cells, including wrap-around groups.</p> <p>Instructional Rationale: The 4-variable K-map requires understanding both horizontal and vertical wrap-around. Interactive grouping with wrap-around visualization builds correct mental models.</p> <p>Canvas Layout:</p> <ul> <li>Main: 4\u00d74 K-map grid with Gray code labels on both axes</li> <li>Top: Row variable labels (AB)</li> <li>Left: Column variable labels (CD)</li> <li>Right: Expression builder showing current groups and terms</li> <li>Bottom: Control panel with grouping tools</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click cells to toggle between 0, 1, and don't care (X)</li> <li>Click and drag to create groups</li> <li>Wrap-around visualization: when group spans edge, show connection on opposite side</li> <li>Color-coded groups (up to 6 different colors)</li> <li>Auto-solve button to show optimal grouping</li> <li>Step-through mode for learning</li> <li>Undo/redo for group editing</li> </ul> <p>Data Visibility:</p> <ul> <li>Cell values with minterm numbers</li> <li>Gray code labels clearly shown</li> <li>Each group's simplified term displayed</li> <li>Final minimized SOP expression</li> <li>Literal count comparison (canonical vs. minimal)</li> </ul> <p>Visual Style:</p> <ul> <li>Clear 4\u00d74 grid with proper spacing</li> <li>Wrap-around groups shown with matching colors on opposite edges</li> <li>Dashed lines indicating wrap-around connections</li> <li>Group terms labeled with color matching the group</li> <li>\"Optimal\" indicator when best solution achieved</li> </ul> <p>Implementation: p5.js with 2D wrap-around detection and group validation</p>"},{"location":"chapters/05-logic-minimization-kmaps/#k-map-grouping-rules-the-complete-guide","title":"K-Map Grouping Rules: The Complete Guide","text":"<p>Now that we have the full-size map, let's formalize all the grouping rules. These apply to K-maps of any size, but they become especially important with 4 variables.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#rule-1-groups-must-be-powers-of-2","title":"Rule 1: Groups Must Be Powers of 2","text":"<p>Valid group sizes are: 1, 2, 4, 8, or 16 cells. You cannot have groups of 3, 5, 6, or 7 cells. Period.</p> <p>Why? Because each doubling of group size eliminates one variable from the term. A group of 3 doesn't correspond to any valid Boolean simplification.</p> Group Size Variables Eliminated Term has... 1 cell 0 All 4 variables 2 cells 1 3 variables 4 cells 2 2 variables 8 cells 3 1 variable 16 cells 4 Just 1 (constant)"},{"location":"chapters/05-logic-minimization-kmaps/#rule-2-groups-must-be-rectangular","title":"Rule 2: Groups Must Be Rectangular","text":"<p>Groups must form rectangles (including squares). You cannot have L-shaped, T-shaped, or diagonal groups.</p> <p>Valid shapes:</p> <ul> <li>1\u00d71 (single cell)</li> <li>1\u00d72 or 2\u00d71 (two adjacent cells)</li> <li>1\u00d74, 4\u00d71, or 2\u00d72 (four cells)</li> <li>1\u00d78, 8\u00d71, 2\u00d74, or 4\u00d72 (eight cells\u2014possible in 5+ variable maps)</li> <li>4\u00d74 (all sixteen cells)</li> </ul>"},{"location":"chapters/05-logic-minimization-kmaps/#rule-3-groups-can-wrap-around","title":"Rule 3: Groups Can Wrap Around","text":"<p>The edges connect! This is the sneakiest rule and the one students most often forget.</p> <ul> <li>Top edge connects to bottom edge</li> <li>Left edge connects to right edge</li> <li>All four corners are mutually adjacent</li> </ul> <p>A group of 4 cells occupying the four corners of a 4-variable K-map is perfectly valid!</p>"},{"location":"chapters/05-logic-minimization-kmaps/#rule-4-every-1-must-be-covered","title":"Rule 4: Every 1 Must Be Covered","text":"<p>Every cell containing a 1 must be included in at least one group. You can't leave any 1s ungrouped\u2014that would mean missing part of the function.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#rule-5-overlapping-is-allowed-and-often-required","title":"Rule 5: Overlapping Is Allowed (and Often Required)","text":"<p>A single cell can belong to multiple groups. In fact, overlapping often leads to better solutions because it allows each group to be as large as possible.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#rule-6-maximize-group-size","title":"Rule 6: Maximize Group Size","text":"<p>Always use the largest possible groups. A group of 4 is better than two groups of 2, even if both cover the same cells. Larger groups produce simpler terms.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#rule-7-minimize-the-number-of-groups","title":"Rule 7: Minimize the Number of Groups","text":"<p>After maximizing group sizes, use as few groups as possible. Each group becomes one product term, so fewer groups mean fewer terms in your SOP expression.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-k-map-grouping-rules-demonstrator","title":"Diagram: K-Map Grouping Rules Demonstrator","text":"K-Map Grouping Rules Interactive Demonstrator <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate understanding of all K-map grouping rules by identifying valid and invalid groups.</p> <p>Instructional Rationale: Presenting valid and invalid grouping examples side-by-side with rule explanations helps students internalize the constraints before attempting their own groupings.</p> <p>Canvas Layout:</p> <ul> <li>Left: Rule selector (list of 7 rules)</li> <li>Center: K-map showing example for selected rule</li> <li>Right: Valid vs. invalid comparison</li> <li>Bottom: Quiz mode toggle</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click through rules to see examples of each</li> <li>For each rule: valid grouping example vs. invalid violation</li> <li>\"What's wrong?\" quiz: show invalid grouping, student identifies the rule violated</li> <li>Animated highlighting of rule violations</li> <li>Random example generator for practice</li> </ul> <p>Data Visibility:</p> <ul> <li>Current rule name and description</li> <li>Example K-map with grouping</li> <li>Clear valid/invalid indicator</li> <li>Explanation of why invalid cases fail</li> </ul> <p>Visual Style:</p> <ul> <li>Valid groupings in green</li> <li>Invalid groupings in red with X overlay</li> <li>Rule text prominently displayed</li> <li>Animation showing wrap-around connections when relevant</li> </ul> <p>Implementation: p5.js with rule library and example database</p>"},{"location":"chapters/05-logic-minimization-kmaps/#adjacent-cells-understanding-adjacency","title":"Adjacent Cells: Understanding Adjacency","text":"<p>The concept of adjacent cells is fundamental to K-map operation. Two cells are adjacent if they differ in exactly one variable. This is why Gray code ordering is used\u2014it guarantees that physically adjacent cells on the map are logically adjacent.</p> <p>Let's trace through the adjacency for cell 5 (minterm \\(m_5 = \\overline{A}BCD\\)):</p> Cell Binary Adjacent to 5? Differs in... 4 0100 Yes D (0\u21921) 7 0111 Yes C (0\u21921) 1 0001 Yes B (1\u21920) 13 1101 Yes A (0\u21921) 6 0110 No C and D both differ <p>Cell 5 has exactly four adjacent cells: 4, 7, 1, and 13. Notice that 13 is not physically next to 5 on the map, but they're logically adjacent (wrap-around on the AB axis).</p> <p>Adjacency Test</p> <p>To check if two cells are adjacent, convert their minterm numbers to binary and count how many bits differ. If exactly one bit differs, they're adjacent. If more than one bit differs, they're not adjacent.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#why-adjacency-matters","title":"Why Adjacency Matters","text":"<p>When you group adjacent cells, you're exploiting the simplification:</p> \\[X \\cdot Y + X \\cdot \\overline{Y} = X\\] <p>Two adjacent cells differ by one variable, so that variable cancels out when they're grouped. Four adjacent cells (differing in two variables) cancel two variables. This is the mathematical magic behind K-map simplification.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#dont-care-conditions-free-optimization","title":"Don't Care Conditions: Free Optimization","text":"<p>In real designs, certain input combinations might never occur\u2014or if they do occur, we don't care what the output is. These are called don't care conditions, and they're optimization gold.</p> <p>Don't cares are marked with an \"X\" (or sometimes \"d\") in truth tables and K-maps. The key insight:</p> <p>You can treat don't cares as either 0 or 1, whichever gives you a better grouping.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#why-dont-cares-exist","title":"Why Don't Cares Exist","text":"<p>Don't cares arise in several situations:</p> <ol> <li> <p>Physically impossible inputs: In a BCD (Binary Coded Decimal) system, inputs 10-15 can never occur because BCD only uses 0-9.</p> </li> <li> <p>Illegal input states: A system might have constraints that make certain combinations impossible (e.g., \"A and B are never both 1\").</p> </li> <li> <p>Outputs we don't care about: Sometimes the output doesn't matter for certain inputs (e.g., we only care about the display during normal operation, not during reset).</p> </li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#using-dont-cares","title":"Using Don't Cares","text":"<p>When simplifying, treat each don't care as either 0 or 1, choosing whichever helps you:</p> <ul> <li>Make groups larger</li> <li>Make fewer groups</li> <li>Simplify the final expression</li> </ul> <p>You don't have to be consistent\u2014one X might be treated as 1 (included in a group) while another X is treated as 0 (left out).</p> <p>Don't Care Example</p> <p>Consider a function with: \\(F = \\sum m(1, 3, 7) + d(0, 5)\\)</p> <p>The 1s are at cells 1, 3, 7. The don't cares are at cells 0 and 5.</p> <p>Without don't cares, we might group {1, 3} and {3, 7}, getting: \\(\\overline{A}D + BC\\)</p> <p>With don't cares, we could include cell 5 with cells 1, 3, 7 (if positions allow) to make a larger group. The X at cell 0 might let us extend another group.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-dont-care-optimization","title":"Diagram: Don't Care Optimization","text":"Don't Care Condition Optimizer <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use don't care conditions to create larger K-map groups and achieve more minimal expressions.</p> <p>Instructional Rationale: Interactive comparison showing minimization with and without don't cares demonstrates the tangible benefit of treating don't cares strategically.</p> <p>Canvas Layout:</p> <ul> <li>Left: K-map with 1s, 0s, and Xs</li> <li>Right: Split view showing:</li> <li>Top: Minimal expression ignoring don't cares</li> <li>Bottom: Minimal expression using don't cares optimally</li> <li>Bottom: Literal count comparison</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click cells to cycle through 0, 1, X</li> <li>Automatic grouping shown for both approaches</li> <li>Highlight which Xs are treated as 1s in optimal solution</li> <li>Toggle: Show/hide how each X is being used</li> <li>Example problems demonstrating significant savings</li> </ul> <p>Data Visibility:</p> <ul> <li>Both expressions displayed</li> <li>Gate count for both solutions</li> <li>Literal count comparison</li> <li>Which don't cares are used vs. ignored</li> </ul> <p>Visual Style:</p> <ul> <li>X cells in distinct color (purple or gray)</li> <li>Groups that include X cells show X with green highlight</li> <li>X cells not used shown with gray highlight</li> <li>Comparison metrics as bar chart</li> </ul> <p>Implementation: p5.js with dual minimization engine</p>"},{"location":"chapters/05-logic-minimization-kmaps/#prime-implicants-the-building-blocks","title":"Prime Implicants: The Building Blocks","text":"<p>Now we get into the formal terminology that makes you sound like a real digital designer (and helps you pass exams).</p> <p>A prime implicant is a product term that:</p> <ol> <li>Covers (is true for) one or more minterms of the function</li> <li>Cannot be combined with another implicant to form a simpler term</li> </ol> <p>In K-map terms, a prime implicant is a group that cannot be made any larger. It's \"maxed out.\"</p> <p>Consider a group of 2 cells. If you could expand it to 4 cells (by including two more adjacent 1s or don't cares), then the 2-cell group is not a prime implicant\u2014it's not maximal. Only when a group cannot grow further is it a prime implicant.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#finding-prime-implicants","title":"Finding Prime Implicants","text":"<p>To find all prime implicants:</p> <ol> <li>Start with each 1 in the K-map</li> <li>For each 1, find the largest group containing it</li> <li>The collection of all such maximal groups gives you the prime implicants</li> </ol> <p>Some 1s might be covered by multiple different maximal groups, which is fine\u2014all of those groups are prime implicants.</p> <p>Prime vs. Implicant</p> <p>An implicant is any product term that implies the function (is true only when F=1). An implicant doesn't have to be maximal.</p> <p>A prime implicant is a maximal implicant\u2014one that can't be simplified further.</p> <p>Think of it like: all prime implicants are implicants, but not all implicants are prime.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#essential-prime-implicants-the-must-haves","title":"Essential Prime Implicants: The Must-Haves","text":"<p>Here's where optimization gets interesting. An essential prime implicant is a prime implicant that covers at least one minterm not covered by any other prime implicant.</p> <p>In other words, if a minterm can only be covered by one prime implicant, that prime implicant is essential\u2014you must include it in your final expression.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#finding-essential-prime-implicants","title":"Finding Essential Prime Implicants","text":"<p>The process:</p> <ol> <li>Identify all prime implicants</li> <li>For each minterm, list which prime implicants cover it</li> <li>If a minterm is covered by only one prime implicant, that prime implicant is essential</li> <li>All essential prime implicants must be in the final solution</li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#the-selection-process","title":"The Selection Process","text":"<p>After including all essential prime implicants, you may still have minterms that aren't covered. For these, you need to select additional prime implicants. The goal: cover all remaining minterms with the fewest additional prime implicants (preferably the largest ones).</p> <p>This is where the problem can get tricky\u2014sometimes there are multiple equally good solutions.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-prime-implicant-finder","title":"Diagram: Prime Implicant Finder","text":"Prime and Essential Prime Implicant Identifier <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Identify</p> <p>Learning Objective: Students will be able to identify all prime implicants and essential prime implicants in a K-map, distinguishing between required and optional implicants.</p> <p>Instructional Rationale: Visual identification of which minterms are covered by which prime implicants builds understanding of why certain implicants are essential while others are optional.</p> <p>Canvas Layout:</p> <ul> <li>Left: K-map with all 1s and don't cares marked</li> <li>Center: List of all prime implicants with their coverage</li> <li>Right: Essential prime implicant selection panel</li> <li>Bottom: Final minimal expression construction</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click cells to set up function</li> <li>\"Find All Prime Implicants\" button</li> <li>Prime implicants shown as colored groups</li> <li>Hover over minterm to see which PIs cover it</li> <li>Essential PIs highlighted automatically</li> <li>Step-through mode showing selection process</li> <li>\"Why essential?\" explanation on hover</li> </ul> <p>Data Visibility:</p> <ul> <li>All prime implicants listed with their terms</li> <li>Coverage matrix: which PIs cover which minterms</li> <li>Essential PIs marked with star</li> <li>Uncovered minterms highlighted</li> <li>Final selection with justification</li> </ul> <p>Visual Style:</p> <ul> <li>Prime implicants in distinct colors</li> <li>Essential PIs with bold outlines</li> <li>Minterms with single coverage highlighted</li> <li>Coverage lines from minterms to PIs</li> <li>Selection checkboxes for non-essential PIs</li> </ul> <p>Implementation: p5.js with prime implicant finding algorithm</p>"},{"location":"chapters/05-logic-minimization-kmaps/#implicant-cover-finding-the-complete-solution","title":"Implicant Cover: Finding the Complete Solution","text":"<p>An implicant cover is a set of prime implicants that, together, cover all minterms of the function. The goal is to find the minimum cover\u2014the smallest set of prime implicants that covers everything.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#the-covering-algorithm","title":"The Covering Algorithm","text":"<ol> <li>Start with essential prime implicants: These must be in every valid cover</li> <li>Remove covered minterms: Mark all minterms covered by essential PIs</li> <li>Cover remaining minterms: Select additional prime implicants to cover any uncovered minterms</li> <li>Minimize: If multiple choices exist, prefer larger PIs (fewer literals) and fewer PIs (fewer terms)</li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#when-multiple-covers-exist","title":"When Multiple Covers Exist","text":"<p>Sometimes there are multiple minimal covers with the same cost. For example, if you have two remaining minterms and two different PIs could each cover one, you might have choices:</p> <ul> <li>Cover minterm A with PI-1, minterm B with PI-2</li> <li>Or use a different combination</li> </ul> <p>Both might give the same number of literals. In such cases, any minimal cover is correct.</p> <p>Practical Hint</p> <p>When you have options, also consider:</p> <ul> <li>Gate fan-in limits (wider gates may not be available)</li> <li>Signal timing (some paths may be more critical)</li> <li>Physical layout (some groupings may route better)</li> </ul> <p>In practice, synthesis tools evaluate many factors beyond just literal count.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#minimal-sop-the-simplest-and-or-form","title":"Minimal SOP: The Simplest AND-OR Form","text":"<p>The minimal SOP (Sum of Products) is the SOP expression with the fewest literals. This is what all our K-map work has been building toward.</p> <p>To find the minimal SOP:</p> <ol> <li>Draw the K-map for the function</li> <li>Mark all 1s (and don't cares if available)</li> <li>Find all prime implicants</li> <li>Identify essential prime implicants</li> <li>Select a minimum cover</li> <li>Write the SOP expression from the selected implicants</li> </ol> <p>Each selected prime implicant becomes one product term. The OR of all these terms is your minimal SOP.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#reading-terms-from-the-k-map","title":"Reading Terms from the K-Map","text":"<p>Remember from Chapter 4: for each group, identify which variables are constant:</p> <ul> <li>Variable always 1 in group \u2192 include as-is</li> <li>Variable always 0 in group \u2192 include complemented</li> <li>Variable varies within group \u2192 omit (it's been simplified out)</li> </ul> <p>Minimal SOP Example</p> <p>For \\(F(A,B,C,D) = \\sum m(0, 2, 5, 7, 8, 10, 13, 15)\\):</p> <p>The K-map reveals groups:</p> <ul> <li>Cells 0, 2, 8, 10 form a 4-cell group: \\(\\overline{B}\\overline{D}\\)</li> <li>Cells 5, 7, 13, 15 form a 4-cell group: \\(BD\\)</li> </ul> <p>Both are essential (each covers cells not covered by the other).</p> <p>Minimal SOP: \\(F = \\overline{B}\\overline{D} + BD\\)</p> <p>This is beautifully symmetric\u2014and much simpler than the 8-term canonical form!</p>"},{"location":"chapters/05-logic-minimization-kmaps/#minimal-pos-the-simplest-or-and-form","title":"Minimal POS: The Simplest OR-AND Form","text":"<p>The minimal POS (Product of Sums) is the dual approach\u2014an AND of OR terms with the fewest literals.</p> <p>To find the minimal POS using K-maps:</p> <ol> <li>Draw the K-map</li> <li>Mark all the 0s (instead of 1s)</li> <li>Group the 0s using the same rules</li> <li>Each group of 0s becomes a sum term (maxterm-style)</li> <li>AND the sum terms together</li> </ol> <p>Alternatively, you can find the minimal SOP for \\(\\overline{F}\\) (the complement), then apply De Morgan's theorem to convert to POS form for \\(F\\).</p>"},{"location":"chapters/05-logic-minimization-kmaps/#when-to-use-pos-vs-sop","title":"When to Use POS vs. SOP","text":"<p>Use the form that's simpler for your function:</p> <ul> <li>If the function has more 1s than 0s \u2192 POS might be simpler (fewer 0s to group)</li> <li>If the function has more 0s than 1s \u2192 SOP might be simpler (fewer 1s to group)</li> <li>If they're equal \u2192 compute both and compare</li> </ul> Function SOP Groups POS Groups Choose... F with 12 ones, 4 zeros Groups of 1s (12) Groups of 0s (4) POS likely simpler F with 4 ones, 12 zeros Groups of 1s (4) Groups of 0s (12) SOP likely simpler"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-sop-vs-pos-comparison","title":"Diagram: SOP vs POS Comparison","text":"Minimal SOP vs Minimal POS Comparison <p>Type: microsim</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare minimal SOP and minimal POS forms and evaluate which is more efficient for a given function.</p> <p>Instructional Rationale: Side-by-side visualization of both minimization approaches helps students understand when each form is preferable.</p> <p>Canvas Layout:</p> <ul> <li>Center: Shared K-map showing the function</li> <li>Left panel: SOP minimization (grouping 1s)</li> <li>Right panel: POS minimization (grouping 0s)</li> <li>Bottom: Comparison metrics</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle cells to define function</li> <li>Automatic grouping for both SOP and POS</li> <li>Highlight which form is more efficient</li> <li>Show gate-level implementation for both</li> <li>Switch between \"Show 1s\" and \"Show 0s\" views</li> </ul> <p>Data Visibility:</p> <ul> <li>Both expressions displayed</li> <li>Literal count for each</li> <li>Gate count for each</li> <li>Winner indicator</li> <li>Implementation cost comparison</li> </ul> <p>Visual Style:</p> <ul> <li>SOP groups in warm colors (orange, red)</li> <li>POS groups in cool colors (blue, green)</li> <li>More efficient form highlighted with gold border</li> <li>Gate diagrams sized proportionally to complexity</li> </ul> <p>Implementation: p5.js with dual minimization and comparison engine</p>"},{"location":"chapters/05-logic-minimization-kmaps/#the-quine-mccluskey-method-when-maps-arent-enough","title":"The Quine-McCluskey Method: When Maps Aren't Enough","text":"<p>K-maps work great for 4 variables. With 5 variables, you can use a stacked pair of 4-variable maps. With 6 variables, you need four stacked maps. Beyond that? It gets unwieldy.</p> <p>Enter the Quine-McCluskey method (also called the tabular method)\u2014an algorithmic approach to logic minimization that works for any number of variables. It's systematic, deterministic, and can be programmed into a computer.</p> <p>The Quine-McCluskey method was developed in the 1950s by Willard Van Orman Quine and extended by Edward McCluskey. It's essentially doing what K-maps do, but using tables instead of visual patterns.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#the-basic-algorithm","title":"The Basic Algorithm","text":"<p>Step 1: List all minterms in binary</p> <p>Group minterms by the number of 1s in their binary representation.</p> <p>Step 2: Compare and combine</p> <p>Compare minterms that differ by exactly one bit. When two minterms combine:</p> <ul> <li>Replace the differing bit with a dash (\u2013)</li> <li>Mark both original minterms as \"used\"</li> </ul> <p>Step 3: Repeat</p> <p>Continue combining terms with dashes. Two terms can combine if they have dashes in the same positions and differ in exactly one other bit.</p> <p>Step 4: Identify prime implicants</p> <p>Terms that cannot be combined further are prime implicants.</p> <p>Step 5: Build the coverage table</p> <p>Create a table showing which prime implicants cover which minterms.</p> <p>Step 6: Select minimum cover</p> <p>Find essential prime implicants, then select additional PIs to cover remaining minterms.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#example-walkthrough","title":"Example Walkthrough","text":"<p>For \\(F = \\sum m(0, 1, 2, 5, 6, 7)\\) with 3 variables:</p> <p>Step 1: Group by number of 1s:</p> Group 0 (zero 1s) Group 1 (one 1) Group 2 (two 1s) Group 3 (three 1s) 0: 000 1: 001, 2: 010 5: 101, 6: 110 7: 111 <p>Step 2: Combine adjacent groups:</p> <ul> <li>0,1: 00\u2013 (differ in bit 0)</li> <li>0,2: 0\u20130 (differ in bit 1)</li> <li>1,5: \u201301 (differ in bit 2)</li> <li>2,6: \u201310 (differ in bit 2)</li> <li>5,7: 1\u20131 (differ in bit 1)</li> <li>6,7: 11\u2013 (differ in bit 0)</li> </ul> <p>Step 3: Combine again:</p> <ul> <li>0,1,2,?: Cannot extend 00\u2013 or 0\u20130 further with remaining terms</li> <li>Looking for patterns...</li> </ul> <p>Step 4: Prime implicants are the terms that can't combine further.</p> <p>This systematic process guarantees finding all prime implicants, which is why it's used in computer-aided design tools.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-quine-mccluskey-visualizer","title":"Diagram: Quine-McCluskey Visualizer","text":"Quine-McCluskey Method Step-by-Step <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute the Quine-McCluskey algorithm step by step to find prime implicants and minimal cover.</p> <p>Instructional Rationale: Step-by-step visualization demystifies the tabular method and shows how it parallels K-map grouping conceptually.</p> <p>Canvas Layout:</p> <ul> <li>Top: Minterm input (enter list or select from K-map)</li> <li>Center: Tabular display showing groups and combinations</li> <li>Left: Current step indicator</li> <li>Right: Prime implicant list (builds as algorithm progresses)</li> <li>Bottom: Coverage table and minimum cover selection</li> </ul> <p>Interactive Elements:</p> <ul> <li>Enter minterms as comma-separated list</li> <li>\"Next Step\" button advances algorithm</li> <li>\"Auto Run\" to see full execution</li> <li>Highlight active comparisons during combination step</li> <li>Click to see why two terms can/cannot combine</li> <li>Interactive coverage table for minimum cover selection</li> </ul> <p>Data Visibility:</p> <ul> <li>All minterms grouped by 1s count</li> <li>Combination history with checkmarks for used terms</li> <li>Dash notation clearly shown</li> <li>Prime implicants accumulated</li> <li>Coverage matrix</li> <li>Final minimal expression</li> </ul> <p>Visual Style:</p> <ul> <li>Table-based layout matching textbook presentation</li> <li>Color coding: combined terms in green, prime implicants in blue</li> <li>Arrows showing which terms combined</li> <li>Coverage table with X marks</li> <li>Essential PIs highlighted</li> </ul> <p>Implementation: p5.js with Quine-McCluskey algorithm engine</p>"},{"location":"chapters/05-logic-minimization-kmaps/#hazards-when-logic-lies-briefly","title":"Hazards: When Logic Lies (Briefly)","text":"<p>Everything we've discussed assumes ideal gates that switch instantly. In reality, gates have propagation delay. This can cause temporary incorrect outputs called hazards.</p> <p>A hazard is a momentary wrong output that occurs when inputs change, even though the steady-state output should remain unchanged.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#why-hazards-occur","title":"Why Hazards Occur","text":"<p>Consider the function \\(F = A\\overline{B} + AB\\), which simplifies to \\(F = A\\). When B changes from 0 to 1 (with A=1):</p> <ul> <li>Before: \\(A\\overline{B} = 1 \\cdot 1 = 1\\), \\(AB = 1 \\cdot 0 = 0\\), so \\(F = 1\\)</li> <li>After: \\(A\\overline{B} = 1 \\cdot 0 = 0\\), \\(AB = 1 \\cdot 1 = 1\\), so \\(F = 1\\)</li> </ul> <p>The output should stay at 1. But here's the problem:</p> <p>Due to gate delays, the \\(\\overline{B}\\) signal might propagate faster than the B signal through the different paths. There could be a tiny moment when:</p> <ul> <li>\\(A\\overline{B}\\) has already become 0 (the inverter is fast)</li> <li>\\(AB\\) hasn't yet become 1 (the AND gate is still switching)</li> <li>Result: F momentarily becomes 0!</li> </ul> <p>This \"glitch\" is a hazard.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#static-hazards-the-1-0-1-and-0-1-0-glitches","title":"Static Hazards: The 1-0-1 and 0-1-0 Glitches","text":"<p>A static hazard occurs when an output that should remain constant briefly flips to the opposite value.</p> <ul> <li>Static-1 hazard: Output should stay 1, but momentarily goes to 0</li> <li>Static-0 hazard: Output should stay 0, but momentarily goes to 1</li> </ul> <p>Static hazards occur in SOP circuits when two adjacent minterms are covered by different product terms (with no overlap). The gap between the groups in the K-map is where the hazard lurks.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#detecting-static-hazards","title":"Detecting Static Hazards","text":"<p>In a K-map, a static-1 hazard exists if:</p> <ol> <li>Two adjacent 1-cells are in different groups</li> <li>No group covers both cells</li> </ol> <p>The hazard occurs when the input changes from one cell to the adjacent cell.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#example-of-static-1-hazard","title":"Example of Static-1 Hazard","text":"<p>For \\(F = \\overline{A}C + AB\\):</p> <p>On a K-map, cells \\(m_3\\) (\\(\\overline{A}BC\\)) and \\(m_7\\) (\\(ABC\\)) are adjacent. If:</p> <ul> <li>\\(m_3\\) is covered by \\(\\overline{A}C\\)</li> <li>\\(m_7\\) is covered by \\(AB\\)</li> </ul> <p>Then changing from \\(\\overline{A}BC\\) (cell 3) to \\(ABC\\) (cell 7)\u2014i.e., A going from 0 to 1\u2014can cause a glitch.</p> <p>When A changes from 0 to 1 (with B=1, C=1):</p> <ul> <li>\\(\\overline{A}C\\) goes from 1 to 0</li> <li>\\(AB\\) goes from 0 to 1</li> <li>If \\(\\overline{A}C\\) falls before \\(AB\\) rises: F glitches to 0!</li> </ul>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-static-hazard-visualizer","title":"Diagram: Static Hazard Visualizer","text":"Static Hazard Detection and Visualization <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine a K-map grouping to identify where static hazards can occur and understand the timing conditions that cause them.</p> <p>Instructional Rationale: Animated timing diagrams showing the glitch as it would appear on an oscilloscope connects the abstract K-map concept to real circuit behavior.</p> <p>Canvas Layout:</p> <ul> <li>Top left: K-map with current grouping</li> <li>Top right: Gate-level circuit diagram</li> <li>Bottom: Timing diagram showing input transitions and output response</li> <li>Side: Hazard indicator and explanation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle cells to define function</li> <li>Draw groups (deliberately creating or avoiding hazards)</li> <li>\"Find Hazards\" button highlights hazard-prone transitions</li> <li>Click on hazard location to see timing animation</li> <li>Adjustable gate delay to show how timing affects glitch width</li> <li>Play/pause timing simulation</li> </ul> <p>Data Visibility:</p> <ul> <li>K-map with groups highlighted</li> <li>Adjacent cells in different groups marked as hazard points</li> <li>Timing diagram with glitch visible</li> <li>Gate delays labeled on circuit</li> <li>Explanation of which transition causes hazard</li> </ul> <p>Visual Style:</p> <ul> <li>Hazard points shown with warning icon</li> <li>Timing diagram with classic oscilloscope look</li> <li>Glitch shown as brief dip (for static-1) or spike (for static-0)</li> <li>Circuit paths color-coded to show timing differences</li> </ul> <p>Implementation: p5.js with timing simulation engine</p>"},{"location":"chapters/05-logic-minimization-kmaps/#dynamic-hazards-multiple-glitches","title":"Dynamic Hazards: Multiple Glitches","text":"<p>A dynamic hazard occurs when an output that should change once (0\u21921 or 1\u21920) instead oscillates multiple times before settling.</p> <p>For example, instead of a clean 0\u21921 transition, you might see: 0\u21921\u21920\u21921</p> <p>Dynamic hazards are more complex than static hazards and occur in multi-level circuits where signals can arrive at different times via multiple paths.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#when-dynamic-hazards-occur","title":"When Dynamic Hazards Occur","text":"<p>Dynamic hazards require:</p> <ol> <li>A multi-level circuit (more than two levels of logic)</li> <li>Multiple paths from an input to the output</li> <li>Paths with different delays</li> </ol> <p>They're less common than static hazards but can occur in complex circuits, especially those with XOR gates or complementary paths.</p> <p>Dynamic Hazards Are Tricky</p> <p>Dynamic hazards can be hard to predict and debug. If you see oscillating outputs during transitions, suspect a dynamic hazard. The solution often involves redesigning the circuit to reduce path differences or adding synchronization.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#hazard-free-design-eliminating-the-glitches","title":"Hazard-Free Design: Eliminating the Glitches","text":"<p>So how do we prevent hazards? The key insight is in the K-map.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#eliminating-static-1-hazards","title":"Eliminating Static-1 Hazards","text":"<p>To make a circuit free of static-1 hazards:</p> <ol> <li>Find all pairs of adjacent 1-cells that are in different groups</li> <li>Add redundant groups to cover these \"gap\" transitions</li> <li>Include these redundant terms in the final expression</li> </ol> <p>Yes, this means the expression won't be minimal\u2014but it will be glitch-free.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#the-redundant-term","title":"The Redundant Term","text":"<p>In the earlier example with \\(F = \\overline{A}C + AB\\), the hazard occurred between cells 3 and 7. To fix it:</p> <ol> <li>Add a group covering both cells 3 and 7: this is \\(BC\\)</li> <li>New expression: \\(F = \\overline{A}C + AB + BC\\)</li> </ol> <p>The term \\(BC\\) is logically redundant (it doesn't add any new minterms), but it bridges the timing gap:</p> <ul> <li>When A changes, \\(BC\\) stays 1 throughout the transition</li> <li>No glitch occurs because \\(BC\\) \"holds\" the output high</li> </ul> <p>This is called a consensus term or redundant cover.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#eliminating-static-0-hazards","title":"Eliminating Static-0 Hazards","text":"<p>For POS circuits, static-0 hazards can occur. The solution is similar:</p> <ol> <li>Find adjacent 0-cells in different groups</li> <li>Add redundant sum terms to cover the gaps</li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#when-hazards-matter","title":"When Hazards Matter","text":"<p>Not all circuits need hazard-free design:</p> <ul> <li>Clocked synchronous circuits: The clock samples outputs after they've settled. Glitches between clock edges don't matter.</li> <li>Asynchronous circuits: Glitches can cause serious problems\u2014hazard-free design is essential.</li> <li>Level-sensitive latches: Glitches during enable can cause wrong values to be stored.</li> </ul>"},{"location":"chapters/05-logic-minimization-kmaps/#diagram-hazard-free-design-tool","title":"Diagram: Hazard-Free Design Tool","text":"Hazard-Free Design Interactive Tool <p>Type: microsim</p> <p>Bloom Level: Create (L6) Bloom Verb: Design</p> <p>Learning Objective: Students will be able to design hazard-free circuits by identifying and adding redundant terms to eliminate static hazards.</p> <p>Instructional Rationale: Interactive before/after comparison with timing simulation shows how redundant terms eliminate glitches, even though they increase gate count.</p> <p>Canvas Layout:</p> <ul> <li>Left: K-map with grouping controls</li> <li>Top right: Minimal (potentially hazardous) circuit</li> <li>Bottom right: Hazard-free circuit with redundant terms</li> <li>Bottom: Timing comparison of both circuits</li> </ul> <p>Interactive Elements:</p> <ul> <li>Set up function by clicking cells</li> <li>Initial grouping shows minimal solution</li> <li>\"Find Hazards\" marks gap transitions</li> <li>\"Add Redundant Terms\" automatically adds consensus groups</li> <li>Compare timing diagrams for both versions</li> <li>Toggle between minimal and hazard-free views</li> </ul> <p>Data Visibility:</p> <ul> <li>Minimal expression and gate count</li> <li>Hazard-free expression and gate count</li> <li>Overhead cost (extra terms/gates)</li> <li>Hazardous transitions highlighted on K-map</li> <li>Timing diagrams showing glitch vs. clean transition</li> </ul> <p>Visual Style:</p> <ul> <li>Redundant groups shown in dotted outline</li> <li>Original groups in solid outline</li> <li>Timing diagram: hazardous version with visible glitch</li> <li>Hazard-free version with clean transition</li> <li>Cost comparison as bar chart</li> </ul> <p>Implementation: p5.js with hazard detection and redundant term generation</p>"},{"location":"chapters/05-logic-minimization-kmaps/#putting-it-all-together-the-complete-optimization-workflow","title":"Putting It All Together: The Complete Optimization Workflow","text":"<p>Let's consolidate everything into a comprehensive optimization workflow:</p> <ol> <li>Specify the function (truth table, minterms, or Boolean expression)</li> <li>Draw the K-map (4 variables = 4\u00d74 grid)</li> <li>Mark 1s, 0s, and don't cares</li> <li>Find all prime implicants (maximal groups)</li> <li>Identify essential prime implicants (cover unique minterms)</li> <li>Select minimum cover (essential PIs + minimum additional PIs)</li> <li>Check for hazards (adjacent cells in different groups)</li> <li>Add redundant terms if needed (for hazard-free design)</li> <li>Write the final expression (SOP or POS)</li> <li>Verify (check against truth table)</li> </ol> <p>For larger functions (5+ variables), use the Quine-McCluskey method or let CAD tools handle it.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you practice advanced optimization, watch out for these pitfalls:</p> <ol> <li> <p>Forgetting wrap-around in 4-variable maps: All four edges connect. The corners are all mutually adjacent. Don't miss groups that span the edges!</p> </li> <li> <p>Not using don't cares: If you have don't cares, USE them. They're free optimization.</p> </li> <li> <p>Confusing prime implicants with essential prime implicants: All essentials are prime, but not all primes are essential. Essentials cover unique minterms.</p> </li> <li> <p>Stopping at the first valid cover: There might be multiple minimum covers. Compare them before choosing.</p> </li> <li> <p>Ignoring hazards in asynchronous designs: For clocked circuits, minimal is fine. For async circuits, add redundant terms.</p> </li> <li> <p>Wrong Gray code order: Rows are 00, 01, 11, 10. Columns are 00, 01, 11, 10. Not 00, 01, 10, 11!</p> </li> <li> <p>Making non-rectangular groups: Groups must be rectangles. No L-shapes, no diagonals, no creative geometry.</p> </li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've mastered the advanced art of logic minimization. Here's what you've learned:</p> <p>K-Map Mastery:</p> <ul> <li>4-variable K-maps have 16 cells in a 4\u00d74 grid with Gray code ordering</li> <li>Wrap-around applies in all directions\u2014edges and corners connect</li> <li>Grouping rules: powers of 2, rectangular, maximal size, minimum number</li> </ul> <p>Formal Terminology:</p> <ul> <li>Prime implicant: A maximal group that can't be expanded</li> <li>Essential prime implicant: A PI that covers a minterm no other PI covers</li> <li>Implicant cover: Set of PIs that cover all minterms</li> </ul> <p>Optimization Techniques:</p> <ul> <li>Don't care conditions are free optimization\u2014use them strategically</li> <li>Minimal SOP: Group 1s for the simplest AND-OR expression</li> <li>Minimal POS: Group 0s for the simplest OR-AND expression</li> <li>Quine-McCluskey: Algorithmic method for 5+ variable functions</li> </ul> <p>Hazard-Free Design:</p> <ul> <li>Static hazards: Momentary glitches when output should stay constant</li> <li>Dynamic hazards: Multiple transitions when only one should occur</li> <li>Fix hazards by adding redundant terms to cover gap transitions</li> </ul> <p>Key Insight</p> <p>Logic minimization is about finding the sweet spot between simplicity and correctness. The minimal expression uses the fewest gates, but sometimes you need redundant logic for reliable operation. Understanding both goals\u2014and when each applies\u2014makes you a complete digital designer.</p> Graphic Novel Suggestion <p>A graphic novel could follow the parallel stories of Willard Van Orman Quine (a philosopher at Harvard) and Edward McCluskey (an engineer at Bell Labs) as they independently work toward systematic logic minimization in the 1950s. The visual narrative could contrast Quine's abstract philosophical approach with McCluskey's practical engineering focus, showing how their collaboration created an algorithm that still powers modern CAD tools. Dramatic tension could come from the race to publish and the challenge of convincing the engineering community that a philosopher's method had practical value.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#practice-problems","title":"Practice Problems","text":"<p>Test your mastery with these challenges:</p> Problem 1: 4-Variable K-Map <p>Minimize \\(F(A,B,C,D) = \\sum m(0, 2, 4, 5, 6, 7, 8, 10, 13, 15)\\) using a 4-variable K-map.</p> <p>Solution:</p> <p>Drawing the K-map and grouping:</p> <ul> <li>Cells 0, 2, 4, 6 form a 4-cell group (column with C=0, D=0): \\(\\overline{D}\\overline{B}\\) wait, let me recalculate...</li> <li>Cells 0, 2, 8, 10 (wrap-around corners, D=0): \\(\\overline{C}\\overline{D}\\)</li> <li>Cells 4, 5, 6, 7 (row AB=01): \\(\\overline{A}B\\)</li> <li>Cells 5, 7, 13, 15 (column CD=01 and CD=11 with B=1): \\(BD\\)</li> </ul> <p>Minimal SOP: \\(F = \\overline{C}\\overline{D} + \\overline{A}B + BD\\)</p> Problem 2: Using Don't Cares <p>Given \\(F = \\sum m(1, 3, 5, 7) + d(0, 2, 6)\\), find the minimal SOP.</p> <p>Solution:</p> <p>The 1s are at cells 1, 3, 5, 7 (these all have D=1 in a 3-variable map).</p> <p>With don't cares at 0, 2, 6:</p> <ul> <li>Include don't care 0 with cells 1, 3, 5, 7? No, cell 0 is not adjacent to all.</li> <li>Group 1, 3, 5, 7: These form a vertical stripe with D=1</li> </ul> <p>Actually, cells 1, 3, 5, 7 all have the last bit D=1. This is just \\(D\\)!</p> <p>Minimal SOP: \\(F = D\\)</p> Problem 3: Essential Prime Implicants <p>For \\(F = \\sum m(0, 4, 5, 7, 8, 9, 13, 15)\\), identify all prime implicants and which are essential.</p> <p>Solution:</p> <p>Drawing the 4-variable K-map:</p> <p>Prime implicants:</p> <ul> <li>\\(m_0, m_4\\): \\(\\overline{B}\\overline{C}\\overline{D}\\)</li> <li>\\(m_4, m_5\\): \\(\\overline{A}B\\overline{C}\\)</li> <li>\\(m_5, m_7, m_13, m_15\\): \\(BD\\)</li> <li>\\(m_8, m_9\\): \\(A\\overline{B}\\overline{C}\\)</li> </ul> <p>Essential analysis:</p> <ul> <li>\\(m_0\\) only covered by \\(\\overline{B}\\overline{C}\\overline{D}\\) \u2192 Essential</li> <li>\\(m_7\\) only covered by \\(BD\\) \u2192 Essential</li> <li>etc.</li> </ul> Problem 4: Hazard Detection <p>For \\(F = \\overline{A}B + AC\\), identify any static-1 hazards and add terms to eliminate them.</p> <p>Solution:</p> <p>The two groups (\\(\\overline{A}B\\) and \\(AC\\)) cover adjacent cells but have a gap where A changes while B=C=1.</p> <p>When A goes from 0 to 1 with B=1, C=1:</p> <ul> <li>\\(\\overline{A}B\\) goes from 1 to 0</li> <li>\\(AC\\) goes from 0 to 1</li> <li>Hazard possible!</li> </ul> <p>To fix: Add the consensus term \\(BC\\).</p> <p>Hazard-free expression: \\(F = \\overline{A}B + AC + BC\\)</p> Problem 5: Quine-McCluskey <p>Use the Quine-McCluskey method to find prime implicants for \\(F = \\sum m(0, 1, 2, 8, 10, 11)\\) with 4 variables.</p> <p>Solution:</p> <p>Group by 1s count:</p> <ul> <li>Group 0: 0 (0000)</li> <li>Group 1: 1 (0001), 2 (0010), 8 (1000)</li> <li>Group 2: 10 (1010)</li> <li>Group 3: 11 (1011)</li> </ul> <p>Combine adjacent groups:</p> <ul> <li>0,1: 000\u2013 (differ in D)</li> <li>0,2: 00\u20130 (differ in C)</li> <li>0,8: \u2013000 (differ in A)</li> <li>8,10: 10\u20130 (differ in C)</li> <li>10,11: 101\u2013 (differ in D)</li> </ul> <p>Combine again:</p> <ul> <li>0,2,8,10: \u20130\u20130 (combining 00\u20130 and 10\u20130)</li> </ul> <p>Prime implicants:</p> <ul> <li>\u20130\u20130: \\(\\overline{B}\\overline{D}\\)</li> <li>000\u2013: \\(\\overline{A}\\overline{B}\\overline{C}\\)</li> <li>101\u2013: \\(A\\overline{B}C\\)</li> </ul> <p>Coverage analysis would determine which are essential.</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/","title":"Quiz: Logic Minimization and K-Maps","text":"<p>Test your understanding of Karnaugh maps, logic simplification, and optimization techniques with these questions.</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#1-what-is-the-primary-purpose-of-a-karnaugh-map","title":"1. What is the primary purpose of a Karnaugh map?","text":"<ol> <li>To implement circuits on breadboards</li> <li>To visually simplify Boolean expressions</li> <li>To generate Verilog code automatically</li> <li>To measure propagation delay</li> </ol> Show Answer <p>The correct answer is B. A Karnaugh map (K-map) is a graphical method for simplifying Boolean expressions. It arranges truth table values in a grid where adjacent cells differ by one variable, making it easy to identify and group terms for simplification.</p> <p>Concept Tested: Karnaugh Map</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#2-in-a-k-map-what-property-must-adjacent-cells-have","title":"2. In a K-map, what property must adjacent cells have?","text":"<ol> <li>They must both contain 1s</li> <li>They must differ by exactly one variable</li> <li>They must be in the same row</li> <li>They must have the same output value</li> </ol> Show Answer <p>The correct answer is B. Adjacent cells in a K-map differ by exactly one variable (one bit of the input). This adjacency property is what allows grouping\u2014when you group adjacent 1s, the variable that changes is eliminated from the resulting term.</p> <p>Concept Tested: Adjacent Cells</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#3-how-many-cells-does-a-4-variable-k-map-contain","title":"3. How many cells does a 4-variable K-map contain?","text":"<ol> <li>4</li> <li>8</li> <li>16</li> <li>32</li> </ol> Show Answer <p>The correct answer is C. A K-map has one cell for each possible input combination. With 4 variables, there are 2\u2074 = 16 combinations, so the K-map has 16 cells arranged in a 4\u00d74 grid.</p> <p>Concept Tested: K-Map 4 Variable</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#4-what-is-a-dont-care-condition-in-a-k-map","title":"4. What is a \"don't care\" condition in a K-map?","text":"<ol> <li>An error in the truth table</li> <li>An input combination that cannot occur or whose output doesn't matter</li> <li>A cell that must always be 0</li> <li>A grouping that cannot be simplified</li> </ol> Show Answer <p>The correct answer is B. Don't care conditions (marked X or d) represent input combinations where the output is unspecified\u2014either because those inputs never occur or because the output value doesn't affect system behavior. They can be treated as 0 or 1 to help form larger groups.</p> <p>Concept Tested: Don't Care Condition</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#5-what-is-a-prime-implicant","title":"5. What is a prime implicant?","text":"<ol> <li>The smallest possible group in a K-map</li> <li>A group that cannot be combined with any other group to form a larger group</li> <li>A group that contains only 1s</li> <li>The first group identified in a K-map</li> </ol> Show Answer <p>The correct answer is B. A prime implicant is a product term (group of 1s) that cannot be combined with another term to eliminate a variable\u2014it's maximal. You cannot make it larger while still covering only 1s.</p> <p>Concept Tested: Prime Implicant</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#6-what-makes-a-prime-implicant-essential","title":"6. What makes a prime implicant \"essential\"?","text":"<ol> <li>It covers the most minterms</li> <li>It is required to complete the design</li> <li>It covers at least one minterm not covered by any other prime implicant</li> <li>It uses the fewest variables</li> </ol> Show Answer <p>The correct answer is C. An essential prime implicant covers at least one minterm that no other prime implicant covers. It must be included in any minimal solution because there's no alternative way to cover that minterm.</p> <p>Concept Tested: Essential Prime Implicant</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#7-what-is-the-valid-group-size-in-a-k-map","title":"7. What is the valid group size in a K-map?","text":"<ol> <li>Any number of cells</li> <li>Only 1, 2, 4, 8, or 16 (powers of 2)</li> <li>Only even numbers</li> <li>Only odd numbers</li> </ol> Show Answer <p>The correct answer is B. K-map groups must contain 2\u207f cells (1, 2, 4, 8, 16, etc.) and must be rectangular. This constraint ensures that each grouping eliminates exactly n variables from the product term.</p> <p>Concept Tested: K-Map Grouping Rules</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#8-what-is-a-static-hazard-in-a-combinational-circuit","title":"8. What is a static hazard in a combinational circuit?","text":"<ol> <li>A circuit that never changes output</li> <li>A momentary glitch when the output should remain constant</li> <li>A permanent manufacturing defect</li> <li>A circuit with no inputs</li> </ol> Show Answer <p>The correct answer is B. A static hazard occurs when an output that should remain constant (either 0 or 1) momentarily glitches to the opposite value during an input transition. This happens due to unequal propagation delays through different circuit paths.</p> <p>Concept Tested: Static Hazard</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#9-in-k-map-minimization-can-groups-wrap-around-edges","title":"9. In K-map minimization, can groups wrap around edges?","text":"<ol> <li>No, groups must be contained within the grid</li> <li>Yes, because edge cells are logically adjacent</li> <li>Only in 4-variable K-maps</li> <li>Only for don't care conditions</li> </ol> Show Answer <p>The correct answer is B. K-map edges wrap around because cells on opposite edges differ by only one variable. The top row is adjacent to the bottom row, and the leftmost column is adjacent to the rightmost column. Corner cells can even form a group of 4.</p> <p>Concept Tested: K-Map Grouping Rules</p>"},{"location":"chapters/05-logic-minimization-kmaps/quiz/#10-what-is-the-advantage-of-the-quine-mccluskey-method-over-k-maps","title":"10. What is the advantage of the Quine-McCluskey method over K-maps?","text":"<ol> <li>It produces better results</li> <li>It is faster for 2-variable functions</li> <li>It can handle functions with more than 4-6 variables</li> <li>It requires no computation</li> </ol> Show Answer <p>The correct answer is C. While K-maps become impractical beyond 5-6 variables, the Quine-McCluskey algorithm is a tabular, systematic method that works for any number of variables. It's also easier to automate in software.</p> <p>Concept Tested: Quine-McCluskey Method</p>"},{"location":"chapters/06-combinational-building-blocks/","title":"Combinational Building Blocks","text":""},{"location":"chapters/06-combinational-building-blocks/#summary","title":"Summary","text":"<p>This chapter introduces the standard combinational circuit modules that serve as building blocks for larger digital systems. Students will design and analyze multiplexers, demultiplexers, encoders, decoders, priority encoders, binary and magnitude comparators, half and full adders, ripple-carry adders, and understand ALU concepts. Additional topics include parity generation and checking for error detection, tri-state buffers, and bus architecture. These modular components are fundamental to constructing complex digital systems efficiently.</p>"},{"location":"chapters/06-combinational-building-blocks/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 35 concepts from the learning graph:</p> <ol> <li>Multiplexer</li> <li>MUX 2-to-1</li> <li>MUX 4-to-1</li> <li>MUX 8-to-1</li> <li>MUX Tree</li> <li>MUX as Logic Function</li> <li>Demultiplexer</li> <li>DEMUX 1-to-4</li> <li>Encoder</li> <li>Decoder</li> <li>2-to-4 Decoder</li> <li>3-to-8 Decoder</li> <li>Decoder Enable</li> <li>Priority Encoder</li> <li>7-Segment Display</li> <li>7-Segment Decoder</li> <li>Binary Comparator</li> <li>Magnitude Comparator</li> <li>Equality Comparator</li> <li>Half Adder</li> <li>Full Adder</li> <li>Carry Bit</li> <li>Sum Bit</li> <li>Ripple Carry Adder</li> <li>Carry Propagation Delay</li> <li>Carry Lookahead Concept</li> <li>Adder Subtractor</li> <li>Overflow in Addition</li> <li>ALU Concept</li> <li>Parity Bit</li> <li>Parity Generator</li> <li>Parity Checker</li> <li>Error Detection</li> <li>Tri-State Buffer</li> <li>Bus Architecture</li> </ol>"},{"location":"chapters/06-combinational-building-blocks/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul>"},{"location":"chapters/06-combinational-building-blocks/#introduction-your-digital-toolbox","title":"Introduction: Your Digital Toolbox","text":"<p>Imagine you're building a house. You could start from scratch\u2014mix your own concrete, forge your own nails, fell your own trees. But that would take forever and probably result in a wonky house. Smart builders use prefabricated components: standard-sized lumber, pre-made windows, factory-built doors.</p> <p>Digital design works the same way.</p> <p>In the previous chapters, you learned how to design circuits from scratch\u2014write truth tables, simplify with K-maps, draw gate-level implementations. That's essential knowledge, like knowing how concrete cures. But now it's time to meet the prefabricated components of digital electronics: combinational building blocks.</p> <p>These are standard, proven modules that you can grab \"off the shelf\" (or from a component library) and snap together like LEGO bricks. Need to select one of eight inputs? There's a block for that (multiplexer). Need to route a signal to one of four destinations? Block for that too (demultiplexer). Need to add two binary numbers? You guessed it\u2014there's a block.</p> <p>By the end of this chapter, you'll have a complete toolbox of digital building blocks. More importantly, you'll understand how each block works internally, so you can modify them when needed or design new ones yourself. You'll transform from someone who builds circuits gate-by-gate into someone who architects systems from proven modules.</p> <p>Let's stock that toolbox!</p>"},{"location":"chapters/06-combinational-building-blocks/#multiplexers-the-data-selectors","title":"Multiplexers: The Data Selectors","text":"<p>A multiplexer (or MUX for short) is one of the most versatile building blocks in digital design. Think of it as a digital selector switch\u2014it chooses one of several inputs and routes it to a single output.</p> <p>Here's the key insight: a multiplexer is essentially a \"many-to-one\" switch controlled by binary select lines.</p> <ul> <li>Data inputs: Multiple signals competing to reach the output</li> <li>Select inputs: Binary code that chooses which data input wins</li> <li>Output: The selected input signal</li> </ul> <p>The select lines work like an address. If you have 4 data inputs, you need 2 select lines (because \\(2^2 = 4\\)). If you have 8 data inputs, you need 3 select lines (\\(2^3 = 8\\)).</p> Inputs Select Lines Common Name 2 1 2-to-1 MUX 4 2 4-to-1 MUX 8 3 8-to-1 MUX 16 4 16-to-1 MUX"},{"location":"chapters/06-combinational-building-blocks/#mux-2-to-1-the-simplest-selector","title":"MUX 2-to-1: The Simplest Selector","text":"<p>The 2-to-1 multiplexer is the fundamental building block. It has:</p> <ul> <li>Two data inputs: \\(D_0\\) and \\(D_1\\)</li> <li>One select input: \\(S\\)</li> <li>One output: \\(Y\\)</li> </ul> <p>The behavior is simple:</p> <ul> <li>When \\(S = 0\\), the output \\(Y = D_0\\)</li> <li>When \\(S = 1\\), the output \\(Y = D_1\\)</li> </ul> <p>The Boolean equation is:</p> \\[Y = \\overline{S} \\cdot D_0 + S \\cdot D_1\\] <p>Reading this equation: \"Output equals NOT-S AND D0, OR S AND D1.\" When S is 0, the first term passes D0. When S is 1, the second term passes D1.</p> <p>Here's the truth table:</p> S D\u2080 D\u2081 Y 0 0 X 0 0 1 X 1 1 X 0 0 1 X 1 1 <p>Notice the pattern: when S=0, Y copies D\u2080 regardless of D\u2081. When S=1, Y copies D\u2081 regardless of D\u2080.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-2-to-1-mux-interactive","title":"Diagram: 2-to-1 MUX Interactive","text":"2-to-1 Multiplexer Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how a 2-to-1 multiplexer selects between two inputs based on the select signal.</p> <p>Instructional Rationale: Interactive toggle of select and data inputs with immediate visual feedback on output helps students internalize the selection mechanism.</p> <p>Canvas Layout:</p> <ul> <li>Left: Input controls (toggle buttons for S, D0, D1)</li> <li>Center: MUX symbol (trapezoid shape with labels)</li> <li>Right: Output display with Y value</li> <li>Bottom: Boolean equation with current values substituted</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for S (select), D0, and D1</li> <li>MUX symbol shows signal flow with highlighted paths</li> <li>Active input path highlighted in green</li> <li>Inactive input path grayed out</li> <li>Output indicator (LED-style)</li> <li>Equation display shows current evaluation</li> </ul> <p>Data Visibility:</p> <ul> <li>All input values clearly labeled</li> <li>Selected path visually emphasized</li> <li>Output value prominent</li> <li>Equation with color-coded substitutions</li> </ul> <p>Visual Style:</p> <ul> <li>Standard MUX trapezoid symbol</li> <li>Signal flow arrows</li> <li>Active path in green, inactive in gray</li> <li>Clean, uncluttered layout</li> </ul> <p>Implementation: p5.js with toggle state management and path highlighting</p>"},{"location":"chapters/06-combinational-building-blocks/#mux-4-to-1-four-choices-two-bits","title":"MUX 4-to-1: Four Choices, Two Bits","text":"<p>The 4-to-1 multiplexer selects one of four inputs using a 2-bit select code:</p> <ul> <li>Four data inputs: \\(D_0, D_1, D_2, D_3\\)</li> <li>Two select inputs: \\(S_1, S_0\\)</li> <li>One output: \\(Y\\)</li> </ul> <p>The select code determines which input reaches the output:</p> S\u2081 S\u2080 Output Y 0 0 D\u2080 0 1 D\u2081 1 0 D\u2082 1 1 D\u2083 <p>The Boolean equation:</p> \\[Y = \\overline{S_1} \\cdot \\overline{S_0} \\cdot D_0 + \\overline{S_1} \\cdot S_0 \\cdot D_1 + S_1 \\cdot \\overline{S_0} \\cdot D_2 + S_1 \\cdot S_0 \\cdot D_3\\] <p>This looks complex, but the pattern is clear: each term \"enables\" one data input when the select lines match its address.</p> <p>Memory Trick</p> <p>Think of the select inputs as a binary address. S\u2081S\u2080 = 00 selects input 0, S\u2081S\u2080 = 01 selects input 1, and so on. The select code is literally the \"address\" of the data input you want.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-4-to-1-mux-interactive","title":"Diagram: 4-to-1 MUX Interactive","text":"4-to-1 Multiplexer Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use a 4-to-1 multiplexer to select any of four inputs by setting the appropriate select code.</p> <p>Instructional Rationale: Building on 2-to-1 understanding, this sim shows how additional select lines exponentially increase input options while maintaining the same selection principle.</p> <p>Canvas Layout:</p> <ul> <li>Left column: Four data input toggles (D0-D3)</li> <li>Center: MUX symbol with internal routing visualization</li> <li>Right: Select input controls (S1, S0) and binary address display</li> <li>Bottom: Output and current equation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for all data inputs (D0-D3)</li> <li>Toggle buttons for select inputs (S1, S0)</li> <li>Binary address display showing select value (00, 01, 10, 11)</li> <li>Internal AND gates visualized</li> <li>Active path highlighted through internal structure</li> <li>Output LED indicator</li> </ul> <p>Data Visibility:</p> <ul> <li>All input values visible</li> <li>Select address prominently displayed</li> <li>Internal gate states optionally visible</li> <li>Active signal path emphasized</li> </ul> <p>Visual Style:</p> <ul> <li>MUX shown as trapezoid or with internal structure option</li> <li>Color-coded paths (selected in green)</li> <li>Address display as binary digits</li> <li>Professional schematic appearance</li> </ul> <p>Implementation: p5.js with multi-input selection logic</p>"},{"location":"chapters/06-combinational-building-blocks/#mux-8-to-1-eight-inputs-three-bits","title":"MUX 8-to-1: Eight Inputs, Three Bits","text":"<p>Following the pattern, an 8-to-1 multiplexer has:</p> <ul> <li>Eight data inputs: \\(D_0\\) through \\(D_7\\)</li> <li>Three select inputs: \\(S_2, S_1, S_0\\)</li> <li>One output: \\(Y\\)</li> </ul> <p>The 3-bit select code addresses any of the 8 inputs (since \\(2^3 = 8\\)).</p> <p>The general formula for an n-to-1 MUX:</p> <ul> <li>Number of data inputs: n</li> <li>Number of select lines: \\(\\log_2(n)\\)</li> <li>Output equation: Sum of (each minterm of select lines ANDed with its corresponding data input)</li> </ul>"},{"location":"chapters/06-combinational-building-blocks/#mux-tree-building-bigger-from-smaller","title":"MUX Tree: Building Bigger from Smaller","text":"<p>What if you need a 16-to-1 MUX but only have 4-to-1 MUXes available? You build a MUX tree\u2014a hierarchical structure where smaller MUXes cascade to form larger ones.</p> <p>Here's the strategy for a 16-to-1 using 4-to-1 MUXes:</p> <p>Level 1 (First stage): Four 4-to-1 MUXes, each selecting from 4 inputs</p> <ul> <li>MUX A: selects from D\u2080-D\u2083</li> <li>MUX B: selects from D\u2084-D\u2087</li> <li>MUX C: selects from D\u2088-D\u2081\u2081</li> <li>MUX D: selects from D\u2081\u2082-D\u2081\u2085</li> </ul> <p>All four use the same select lines (S\u2081S\u2080) for their internal selection.</p> <p>Level 2 (Second stage): One 4-to-1 MUX selecting among the Level 1 outputs</p> <ul> <li>Inputs: outputs from MUX A, B, C, D</li> <li>Select lines: S\u2083S\u2082 (the higher-order bits)</li> </ul> <p>This creates a 16-to-1 MUX using five 4-to-1 MUXes!</p> <p>The same principle extends indefinitely. Need a 64-to-1? Use 4-to-1s in a three-level tree. This modular approach is fundamental to digital design.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-mux-tree-builder","title":"Diagram: MUX Tree Builder","text":"Multiplexer Tree Hierarchical Builder <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Organize</p> <p>Learning Objective: Students will be able to organize smaller multiplexers into tree structures to create larger multiplexers, understanding how select lines are distributed across levels.</p> <p>Instructional Rationale: Visualizing the hierarchical structure helps students understand how modularity enables scalable design. Interactive building reinforces the select line distribution concept.</p> <p>Canvas Layout:</p> <ul> <li>Left: Available MUX components (4-to-1 blocks)</li> <li>Center: Canvas for building tree structure</li> <li>Right: Select line assignment panel</li> <li>Bottom: Input/output test interface</li> </ul> <p>Interactive Elements:</p> <ul> <li>Drag and drop MUX blocks onto canvas</li> <li>Connect outputs to inputs</li> <li>Assign select lines to each MUX level</li> <li>Test with specific input patterns</li> <li>View signal propagation through tree</li> <li>Preset examples (8-to-1 from 2-to-1s, 16-to-1 from 4-to-1s)</li> </ul> <p>Data Visibility:</p> <ul> <li>Clear level labeling</li> <li>Select line distribution shown</li> <li>Data path highlighting during test</li> <li>Total component count</li> </ul> <p>Visual Style:</p> <ul> <li>Tree structure flowing left to right</li> <li>MUXes as consistent block symbols</li> <li>Color coding by tree level</li> <li>Connection wires with proper routing</li> </ul> <p>Implementation: p5.js with drag-drop and connection logic</p>"},{"location":"chapters/06-combinational-building-blocks/#mux-as-logic-function-the-universal-implementer","title":"MUX as Logic Function: The Universal Implementer","text":"<p>Here's a mind-bending fact: a multiplexer can implement any Boolean function. This makes MUXes incredibly versatile.</p> <p>The trick is to use the function's input variables as the MUX select lines, and connect the function's truth table outputs to the MUX data inputs.</p> <p>Example: Implement \\(F(A, B) = A \\oplus B\\) (XOR) using a 4-to-1 MUX.</p> <p>Step 1: Write the truth table:</p> A B F 0 0 0 0 1 1 1 0 1 1 1 0 <p>Step 2: Connect A and B to the select inputs (S\u2081 = A, S\u2080 = B).</p> <p>Step 3: Connect the F column values to the data inputs:</p> <ul> <li>\\(D_0 = 0\\) (for AB = 00)</li> <li>\\(D_1 = 1\\) (for AB = 01)</li> <li>\\(D_2 = 1\\) (for AB = 10)</li> <li>\\(D_3 = 0\\) (for AB = 11)</li> </ul> <p>That's it! The MUX now computes XOR. For any input combination, the select lines choose the correct output from the data inputs.</p> <p>Even cooler: You can implement an n-variable function with a \\(2^{n-1}\\)-to-1 MUX by using one variable directly and its complement on the data inputs. This is called the Shannon expansion.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-mux-function-implementer","title":"Diagram: MUX Function Implementer","text":"MUX as Logic Function Implementer <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Implement</p> <p>Learning Objective: Students will be able to implement any Boolean function using a multiplexer by mapping truth table outputs to data inputs.</p> <p>Instructional Rationale: This demonstrates the universality of multiplexers and provides a systematic method for function implementation that doesn't require Boolean simplification.</p> <p>Canvas Layout:</p> <ul> <li>Left: Truth table input (editable)</li> <li>Center: MUX symbol with configurable data inputs</li> <li>Right: Test interface with variable toggles</li> <li>Bottom: Verification panel comparing MUX output to truth table</li> </ul> <p>Interactive Elements:</p> <ul> <li>Editable truth table for 2 or 3 variable functions</li> <li>Auto-configure MUX data inputs from truth table</li> <li>Test inputs by toggling variables</li> <li>Compare MUX output to expected truth table value</li> <li>Highlight which data input is currently selected</li> <li>Option to show intermediate calculations</li> </ul> <p>Data Visibility:</p> <ul> <li>Truth table with current row highlighted</li> <li>MUX data input values</li> <li>Current select code and selected input</li> <li>Output verification (match/mismatch indicator)</li> </ul> <p>Visual Style:</p> <ul> <li>Truth table on left, MUX on right</li> <li>Arrow showing mapping from truth table to data inputs</li> <li>Active row and path highlighted</li> <li>Success/verification indicators</li> </ul> <p>Implementation: p5.js with truth table parser and MUX simulator</p>"},{"location":"chapters/06-combinational-building-blocks/#demultiplexers-the-opposite-direction","title":"Demultiplexers: The Opposite Direction","text":"<p>If a multiplexer is many-to-one, a demultiplexer (DEMUX) is one-to-many. It takes a single input and routes it to one of several outputs based on select lines.</p> <p>Think of it as a digital rotary switch or a train track switch\u2014the signal comes in on one line and gets routed to exactly one destination.</p> <ul> <li>Data input: Single signal to be routed</li> <li>Select inputs: Binary code choosing the destination</li> <li>Outputs: Multiple lines, only one active at a time</li> </ul>"},{"location":"chapters/06-combinational-building-blocks/#demux-1-to-4-one-input-four-destinations","title":"DEMUX 1-to-4: One Input, Four Destinations","text":"<p>A 1-to-4 demultiplexer has:</p> <ul> <li>One data input: D</li> <li>Two select inputs: \\(S_1, S_0\\)</li> <li>Four outputs: \\(Y_0, Y_1, Y_2, Y_3\\)</li> </ul> <p>The behavior:</p> S\u2081 S\u2080 Y\u2080 Y\u2081 Y\u2082 Y\u2083 0 0 D 0 0 0 0 1 0 D 0 0 1 0 0 0 D 0 1 1 0 0 0 D <p>The selected output equals D; all others equal 0.</p> <p>The Boolean equations:</p> <p>[Y_0 = \\overline{S_1} \\cdot \\overline{S_0} \\cdot D] [Y_1 = \\overline{S_1} \\cdot S_0 \\cdot D] [Y_2 = S_1 \\cdot \\overline{S_0} \\cdot D] [Y_3 = S_1 \\cdot S_0 \\cdot D]</p> <p>Notice the pattern: each output is the corresponding minterm of the select lines, ANDed with D.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-1-to-4-demux-interactive","title":"Diagram: 1-to-4 DEMUX Interactive","text":"1-to-4 Demultiplexer Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Contrast</p> <p>Learning Objective: Students will be able to contrast demultiplexer operation with multiplexer operation, understanding the one-to-many signal routing.</p> <p>Instructional Rationale: Showing DEMUX as the \"opposite\" of MUX reinforces both concepts. Highlighting exactly one active output emphasizes the routing behavior.</p> <p>Canvas Layout:</p> <ul> <li>Left: Data input toggle and select input controls</li> <li>Center: DEMUX symbol (inverted trapezoid or standard representation)</li> <li>Right: Four output indicators (LED style)</li> <li>Bottom: Current routing description</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle for data input D</li> <li>Toggle buttons for select inputs S1, S0</li> <li>DEMUX symbol with internal routing paths</li> <li>Active output LED lights up</li> <li>Inactive outputs clearly shown as off</li> <li>Address display showing current destination</li> </ul> <p>Data Visibility:</p> <ul> <li>Input value D</li> <li>Select code as binary and decimal</li> <li>All four output values</li> <li>Clear indication of which output is \"active\"</li> </ul> <p>Visual Style:</p> <ul> <li>DEMUX as inverted trapezoid (complement to MUX shape)</li> <li>Single input branching to multiple outputs</li> <li>Active path in green, inactive in gray</li> <li>LED-style output indicators</li> </ul> <p>Implementation: p5.js with routing visualization</p> <p>MUX-DEMUX Duality</p> <p>Multiplexers and demultiplexers are duals of each other. In fact, the internal structure of a DEMUX is nearly identical to a decoder (which we'll meet shortly). Some chips combine both functions, acting as a MUX in one direction and DEMUX in the other.</p>"},{"location":"chapters/06-combinational-building-blocks/#encoders-and-decoders-binary-translation","title":"Encoders and Decoders: Binary Translation","text":"<p>Encoders and decoders are complementary circuits that translate between different representations of information.</p>"},{"location":"chapters/06-combinational-building-blocks/#encoder-many-bits-to-few","title":"Encoder: Many Bits to Few","text":"<p>An encoder converts a \"one-hot\" input (where exactly one of many inputs is active) into a compact binary code.</p> <p>Think of it as a compression function: many wires go in, fewer wires come out.</p> <p>For an 8-to-3 encoder:</p> <ul> <li>8 inputs: \\(D_0\\) through \\(D_7\\) (only one should be active)</li> <li>3 outputs: \\(A_2, A_1, A_0\\) (binary code indicating which input is active)</li> </ul> <p>When input \\(D_5\\) is high (and all others low), the output is 101 (binary for 5).</p> Active Input A\u2082 A\u2081 A\u2080 D\u2080 0 0 0 D\u2081 0 0 1 D\u2082 0 1 0 D\u2083 0 1 1 D\u2084 1 0 0 D\u2085 1 0 1 D\u2086 1 1 0 D\u2087 1 1 1 <p>The output equations are simply ORs of the inputs that should produce a 1 in each output position:</p> <p>[A_0 = D_1 + D_3 + D_5 + D_7] [A_1 = D_2 + D_3 + D_6 + D_7] [A_2 = D_4 + D_5 + D_6 + D_7]</p>"},{"location":"chapters/06-combinational-building-blocks/#decoder-few-bits-to-many","title":"Decoder: Few Bits to Many","text":"<p>A decoder is the inverse: it takes a binary code and activates exactly one of many outputs.</p> <p>For a 3-to-8 decoder:</p> <ul> <li>3 inputs: \\(A_2, A_1, A_0\\) (the binary code)</li> <li>8 outputs: \\(Y_0\\) through \\(Y_7\\) (only one active at a time)</li> </ul> <p>When the input is 101 (5 in decimal), output \\(Y_5\\) goes high and all others stay low.</p>"},{"location":"chapters/06-combinational-building-blocks/#2-to-4-decoder","title":"2-to-4 Decoder","text":"<p>The 2-to-4 decoder is the smallest useful decoder:</p> <ul> <li>2 inputs: \\(A_1, A_0\\)</li> <li>4 outputs: \\(Y_0, Y_1, Y_2, Y_3\\)</li> </ul> <p>Each output corresponds to a minterm:</p> <p>[Y_0 = \\overline{A_1} \\cdot \\overline{A_0}] [Y_1 = \\overline{A_1} \\cdot A_0] [Y_2 = A_1 \\cdot \\overline{A_0}] [Y_3 = A_1 \\cdot A_0]</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-2-to-4-decoder-interactive","title":"Diagram: 2-to-4 Decoder Interactive","text":"2-to-4 Decoder Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how a decoder converts a binary input code into exactly one active output line.</p> <p>Instructional Rationale: The 2-to-4 decoder is simple enough to see the complete pattern while demonstrating the minterm-based implementation.</p> <p>Canvas Layout:</p> <ul> <li>Left: Two input toggles (A1, A0)</li> <li>Center: Decoder symbol with internal AND gates visible</li> <li>Right: Four output indicators with labels (Y0-Y3)</li> <li>Bottom: Minterm equation for currently active output</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for A1 and A0</li> <li>Internal structure showing two inverters and four AND gates</li> <li>Signal flow animation through gates</li> <li>Active output highlighted prominently</li> <li>Minterm expression displayed for active output</li> </ul> <p>Data Visibility:</p> <ul> <li>Input binary value and decimal equivalent</li> <li>All four outputs with active one emphasized</li> <li>Gate-level signal states</li> <li>Current minterm equation</li> </ul> <p>Visual Style:</p> <ul> <li>Standard decoder block symbol with optional internal view</li> <li>Active output LED style (bright green)</li> <li>Inactive outputs dim</li> <li>Gate-level view toggle</li> </ul> <p>Implementation: p5.js with gate simulation</p>"},{"location":"chapters/06-combinational-building-blocks/#3-to-8-decoder","title":"3-to-8 Decoder","text":"<p>The 3-to-8 decoder follows the same pattern:</p> <ul> <li>3 inputs: \\(A_2, A_1, A_0\\)</li> <li>8 outputs: \\(Y_0\\) through \\(Y_7\\)</li> <li>Each output is a 3-variable minterm</li> </ul> <p>A 3-to-8 decoder is essentially a minterm generator\u2014each output corresponds to one minterm. This makes decoders incredibly useful for implementing Boolean functions!</p>"},{"location":"chapters/06-combinational-building-blocks/#decoder-enable","title":"Decoder Enable","text":"<p>Most practical decoders include an enable input (sometimes labeled E or G). When enable is inactive (typically low), ALL outputs are forced to 0 regardless of the select inputs. When enable is active, the decoder operates normally.</p> <p>Enable inputs serve several purposes:</p> <ul> <li>Power saving: Disable unused decoders</li> <li>Cascading: Build larger decoders from smaller ones</li> <li>Timing control: Only activate outputs at specific times</li> <li>Memory addressing: Enable specific memory chips</li> </ul> <p>With an enable input, the decoder equations become:</p> \\[Y_i = E \\cdot (\\text{minterm}_i)\\]"},{"location":"chapters/06-combinational-building-blocks/#diagram-decoder-with-enable","title":"Diagram: Decoder with Enable","text":"Decoder with Enable Input Demonstration <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use the enable input to control decoder operation, understanding its role in system design.</p> <p>Instructional Rationale: Enable inputs are crucial for cascading decoders and memory system design. Interactive demonstration shows how enable gates the entire decoder output.</p> <p>Canvas Layout:</p> <ul> <li>Left: Enable input and address inputs</li> <li>Center: 3-to-8 decoder symbol with enable</li> <li>Right: Eight output indicators</li> <li>Bottom: Use case examples (cascading, memory addressing)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle for Enable input</li> <li>Toggle buttons for address inputs (A2, A1, A0)</li> <li>When E=0, all outputs show \"disabled\" state</li> <li>When E=1, normal decoder operation</li> <li>Show cascading example with two decoders making 4-to-16</li> </ul> <p>Data Visibility:</p> <ul> <li>Enable state prominently displayed</li> <li>Address value in binary and decimal</li> <li>Output states with disabled indication when E=0</li> <li>Cascade mode shows larger decoder configuration</li> </ul> <p>Visual Style:</p> <ul> <li>Enable input at top of decoder symbol</li> <li>Disabled state shown with grayed outputs</li> <li>Active state with green LED outputs</li> <li>Optional cascade view with two decoders</li> </ul> <p>Implementation: p5.js with enable gating logic</p>"},{"location":"chapters/06-combinational-building-blocks/#priority-encoder-when-multiple-inputs-compete","title":"Priority Encoder: When Multiple Inputs Compete","text":"<p>A standard encoder assumes exactly one input is active. But what happens if multiple inputs are high simultaneously? Chaos! The output would be an unpredictable OR of multiple codes.</p> <p>A priority encoder solves this by assigning priorities: if multiple inputs are active, the highest-priority one wins.</p> <p>For a 4-to-2 priority encoder with D\u2083 as highest priority:</p> D\u2083 D\u2082 D\u2081 D\u2080 A\u2081 A\u2080 V 0 0 0 0 X X 0 0 0 0 1 0 0 1 0 0 1 X 0 1 1 0 1 X X 1 0 1 1 X X X 1 1 1 <p>Notice the \"X\" (don't care) entries. Once a higher-priority input is active, lower-priority inputs don't matter.</p> <p>The V output is a \"valid\" flag\u2014it's 1 when ANY input is active, 0 when all inputs are low. This distinguishes between \"output is 00 because D\u2080 is active\" and \"output is 00 because nothing is active.\"</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-priority-encoder-interactive","title":"Diagram: Priority Encoder Interactive","text":"Priority Encoder Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how a priority encoder resolves conflicts when multiple inputs are active simultaneously.</p> <p>Instructional Rationale: The priority resolution is the key distinguishing feature. Showing multiple active inputs with clear priority indication demonstrates why this circuit is needed.</p> <p>Canvas Layout:</p> <ul> <li>Left: Four input toggles with priority labels (Highest D3 to Lowest D0)</li> <li>Center: Priority encoder block with internal priority logic visible</li> <li>Right: Output code and valid indicator</li> <li>Bottom: Priority resolution explanation for current state</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for all four inputs</li> <li>Allow multiple inputs to be active simultaneously</li> <li>Show priority resolution in real-time</li> <li>Indicate which input \"wins\"</li> <li>Valid output as separate indicator</li> <li>Comparison mode: show what regular encoder would output (undefined)</li> </ul> <p>Data Visibility:</p> <ul> <li>All input states</li> <li>Winning input highlighted with priority crown</li> <li>Output code with decimal equivalent</li> <li>Valid signal status</li> <li>Ignored (lower priority) inputs marked</li> </ul> <p>Visual Style:</p> <ul> <li>Priority levels visualized as stacked heights</li> <li>Winning input emphasized with color/glow</li> <li>Output arrows from winning input only</li> <li>Conflict indication when multiple inputs active</li> </ul> <p>Implementation: p5.js with priority resolution logic</p> <p>Real-World Use: Interrupt Controllers</p> <p>Priority encoders are the heart of interrupt controllers in CPUs. When multiple devices request attention simultaneously, the priority encoder determines which one gets serviced first. Higher-priority devices (like keyboard input) get encoded over lower-priority ones (like background disk access).</p>"},{"location":"chapters/06-combinational-building-blocks/#7-segment-display-and-decoder","title":"7-Segment Display and Decoder","text":"<p>One of the most visible applications of decoders is driving 7-segment displays\u2014those ubiquitous numeric readouts found in clocks, microwaves, and calculator screens.</p>"},{"location":"chapters/06-combinational-building-blocks/#7-segment-display-basics","title":"7-Segment Display Basics","text":"<p>A 7-segment display consists of seven LED segments arranged in a figure-8 pattern:</p> <pre><code>  _a_\n |   |\n f   b\n |_g_|\n |   |\n e   c\n |_d_|\n</code></pre> <p>By lighting specific combinations of segments, you can display digits 0-9 (and some letters).</p> Digit a b c d e f g 0 1 1 1 1 1 1 0 1 0 1 1 0 0 0 0 2 1 1 0 1 1 0 1 3 1 1 1 1 0 0 1 4 0 1 1 0 0 1 1 5 1 0 1 1 0 1 1 6 1 0 1 1 1 1 1 7 1 1 1 0 0 0 0 8 1 1 1 1 1 1 1 9 1 1 1 1 0 1 1"},{"location":"chapters/06-combinational-building-blocks/#7-segment-decoder","title":"7-Segment Decoder","text":"<p>A 7-segment decoder takes a 4-bit BCD (Binary Coded Decimal) input and produces the seven outputs needed to display the corresponding digit.</p> <p>This is a specialized decoder\u2014instead of one-hot outputs, it produces the specific segment pattern for each digit.</p> <p>Each segment output is a separate Boolean function of the four inputs:</p> <ul> <li>\\(a = f(D_3, D_2, D_1, D_0)\\)</li> <li>\\(b = f(D_3, D_2, D_1, D_0)\\)</li> <li>... and so on for all seven segments</li> </ul> <p>For example, segment 'a' should be ON for digits 0, 2, 3, 5, 6, 7, 8, 9:</p> \\[a = \\sum m(0, 2, 3, 5, 6, 7, 8, 9)\\] <p>Since BCD only uses values 0-9, inputs 10-15 are don't cares, which can be exploited for simplification.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-7-segment-display-driver","title":"Diagram: 7-Segment Display Driver","text":"7-Segment Display and Decoder Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute the conversion from BCD input to 7-segment display output by tracing signals through the decoder.</p> <p>Instructional Rationale: The 7-segment display is a tangible, familiar application that connects abstract Boolean logic to a real-world output students recognize.</p> <p>Canvas Layout:</p> <ul> <li>Left: 4-bit BCD input controls (toggles or buttons 0-9)</li> <li>Center: 7-segment display visualization (realistic LED segments)</li> <li>Right: Individual segment state indicators (a-g)</li> <li>Bottom: K-map or truth table for selected segment</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input as either toggles (D3-D0) or direct digit buttons (0-9)</li> <li>Large 7-segment display showing current digit</li> <li>Individual segment LEDs with labels</li> <li>Select a segment to see its K-map/truth table</li> <li>Invalid BCD inputs (10-15) show as blank or special pattern</li> <li>Segment equation display option</li> </ul> <p>Data Visibility:</p> <ul> <li>BCD input value in binary and decimal</li> <li>All seven segment states</li> <li>Currently displayed digit</li> <li>Boolean equation for selected segment</li> </ul> <p>Visual Style:</p> <ul> <li>Realistic 7-segment LED display (red or green segments)</li> <li>Segment labels clearly visible</li> <li>Active segments bright, inactive dim</li> <li>Professional appearance matching real displays</li> </ul> <p>Implementation: p5.js with 7-segment rendering and decoder logic</p>"},{"location":"chapters/06-combinational-building-blocks/#comparators-digital-decision-makers","title":"Comparators: Digital Decision Makers","text":"<p>Comparators are circuits that compare two binary numbers and indicate their relationship. Is A equal to B? Is A greater than B? Is A less than B? These fundamental questions arise constantly in digital systems.</p>"},{"location":"chapters/06-combinational-building-blocks/#equality-comparator","title":"Equality Comparator","text":"<p>An equality comparator determines if two n-bit numbers are identical. The output is 1 if A = B, and 0 otherwise.</p> <p>For single bits, equality is simply XNOR:</p> \\[EQ = A \\odot B = \\overline{A \\oplus B} = A \\cdot B + \\overline{A} \\cdot \\overline{B}\\] <p>For multi-bit comparison, each bit position is compared, and ALL must match:</p> \\[A = B \\text{ when } (A_3 \\odot B_3) \\cdot (A_2 \\odot B_2) \\cdot (A_1 \\odot B_1) \\cdot (A_0 \\odot B_0) = 1\\] <p>This is simply ANDing all the bit-wise XNOR results.</p>"},{"location":"chapters/06-combinational-building-blocks/#binary-comparator-single-bit","title":"Binary Comparator (Single Bit)","text":"<p>A binary comparator for single bits determines all three relationships:</p> A B A &gt; B A = B A &lt; B 0 0 0 1 0 0 1 0 0 1 1 0 1 0 0 1 1 0 1 0 <p>The equations:</p> <p>[A &gt; B = A \\cdot \\overline{B}] [A = B = \\overline{A \\oplus B}] [A &lt; B = \\overline{A} \\cdot B]</p>"},{"location":"chapters/06-combinational-building-blocks/#magnitude-comparator","title":"Magnitude Comparator","text":"<p>A magnitude comparator extends this to multi-bit numbers. For n-bit numbers A and B, it outputs three signals: A &gt; B, A = B, and A &lt; B.</p> <p>The comparison starts from the most significant bit:</p> <ol> <li>If \\(A_{n-1} &gt; B_{n-1}\\), then A &gt; B (regardless of other bits)</li> <li>If \\(A_{n-1} &lt; B_{n-1}\\), then A &lt; B</li> <li>If \\(A_{n-1} = B_{n-1}\\), compare the next bit down</li> <li>Continue until a difference is found, or all bits match (equality)</li> </ol> <p>For a 4-bit magnitude comparator, the equations become complex, but the logic follows this cascading comparison pattern.</p> <p>Standard IC magnitude comparators (like the 74LS85) include cascade inputs, allowing multiple chips to be connected for comparing larger numbers.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-magnitude-comparator-interactive","title":"Diagram: Magnitude Comparator Interactive","text":"4-Bit Magnitude Comparator Interactive <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Differentiate</p> <p>Learning Objective: Students will be able to differentiate between the three comparison outcomes (A&gt;B, A=B, A&lt;B) and trace how the comparison cascades from MSB to LSB.</p> <p>Instructional Rationale: Understanding the bit-by-bit comparison process reveals why magnitude comparison is more complex than equality checking. Step-through visualization makes the cascade logic clear.</p> <p>Canvas Layout:</p> <ul> <li>Left: 4-bit input A (toggles or slider 0-15)</li> <li>Right: 4-bit input B (toggles or slider 0-15)</li> <li>Center: Comparison visualization with bit-by-bit analysis</li> <li>Bottom: Three output indicators (A&gt;B, A=B, A&lt;B)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons or sliders for A and B (4 bits each)</li> <li>Decimal value display for both inputs</li> <li>Step-by-step comparison animation showing bit-by-bit analysis</li> <li>Highlight which bit \"decides\" the comparison</li> <li>Three output LEDs with only one active</li> <li>Cascade mode showing multi-chip comparison</li> </ul> <p>Data Visibility:</p> <ul> <li>Binary and decimal values for A and B</li> <li>Bit-by-bit comparison status</li> <li>Deciding bit highlighted</li> <li>All three comparison outputs (exactly one true)</li> </ul> <p>Visual Style:</p> <ul> <li>Numbers displayed as bit columns</li> <li>Comparison arrows between corresponding bits</li> <li>Deciding bit connection emphasized</li> <li>Clear output labeling with symbols (&gt;, =, &lt;)</li> </ul> <p>Implementation: p5.js with cascading comparison logic and animation</p>"},{"location":"chapters/06-combinational-building-blocks/#adders-the-heart-of-arithmetic","title":"Adders: The Heart of Arithmetic","text":"<p>Addition is the most fundamental arithmetic operation in digital systems. All other arithmetic (subtraction, multiplication, division) ultimately reduces to combinations of addition. Let's build adders from the ground up.</p>"},{"location":"chapters/06-combinational-building-blocks/#half-adder","title":"Half Adder","text":"<p>A half adder adds two single-bit inputs and produces a sum and carry:</p> <ul> <li>Inputs: A, B (single bits)</li> <li>Outputs: Sum (S), Carry (C)</li> </ul> <p>The truth table:</p> A B C (Carry) S (Sum) 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 <p>This is just binary addition: 0+0=0, 0+1=1, 1+0=1, 1+1=10 (which is 0 with carry 1).</p> <p>The equations:</p> <p>[S = A \\oplus B] [C = A \\cdot B]</p> <p>The sum bit is XOR (it's 1 when inputs differ). The carry bit is AND (it's 1 when both inputs are 1).</p> <p>Why \"half\"? Because it only handles two inputs. Real multi-bit addition needs to handle a carry coming in from the previous position.</p>"},{"location":"chapters/06-combinational-building-blocks/#full-adder","title":"Full Adder","text":"<p>A full adder adds three single-bit inputs: two data bits plus a carry-in from the previous position.</p> <ul> <li>Inputs: A, B, \\(C_{in}\\) (carry in)</li> <li>Outputs: S (sum), \\(C_{out}\\) (carry out)</li> </ul> <p>The truth table:</p> A B C\u1d62\u2099 C\u2092\u1d64\u209c S 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 <p>The equations:</p> <p>[S = A \\oplus B \\oplus C_{in}] [C_{out} = A \\cdot B + C_{in} \\cdot (A \\oplus B)]</p> <p>The sum is the XOR of all three inputs (odd number of 1s gives 1). The carry-out is 1 when at least two inputs are 1.</p> <p>A full adder can be built from two half adders and an OR gate:</p> <ol> <li>First half adder: add A and B \u2192 partial sum, partial carry</li> <li>Second half adder: add partial sum and C\u1d62\u2099 \u2192 final sum, second partial carry</li> <li>OR gate: combine partial carries \u2192 final C\u2092\u1d64\u209c</li> </ol>"},{"location":"chapters/06-combinational-building-blocks/#diagram-half-and-full-adder-interactive","title":"Diagram: Half and Full Adder Interactive","text":"Half Adder and Full Adder Interactive <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain the difference between half and full adders, including why full adders are necessary for multi-bit addition.</p> <p>Instructional Rationale: Side-by-side comparison of half and full adders clarifies the role of carry-in. Building full adder from half adders reinforces modular design concepts.</p> <p>Canvas Layout:</p> <ul> <li>Top tabs: Half Adder / Full Adder toggle</li> <li>Left: Input controls (2 for half, 3 for full)</li> <li>Center: Circuit diagram with gate-level detail</li> <li>Right: Sum and Carry outputs</li> <li>Bottom: Binary addition visualization</li> </ul> <p>Interactive Elements:</p> <ul> <li>Switch between half adder and full adder views</li> <li>Toggle buttons for all inputs</li> <li>Gate-level simulation showing signal propagation</li> <li>Binary addition shown as column addition (like pencil and paper)</li> <li>Build mode: construct full adder from half adders</li> <li>Animation showing carry propagation concept</li> </ul> <p>Data Visibility:</p> <ul> <li>All input values</li> <li>Sum and Carry outputs</li> <li>Gate output states in circuit view</li> <li>Binary column addition visualization</li> </ul> <p>Visual Style:</p> <ul> <li>Clean gate-level circuit diagrams</li> <li>XOR and AND gates clearly labeled</li> <li>Signal flow arrows</li> <li>Column addition format familiar from arithmetic</li> </ul> <p>Implementation: p5.js with gate simulation and dual-mode display</p>"},{"location":"chapters/06-combinational-building-blocks/#ripple-carry-adder","title":"Ripple Carry Adder","text":"<p>To add multi-bit numbers, we cascade full adders, connecting each carry-out to the next carry-in. This is called a ripple carry adder because the carry \"ripples\" through the chain.</p> <p>For a 4-bit ripple carry adder:</p> <ul> <li>Inputs: A\u2083A\u2082A\u2081A\u2080 and B\u2083B\u2082B\u2081B\u2080</li> <li>Outputs: S\u2083S\u2082S\u2081S\u2080 and C\u2092\u1d64\u209c (final carry)</li> <li>Structure: Four full adders in series</li> </ul> <p>The LSB adder's carry-in is typically 0 (unless we're doing subtraction). Each subsequent adder takes its carry-in from the previous adder's carry-out.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-4-bit-ripple-carry-adder","title":"Diagram: 4-Bit Ripple Carry Adder","text":"4-Bit Ripple Carry Adder Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Calculate</p> <p>Learning Objective: Students will be able to calculate the sum of two 4-bit binary numbers by tracing through a ripple carry adder.</p> <p>Instructional Rationale: Visualizing the carry chain makes the ripple effect tangible. Timing animation shows why this design has latency issues.</p> <p>Canvas Layout:</p> <ul> <li>Top: Two 4-bit input fields (binary or decimal entry)</li> <li>Center: Four cascaded full adders with carry chain visible</li> <li>Bottom: 5-bit result (4 sum bits + carry out)</li> <li>Optional: Timing diagram showing carry propagation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input A and B as binary toggles or decimal 0-15</li> <li>Carry chain highlighted showing propagation</li> <li>Step-through mode: watch carry ripple bit by bit</li> <li>Speed control for animation</li> <li>Timing visualization showing delay accumulation</li> <li>Decimal equivalents displayed</li> </ul> <p>Data Visibility:</p> <ul> <li>Input values in binary and decimal</li> <li>Each full adder's sum and carry</li> <li>Carry chain connections</li> <li>Final sum with possible overflow indication</li> </ul> <p>Visual Style:</p> <ul> <li>Four FA blocks connected horizontally</li> <li>Carry wires clearly connecting adjacent stages</li> <li>Active carries highlighted during propagation</li> <li>Time labels showing cumulative delay</li> </ul> <p>Implementation: p5.js with cascaded full adder simulation and timing display</p>"},{"location":"chapters/06-combinational-building-blocks/#carry-propagation-delay","title":"Carry Propagation Delay","text":"<p>Here's the problem with ripple carry adders: each bit must wait for the carry from the previous bit. The carry \"ripples\" through the entire chain, causing carry propagation delay.</p> <p>For an n-bit ripple carry adder:</p> <ul> <li>Worst case: carry must propagate through all n stages</li> <li>Delay = n \u00d7 (delay of one full adder)</li> </ul> <p>For a 32-bit adder, that's 32 gate delays just for the carry chain! In modern processors running at gigahertz speeds, this is unacceptable.</p>"},{"location":"chapters/06-combinational-building-blocks/#carry-lookahead-concept","title":"Carry Lookahead Concept","text":"<p>The solution is carry lookahead: instead of waiting for carries to ripple, we calculate them in advance using combinational logic.</p> <p>The key insight: for each bit position, we can determine if it will:</p> <ul> <li>Generate a carry: when both A\u1d62 = 1 and B\u1d62 = 1</li> <li>Propagate a carry: when exactly one of A\u1d62 or B\u1d62 = 1</li> </ul> <p>Define generate (G) and propagate (P) signals:</p> <p>[G_i = A_i \\cdot B_i] [P_i = A_i \\oplus B_i]</p> <p>The carry for position i can be calculated directly:</p> <p>[C_1 = G_0 + P_0 \\cdot C_0] [C_2 = G_1 + P_1 \\cdot G_0 + P_1 \\cdot P_0 \\cdot C_0] [C_3 = G_2 + P_2 \\cdot G_1 + P_2 \\cdot P_1 \\cdot G_0 + P_2 \\cdot P_1 \\cdot P_0 \\cdot C_0]</p> <p>These are parallel calculations\u2014all carries can be computed simultaneously in just a few gate delays, regardless of word size!</p> <p>The tradeoff: carry lookahead requires more gates (those equations get big). It's a classic speed vs. area tradeoff.</p> <p>Real-World Adders</p> <p>Modern processors use hierarchical carry lookahead with multiple levels of G and P calculations. A 64-bit adder might use 4-bit carry lookahead blocks cascaded with block-level lookahead, achieving logarithmic delay instead of linear delay.</p>"},{"location":"chapters/06-combinational-building-blocks/#adder-subtractor","title":"Adder Subtractor","text":"<p>Here's a clever trick: you can build a combined adder/subtractor with just one adder and some XOR gates.</p> <p>Recall that in two's complement:</p> \\[A - B = A + (-B) = A + \\overline{B} + 1\\] <p>To subtract, we:</p> <ol> <li>Complement B (flip all bits)</li> <li>Add 1 (set carry-in to 1)</li> </ol> <p>Using XOR gates as controlled inverters:</p> <ul> <li>When control = 0: XOR passes B unchanged (addition)</li> <li>When control = 1: XOR inverts B (preparation for subtraction)</li> </ul> <p>The control signal also connects to the LSB carry-in:</p> <ul> <li>Control = 0: C\u1d62\u2099 = 0 (normal addition)</li> <li>Control = 1: C\u1d62\u2099 = 1 (adds the +1 for two's complement)</li> </ul> <p>One circuit, two operations!</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-adder-subtractor","title":"Diagram: Adder-Subtractor","text":"4-Bit Adder-Subtractor with Two's Complement <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute both addition and subtraction using a single adder circuit by understanding the role of XOR inversion and carry-in control.</p> <p>Instructional Rationale: Seeing how subtraction reuses the addition hardware reinforces two's complement concepts and demonstrates efficient hardware design.</p> <p>Canvas Layout:</p> <ul> <li>Top: Add/Subtract mode toggle</li> <li>Left: 4-bit input A</li> <li>Right: 4-bit input B (with XOR inversion visible)</li> <li>Center: 4-bit adder with controlled carry-in</li> <li>Bottom: Result with sign interpretation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Mode toggle (Add/Subtract)</li> <li>Input toggles for A and B</li> <li>XOR gates visible on B path, controlled by mode</li> <li>Carry-in connected to mode signal</li> <li>Show both unsigned and signed interpretations of result</li> <li>Overflow detection indicator</li> </ul> <p>Data Visibility:</p> <ul> <li>Original A and B values</li> <li>Complemented B when subtracting</li> <li>Carry-in value</li> <li>Sum/difference result</li> <li>Overflow/underflow indication</li> </ul> <p>Visual Style:</p> <ul> <li>XOR gates clearly shown on B input path</li> <li>Control signal branching to XORs and carry-in</li> <li>Color coding: add mode in blue, subtract mode in orange</li> <li>Clear labeling of two's complement operation</li> </ul> <p>Implementation: p5.js with mode-switched arithmetic</p>"},{"location":"chapters/06-combinational-building-blocks/#overflow-in-addition","title":"Overflow in Addition","text":"<p>When adding signed numbers, we can get overflow\u2014a result that doesn't fit in the available bits.</p> <p>For signed numbers using two's complement:</p> <ul> <li>Positive + Positive that yields Negative = Overflow</li> <li>Negative + Negative that yields Positive = Overflow</li> <li>Mixed signs (positive + negative) = Never overflows</li> </ul> <p>The overflow detection rule:</p> \\[\\text{Overflow} = C_{n-1} \\oplus C_{n-2}\\] <p>Overflow occurs when the carry into the MSB differs from the carry out of the MSB.</p> <p>Alternatively:</p> \\[\\text{Overflow} = (A_{n-1} \\cdot B_{n-1} \\cdot \\overline{S_{n-1}}) + (\\overline{A_{n-1}} \\cdot \\overline{B_{n-1}} \\cdot S_{n-1})\\] <p>This checks: \"Did two positives give negative, or two negatives give positive?\"</p>"},{"location":"chapters/06-combinational-building-blocks/#alu-concept-the-calculator-core","title":"ALU Concept: The Calculator Core","text":"<p>All the arithmetic and logic circuits we've discussed come together in the Arithmetic Logic Unit (ALU)\u2014the computational heart of any processor.</p> <p>An ALU combines:</p> <ul> <li>Arithmetic operations: add, subtract, increment, decrement</li> <li>Logic operations: AND, OR, XOR, NOT</li> <li>Comparison: set flags based on results</li> </ul> <p>The operation is selected by a function code:</p> Function Code Operation 00 AND 01 OR 10 Add 11 Subtract ... ... <p>Multiplexers select which circuit's output becomes the ALU result.</p> <p>An ALU also produces status flags:</p> <ul> <li>Zero (Z): Result is all zeros</li> <li>Negative (N): Result's MSB is 1 (negative in signed interpretation)</li> <li>Carry (C): Carry out from MSB (unsigned overflow)</li> <li>Overflow (V): Signed overflow occurred</li> </ul> <p>These flags drive conditional branches in programs: \"jump if zero,\" \"branch if negative,\" etc.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-simple-alu","title":"Diagram: Simple ALU","text":"Simple 4-Bit ALU Interactive <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how an ALU selects between multiple operations and generates status flags.</p> <p>Instructional Rationale: The ALU integrates many concepts from this chapter. Seeing how selection logic routes between different functional units provides insight into processor architecture.</p> <p>Canvas Layout:</p> <ul> <li>Top: Two 4-bit inputs (A and B)</li> <li>Center: ALU block showing multiple internal functional units</li> <li>Right: Operation selector (function code input)</li> <li>Bottom: Result and status flags (Z, N, C, V)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input toggles or sliders for A and B</li> <li>Operation selector (dropdown or buttons)</li> <li>Internal view toggle showing which unit is active</li> <li>Status flag indicators with tooltips explaining each</li> <li>Example calculations for each operation</li> <li>Step through showing data path for selected operation</li> </ul> <p>Data Visibility:</p> <ul> <li>Both input values</li> <li>Selected operation name</li> <li>Intermediate results from each functional unit</li> <li>MUX selection to output</li> <li>All four status flags with explanations</li> </ul> <p>Visual Style:</p> <ul> <li>ALU as block with internal functional units</li> <li>Currently active unit highlighted</li> <li>Flag indicators as LEDs with labels</li> <li>Clean, processor-diagram aesthetic</li> </ul> <p>Implementation: p5.js with multi-function simulation</p>"},{"location":"chapters/06-combinational-building-blocks/#error-detection-parity","title":"Error Detection: Parity","text":"<p>Digital systems aren't perfect\u2014noise can flip bits during transmission or storage. Parity is one of the simplest error detection techniques.</p>"},{"location":"chapters/06-combinational-building-blocks/#parity-bit","title":"Parity Bit","text":"<p>A parity bit is an extra bit added to data to make the total count of 1s either even (even parity) or odd (odd parity).</p> <p>For even parity: the parity bit is set so the total number of 1s (including the parity bit) is even.</p> Data 1s Count Parity Bit Total with Parity 0000 0 0 00000 0001 1 1 00011 0110 2 0 01100 0111 3 1 01111 1111 4 0 11110 <p>For odd parity: the parity bit makes the total count odd.</p>"},{"location":"chapters/06-combinational-building-blocks/#parity-generator","title":"Parity Generator","text":"<p>A parity generator circuit computes the parity bit from the data bits. For even parity:</p> \\[P = D_0 \\oplus D_1 \\oplus D_2 \\oplus D_3 \\oplus ...\\] <p>It's simply the XOR of all data bits. XOR is the \"odd function\"\u2014it outputs 1 when an odd number of inputs are 1. Adding this bit makes the total even.</p>"},{"location":"chapters/06-combinational-building-blocks/#parity-checker","title":"Parity Checker","text":"<p>A parity checker verifies that received data has correct parity. It XORs all bits including the parity bit:</p> \\[\\text{Error} = D_0 \\oplus D_1 \\oplus D_2 \\oplus ... \\oplus P\\] <p>For even parity: if the result is 0, parity is correct. If 1, an error occurred.</p>"},{"location":"chapters/06-combinational-building-blocks/#error-detection-limitations","title":"Error Detection Limitations","text":"<p>Parity is simple but limited:</p> <ul> <li>Detects: Any single-bit error (odd number of errors)</li> <li>Misses: Two-bit errors (or any even number of errors)</li> <li>Cannot correct: Only detects, doesn't identify which bit is wrong</li> </ul> <p>For better error handling, more sophisticated codes like Hamming codes add multiple parity bits to enable single-error correction.</p>"},{"location":"chapters/06-combinational-building-blocks/#diagram-parity-generator-and-checker","title":"Diagram: Parity Generator and Checker","text":"Parity Generator and Checker Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use parity generation and checking to detect single-bit errors in transmitted data.</p> <p>Instructional Rationale: Error detection is a practical application of XOR gates. Introducing bit-flip errors demonstrates the detection capability and its limitations.</p> <p>Canvas Layout:</p> <ul> <li>Top: Transmitter section with 4 data bits and generated parity</li> <li>Center: Transmission channel with error injection option</li> <li>Bottom: Receiver section with parity check result</li> <li>Side: Error indicator and explanation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for 4 data bits at transmitter</li> <li>Auto-computed parity bit display</li> <li>Error injection: click any bit in channel to flip it</li> <li>Parity checker output (OK/ERROR)</li> <li>Even/odd parity mode toggle</li> <li>Multi-bit error demonstration (shows undetected errors)</li> </ul> <p>Data Visibility:</p> <ul> <li>Original data and parity</li> <li>Transmitted data (possibly with errors)</li> <li>Received data with parity check result</li> <li>Count of errors introduced</li> <li>Explanation of why error was detected/missed</li> </ul> <p>Visual Style:</p> <ul> <li>Transmitter, channel, and receiver as distinct sections</li> <li>XOR tree visualization for generator/checker</li> <li>Error injection as clickable bits in channel</li> <li>OK in green, ERROR in red</li> <li>Transmission arrow between sections</li> </ul> <p>Implementation: p5.js with error injection simulation</p>"},{"location":"chapters/06-combinational-building-blocks/#tri-state-buffers-and-bus-architecture","title":"Tri-State Buffers and Bus Architecture","text":"<p>So far, all our outputs have been either 0 or 1. But real digital systems need a third state: high-impedance (Z), where the output is effectively disconnected.</p>"},{"location":"chapters/06-combinational-building-blocks/#tri-state-buffer","title":"Tri-State Buffer","text":"<p>A tri-state buffer has three possible output states:</p> <ul> <li>0: Low voltage, actively driven</li> <li>1: High voltage, actively driven</li> <li>Z: High impedance, electrically disconnected</li> </ul> <p>The control:</p> <ul> <li>Enable = 1: Output follows input (normal buffer behavior)</li> <li>Enable = 0: Output is Z (buffer appears disconnected)</li> </ul> Enable Input Output 0 X Z 1 0 0 1 1 1 <p>Why is this useful? It allows multiple sources to share a single wire without fighting.</p>"},{"location":"chapters/06-combinational-building-blocks/#bus-architecture","title":"Bus Architecture","text":"<p>A bus is a shared communication pathway\u2014multiple devices connect to the same wires. But only one device can \"talk\" at a time; otherwise, you get electrical conflicts.</p> <p>Tri-state buffers make buses work:</p> <ol> <li>All devices connect to the bus through tri-state buffers</li> <li>Only ONE device's buffer is enabled at any time</li> <li>All others are in high-Z (disconnected) state</li> <li>The enabled device drives the bus, others just listen</li> </ol> <p>This is how your computer's data bus works\u2014the CPU, memory, and I/O all share the same wires, taking turns to transmit.</p> <p>Common bus widths:</p> <ul> <li>8-bit: Early microprocessors</li> <li>16-bit: Older PCs</li> <li>32-bit: Standard PCs for decades</li> <li>64-bit: Modern processors</li> </ul>"},{"location":"chapters/06-combinational-building-blocks/#diagram-tri-state-buffer-and-bus","title":"Diagram: Tri-State Buffer and Bus","text":"Tri-State Buffer and Bus Architecture Interactive <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Organize</p> <p>Learning Objective: Students will be able to organize multiple data sources onto a shared bus using tri-state buffers, understanding why only one source can be active at a time.</p> <p>Instructional Rationale: Bus architecture is fundamental to computer organization. Demonstrating the bus conflict problem and its tri-state solution shows why this circuit exists.</p> <p>Canvas Layout:</p> <ul> <li>Top: Three data sources with enable controls</li> <li>Center: Shared bus (single wire/set of wires)</li> <li>Bottom: Receiver(s) connected to bus</li> <li>Side: Bus state indicator and conflict warning</li> </ul> <p>Interactive Elements:</p> <ul> <li>Three sources with data input and enable toggles</li> <li>Enable exactly one source at a time (automatic or manual)</li> <li>Attempt to enable multiple sources shows \"BUS CONFLICT\" warning</li> <li>Bus value display shows current driven value</li> <li>Receiver(s) show received data</li> <li>Animation showing data flow</li> </ul> <p>Data Visibility:</p> <ul> <li>Each source's data and enable state</li> <li>Current bus value (or conflict indication)</li> <li>Which source is currently driving</li> <li>Receiver(s) capturing bus value</li> </ul> <p>Visual Style:</p> <ul> <li>Bus as thick wire in center</li> <li>Tri-state symbols on connections</li> <li>Active connection in green</li> <li>Disabled connections with Z symbol</li> <li>Bus conflict shown in red with warning icon</li> </ul> <p>Implementation: p5.js with bus arbitration and conflict detection</p> <p>Bus Conflict</p> <p>If two tri-state buffers driving the same bus are both enabled with different values, you get a bus conflict\u2014one tries to drive 0, the other 1. This causes undefined voltage levels, excessive current, and can damage circuits. Proper bus control is essential!</p>"},{"location":"chapters/06-combinational-building-blocks/#putting-it-all-together","title":"Putting It All Together","text":"<p>We've covered a lot of ground in this chapter. Let's see how these building blocks work together in a real system.</p> <p>Consider a simple calculator that can add or subtract two 4-bit numbers selected from multiple inputs:</p> <ol> <li>Input selection: 4-to-1 MUXes choose which operands to use</li> <li>Operation: Adder-subtractor performs the calculation</li> <li>Output routing: DEMUX sends result to appropriate destination</li> <li>Display: 7-segment decoder shows the result</li> <li>Error checking: Parity added for data transmission</li> <li>Bus architecture: Shared data path between components</li> </ol> <p>Each block is a \"black box\" with defined inputs and outputs. You don't need to think about the internal gates\u2014just connect the blocks correctly.</p> <p>This modular approach scales to enormous complexity:</p> <ul> <li>A simple CPU might use hundreds of these blocks</li> <li>A modern processor uses billions of transistors organized into these functional modules</li> <li>System-on-chip designs integrate memory, I/O, and processing\u2014all from the same building blocks</li> </ul>"},{"location":"chapters/06-combinational-building-blocks/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've stocked your digital toolbox with the fundamental building blocks of combinational logic. Here's your inventory:</p> <p>Selection and Routing:</p> <ul> <li>Multiplexers (MUX): Select one of many inputs</li> <li>Demultiplexers (DEMUX): Route one input to many outputs</li> <li>MUXes can implement any Boolean function!</li> </ul> <p>Code Conversion:</p> <ul> <li>Encoders: Compress one-hot to binary</li> <li>Priority encoders: Handle multiple active inputs gracefully</li> <li>Decoders: Expand binary to one-hot</li> <li>7-segment decoders: Drive numeric displays</li> </ul> <p>Comparison:</p> <ul> <li>Equality comparators: Test A = B</li> <li>Magnitude comparators: Determine A &gt; B, A = B, or A &lt; B</li> <li>Cascading enables comparison of larger numbers</li> </ul> <p>Arithmetic:</p> <ul> <li>Half adder: Add two bits, produce sum and carry</li> <li>Full adder: Add three bits (includes carry-in)</li> <li>Ripple carry adder: Cascade full adders for multi-bit addition</li> <li>Carry lookahead: Faster addition at the cost of more gates</li> <li>Adder-subtractor: Two's complement enables subtract using add</li> </ul> <p>Error Detection:</p> <ul> <li>Parity generator/checker: Simple single-bit error detection</li> <li>XOR is the key operation for parity</li> </ul> <p>Bus Control:</p> <ul> <li>Tri-state buffers: Three output states (0, 1, Z)</li> <li>Enable shared buses without conflicts</li> </ul> <p>System Integration:</p> <ul> <li>ALU: Combines arithmetic and logic operations</li> <li>Function select chooses the operation</li> <li>Status flags (Z, N, C, V) report results</li> </ul> <p>Key Insight</p> <p>Digital systems are built from proven, modular components. Just as a builder uses standard-sized doors and windows, you'll use standard MUXes, decoders, adders, and comparators. Understanding these building blocks transforms you from a gate-level designer into a system architect.</p> Graphic Novel Suggestion <p>A fascinating graphic novel could follow Claude Shannon, the father of information theory, as he develops the mathematical foundations of digital circuit design at MIT and Bell Labs in the 1930s-40s. The story could show young Shannon's insight that Boolean algebra could model telephone switching circuits, leading to his legendary master's thesis\u2014often called the most important master's thesis of the 20th century. The visual medium would brilliantly capture his relay circuits transforming into the digital logic we use today, connecting the abstract symbols of Boolean algebra to the physical circuits that power our modern world.</p>"},{"location":"chapters/06-combinational-building-blocks/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: MUX Selection <p>A 4-to-1 MUX has inputs D\u2080=1, D\u2081=0, D\u2082=1, D\u2083=0 and select inputs S\u2081=1, S\u2080=0. What is the output Y?</p> <p>Solution: With S\u2081S\u2080 = 10, the MUX selects input D\u2082. Since D\u2082 = 1, the output Y = 1.</p> Problem 2: Decoder Outputs <p>For a 3-to-8 decoder with input A\u2082A\u2081A\u2080 = 101, which output is active?</p> <p>Solution: The input 101 in binary equals 5 in decimal. Therefore, output Y\u2085 is active (HIGH), and all other outputs (Y\u2080-Y\u2084, Y\u2086-Y\u2087) are inactive (LOW).</p> Problem 3: Priority Encoder <p>A 4-to-2 priority encoder has inputs D\u2083=0, D\u2082=1, D\u2081=1, D\u2080=0 with D\u2083 as highest priority. What is the output?</p> <p>Solution: Multiple inputs are active (D\u2082 and D\u2081). The highest priority active input is D\u2082. Therefore: A\u2081A\u2080 = 10 (binary for 2), V = 1 (valid output).</p> Problem 4: Full Adder <p>What are the Sum and Carry-out for a full adder with A=1, B=1, C\u1d62\u2099=1?</p> <p>Solution: Sum = A \u2295 B \u2295 C\u1d62\u2099 = 1 \u2295 1 \u2295 1 = 0 \u2295 1 = 1 C\u2092\u1d64\u209c = AB + C\u1d62\u2099(A \u2295 B) = 1\u00b71 + 1\u00b7(1\u22951) = 1 + 1\u00b70 = 1</p> <p>In decimal: 1 + 1 + 1 = 3, which is 11 in binary (Sum=1, Carry=1). \u2713</p> Problem 5: Ripple Carry Delay <p>A ripple carry adder has 8 full adders, each with a gate delay of 2 ns. What is the worst-case delay for the carry to propagate from C\u2080 to C\u2088?</p> <p>Solution: Worst case: carry must ripple through all 8 stages. Each stage contributes its carry path delay. Total delay = 8 \u00d7 2 ns = 16 ns.</p> <p>(In practice, the delay might be slightly different depending on gate structure, but the linear relationship holds.)</p> Problem 6: Parity Check <p>Data 10110 is received with even parity (the last bit is the parity bit). Is there an error?</p> <p>Solution: Count the 1s in the received data: 1+0+1+1+0 = 3 (odd). For even parity, the total should be even. Since we have an odd count, an error is detected!</p> Problem 7: MUX as Logic <p>Implement the function F(A,B) = AB + \u0100B\u0304 (XNOR) using a 4-to-1 MUX.</p> <p>Solution: Use A as S\u2081 and B as S\u2080. Fill in data inputs from the truth table:</p> <ul> <li>AB = 00: F = 1 \u2192 D\u2080 = 1</li> <li>AB = 01: F = 0 \u2192 D\u2081 = 0</li> <li>AB = 10: F = 0 \u2192 D\u2082 = 0</li> <li>AB = 11: F = 1 \u2192 D\u2083 = 1</li> </ul> <p>Connect: S\u2081=A, S\u2080=B, D\u2080=1, D\u2081=0, D\u2082=0, D\u2083=1. Output Y gives F = XNOR.</p> Problem 8: Tri-State Bus <p>Three devices A, B, C connect to a shared bus via tri-state buffers. Device A wants to send 1, B wants to send 0, C wants to send 1. If only device B is enabled, what is the bus value?</p> <p>Solution: Since only device B's buffer is enabled:</p> <ul> <li>Device A: disabled \u2192 high-Z (disconnected)</li> <li>Device B: enabled, driving 0 \u2192 BUS = 0</li> <li>Device C: disabled \u2192 high-Z (disconnected)</li> </ul> <p>The bus value is 0.</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/","title":"Quiz: Combinational Building Blocks","text":"<p>Test your understanding of multiplexers, decoders, encoders, adders, and other combinational building blocks.</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#1-how-many-select-lines-does-a-4-to-1-multiplexer-require","title":"1. How many select lines does a 4-to-1 multiplexer require?","text":"<ol> <li>1</li> <li>2</li> <li>4</li> <li>8</li> </ol> Show Answer <p>The correct answer is B. A 4-to-1 MUX needs 2 select lines because 2\u00b2 = 4. In general, a 2\u207f-to-1 multiplexer requires n select lines to choose among the inputs.</p> <p>Concept Tested: MUX 4-to-1</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#2-what-is-the-output-of-a-2-to-4-decoder-when-the-input-is-10-binary","title":"2. What is the output of a 2-to-4 decoder when the input is 10 (binary)?","text":"<ol> <li>Y0 = 1, all others 0</li> <li>Y1 = 1, all others 0</li> <li>Y2 = 1, all others 0</li> <li>Y3 = 1, all others 0</li> </ol> Show Answer <p>The correct answer is C. A 2-to-4 decoder activates exactly one output based on the binary input value. Input 10 (decimal 2) activates output Y2. The decoder converts the binary code to a one-hot output.</p> <p>Concept Tested: 2-to-4 Decoder</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#3-what-is-the-purpose-of-a-priority-encoder","title":"3. What is the purpose of a priority encoder?","text":"<ol> <li>To convert binary to one-hot encoding</li> <li>To output the code for the highest-priority active input</li> <li>To generate parity bits</li> <li>To add two binary numbers</li> </ol> Show Answer <p>The correct answer is B. A priority encoder produces a binary code corresponding to the highest-priority active input when multiple inputs are asserted simultaneously. Lower-priority inputs are ignored. It also typically provides a \"valid\" output.</p> <p>Concept Tested: Priority Encoder</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#4-in-a-half-adder-what-are-the-two-outputs","title":"4. In a half adder, what are the two outputs?","text":"<ol> <li>AND and OR</li> <li>Sum and Carry</li> <li>Select and Enable</li> <li>Data and Control</li> </ol> Show Answer <p>The correct answer is B. A half adder has two outputs: Sum (S) and Carry (C). For inputs A and B: Sum = A XOR B, Carry = A AND B. It's called \"half\" because it cannot accept a carry input from a previous stage.</p> <p>Concept Tested: Half Adder</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#5-what-advantage-does-a-full-adder-have-over-a-half-adder","title":"5. What advantage does a full adder have over a half adder?","text":"<ol> <li>It uses fewer gates</li> <li>It can accept a carry input from a previous stage</li> <li>It operates faster</li> <li>It handles negative numbers</li> </ol> Show Answer <p>The correct answer is B. A full adder has three inputs: A, B, and Carry-in (Cin). This allows full adders to be chained together to build multi-bit adders like ripple-carry adders. A half adder cannot be chained this way.</p> <p>Concept Tested: Full Adder</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#6-how-can-a-multiplexer-implement-any-boolean-function","title":"6. How can a multiplexer implement any Boolean function?","text":"<ol> <li>By using the output as a clock</li> <li>By connecting function inputs to select lines and truth table values to data inputs</li> <li>By adding feedback from output to input</li> <li>It cannot implement arbitrary functions</li> </ol> Show Answer <p>The correct answer is B. A 2\u207f-to-1 MUX can implement any n-variable function by connecting the input variables to the select lines and connecting the truth table output values (0 or 1) to the corresponding data inputs.</p> <p>Concept Tested: MUX as Logic Function</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#7-what-is-carry-propagation-delay-in-a-ripple-carry-adder","title":"7. What is carry propagation delay in a ripple-carry adder?","text":"<ol> <li>The time for the first bit to compute</li> <li>The time for carries to ripple through all stages</li> <li>The clock period required</li> <li>The delay of a single gate</li> </ol> Show Answer <p>The correct answer is B. In a ripple-carry adder, each bit position must wait for the carry from the previous position. The total delay is proportional to the bit width, as the carry must \"ripple\" through all stages sequentially.</p> <p>Concept Tested: Carry Propagation Delay</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#8-what-is-the-function-of-a-7-segment-decoder","title":"8. What is the function of a 7-segment decoder?","text":"<ol> <li>To decode memory addresses</li> <li>To convert BCD or binary to 7-segment display signals</li> <li>To add seven numbers together</li> <li>To divide a frequency by 7</li> </ol> Show Answer <p>The correct answer is B. A 7-segment decoder takes a binary or BCD input and generates the seven output signals needed to display the corresponding digit on a 7-segment LED display. Each segment is driven based on which digit is being displayed.</p> <p>Concept Tested: 7-Segment Decoder</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#9-what-does-a-magnitude-comparator-output-when-a-b","title":"9. What does a magnitude comparator output when A &gt; B?","text":"<ol> <li>Only the \"equal\" output is high</li> <li>Only the \"A greater than B\" output is high</li> <li>All outputs are high</li> <li>All outputs are low</li> </ol> Show Answer <p>The correct answer is B. A magnitude comparator has three outputs: A&gt;B, AB output is high; the others are low. <p>Concept Tested: Magnitude Comparator</p>"},{"location":"chapters/06-combinational-building-blocks/quiz/#10-what-is-the-purpose-of-an-enable-input-on-a-decoder","title":"10. What is the purpose of an enable input on a decoder?","text":"<ol> <li>To increase the number of outputs</li> <li>To control whether any output is active</li> <li>To select between multiple decoders</li> <li>To invert all outputs</li> </ol> Show Answer <p>The correct answer is B. The enable input controls whether the decoder is active. When disabled, all outputs are deasserted regardless of the input code. This allows building larger decoders from smaller ones and implementing memory address decoding.</p> <p>Concept Tested: Decoder Enable</p>"},{"location":"chapters/07-intro-sequential-logic/","title":"Introduction to Sequential Logic","text":""},{"location":"chapters/07-intro-sequential-logic/#summary","title":"Summary","text":"<p>This chapter marks the conceptual leap from combinational to sequential logic, where circuits can store information and their outputs depend on both current inputs and past history. Students will learn about memory elements, the concept of state, feedback loops in circuits, bistable elements, and latches including SR and D latches. The chapter also covers level-sensitive behavior, timing problems with latches, race conditions, and introduces clock signals as the foundation for synchronous design. Understanding these concepts is essential before studying flip-flops and finite state machines.</p>"},{"location":"chapters/07-intro-sequential-logic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Memory Element</li> <li>State Concept</li> <li>Feedback Loop</li> <li>Bistable Element</li> <li>SR Latch</li> <li>SR Latch Truth Table</li> <li>Invalid State Problem</li> <li>Gated SR Latch</li> <li>D Latch</li> <li>Level Sensitive</li> <li>Transparent Latch</li> <li>Latch Timing Problem</li> <li>Race Condition</li> <li>Clock Signal</li> <li>Clock Edge</li> <li>Rising Edge</li> <li>Falling Edge</li> <li>Clock Period</li> <li>Clock Frequency</li> <li>Duty Cycle</li> </ol>"},{"location":"chapters/07-intro-sequential-logic/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul>"},{"location":"chapters/07-intro-sequential-logic/#introduction-when-circuits-learn-to-remember","title":"Introduction: When Circuits Learn to Remember","text":"<p>You've spent the last several chapters mastering combinational logic\u2014circuits that are, frankly, a bit forgetful. Give a combinational circuit an input, it produces an output. Remove the input, and poof! It has absolutely no idea what just happened. It's like a goldfish, but made of transistors.</p> <p>But here's the thing: real computers need to remember things. Your laptop remembers your files. Your phone remembers your contacts. Even your microwave remembers how long to cook that burrito (well, until you unplug it).</p> <p>Welcome to sequential logic\u2014the moment when circuits gain the superpower of memory. This is arguably the most important conceptual leap in digital electronics. After this chapter, you'll understand how it's possible for a circuit made of simple logic gates to actually store information.</p> <p>Fair warning: this chapter is going to feel different. We're not just learning new gates or optimization tricks. We're fundamentally changing how we think about circuits. By the end, the phrase \"the output depends on the history of inputs\" will make perfect sense, and you'll wonder how you ever thought about digital systems without it.</p> <p>Let's teach some gates to remember.</p>"},{"location":"chapters/07-intro-sequential-logic/#memory-elements-the-foundation-of-sequential-logic","title":"Memory Elements: The Foundation of Sequential Logic","text":"<p>A memory element is any circuit that can store one bit of information. That's it. One measly bit\u2014a single 0 or 1. But don't let the simplicity fool you. From this humble beginning springs everything from the registers in your CPU to the gigabytes in your SSD.</p> <p>What makes a memory element different from combinational logic? Two key properties:</p> <ol> <li>It has a stored value that persists over time</li> <li>Its output depends on this stored value, not just current inputs</li> </ol> <p>Think of a light switch. Flip it up, the light turns on. Flip it down, the light turns off. But here's the important part: let go of the switch, and it stays where you put it. The switch \"remembers\" whether you last pushed it up or down. That's memory!</p> <p>Compare this to a doorbell button. Press it, the bell rings. Release it, the bell stops. The doorbell has no memory\u2014it only responds to what's happening right now.</p> Circuit Type Example Output Depends On Memory? Combinational Doorbell Current input only No Sequential Light switch Stored state Yes <p>Memory elements are the building blocks we'll use to construct latches, flip-flops, registers, and eventually entire computers. Before we build them, though, we need to understand what we're actually storing.</p>"},{"location":"chapters/07-intro-sequential-logic/#the-state-concept-what-sequential-circuits-remember","title":"The State Concept: What Sequential Circuits Remember","text":"<p>In sequential logic, we use the word state to describe what a circuit is remembering at any given moment. The state is like a snapshot of the circuit's internal condition.</p> <p>For a simple 1-bit memory element, the state is just that single bit: either 0 or 1. For a more complex sequential circuit\u2014say, a counter that counts from 0 to 7\u2014the state might be a 3-bit number representing the current count.</p> <p>Here's the key insight: in sequential logic, the output depends on both the current input AND the current state.</p> <p>Let's make this concrete with a simple example. Imagine a \"lock\" circuit with two inputs:</p> <ul> <li>Set: When you pulse this, the output goes to 1</li> <li>Reset: When you pulse this, the output goes to 0</li> </ul> <p>The output doesn't just depend on what inputs are active right now. It depends on which input was last pulsed. If you last pressed Set, the output is 1. If you last pressed Reset, the output is 0. The circuit remembers.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-state-concept-visualizer","title":"Diagram: State Concept Visualizer","text":"State Concept Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how the state of a sequential circuit determines its behavior, and how the same input can produce different outputs depending on the current state.</p> <p>Instructional Rationale: Concrete visualization of state transitions helps students grasp the abstract concept of \"memory\" in circuits. Showing the same input producing different outputs based on state crystallizes understanding.</p> <p>Canvas Layout:</p> <ul> <li>Left: Simple sequential circuit symbol (box with Q output)</li> <li>Center: State indicator showing current state (0 or 1)</li> <li>Right: Input/output history log</li> <li>Bottom: Input buttons (Set, Reset) and state transition visualization</li> </ul> <p>Interactive Elements:</p> <ul> <li>\"Set\" button to pulse the set input</li> <li>\"Reset\" button to pulse the reset input</li> <li>Current state prominently displayed</li> <li>History log showing sequence of inputs and resulting states</li> <li>Highlight when same input gives different result (won't happen here but sets up concept)</li> <li>\"What determines Q?\" question with answer based on history</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state Q displayed large</li> <li>Previous state shown faded</li> <li>Input history as timeline</li> <li>Output history aligned with inputs</li> <li>Annotation: \"Q depends on LAST input, not current\"</li> </ul> <p>Visual Style:</p> <ul> <li>Clean state diagram with two states (Q=0, Q=1)</li> <li>Arrows showing transitions on Set/Reset</li> <li>Current state highlighted</li> <li>History log scrolls as interactions occur</li> </ul> <p>Implementation: p5.js with state machine and history tracking</p>"},{"location":"chapters/07-intro-sequential-logic/#state-diagrams-visualizing-memory","title":"State Diagrams: Visualizing Memory","text":"<p>We often draw state diagrams to visualize sequential circuits. A state diagram shows:</p> <ul> <li>States as circles (or bubbles)</li> <li>Transitions as arrows between states</li> <li>Labels on arrows showing what input causes each transition</li> </ul> <p>For our Set/Reset example, the state diagram would have two states (Q=0 and Q=1), with arrows showing how Set moves you to Q=1 and Reset moves you to Q=0.</p> <p>State diagrams will become your best friend when we reach finite state machines in later chapters. For now, just understand that they're a visual way to represent what a circuit remembers and how its memory changes.</p>"},{"location":"chapters/07-intro-sequential-logic/#feedback-loops-how-memory-happens","title":"Feedback Loops: How Memory Happens","text":"<p>So how does a circuit actually remember? The secret ingredient is feedback\u2014connecting an output back to an input.</p> <p>A feedback loop occurs when the output of a circuit is routed back and used as one of its inputs. This creates a cycle where the circuit can influence its own future behavior.</p> <p>Consider what happens with a simple inverter (NOT gate) whose output is connected to its input. If the output is 1, the input becomes 1, so the output becomes 0. But now the input is 0, so the output becomes 1 again. And around and around we go! This circuit would actually oscillate rapidly (it's the basis of a ring oscillator), which isn't memory\u2014it's instability.</p> <p>But what if we use two inverters in a loop?</p> <pre><code>       +---[NOT]---+\n       |           |\n   Q \u2190-+           +\u2192 Q\u0304\n       |           |\n       +---[NOT]---+\n</code></pre> <p>Now something interesting happens. If Q is 1, the top inverter outputs 0 (which is \\(\\overline{Q}\\)), and the bottom inverter outputs 1 (which matches Q). The circuit is stable! Similarly, if Q is 0, the top inverter outputs 1, and the bottom inverter outputs 0. Also stable!</p> <p>We've just created a circuit with two stable states. It can sit happily at Q=0 or Q=1, and it will stay there until something forces it to change. This is the essence of memory.</p> <p>The Feedback Principle</p> <p>Memory in digital circuits comes from feedback. By connecting outputs back to inputs, a circuit can maintain its state indefinitely. The challenge is designing feedback loops that are stable and controllable.</p>"},{"location":"chapters/07-intro-sequential-logic/#bistable-elements-the-two-state-building-block","title":"Bistable Elements: The Two-State Building Block","text":"<p>A bistable element is a circuit with exactly two stable states. \"Bi\" means two, and \"stable\" means the circuit will happily remain in either state without external forcing.</p> <p>The two-inverter loop we just discussed is a bistable element. It can be in state Q=0 (with \\(\\overline{Q}\\)=1) or state Q=1 (with \\(\\overline{Q}\\)=0). Once it's in one of these states, it stays there.</p> <p>But there's a problem with our simple two-inverter loop: we have no way to control which state it's in! We can't set it to 1 or reset it to 0. The circuit has memory, but we can't write to that memory.</p> <p>What we need is a bistable element with inputs that let us control the state. That's where latches come in.</p> <p>Think of a bistable element like a ball in a valley between two hills. The ball can rest in either valley (two stable states), but it won't stay on top of a hill (those would be unstable states). To move the ball from one valley to the other, you need to give it a push\u2014that's what the inputs will do.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-bistable-element-concept","title":"Diagram: Bistable Element Concept","text":"Bistable Element Ball-and-Valley Analogy <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Describe</p> <p>Learning Objective: Students will be able to describe how a bistable element maintains one of two stable states using the ball-and-valley physical analogy.</p> <p>Instructional Rationale: Physical analogies make abstract circuit concepts tangible. The ball-and-valley metaphor is widely used and builds intuition for stability in feedback systems.</p> <p>Canvas Layout:</p> <ul> <li>Top: Cross-section showing two valleys with hill between</li> <li>Ball that can rest in either valley</li> <li>Labels for \"State 0\" and \"State 1\" valleys</li> <li>Bottom: Circuit diagram showing cross-coupled inverters or NOR gates</li> <li>Side: State indicator matching ball position</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click in valley to move ball to that state</li> <li>Ball animates rolling to stable position</li> <li>Corresponding circuit diagram highlights matching state</li> <li>\"Push left\" and \"Push right\" buttons for controlled transitions</li> <li>Show ball wobbling if placed on unstable hill point</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state clearly displayed</li> <li>Ball position matches circuit state</li> <li>\"Stable\" indicator when ball is in valley</li> <li>\"Unstable\" warning if ball is on hill</li> </ul> <p>Visual Style:</p> <ul> <li>Smooth 2D side-view of energy landscape</li> <li>Ball with physics-based rolling animation</li> <li>Circuit diagram synchronized with ball position</li> <li>Valleys labeled as 0 and 1</li> </ul> <p>Implementation: p5.js with simple physics for ball animation</p>"},{"location":"chapters/07-intro-sequential-logic/#the-sr-latch-your-first-real-memory-circuit","title":"The SR Latch: Your First Real Memory Circuit","text":"<p>Time to build something practical! The SR latch (also called Set-Reset latch) is the simplest memory element with controllable inputs. It has two inputs:</p> <ul> <li>S (Set): Makes the output go to 1</li> <li>R (Reset): Makes the output go to 0</li> </ul> <p>And two outputs:</p> <ul> <li>Q: The stored state</li> <li>\\(\\overline{Q}\\): The complement of Q</li> </ul> <p>The SR latch can be built from two cross-coupled NOR gates:</p> <pre><code>    S \u2500\u2500\u252c\u2500\u2500[NOR]\u2500\u2500\u252c\u2500\u2500 Q\u0304\n        \u2502         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n             \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n        \u2502         \u2502\n    R \u2500\u2500\u2534\u2500\u2500[NOR]\u2500\u2500\u2534\u2500\u2500 Q\n</code></pre> <p>Wait, let me draw that more clearly. Each NOR gate has two inputs: one from the external input (S or R) and one from the output of the other NOR gate. This cross-coupling creates the feedback loop that enables memory.</p> <p>How does it work? Let's trace through the logic:</p> <p>When S=0 and R=0 (Hold mode): The latch remembers its previous state. If Q was 1, it stays 1. If Q was 0, it stays 0. This is the memory state!</p> <p>When S=1 and R=0 (Set mode): The S input forces the upper NOR gate output (\\(\\overline{Q}\\)) to 0 (because any 1 input to NOR produces 0). This means the lower NOR gate sees R=0 and \\(\\overline{Q}\\)=0, so it outputs 1. Q becomes 1.</p> <p>When S=0 and R=1 (Reset mode): By similar logic, Q becomes 0 and \\(\\overline{Q}\\) becomes 1.</p> <p>When S=1 and R=1 (Forbidden!): Both NOR outputs are forced to 0. So Q=0 and \\(\\overline{Q}\\)=0. But wait... Q and \\(\\overline{Q}\\) are supposed to be complements! This is the invalid state, and we'll discuss why it's problematic soon.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-sr-latch-interactive","title":"Diagram: SR Latch Interactive","text":"SR Latch NOR Gate Implementation <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how an SR latch stores and changes state by manipulating the Set and Reset inputs and observing the feedback behavior.</p> <p>Instructional Rationale: Interactive manipulation of S and R inputs with real-time circuit simulation builds operational understanding of how the latch responds to different input combinations.</p> <p>Canvas Layout:</p> <ul> <li>Center: Circuit diagram with two cross-coupled NOR gates</li> <li>Left: S and R input toggles</li> <li>Right: Q and Q\u0304 output displays</li> <li>Bottom: Current mode indicator (Hold, Set, Reset, Invalid)</li> <li>Top: State history timeline</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for S and R inputs</li> <li>Real-time signal propagation animation through gates</li> <li>Output values update as inputs change</li> <li>Mode indicator shows current operation</li> <li>Warning indicator when S=R=1</li> <li>Animation showing signal flow through feedback path</li> <li>\"Trace signal\" mode to follow logic step by step</li> </ul> <p>Data Visibility:</p> <ul> <li>Current S, R values</li> <li>Current Q, Q\u0304 values</li> <li>Previous Q value (for hold comparison)</li> <li>Mode name displayed</li> <li>Invalid state warning when applicable</li> </ul> <p>Visual Style:</p> <ul> <li>Standard NOR gate symbols</li> <li>Signal wires show logic levels as colors (blue=0, orange=1)</li> <li>Feedback paths clearly visible</li> <li>Invalid state shown with red warning overlay</li> <li>Smooth transitions when state changes</li> </ul> <p>Implementation: p5.js with gate-level simulation and animation</p>"},{"location":"chapters/07-intro-sequential-logic/#sr-latch-truth-table-the-complete-behavior","title":"SR Latch Truth Table: The Complete Behavior","text":"<p>Let's formalize the SR latch behavior with a truth table. But this truth table is different from combinational logic tables\u2014we need to include the previous state because the output depends on history.</p> S R Q (next) \\(\\overline{Q}\\) (next) Operation 0 0 Q (no change) \\(\\overline{Q}\\) (no change) Hold 0 1 0 1 Reset 1 0 1 0 Set 1 1 0 0 Invalid! <p>The notation \"Q (no change)\" means the output stays whatever it was before. This is the memory behavior.</p> <p>You can also write this using the notation \\(Q^+\\) for \"next state of Q\":</p> \\[Q^+ = S + \\overline{R} \\cdot Q\\] <p>This equation says: the next state is 1 if you're setting (S=1) OR if you're not resetting (R=0) AND you're already at 1 (Q=1).</p> <p>The S=R=1 Problem</p> <p>When both S and R are 1 simultaneously, the SR latch enters an invalid state where both outputs are 0. This violates the fundamental property that Q and \\(\\overline{Q}\\) should be complements. Even worse, when both inputs return to 0, the final state is unpredictable\u2014it depends on which input goes to 0 first and the exact gate delays. This is a race condition, which we'll explore soon.</p>"},{"location":"chapters/07-intro-sequential-logic/#the-invalid-state-problem-when-memory-gets-confused","title":"The Invalid State Problem: When Memory Gets Confused","text":"<p>The invalid state problem is a fundamental issue with the basic SR latch: what happens when you simultaneously tell it to set AND reset?</p> <p>When S=R=1:</p> <ol> <li>Both NOR gates have at least one input at 1</li> <li>So both NOR gates output 0</li> <li>Q=0 and \\(\\overline{Q}\\)=0 (violating the complementary relationship)</li> </ol> <p>This is bad, but it gets worse. What happens when you release both inputs (S=R=0)?</p> <p>Both NOR gates now see 0 from their external input and 0 from the other gate (since both outputs are currently 0). According to NOR logic, 0 NOR 0 = 1. So both gates try to output 1!</p> <p>But wait\u2014if both outputs become 1, each gate now sees a 1 from the other gate, so both outputs become 0 again. We're in an unstable oscillation.</p> <p>In reality, perfect symmetry doesn't exist. One gate is always slightly faster. Whichever gate \"wins\" the race determines the final state. This is non-deterministic behavior\u2014the circuit might end up in either state, and we can't predict which.</p> <p>This is unacceptable for reliable digital design. The solution? Don't allow S=R=1. We can either:</p> <ol> <li>Trust the designer never to apply this condition (risky!)</li> <li>Add logic to prevent it (gated latches)</li> <li>Use a different latch design that doesn't have this problem (D latch)</li> </ol>"},{"location":"chapters/07-intro-sequential-logic/#diagram-invalid-state-demonstration","title":"Diagram: Invalid State Demonstration","text":"SR Latch Invalid State and Race Condition <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine what happens during and after the S=R=1 condition, understanding why this creates unpredictable behavior due to race conditions.</p> <p>Instructional Rationale: Seeing the race condition in action\u2014with randomized \"winner\"\u2014makes the problem concrete and explains why this input combination must be avoided.</p> <p>Canvas Layout:</p> <ul> <li>Center: SR latch circuit with gate delay simulation</li> <li>Top: Input controls for S and R</li> <li>Right: Race animation when both inputs go high then low</li> <li>Bottom: Results log showing random outcomes of repeated races</li> <li>Side: Explanation panel</li> </ul> <p>Interactive Elements:</p> <ul> <li>Set S=R=1 button to demonstrate invalid state</li> <li>\"Release both\" button to trigger race condition</li> <li>Randomized race outcome (different each time)</li> <li>Slow-motion playback of gate propagation</li> <li>Statistics counter for race outcomes over many trials</li> <li>Reset to clear statistics</li> </ul> <p>Data Visibility:</p> <ul> <li>Current Q and Q\u0304 values</li> <li>Gate propagation delays (with slight random variation)</li> <li>Race winner highlighted</li> <li>Statistics: how many times each state won</li> <li>Invalid state warning</li> </ul> <p>Visual Style:</p> <ul> <li>Animated signal propagation with timing</li> <li>Racing signals shown as moving pulses</li> <li>Winner/loser highlighted when race completes</li> <li>Statistics as bar chart</li> <li>Warning colors for invalid condition</li> </ul> <p>Implementation: p5.js with randomized timing and race simulation</p>"},{"location":"chapters/07-intro-sequential-logic/#the-gated-sr-latch-adding-control","title":"The Gated SR Latch: Adding Control","text":"<p>The gated SR latch (also called enabled SR latch or clocked SR latch) adds an enable input that controls when the latch responds to S and R.</p> <p>When Enable=0, the latch ignores S and R completely\u2014it just holds its current state. When Enable=1, the latch responds to S and R normally.</p> <p>This is implemented by ANDing the S and R inputs with the Enable signal before they reach the basic SR latch:</p> <pre><code>S \u2500\u2500[AND]\u2500\u2500\u2510\n     \u2191     \u2502\nEnable\u2500\u2500\u2500\u2500\u2500\u2524    [Basic SR Latch]\u2500\u2500\u2192 Q, Q\u0304\n     \u2193     \u2502\nR \u2500\u2500[AND]\u2500\u2500\u2518\n</code></pre> <p>Now we have control over when the latch is allowed to change. This is a stepping stone toward clock-controlled circuits.</p> Enable S R Q (next) Operation 0 X X Q (hold) Disabled\u2014inputs ignored 1 0 0 Q (hold) Enabled\u2014hold 1 0 1 0 Enabled\u2014reset 1 1 0 1 Enabled\u2014set 1 1 1 ? Enabled\u2014still invalid! <p>The X means \"don't care\"\u2014when Enable=0, it doesn't matter what S and R are.</p> <p>The Enable Signal</p> <p>The Enable input is sometimes called G (for Gate), EN, or even CLK (when used with a clock). Regardless of name, its purpose is the same: control when the latch is allowed to change state.</p>"},{"location":"chapters/07-intro-sequential-logic/#the-d-latch-eliminating-the-invalid-state","title":"The D Latch: Eliminating the Invalid State","text":"<p>The D latch (Data latch) is a brilliant solution to the invalid state problem. Instead of having separate Set and Reset inputs, it has just one data input: D.</p> <p>The idea is simple: connect D directly to where S would go, and connect \\(\\overline{D}\\) (the complement of D) to where R would go.</p> <pre><code>D \u2500\u2500[AND]\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2191         \u2502\nEnable\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    [Basic SR Latch]\u2500\u2500\u2192 Q, Q\u0304\n     \u2193         \u2502\nD \u2500\u2500[NOT]\u2500\u2500[AND]\u2500\u2500\u2518\n</code></pre> <p>Now look at what happens:</p> <ul> <li>When Enable=0: Latch holds (as before)</li> <li>When Enable=1 and D=1: S gets 1, R gets 0 \u2192 Q becomes 1</li> <li>When Enable=1 and D=0: S gets 0, R gets 1 \u2192 Q becomes 0</li> </ul> <p>The outputs Q simply follows D when enabled! And here's the magic: S and R can never both be 1 at the same time because they're derived from D and \\(\\overline{D}\\), which are always complements.</p> <p>Invalid state? Problem solved!</p> Enable D Q (next) Operation 0 X Q (hold) Disabled\u2014hold current state 1 0 0 Enabled\u2014Q follows D 1 1 1 Enabled\u2014Q follows D <p>The characteristic equation is beautifully simple:</p> \\[Q^+ = D \\cdot Enable + Q \\cdot \\overline{Enable}\\] <p>Or in words: \"The next state equals D if enabled, otherwise stay at current Q.\"</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-d-latch-operation","title":"Diagram: D Latch Operation","text":"D Latch Interactive Demonstration <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use a D latch to store a bit value by controlling the Enable signal and observing how Q follows D only when enabled.</p> <p>Instructional Rationale: Interactive manipulation with timing diagram output helps students understand the temporal relationship between D, Enable, and Q.</p> <p>Canvas Layout:</p> <ul> <li>Left: D latch circuit diagram (gates visible)</li> <li>Center: D and Enable input controls</li> <li>Right: Q output display with comparison to D</li> <li>Bottom: Rolling timing diagram showing D, Enable, Q over time</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle for D input (0 or 1)</li> <li>Toggle for Enable input</li> <li>Real-time timing diagram that scrolls</li> <li>Highlight when Q changes vs. holds</li> <li>\"Capture D\" animation when Enable goes high</li> <li>Comparison panel: \"D at last enable\" vs \"current Q\"</li> </ul> <p>Data Visibility:</p> <ul> <li>Current D, Enable, Q values</li> <li>Timing diagram with time axis</li> <li>\"Q follows D\" indicator when enabled</li> <li>\"Q holding\" indicator when disabled</li> <li>Value that Q captured when last enabled</li> </ul> <p>Visual Style:</p> <ul> <li>Clean D latch symbol and gate implementation</li> <li>Timing diagram with standard waveform look</li> <li>Color coding: D in blue, Enable in green, Q in orange</li> <li>Arrows showing causation (Enable rising \u2192 Q captures D)</li> </ul> <p>Implementation: p5.js with real-time timing diagram generation</p>"},{"location":"chapters/07-intro-sequential-logic/#level-sensitive-behavior-when-the-gate-is-open","title":"Level Sensitive Behavior: When the Gate is Open","text":"<p>The D latch exhibits level-sensitive behavior, meaning its ability to change depends on the level (high or low) of the Enable signal, not on transitions.</p> <p>When Enable is high (1), the latch is said to be transparent\u2014any changes to D pass straight through to Q. It's like having a window open: whatever's outside (D) appears inside (Q) immediately.</p> <p>When Enable is low (0), the latch is opaque\u2014it ignores D completely and holds its stored value. The window is closed; Q maintains whatever value it had when the window closed.</p> <p>This level sensitivity has important implications:</p> <ul> <li>While Enable=1, Q follows every change in D (even glitches!)</li> <li>The value stored is whatever D was at the moment Enable goes from 1 to 0</li> <li>If D changes while Enable is low, Q doesn't notice</li> </ul> <p>The term transparent latch comes from this behavior\u2014when enabled, the latch is \"transparent\" to the data signal.</p> <p>Transparency in Action</p> <p>Imagine Enable=1 and D switches from 0 \u2192 1 \u2192 0 \u2192 1 \u2192 0 rapidly. Q would follow every single transition! The latch \"sees\" all these changes. Only when Enable drops to 0 does Q freeze at whatever D happened to be at that instant.</p>"},{"location":"chapters/07-intro-sequential-logic/#the-transparent-latch-a-feature-and-a-problem","title":"The Transparent Latch: A Feature and a Problem","text":"<p>The transparency of level-sensitive latches is both useful and dangerous.</p> <p>Useful because:</p> <ul> <li>Simple to understand\u2014Q equals D when enabled</li> <li>Good for simple data capture applications</li> <li>Forms the basis of more sophisticated storage elements</li> </ul> <p>Dangerous because:</p> <ul> <li>Any noise or glitch on D while Enable is high goes straight to Q</li> <li>In complex systems, data might race through multiple latches in a single enable period</li> <li>Timing becomes tricky when you have multiple latches in sequence</li> </ul> <p>Here's a troubling scenario: Imagine two latches in series, both enabled by the same signal. Data enters the first latch and appears at its Q output. But that Q is connected to the second latch's D input, and the second latch is also enabled! The data might \"race through\" both latches in a single enable period.</p> <p>This is not what we want. We want data to move one stage at a time, in a controlled fashion. Level-sensitive latches make this difficult.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-transparent-latch-timing","title":"Diagram: Transparent Latch Timing","text":"Transparent Latch Behavior Visualization <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Differentiate</p> <p>Learning Objective: Students will be able to differentiate between transparent and opaque modes of a latch, understanding how the level of the enable signal affects whether changes in D affect Q.</p> <p>Instructional Rationale: Side-by-side comparison of D and Q with explicit transparency window marking helps students understand when the latch is \"open\" vs \"closed.\"</p> <p>Canvas Layout:</p> <ul> <li>Top: D input waveform with controls</li> <li>Middle: Enable signal with high period clearly marked</li> <li>Bottom: Q output showing response</li> <li>Right: Transparency indicator panel</li> <li>Overlay: \"Transparent window\" highlighting</li> </ul> <p>Interactive Elements:</p> <ul> <li>Programmable D pattern (sequence of changes)</li> <li>Enable duration control</li> <li>Play/pause animation</li> <li>Step through time</li> <li>Highlight transparency window on waveform</li> <li>Show exactly what value Q captures at Enable falling edge</li> </ul> <p>Data Visibility:</p> <ul> <li>D, Enable, Q waveforms aligned</li> <li>Transparency window shaded on Enable high period</li> <li>Captured value indicator at Enable falling edge</li> <li>\"Glitches pass through\" warning when applicable</li> </ul> <p>Visual Style:</p> <ul> <li>Standard timing diagram appearance</li> <li>Transparency window as semi-transparent green overlay</li> <li>Capture moment marked with vertical line</li> <li>Glitches in D shown in red if they appear in Q</li> </ul> <p>Implementation: p5.js with waveform animation and timing analysis</p>"},{"location":"chapters/07-intro-sequential-logic/#latch-timing-problems-when-level-sensitivity-hurts","title":"Latch Timing Problems: When Level Sensitivity Hurts","text":"<p>The latch timing problem refers to the challenges of using level-sensitive latches in systems with multiple storage elements.</p> <p>Consider a simple two-stage register where data should shift from Stage 1 to Stage 2 on each clock cycle:</p> <pre><code>D_in \u2192 [Latch 1] \u2192 [Latch 2] \u2192 D_out\n          \u2191           \u2191\n          Enable \u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Both latches share the same Enable. When Enable goes high:</p> <ol> <li>D_in enters Latch 1 and appears at its output</li> <li>But that output is connected to Latch 2's input!</li> <li>So the data immediately passes through to Latch 2's output</li> <li>Both latches have captured the same new value!</li> </ol> <p>We wanted data to move one stage per clock cycle, but it moved two stages. This is called data race-through, and it's a serious problem.</p> <p>The fundamental issue is that level-sensitive latches are transparent for the entire duration of the enable pulse. If that duration is long enough for data to propagate through the circuit, unwanted behavior results.</p> <p>Solutions to the latch timing problem:</p> <ol> <li>Use very short enable pulses: But this is unreliable and hard to guarantee</li> <li>Use two-phase non-overlapping clocks: Complex but workable</li> <li>Use edge-triggered flip-flops: This is the standard solution (next chapter!)</li> </ol>"},{"location":"chapters/07-intro-sequential-logic/#race-conditions-when-timing-creates-chaos","title":"Race Conditions: When Timing Creates Chaos","text":"<p>A race condition occurs when the behavior of a circuit depends on the relative timing of different signal paths. If small timing differences change the outcome, you have a race.</p> <p>We saw one race condition in the SR latch's invalid state: when S and R both go from 1 to 0, which gate wins determines the final state.</p> <p>In latch-based systems, race conditions appear in several forms:</p> <p>Data race-through: As we just discussed, data racing through multiple transparent latches.</p> <p>Hold time violations: If data changes too soon after the enable falls, the captured value might be corrupted.</p> <p>Setup time violations: If data hasn't been stable long enough before enable falls, the captured value might be wrong.</p> <p>Feedback races: In circuits with feedback, the order of signal arrival can determine behavior.</p> <p>Race conditions are nasty because they're non-deterministic. A circuit might work perfectly in the lab but fail in the field due to temperature changes, voltage variations, or manufacturing differences affecting timing.</p> <p>Racing is for Cars, Not Circuits</p> <p>Race conditions are among the hardest bugs to find and fix. The circuit might work 99.99% of the time, then mysteriously fail. Worse, adding debug probes might change the timing enough to make the race condition disappear! This is sometimes called a \"Heisenbug\"\u2014it disappears when you try to observe it.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-race-condition-demonstration","title":"Diagram: Race Condition Demonstration","text":"Race Condition in Two-Stage Latch System <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how race conditions occur in latch-based systems and why data can race through multiple transparent latches during a single enable period.</p> <p>Instructional Rationale: Visual animation of data racing through stages makes the abstract timing problem concrete and motivates the need for edge-triggered flip-flops.</p> <p>Canvas Layout:</p> <ul> <li>Top: Two D latches in series with connecting wire</li> <li>Middle: Shared Enable signal display</li> <li>Bottom: Timing diagram showing D1, Q1, Q2 waveforms</li> <li>Side: Race condition indicator and explanation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input data toggle</li> <li>Enable pulse trigger</li> <li>Adjustable enable pulse width</li> <li>Step-through mode showing propagation</li> <li>Highlight data path as it races through</li> <li>Counter: \"Stages traversed in one enable\"</li> </ul> <p>Data Visibility:</p> <ul> <li>Current values at each stage</li> <li>Enable duration vs. propagation delay</li> <li>Number of stages data traveled</li> <li>\"Race detected\" warning when data passes through multiple stages</li> <li>Timing margins displayed</li> </ul> <p>Visual Style:</p> <ul> <li>Data shown as colored pulse moving through circuit</li> <li>Enable window clearly marked</li> <li>Race path highlighted in red</li> <li>Timing diagram with propagation delays marked</li> </ul> <p>Implementation: p5.js with configurable timing and race detection</p>"},{"location":"chapters/07-intro-sequential-logic/#clock-signals-the-heartbeat-of-digital-systems","title":"Clock Signals: The Heartbeat of Digital Systems","text":"<p>Enter the clock signal\u2014the regular, periodic pulse that synchronizes everything in a digital system. The clock is like the heartbeat of your circuit, telling all the sequential elements when to \"tick.\"</p> <p>A clock signal is simply a square wave that alternates between high (1) and low (0) at regular intervals:</p> <pre><code>     \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\nCLK: \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502\n     \u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\n     \u2190T\u2192\n</code></pre> <p>The clock provides:</p> <ul> <li>Synchronization: All elements update at the same time</li> <li>Predictability: We know exactly when state changes occur</li> <li>Noise immunity: Changes only happen at clock edges, reducing sensitivity to glitches</li> </ul> <p>In a synchronous digital system (which is what almost all modern digital systems are), all sequential elements are controlled by the same clock. This makes timing analysis tractable and behavior predictable.</p> <p>Why Clocks Matter</p> <p>The introduction of clocked synchronous design in the 1950s was revolutionary. It transformed digital design from a timing nightmare into a manageable engineering discipline. Instead of worrying about every signal's timing, you only need to ensure signals are stable at clock edges.</p>"},{"location":"chapters/07-intro-sequential-logic/#clock-edges-the-moments-that-matter","title":"Clock Edges: The Moments That Matter","text":"<p>When using clocks, we care about specific moments called clock edges\u2014the transitions between low and high (or vice versa).</p> <p>A clock edge is the instant when the clock signal changes value. There are two types:</p> <ul> <li>Rising edge (positive edge): Clock goes from 0 to 1</li> <li>Falling edge (negative edge): Clock goes from 1 to 0</li> </ul> <p>In edge-triggered circuits (which we'll study next chapter), state changes occur only at clock edges, not during the entire high or low period. This solves the transparency problem of level-sensitive latches.</p> <pre><code>         Rising    Falling   Rising\n         Edge      Edge      Edge\n           \u2193         \u2193         \u2193\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\nCLK: \u2502     \u2502     \u2502     \u2502     \u2502\n\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Most digital systems use rising-edge triggering because it's slightly easier to implement, but falling-edge triggering works equally well.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-clock-signal-and-edges","title":"Diagram: Clock Signal and Edges","text":"Clock Signal Properties Visualizer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Identify</p> <p>Learning Objective: Students will be able to identify rising and falling edges in a clock signal and understand how these edges serve as triggering events for sequential circuits.</p> <p>Instructional Rationale: Interactive clock visualization with highlighted edges helps students recognize the precise moments when state changes occur in edge-triggered systems.</p> <p>Canvas Layout:</p> <ul> <li>Center: Large clock waveform display</li> <li>Markers highlighting rising and falling edges</li> <li>Bottom: Clock parameters (period, frequency, duty cycle)</li> <li>Side: Edge counter and edge type indicators</li> </ul> <p>Interactive Elements:</p> <ul> <li>Adjustable clock frequency (slow for visualization)</li> <li>Rising edge highlight toggle</li> <li>Falling edge highlight toggle</li> <li>Click on edge to see \"trigger event\" indicator</li> <li>Edge counter incrementing with each edge</li> <li>Pause/play clock</li> </ul> <p>Data Visibility:</p> <ul> <li>Current clock level (high/low)</li> <li>Time since last edge</li> <li>Edge type of most recent edge</li> <li>Running count of rising and falling edges</li> <li>Clock parameters (period, frequency, duty cycle)</li> </ul> <p>Visual Style:</p> <ul> <li>Clean square wave with smooth animation</li> <li>Rising edges marked with upward arrow</li> <li>Falling edges marked with downward arrow</li> <li>Current portion of waveform highlighted</li> <li>Edge counts displayed as tickers</li> </ul> <p>Implementation: p5.js with animated clock generation</p>"},{"location":"chapters/07-intro-sequential-logic/#rising-edge-and-falling-edge-which-one-wins","title":"Rising Edge and Falling Edge: Which One Wins?","text":"<p>The rising edge (also called positive edge) is the transition from logic low (0) to logic high (1). Think of it as the clock \"rising up\" from 0 to 1.</p> <p>The falling edge (also called negative edge) is the transition from logic high (1) to logic low (0). The clock is \"falling down\" from 1 to 0.</p> <p>In circuit diagrams and datasheets, you'll often see:</p> <ul> <li>A small triangle at the clock input indicating edge-triggered behavior</li> <li>Sometimes a bubble before the triangle indicating falling-edge triggering</li> </ul> Trigger Type Symbol Active On Use Case Rising edge Triangle 0\u21921 Most common default Falling edge Bubble + Triangle 1\u21920 When needed for timing <p>Why would you choose one over the other? Usually it's about timing relationships with other signals. If your data arrives and stabilizes during the clock high period, rising edge triggering gives you the entire high period for propagation. Different systems have different timing needs.</p> <p>The good news: from a functional standpoint, rising and falling edge triggered circuits work identically. It's just a matter of when during the clock cycle the action happens.</p>"},{"location":"chapters/07-intro-sequential-logic/#clock-period-the-duration-of-one-cycle","title":"Clock Period: The Duration of One Cycle","text":"<p>The clock period (T) is the time it takes for the clock to complete one full cycle\u2014from rising edge to the next rising edge (or falling edge to the next falling edge).</p> \\[T = \\text{time for one complete clock cycle}\\] <p>The period is typically measured in nanoseconds (ns) for modern digital systems:</p> <ul> <li>1 ns = 0.000000001 seconds = \\(10^{-9}\\) seconds</li> <li>A 1 GHz clock has a period of 1 ns</li> <li>A 100 MHz clock has a period of 10 ns</li> </ul> <p>The clock period determines how much time you have for:</p> <ol> <li>Computation: Logic gates must produce their outputs</li> <li>Propagation: Signals must travel through wires</li> <li>Setup: Data must be stable before the next clock edge</li> <li>Hold: Data must remain stable after the clock edge</li> </ol> <p>If your logic takes too long, you need a slower clock (longer period). This is why clock frequency is such an important specification for processors\u2014it tells you how many operations per second the chip can perform.</p>"},{"location":"chapters/07-intro-sequential-logic/#clock-frequency-how-fast-the-heart-beats","title":"Clock Frequency: How Fast the Heart Beats","text":"<p>The clock frequency (f) is the reciprocal of the period\u2014it tells you how many clock cycles occur per second.</p> \\[f = \\frac{1}{T}\\] <p>Frequency is measured in Hertz (Hz):</p> <ul> <li>1 Hz = 1 cycle per second</li> <li>1 MHz = 1,000,000 cycles per second</li> <li>1 GHz = 1,000,000,000 cycles per second</li> </ul> <p>The clock frequency of a processor is one of its defining characteristics:</p> Device Typical Clock Frequency Period Arduino (ATmega328) 16 MHz 62.5 ns Raspberry Pi (ARM Cortex-A72) 1.5 GHz 0.67 ns Modern desktop CPU 3-5 GHz 0.2-0.33 ns DDR5 memory 4.8-6.4 GHz 0.15-0.2 ns <p>Higher frequency means more operations per second, which generally means faster performance. But higher frequency also means:</p> <ul> <li>More power consumption (power \u221d frequency)</li> <li>More heat generation</li> <li>Tighter timing margins</li> <li>More challenging circuit design</li> </ul> <p>The quest for higher clock speeds drove processor development for decades, until power and heat limits led to the multi-core revolution around 2005.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-period-and-frequency-relationship","title":"Diagram: Period and Frequency Relationship","text":"Clock Period and Frequency Calculator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Calculate</p> <p>Learning Objective: Students will be able to calculate clock frequency from period and vice versa, understanding the reciprocal relationship between these quantities.</p> <p>Instructional Rationale: Interactive calculator with visual waveform reinforces the mathematical relationship while connecting to concrete clock behavior.</p> <p>Canvas Layout:</p> <ul> <li>Top: Clock waveform with period marked</li> <li>Middle: Dual sliders for period and frequency (reciprocally linked)</li> <li>Bottom: Calculation display showing f = 1/T</li> <li>Side: Common clock speeds for reference</li> </ul> <p>Interactive Elements:</p> <ul> <li>Period slider (adjusts frequency automatically)</li> <li>Frequency slider (adjusts period automatically)</li> <li>Input fields for exact values</li> <li>Unit converter (ns, \u00b5s, ms for period; Hz, kHz, MHz, GHz for frequency)</li> <li>Preset buttons for common clock speeds</li> <li>Visual waveform updates to match current period</li> </ul> <p>Data Visibility:</p> <ul> <li>Current period with unit</li> <li>Current frequency with unit</li> <li>Calculation shown: f = 1/T</li> <li>Reference comparison to common devices</li> <li>Number of cycles in a fixed time window</li> </ul> <p>Visual Style:</p> <ul> <li>Waveform scales appropriately with period</li> <li>Sliders logarithmic for wide range</li> <li>Clean calculation display</li> <li>Reference chart for common frequencies</li> </ul> <p>Implementation: p5.js with reciprocal calculation and unit conversion</p>"},{"location":"chapters/07-intro-sequential-logic/#duty-cycle-the-balance-of-high-and-low","title":"Duty Cycle: The Balance of High and Low","text":"<p>The duty cycle describes what fraction of each clock period the signal spends high. It's expressed as a percentage.</p> \\[\\text{Duty Cycle} = \\frac{T_{high}}{T} \\times 100\\%\\] <p>For an ideal square wave clock, the duty cycle is 50%\u2014equal time high and low. But clocks don't have to be 50%:</p> <ul> <li>50% duty cycle: \\(T_{high} = T_{low}\\) (symmetric)</li> <li>25% duty cycle: High for 1/4 of period, low for 3/4</li> <li>75% duty cycle: High for 3/4 of period, low for 1/4</li> </ul> <p>Why does duty cycle matter?</p> <ol> <li>Power: Some circuits consume more power when clock is high</li> <li>Timing margins: Asymmetric clocks can provide more time for certain operations</li> <li>Multi-phase clocks: Non-overlapping clocks need specific duty cycles</li> <li>Clock distribution: Duty cycle can drift in long clock networks</li> </ol> <p>Most synchronous systems use 50% duty cycle because it provides equal time for operations on rising and falling edges. But specialized applications might use different duty cycles.</p> <p>Duty Cycle in Practice</p> <p>LED dimming often uses PWM (Pulse Width Modulation) where the duty cycle directly controls brightness. A 25% duty cycle means the LED is on only 25% of the time, appearing 1/4 as bright. The \"clock\" in this case might be a few hundred Hz\u2014too fast for your eye to notice the blinking, but slow enough to easily control.</p>"},{"location":"chapters/07-intro-sequential-logic/#diagram-duty-cycle-visualizer","title":"Diagram: Duty Cycle Visualizer","text":"Clock Duty Cycle Interactive <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Describe</p> <p>Learning Objective: Students will be able to describe how duty cycle affects the proportion of time a clock signal spends in the high state versus the low state.</p> <p>Instructional Rationale: Visual adjustment of duty cycle with real-time waveform and percentage display makes this timing concept intuitive.</p> <p>Canvas Layout:</p> <ul> <li>Center: Clock waveform with variable duty cycle</li> <li>Top: Duty cycle slider (0% to 100%)</li> <li>Bottom: Time breakdown (T_high, T_low, percentage)</li> <li>Side: Applications of different duty cycles</li> </ul> <p>Interactive Elements:</p> <ul> <li>Duty cycle slider</li> <li>Preset buttons (25%, 50%, 75%)</li> <li>Waveform updates in real-time</li> <li>Display of T_high and T_low durations</li> <li>Visual bar showing proportion of high vs. low</li> <li>Animation showing one complete cycle</li> </ul> <p>Data Visibility:</p> <ul> <li>Current duty cycle percentage</li> <li>T_high duration</li> <li>T_low duration</li> <li>Total period T</li> <li>Ratio display</li> </ul> <p>Visual Style:</p> <ul> <li>Waveform clearly shows high and low regions</li> <li>Color coding: high period in one color, low in another</li> <li>Proportional bar below waveform</li> <li>Clean percentage display</li> </ul> <p>Implementation: p5.js with adjustable duty cycle waveform</p>"},{"location":"chapters/07-intro-sequential-logic/#putting-it-all-together-from-gates-to-memory","title":"Putting It All Together: From Gates to Memory","text":"<p>Let's step back and appreciate what we've learned. Starting from simple logic gates, we've discovered how to build circuits that remember.</p> <p>The Journey:</p> <ol> <li>Feedback creates the possibility of memory</li> <li>Bistable elements provide two stable states</li> <li>SR latches give us control over which state to choose</li> <li>D latches eliminate the invalid state problem</li> <li>Clock signals provide synchronization</li> <li>Clock edges will give us precise triggering (next chapter!)</li> </ol> <p>Key Equations:</p> <p>SR Latch: \\(Q^+ = S + \\overline{R} \\cdot Q\\) (with constraint S\u00b7R=0)</p> <p>D Latch: \\(Q^+ = D \\cdot Enable + Q \\cdot \\overline{Enable}\\)</p> <p>Clock Frequency: \\(f = \\frac{1}{T}\\)</p> <p>Duty Cycle: \\(\\frac{T_{high}}{T} \\times 100\\%\\)</p> <p>The Big Ideas:</p> Concept Why It Matters State Circuits can remember Feedback Enables memory in logic Latches Controllable memory elements Level sensitivity Transparency can cause problems Clocks Synchronization for reliable operation"},{"location":"chapters/07-intro-sequential-logic/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you begin working with sequential logic, watch out for these pitfalls:</p> <ol> <li> <p>Treating latches like combinational logic: Remember, the output depends on history! The same inputs can produce different outputs depending on the current state.</p> </li> <li> <p>Forgetting the invalid state in SR latches: Never apply S=R=1 to a basic SR latch. If you can't guarantee this, use a D latch instead.</p> </li> <li> <p>Ignoring the transparency window: When a D latch is enabled, Q follows every change in D. Glitches matter!</p> </li> <li> <p>Confusing level-sensitive with edge-triggered: Latches respond to levels; flip-flops respond to edges. We'll cover flip-flops next chapter, but don't mix up the terminology.</p> </li> <li> <p>Neglecting timing: Sequential circuits are all about when things happen. A circuit that's logically correct might still fail due to timing issues.</p> </li> <li> <p>Forgetting that clock frequency and period are reciprocals: If someone says \"100 MHz\" you should immediately think \"10 ns period.\"</p> </li> </ol>"},{"location":"chapters/07-intro-sequential-logic/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've crossed the threshold from combinational to sequential logic. This is a fundamental shift in how we think about digital circuits.</p> <p>Core Concepts:</p> <ul> <li>Sequential logic circuits have memory\u2014outputs depend on both current inputs and past history</li> <li>State is what the circuit remembers</li> <li>Feedback loops enable memory by routing outputs back to inputs</li> <li>Bistable elements have two stable states</li> </ul> <p>Latches:</p> <ul> <li>SR latch uses Set and Reset inputs (invalid when S=R=1)</li> <li>Gated SR latch adds an Enable input for control</li> <li>D latch uses a single data input, eliminating invalid states</li> <li>Level-sensitive (transparent) behavior can cause timing problems</li> </ul> <p>Clocking:</p> <ul> <li>Clock signals provide regular synchronization pulses</li> <li>Rising edge: 0\u21921 transition</li> <li>Falling edge: 1\u21920 transition</li> <li>Period (T): time for one complete cycle</li> <li>Frequency (f = 1/T): cycles per second</li> <li>Duty cycle: percentage of time spent high</li> </ul> <p>The Key Insight</p> <p>Memory comes from feedback, but useful memory requires control. The evolution from raw feedback loops to gated latches to clocked systems is the story of gaining ever more precise control over when and how state changes. Next chapter, we'll see how edge-triggered flip-flops solve the level-sensitivity problem once and for all.</p> Graphic Novel Suggestion <p>A compelling graphic novel could tell the story of the engineers who first grappled with building reliable memory circuits in the 1940s and 1950s. The drama would center on the \"race condition\" problem\u2014circuits that worked sometimes but failed mysteriously. We could follow the development of the flip-flop from early vacuum tube implementations through to transistor versions, with tension building around the discovery that edge-triggering could solve problems that had plagued level-sensitive designs. The climax could feature the moment when synchronous design principles finally made reliable large-scale digital systems possible.</p>"},{"location":"chapters/07-intro-sequential-logic/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: State Identification <p>A sequential circuit has output Q that is currently 1. If you apply S=0, R=0 to an SR latch, what is the next state of Q?</p> <p>Solution: With S=0 and R=0, the SR latch is in \"hold\" mode. The output Q remains at whatever value it currently has. Since Q is currently 1, Q stays 1.</p> Problem 2: D Latch Behavior <p>A D latch has Enable=1, D=0, and Q=1. What happens to Q? Then Enable goes to 0 while D changes to 1. What is Q now?</p> <p>Solution: Step 1: Enable=1, D=0 \u2192 The latch is transparent, so Q follows D. Q becomes 0. Step 2: Enable goes to 0 \u2192 The latch holds its current value (Q=0). Step 3: D changes to 1 while Enable=0 \u2192 The latch ignores D since it's disabled. Q remains 0.</p> Problem 3: Clock Calculations <p>A processor has a 2.5 GHz clock. What is the clock period? How many clock cycles occur in 1 microsecond?</p> <p>Solution: Period: \\(T = \\frac{1}{f} = \\frac{1}{2.5 \\times 10^9} = 0.4 \\times 10^{-9} = 0.4\\) ns = 400 ps</p> <p>Cycles in 1 \u00b5s: \\(\\frac{1 \\times 10^{-6}}{0.4 \\times 10^{-9}} = 2500\\) cycles</p> Problem 4: Invalid State <p>Why can't S and R both be 1 in an SR latch built from NOR gates? What happens to Q and \\(\\overline{Q}\\)?</p> <p>Solution: When S=R=1 in a NOR-based SR latch, both NOR gates have at least one input at 1, so both outputs become 0. This means Q=0 and \\(\\overline{Q}\\)=0, which violates the requirement that they be complements. Additionally, when both inputs return to 0, the circuit enters an unstable race condition where the final state depends on which gate's input drops first\u2014making the behavior unpredictable.</p> Problem 5: Duty Cycle <p>A clock has a period of 20 ns and is high for 8 ns. What is the duty cycle? If the frequency is doubled while maintaining the same duty cycle, how long is the high time?</p> <p>Solution: Duty cycle: \\(\\frac{8}{20} \\times 100\\% = 40\\%\\)</p> <p>If frequency doubles, period halves to 10 ns. With 40% duty cycle: \\(T_{high} = 0.4 \\times 10 = 4\\) ns</p> Problem 6: Timing Analysis <p>A D latch has Enable=1 continuously. D starts at 0, then goes to 1, then to 0, then to 1. What is the final value of Q?</p> <p>Solution: With Enable=1 continuously, the latch is transparent. Q follows every change in D: - D=0 \u2192 Q=0 - D=1 \u2192 Q=1 - D=0 \u2192 Q=0 - D=1 \u2192 Q=1</p> <p>Final Q = 1. The latch captures every transition while transparent.</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/","title":"Quiz: Introduction to Sequential Logic","text":"<p>Test your understanding of memory elements, latches, clocks, and the foundations of sequential logic.</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#1-what-distinguishes-sequential-logic-from-combinational-logic","title":"1. What distinguishes sequential logic from combinational logic?","text":"<ol> <li>Sequential logic uses only NAND gates</li> <li>Sequential logic has memory and outputs depend on past inputs</li> <li>Sequential logic operates faster</li> <li>Sequential logic uses fewer transistors</li> </ol> Show Answer <p>The correct answer is B. Sequential logic circuits have memory\u2014their outputs depend on both current inputs AND the history of past inputs (stored as state). Combinational logic has no memory; outputs depend only on current inputs.</p> <p>Concept Tested: Sequential Logic</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#2-what-is-the-state-of-a-sequential-circuit","title":"2. What is the \"state\" of a sequential circuit?","text":"<ol> <li>The physical location of the circuit</li> <li>The stored information that affects future behavior</li> <li>The power consumption level</li> <li>The number of inputs</li> </ol> Show Answer <p>The correct answer is B. State represents the internal stored information that the circuit \"remembers.\" It determines how the circuit responds to inputs and what outputs it produces. State is stored in memory elements like latches and flip-flops.</p> <p>Concept Tested: State Concept</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#3-what-problem-occurs-when-s1-and-r1-in-a-basic-sr-latch","title":"3. What problem occurs when S=1 and R=1 in a basic SR latch?","text":"<ol> <li>The latch operates normally</li> <li>The outputs become unpredictable (invalid state)</li> <li>The latch resets to 0</li> <li>The latch sets to 1</li> </ol> Show Answer <p>The correct answer is B. When both S and R are 1, both outputs try to be 0, violating the complementary relationship (Q and Q' should be opposites). When S and R return to 0, the final state is unpredictable, depending on which input changes first.</p> <p>Concept Tested: Invalid State Problem</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#4-what-is-the-behavior-of-a-transparent-latch","title":"4. What is the behavior of a \"transparent\" latch?","text":"<ol> <li>It has no visible output</li> <li>Input changes pass through to output while enabled</li> <li>It only works with glass substrates</li> <li>It inverts all inputs</li> </ol> Show Answer <p>The correct answer is B. A transparent latch allows input changes to propagate directly to the output while the enable is active. The output \"follows\" the input during this transparent phase and holds its value when enable goes inactive.</p> <p>Concept Tested: Transparent Latch</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#5-what-creates-memory-in-a-basic-latch-circuit","title":"5. What creates memory in a basic latch circuit?","text":"<ol> <li>A capacitor storing charge</li> <li>A feedback loop from outputs to inputs</li> <li>A battery backup</li> <li>Extra ground connections</li> </ol> Show Answer <p>The correct answer is B. Feedback loops from gate outputs back to inputs create bistability\u2014the circuit can maintain one of two stable states indefinitely. Cross-coupled gates (like NAND or NOR) form the fundamental memory element.</p> <p>Concept Tested: Feedback Loop</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#6-what-is-the-purpose-of-the-clock-signal-in-digital-systems","title":"6. What is the purpose of the clock signal in digital systems?","text":"<ol> <li>To measure elapsed time</li> <li>To synchronize all state changes to defined moments</li> <li>To power the circuit</li> <li>To generate random numbers</li> </ol> Show Answer <p>The correct answer is B. The clock signal provides a timing reference that synchronizes when flip-flops can change state. All state changes occur at clock edges, making timing predictable and preventing race conditions in large designs.</p> <p>Concept Tested: Clock Signal</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#7-what-is-the-relationship-between-clock-period-and-clock-frequency","title":"7. What is the relationship between clock period and clock frequency?","text":"<ol> <li>Period = Frequency \u00d7 2</li> <li>Period = 1 / Frequency</li> <li>Period = Frequency\u00b2</li> <li>They are the same thing</li> </ol> Show Answer <p>The correct answer is B. Clock period (T) and frequency (f) are inversely related: T = 1/f. A 100 MHz clock has a period of 10 nanoseconds (1 / 100,000,000 seconds). Higher frequency means shorter period.</p> <p>Concept Tested: Clock Frequency</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#8-what-is-a-rising-edge-of-a-clock-signal","title":"8. What is a rising edge of a clock signal?","text":"<ol> <li>The high voltage level</li> <li>The transition from low to high</li> <li>The maximum voltage reached</li> <li>The average voltage</li> </ol> Show Answer <p>The correct answer is B. The rising edge (positive edge) is the transition moment when the clock changes from 0 to 1. Many sequential circuits are \"positive-edge-triggered,\" meaning they sample inputs and update state at this transition.</p> <p>Concept Tested: Rising Edge</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#9-why-are-level-sensitive-latches-problematic-in-large-designs","title":"9. Why are level-sensitive latches problematic in large designs?","text":"<ol> <li>They consume too much power</li> <li>They are too slow</li> <li>Signals can propagate through multiple stages during one enable period</li> <li>They require too many transistors</li> </ol> Show Answer <p>The correct answer is C. When a latch is transparent, input changes pass through immediately. In a chain of latches with the same enable, a signal could propagate through multiple stages in one enable period, causing unpredictable behavior (race conditions).</p> <p>Concept Tested: Latch Timing Problem</p>"},{"location":"chapters/07-intro-sequential-logic/quiz/#10-what-is-a-bistable-element","title":"10. What is a bistable element?","text":"<ol> <li>An element that oscillates between two states</li> <li>An element with exactly two stable states that persists without input</li> <li>An element that requires two power supplies</li> <li>An element with two outputs</li> </ol> Show Answer <p>The correct answer is B. A bistable element has exactly two stable states (typically representing 0 and 1) and will remain in its current state indefinitely without external input. Latches and flip-flops are bistable elements that form the basis of digital memory.</p> <p>Concept Tested: Bistable Element</p>"},{"location":"chapters/08-flip-flops-timing/","title":"Flip-Flops and Timing","text":""},{"location":"chapters/08-flip-flops-timing/#summary","title":"Summary","text":"<p>This chapter covers edge-triggered flip-flops, the fundamental storage elements in synchronous digital systems. Students will learn about D, JK, and T flip-flops, understand edge-triggering mechanisms including master-slave configurations, and work with asynchronous preset and clear inputs. Critical timing concepts including setup time, hold time, clock-to-Q delay, timing diagrams, and timing violations are thoroughly covered. The chapter also addresses metastability, its causes, and synchronization techniques including the double-flop synchronizer for handling asynchronous inputs safely.</p>"},{"location":"chapters/08-flip-flops-timing/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>D Flip-Flop</li> <li>Edge Triggered</li> <li>Positive Edge Triggered</li> <li>Negative Edge Triggered</li> <li>Master-Slave Flip-Flop</li> <li>JK Flip-Flop</li> <li>JK Toggle Mode</li> <li>T Flip-Flop</li> <li>Flip-Flop Symbol</li> <li>Preset Input</li> <li>Clear Input</li> <li>Asynchronous Reset</li> <li>Synchronous Reset</li> <li>Setup Time</li> <li>Hold Time</li> <li>Clock-to-Q Delay</li> <li>Timing Diagram</li> <li>Timing Constraint</li> <li>Timing Violation</li> <li>Metastability</li> <li>MTBF Concept</li> <li>Synchronous System</li> <li>Asynchronous Input</li> <li>Synchronizer Circuit</li> <li>Double Flop Synchronizer</li> </ol>"},{"location":"chapters/08-flip-flops-timing/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 7: Introduction to Sequential Logic</li> </ul>"},{"location":"chapters/08-flip-flops-timing/#introduction-the-edge-of-glory","title":"Introduction: The Edge of Glory","text":"<p>In the last chapter, we discovered that circuits could learn to remember. We built latches\u2014wonderful little memory elements that gave us our first taste of sequential logic. But we also discovered a dark secret: level-sensitive latches have a transparency problem. Leave the enable high for too long, and data can race through multiple stages like an over-caffeinated college student during finals week.</p> <p>What we need is a memory element that responds to a precise moment in time\u2014not an entire duration. We need edge-triggered flip-flops.</p> <p>Think of it like catching a photograph versus recording video. A level-sensitive latch is like a security camera: it captures everything that happens while it's on. An edge-triggered flip-flop is like a camera: it captures exactly one moment when you click the shutter. No blurry race conditions, no mysterious ghost images of intermediate values\u2014just clean, predictable snapshots of your data.</p> <p>Welcome to the world of flip-flops and timing. By the end of this chapter, you'll understand not just how flip-flops work, but when they work\u2014and more importantly, when they don't. These timing concepts are so fundamental that even experienced engineers occasionally mess them up, leading to the kinds of bugs that make you question your life choices.</p> <p>Let's flip into it! (Sorry, I had to.)</p>"},{"location":"chapters/08-flip-flops-timing/#edge-triggered-the-precise-moment","title":"Edge-Triggered: The Precise Moment","text":"<p>An edge-triggered circuit responds only at the moment of a clock transition\u2014either rising (0\u21921) or falling (1\u21920)\u2014rather than during the entire high or low level. This is the key difference between flip-flops and latches.</p> <p>Remember our transparent latch problem from the last chapter? With a level-sensitive latch, data could change the output any time the enable was high. With edge-triggering, the window for data capture shrinks to an infinitesimally brief moment: the clock edge itself.</p> <p>Here's the conceptual difference:</p> Property Level-Sensitive (Latch) Edge-Triggered (Flip-Flop) Response During entire enable At transition moment Transparency Entire high period None Data capture Continuous while enabled Single snapshot at edge Race-through risk High Eliminated <p>Think of edge-triggering like a starting gun at a race. The runners don't start \"while the gun is being fired\"\u2014they start at the exact moment of the bang. Similarly, flip-flops respond at the exact moment of the clock edge.</p> <p>Why Edges Work Better</p> <p>Edge-triggering solves the race-through problem because the \"capture window\" is essentially zero width. Data can't race through multiple flip-flops in a single edge because each flip-flop only looks at its input for that one instant.</p>"},{"location":"chapters/08-flip-flops-timing/#positive-edge-triggered-rising-to-the-occasion","title":"Positive Edge Triggered: Rising to the Occasion","text":"<p>A positive edge triggered flip-flop (also called rising-edge triggered) responds when the clock transitions from low to high (0\u21921). This is the most common type of flip-flop in modern digital design.</p> <p>When we say a flip-flop is positive-edge triggered:</p> <ul> <li>It ignores the clock when it's stable at 0</li> <li>It ignores the clock when it's stable at 1</li> <li>It only captures data at the 0\u21921 transition</li> </ul> <pre><code>           \u2193 Data captured here!\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2510\nCLK: \u2502     \u2502     \u2502     \u2502\n\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\n     \u2191           \u2191\n  Rising      Rising\n  Edge        Edge\n</code></pre> <p>In circuit symbols, a positive edge triggered flip-flop is indicated by a small triangle at the clock input:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nD \u2500\u2500\u2524       \u251c\u2500\u2500 Q\n    \u2502  D FF \u2502\nCLK&gt;\u2502       \u251c\u2500\u2500 Q\u0304\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    (&gt; indicates edge-triggered)\n</code></pre> <p>Why is positive edge triggering so popular? Historically, it became the default because:</p> <ol> <li>Early TTL logic naturally supported rising-edge detection</li> <li>Data typically stabilizes during the clock low period, ready for capture at the rising edge</li> <li>Consistency\u2014when everyone uses the same edge, systems interoperate more easily</li> </ol>"},{"location":"chapters/08-flip-flops-timing/#negative-edge-triggered-falling-with-style","title":"Negative Edge Triggered: Falling with Style","text":"<p>A negative edge triggered flip-flop (also called falling-edge triggered) responds when the clock transitions from high to low (1\u21920). While less common as the primary flip-flop type, it's essential for certain timing arrangements.</p> <pre><code>           \u2193 Data captured here!\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2510\nCLK: \u2502     \u2502     \u2502     \u2502\n\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\n           \u2191           \u2191\n        Falling     Falling\n         Edge        Edge\n</code></pre> <p>The symbol for a negative edge triggered flip-flop adds a bubble before the triangle:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nD \u2500\u2500\u2524       \u251c\u2500\u2500 Q\n    \u2502  D FF \u2502\nCLKo&gt;\u2502      \u251c\u2500\u2500 Q\u0304\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    (o&gt; indicates negative edge-triggered)\n</code></pre> <p>When would you use falling-edge triggering? Several scenarios:</p> <ul> <li>Two-phase systems: Using both edges of the same clock can double your effective logic time</li> <li>Timing alignment: When data arrives late in the clock high period, falling edge gives more setup time</li> <li>Interfacing: Some systems specifically require falling-edge timing</li> </ul> <p>The great news is that positive and negative edge-triggered flip-flops are functionally identical\u2014they just respond at different moments in the clock cycle.</p>"},{"location":"chapters/08-flip-flops-timing/#the-d-flip-flop-the-workhorse-of-sequential-logic","title":"The D Flip-Flop: The Workhorse of Sequential Logic","text":"<p>The D flip-flop (Data flip-flop) is the most important and widely used edge-triggered storage element. It has one data input (D), one clock input (CLK), and two outputs (Q and \\(\\overline{Q}\\)).</p> <p>The behavior is beautifully simple:</p> <ul> <li>At each active clock edge, Q takes on whatever value D had at that moment</li> <li>Between clock edges, Q holds its value regardless of what D does</li> </ul> D (at clock edge) Q (after clock edge) 0 0 1 1 <p>That's it! The characteristic equation is simply:</p> \\[Q^+ = D\\] <p>Read as: \"The next state of Q equals D (sampled at the clock edge).\"</p> <p>Compare this to the D latch equation from last chapter: \\(Q^+ = D \\cdot Enable + Q \\cdot \\overline{Enable}\\). The flip-flop is conceptually simpler because \"Enable\" is replaced by an instantaneous edge event.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-d-flip-flop-interactive","title":"Diagram: D Flip-Flop Interactive","text":"D Flip-Flop Edge Triggered Demonstration <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how a D flip-flop captures data only at the clock edge, contrasting this behavior with the transparent behavior of a D latch.</p> <p>Instructional Rationale: Step-by-step comparison of D latch vs D flip-flop with the same inputs makes the edge-triggering concept concrete. Students can change D at various times and observe that only the value at the clock edge matters.</p> <p>Canvas Layout:</p> <ul> <li>Left side: D flip-flop symbol with inputs (D, CLK) and outputs (Q, Q\u0304)</li> <li>Right side: Timing diagram showing CLK, D, and Q waveforms</li> <li>Bottom: Control panel with D toggle, clock pulse button, and mode comparison</li> <li>Top: \"Current State\" and \"Next State at Edge\" indicators</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle button for D input</li> <li>\"Clock Pulse\" button that triggers a rising edge</li> <li>Automatic timing diagram that scrolls with each interaction</li> <li>Highlight showing exactly when Q changes (only at rising edge)</li> <li>Comparison mode showing how D latch would behave with same inputs</li> <li>\"What value will Q capture?\" prediction before triggering clock</li> </ul> <p>Data Visibility:</p> <ul> <li>Current D value</li> <li>Current Q value</li> <li>Clock edge indicator (highlight at moment of edge)</li> <li>Captured value shown after each edge</li> <li>Timing diagram with clear cause-effect relationship</li> </ul> <p>Visual Style:</p> <ul> <li>Standard D flip-flop symbol with triangle at clock</li> <li>Waveform display with clear edge markers</li> <li>Q changes highlighted in orange</li> <li>Ignored D transitions shown faded in timing diagram</li> <li>Color coding: CLK green, D blue, Q orange</li> </ul> <p>Implementation: p5.js with edge detection and timing diagram generation</p> <p>The D flip-flop is everywhere in digital design:</p> <ul> <li>Registers: Just put 8 or 16 or 32 D flip-flops in parallel\u2014boom, you have a register</li> <li>Pipeline stages: Each stage of a processor pipeline is separated by D flip-flops</li> <li>State machines: The state variables in FSMs are stored in D flip-flops</li> <li>Shift registers: Chain D flip-flops together with Q of one feeding D of the next</li> </ul> <p>If the D latch is the basic unit of memory, the D flip-flop is the basic unit of synchronous memory.</p>"},{"location":"chapters/08-flip-flops-timing/#master-slave-flip-flop-how-edge-triggering-works","title":"Master-Slave Flip-Flop: How Edge-Triggering Works","text":"<p>How do we actually build an edge-triggered flip-flop? One classic approach is the master-slave flip-flop, which uses two latches in series with opposite enable signals.</p> <p>Here's the concept:</p> <pre><code>D \u2500\u2500\u2192 [Master Latch] \u2500\u2500\u2192 [Slave Latch] \u2500\u2500\u2192 Q\n             \u2191                 \u2191\n           CLK=1             CLK=0\n         (transparent       (transparent\n          when high)         when low)\n</code></pre> <p>When CLK is low (0):</p> <ul> <li>Master is opaque (holding its value)</li> <li>Slave is transparent (passing master's output to Q)</li> <li>Any changes at D are ignored by the system</li> </ul> <p>When CLK is high (1):</p> <ul> <li>Master is transparent (D passes through to master output)</li> <li>Slave is opaque (holding, so Q doesn't change yet)</li> <li>D is captured by the master but not yet visible at Q</li> </ul> <p>At the falling edge (1\u21920):</p> <ul> <li>Master becomes opaque (freezes whatever D was)</li> <li>Slave becomes transparent (passes frozen value to Q)</li> <li>This is when Q changes!</li> </ul> <p>So a master-slave flip-flop with positive-level master and negative-level slave is actually falling-edge triggered! To get rising-edge triggering, you invert the clock to the master, making it transparent when CLK is low.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-master-slave-operation","title":"Diagram: Master-Slave Operation","text":"Master-Slave Flip-Flop Internal Operation <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Describe</p> <p>Learning Objective: Students will be able to describe how a master-slave flip-flop achieves edge-triggered behavior by using two level-sensitive latches with complementary enables.</p> <p>Instructional Rationale: Animated visualization of data flowing through master and slave stages, with transparency windows clearly marked, builds understanding of the internal mechanism.</p> <p>Canvas Layout:</p> <ul> <li>Top: Block diagram showing Master and Slave latches in series</li> <li>Middle: Internal state display (Master Q, Slave Q)</li> <li>Bottom: Clock waveform with current position indicator</li> <li>Side: \"Transparency Window\" indicators for each latch</li> </ul> <p>Interactive Elements:</p> <ul> <li>D input toggle</li> <li>Slow clock animation (controllable speed)</li> <li>Step-through mode (CLK high, CLK low, transitions)</li> <li>Highlight data path as it propagates</li> <li>Show which latch is transparent at each moment</li> <li>\"Why doesn't data race through?\" explanation panel</li> </ul> <p>Data Visibility:</p> <ul> <li>D input value</li> <li>Master internal Q value</li> <li>Slave output Q value</li> <li>Clock state (high/low)</li> <li>Which latch is transparent/opaque</li> <li>Timing diagram building over time</li> </ul> <p>Visual Style:</p> <ul> <li>Two distinct latch blocks with connection</li> <li>Transparent latch shown with \"open gate\" visual</li> <li>Opaque latch shown with \"closed gate\" visual</li> <li>Data shown as colored pulse moving through</li> <li>Clear before/after for each clock transition</li> </ul> <p>Implementation: p5.js with step-through animation and state tracking</p> <p>Why Master-Slave?</p> <p>The master-slave configuration is clever because it never has both latches transparent simultaneously. This eliminates the race-through problem inherent in a single transparent latch. The \"hand-off\" from master to slave happens atomically at the clock edge.</p> <p>Modern flip-flops don't always use the traditional master-slave structure\u2014they may use more sophisticated edge-detection circuits\u2014but the master-slave concept beautifully illustrates why edge-triggering works.</p>"},{"location":"chapters/08-flip-flops-timing/#the-jk-flip-flop-more-than-set-reset","title":"The JK Flip-Flop: More Than Set-Reset","text":"<p>The JK flip-flop is like the SR flip-flop's smarter cousin who went to engineering school. It has two control inputs\u2014J and K\u2014but eliminates the dreaded \"invalid state\" that plagued SR latches.</p> J K Q (next) Operation 0 0 Q Hold 0 1 0 Reset 1 0 1 Set 1 1 \\(\\overline{Q}\\) Toggle! <p>See that last row? When J=K=1, instead of creating an invalid state, the JK flip-flop toggles\u2014it changes to the opposite of its current value. If Q was 0, it becomes 1. If Q was 1, it becomes 0.</p> <p>The characteristic equation is:</p> \\[Q^+ = J \\cdot \\overline{Q} + \\overline{K} \\cdot Q\\] <p>This equation says: \"Set if J=1 and currently at 0, OR stay set if K=0 and already at 1.\"</p> <p>Why would you use a JK flip-flop instead of a D flip-flop?</p> <ul> <li>When you need explicit set/reset control</li> <li>When you want toggle behavior without external logic</li> <li>In legacy designs (JK was more common before D dominated)</li> <li>When converting from SR-based state machines</li> </ul> <p>The JK flip-flop was invented by Jack Kilby (yes, that Jack Kilby, co-inventor of the integrated circuit), though whether \"JK\" stands for his initials or \"Jack Kilby\" or just \"Jump-Key\" is debated by digital lore historians.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-jk-flip-flop-modes","title":"Diagram: JK Flip-Flop Modes","text":"JK Flip-Flop Operation Modes <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate the four operation modes of a JK flip-flop (Hold, Reset, Set, Toggle) by manipulating the J and K inputs and observing the output behavior.</p> <p>Instructional Rationale: Interactive exploration of all four modes, especially the toggle behavior, reinforces understanding of how JK extends beyond SR functionality.</p> <p>Canvas Layout:</p> <ul> <li>Center: JK flip-flop symbol with J, K, CLK inputs and Q output</li> <li>Left: J and K input controls</li> <li>Right: Current mode indicator and operation description</li> <li>Bottom: Timing diagram showing J, K, CLK, Q</li> <li>Top: Q state display with next-state prediction</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for J and K</li> <li>Clock pulse trigger button</li> <li>Mode indicator updates automatically based on J, K</li> <li>Prediction: \"What will Q be after the clock edge?\"</li> <li>Toggle counter (how many times J=K=1 has been applied)</li> <li>Comparison table with SR latch (showing J=K=1 vs S=R=1)</li> </ul> <p>Data Visibility:</p> <ul> <li>Current J, K values</li> <li>Current Q value</li> <li>Predicted next Q value</li> <li>Mode name (Hold, Reset, Set, Toggle)</li> <li>Toggle count</li> <li>Timing history</li> </ul> <p>Visual Style:</p> <ul> <li>Standard JK flip-flop symbol with edge indicator</li> <li>Color-coded modes (blue=hold, red=reset, green=set, purple=toggle)</li> <li>Timing diagram updates with each clock pulse</li> <li>Toggle animation when J=K=1</li> </ul> <p>Implementation: p5.js with mode detection and timing diagram</p>"},{"location":"chapters/08-flip-flops-timing/#jk-toggle-mode-the-secret-weapon","title":"JK Toggle Mode: The Secret Weapon","text":"<p>The JK toggle mode (J=K=1) deserves special attention because it's incredibly useful for building counters.</p> <p>When J=K=1, each clock edge causes Q to flip to its opposite value:</p> <ul> <li>If Q=0 \u2192 Q becomes 1</li> <li>If Q=1 \u2192 Q becomes 0</li> </ul> <p>Apply this repeatedly, and you get:</p> <pre><code>CLK: \u2191  \u2191  \u2191  \u2191  \u2191  \u2191  \u2191  \u2191\nQ:   0\u21921\u21920\u21921\u21920\u21921\u21920\u21921\n</code></pre> <p>Look at that\u2014Q is now a clock at half the frequency of the input! This is the basis of frequency dividers and binary counters.</p> <p>Want a 4-bit binary counter? Chain four JK flip-flops, each with J=K=1, where each flip-flop's clock is driven by the previous flip-flop's Q output:</p> <pre><code>CLK \u2192 FF0 \u2192 FF1 \u2192 FF2 \u2192 FF3\n       Q0    Q1    Q2    Q3\n</code></pre> <p>The count sequence is: 0000 \u2192 0001 \u2192 0010 \u2192 0011 \u2192 0100 \u2192 ... \u2192 1111 \u2192 0000</p> <p>Pure magic from the toggle mode!</p> <p>Toggle Mode in Action</p> <p>The seconds digit of a digital clock needs to count 0-9 and then reset. While this requires more than just toggle mode (you need to detect when to reset), the basic counting structure uses JK flip-flops in toggle mode with additional gating.</p>"},{"location":"chapters/08-flip-flops-timing/#the-t-flip-flop-toggle-simplified","title":"The T Flip-Flop: Toggle Simplified","text":"<p>The T flip-flop (Toggle flip-flop) is the JK flip-flop with J and K tied together. Since J always equals K, you only have two possible states:</p> <ul> <li>T=0: Hold (equivalent to J=K=0)</li> <li>T=1: Toggle (equivalent to J=K=1)</li> </ul> T Q (next) Operation 0 Q Hold current state 1 \\(\\overline{Q}\\) Toggle to opposite <p>The characteristic equation is:</p> \\[Q^+ = T \\oplus Q\\] <p>That's an XOR! When T=1, Q flips. When T=0, Q stays the same.</p> <p>You can build a T flip-flop from a D flip-flop:</p> <pre><code>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nT \u2500\u2500\u2192\u2502   XOR    \u2502\u2500\u2500\u2192 D input of D flip-flop\nQ \u2500\u2500\u2500\u2502          \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The XOR of T and Q feeds the D input. When T=0, D=Q (hold). When T=1, D=\\(\\overline{Q}\\) (toggle).</p> <p>T flip-flops are perfect for:</p> <ul> <li>Binary counters (keep T=1 for continuous counting)</li> <li>Clock dividers</li> <li>Simple toggle switches</li> </ul>"},{"location":"chapters/08-flip-flops-timing/#diagram-t-flip-flop-counter","title":"Diagram: T Flip-Flop Counter","text":"T Flip-Flop Toggle Counter <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use a T flip-flop to build a simple binary counter and observe how toggle mode creates frequency division.</p> <p>Instructional Rationale: Seeing the toggle behavior over multiple clock cycles, especially the frequency division effect, makes the counter application intuitive.</p> <p>Canvas Layout:</p> <ul> <li>Top: T flip-flop symbol with T, CLK inputs and Q output</li> <li>Middle: Clock and Q waveforms showing frequency division</li> <li>Bottom: Running count of toggles</li> <li>Right: Frequency comparison (input clock vs. Q frequency)</li> </ul> <p>Interactive Elements:</p> <ul> <li>T input toggle (0 or 1)</li> <li>Clock speed control</li> <li>Run/pause button</li> <li>Toggle counter</li> <li>Frequency ratio display</li> <li>Chain multiple T flip-flops together option</li> </ul> <p>Data Visibility:</p> <ul> <li>Current T value</li> <li>Current Q value</li> <li>Clock frequency</li> <li>Q frequency (half of clock when T=1)</li> <li>Toggle count</li> </ul> <p>Visual Style:</p> <ul> <li>Clean T flip-flop symbol</li> <li>Animated waveforms showing division</li> <li>Frequency ratio as simple fraction</li> <li>Cascaded flip-flops when multi-bit mode</li> </ul> <p>Implementation: p5.js with counter and waveform generation</p>"},{"location":"chapters/08-flip-flops-timing/#flip-flop-symbols-reading-the-schematic-language","title":"Flip-Flop Symbols: Reading the Schematic Language","text":"<p>Understanding flip-flop symbols is essential for reading datasheets and schematics. Here's a guide to the visual language:</p> <p>Basic D Flip-Flop: <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nD \u2500\u2500\u2524       \u251c\u2500\u2500 Q\n    \u2502  D FF \u2502\nCLK&gt;\u2502       \u251c\u2500\u2500 Q\u0304\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Key symbol elements:</p> Symbol Meaning &gt; (triangle at clock) Edge-triggered input o&gt; (bubble + triangle) Negative edge-triggered Bubble on any input Active-low signal Q\u0304 (bar over Q) Complementary output <p>D Flip-Flop with Preset and Clear: <pre><code>         PRE\n          \u2193\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nD \u2500\u2500\u2524       \u251c\u2500\u2500 Q\n    \u2502  D FF \u2502\nCLK&gt;\u2502       \u251c\u2500\u2500 Q\u0304\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2191\n         CLR\n</code></pre></p> <p>JK Flip-Flop: <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nJ \u2500\u2500\u2524       \u251c\u2500\u2500 Q\n    \u2502 JK FF \u2502\nCLK&gt;\u2502       \u251c\u2500\u2500 Q\u0304\nK \u2500\u2500\u2524       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>T Flip-Flop: <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nT \u2500\u2500\u2524       \u251c\u2500\u2500 Q\n    \u2502  T FF \u2502\nCLK&gt;\u2502       \u251c\u2500\u2500 Q\u0304\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>When reading datasheets, pay close attention to:</p> <ul> <li>Active-low vs. active-high signals (bubbles matter!)</li> <li>Which edge triggers the flip-flop</li> <li>Presence of asynchronous preset/clear inputs</li> <li>Whether Q\u0304 is actually provided or just implied</li> </ul> <p>Symbol Variations</p> <p>Different standards (IEEE, MIL, etc.) have slightly different symbol conventions. Always check the datasheet legend if you're unsure about a symbol's meaning.</p>"},{"location":"chapters/08-flip-flops-timing/#preset-input-setting-to-1-immediately","title":"Preset Input: Setting to 1 Immediately","text":"<p>The preset input (sometimes called PRE, SET, or S) forces the flip-flop output Q to 1 immediately, regardless of the clock or data inputs.</p> <p>Preset is typically an asynchronous input, meaning it works immediately without waiting for a clock edge. When PRE is asserted:</p> <ul> <li>Q goes to 1 immediately</li> <li>Q\u0304 goes to 0 immediately</li> <li>Clock and D inputs are ignored</li> </ul> <p>Preset inputs are usually active-low (indicated by PRE\u0304 or PRE with a bubble), meaning you assert them by pulling the signal to 0:</p> PRE\u0304 Effect 0 Force Q=1 immediately 1 Normal operation (clock controls Q) <p>When would you use preset?</p> <ul> <li>Initialization: Set a known starting state at power-up</li> <li>Emergency override: Force a state regardless of clock timing</li> <li>Testing: Set flip-flops to specific values for test scenarios</li> </ul> <p>Think of preset like an override switch\u2014it bypasses the normal clock-controlled operation to jam Q to 1 immediately.</p>"},{"location":"chapters/08-flip-flops-timing/#clear-input-resetting-to-0-immediately","title":"Clear Input: Resetting to 0 Immediately","text":"<p>The clear input (sometimes called CLR, RESET, or R) is the opposite of preset\u2014it forces Q to 0 immediately, regardless of clock or data.</p> <p>Like preset, clear is typically asynchronous and active-low:</p> CLR\u0304 Effect 0 Force Q=0 immediately 1 Normal operation <p>Clear is essential for:</p> <ul> <li>System reset: Initialize all flip-flops to 0 at power-up</li> <li>State machine reset: Return to the initial state</li> <li>Counter reset: Clear to zero before counting</li> </ul> <p>Most flip-flops in datasheets come with both preset and clear inputs, giving you complete asynchronous control:</p> PRE\u0304 CLR\u0304 Q 1 1 Normal operation (D, CLK control Q) 0 1 Q = 1 (preset) 1 0 Q = 0 (clear) 0 0 Invalid! (don't do this) <p>Never Assert Both!</p> <p>Just like S=R=1 in an SR latch, asserting both preset and clear simultaneously is invalid. Both would try to force Q to different values\u2014Q can't be 0 and 1 at the same time. Design your reset logic carefully to prevent this.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-preset-and-clear-operation","title":"Diagram: Preset and Clear Operation","text":"Preset and Clear Asynchronous Inputs <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how preset and clear inputs override normal clock-controlled operation to force the flip-flop to a known state immediately.</p> <p>Instructional Rationale: Showing that preset/clear work instantly\u2014even in the middle of a clock period\u2014contrasts with the edge-triggered behavior of normal operation.</p> <p>Canvas Layout:</p> <ul> <li>Center: D flip-flop symbol with PRE and CLR inputs</li> <li>Left: Input controls for D, CLK, PRE, CLR</li> <li>Right: Q output display with mode indicator</li> <li>Bottom: Timing diagram showing all signals</li> <li>Top: \"Override Active\" indicator when PRE or CLR asserted</li> </ul> <p>Interactive Elements:</p> <ul> <li>D input toggle</li> <li>Clock pulse button</li> <li>PRE\u0304 button (active-low, shows bar)</li> <li>CLR\u0304 button (active-low, shows bar)</li> <li>Mode indicator (Normal, Preset Override, Clear Override, Invalid)</li> <li>Timing diagram showing immediate response to preset/clear</li> <li>Warning when both PRE and CLR are active</li> </ul> <p>Data Visibility:</p> <ul> <li>Current D, CLK, PRE, CLR values</li> <li>Current Q value</li> <li>Mode name</li> <li>Response delay (immediate for preset/clear, at edge for D)</li> <li>Timing history</li> </ul> <p>Visual Style:</p> <ul> <li>Flip-flop with all four inputs clearly labeled</li> <li>Active-low inputs shown with overbars and bubbles</li> <li>Override state shown with special highlight</li> <li>Invalid state shown with red warning</li> <li>Timing diagram with immediate transitions for async inputs</li> </ul> <p>Implementation: p5.js with asynchronous override logic</p>"},{"location":"chapters/08-flip-flops-timing/#asynchronous-reset-the-emergency-override","title":"Asynchronous Reset: The Emergency Override","text":"<p>An asynchronous reset is a reset signal that takes effect immediately, independent of the clock. When asserted, the flip-flop clears (or sets, if it's a preset) right now, not at the next clock edge.</p> <p>Asynchronous resets are crucial for:</p> <ol> <li>Power-on initialization: The system must start in a known state before the clock even starts running</li> <li>Emergency shutdown: Safety systems need to reset instantly, not wait for a clock</li> <li>Hard reset: When you press the reset button, you want immediate response</li> </ol> <p>The timing relationship looks like this:</p> <pre><code>CLK:    ___\u2191___\u2191___\u2191___\u2191___\n              \u2191 Normal operation\nCLR: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2191 Q goes to 0 IMMEDIATELY\nQ:    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice that Q responds to CLR instantly, not at a clock edge. This is what makes it asynchronous\u2014not synchronized to the clock.</p> <p>The symbol convention for asynchronous reset is typically:</p> <ul> <li>Input goes directly to the flip-flop core (not through clock-triggered logic)</li> <li>Active-low indicated by bubble</li> <li>Often labeled CLR\u0304, RST\u0304, or AR\u0304</li> </ul> <p>The Price of Asynchrony</p> <p>Asynchronous resets are powerful but dangerous. Because they ignore the clock, they can cause timing violations if released at the wrong moment. We'll see why this matters when we discuss metastability later in this chapter.</p>"},{"location":"chapters/08-flip-flops-timing/#synchronous-reset-patient-and-predictable","title":"Synchronous Reset: Patient and Predictable","text":"<p>A synchronous reset only takes effect at the next clock edge, like all other inputs. When asserted, the flip-flop will clear\u2014but only when the clock arrives.</p> <p>Synchronous resets are implemented by gating the D input:</p> \\[D_{effective} = D \\cdot \\overline{SRST}\\] <p>If SRST=1 (reset asserted), D_effective = 0, so Q becomes 0 at the next clock edge. If SRST=0 (normal operation), D_effective = D, so normal behavior continues.</p> <p>The timing looks like:</p> <pre><code>CLK:    ___\u2191___\u2191___\u2191___\u2191___\n                  \u2191 Q changes here\nSRST: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2191 Reset asserted, but waits for edge\nQ:    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2514\u2500\u2518\n</code></pre> <p>Advantages of synchronous reset:</p> <ul> <li>Timing predictability: Changes only happen at clock edges</li> <li>No timing violations: Reset release can't cause metastability</li> <li>Simpler static timing analysis: Tools can analyze it like any other logic</li> </ul> <p>Disadvantages:</p> <ul> <li>Requires running clock: If the clock is stopped, reset won't work</li> <li>Latency: Must wait for clock edge, which might be too slow for emergencies</li> </ul> Feature Asynchronous Reset Synchronous Reset Response time Immediate At next clock edge Requires clock No Yes Timing analysis Complex Simple Power-on reliable Yes Only if clock runs Metastability risk On release Eliminated <p>Many real designs use asynchronous assertion, synchronous release\u2014the reset takes effect immediately (safe because going to 0 is well-defined), but the release is synchronized to the clock (avoiding metastability on the release edge).</p>"},{"location":"chapters/08-flip-flops-timing/#setup-time-datas-head-start","title":"Setup Time: Data's Head Start","text":"<p>Now we enter the realm of timing\u2014where nanoseconds matter and engineers lose sleep.</p> <p>Setup time (\\(t_{setup}\\) or \\(t_{su}\\)) is the minimum time that data must be stable before the clock edge for the flip-flop to reliably capture it.</p> <p>Think of it like a photograph: if you move right as the shutter clicks, you get a blurry picture. The data must \"pose\" (be stable) for a minimum time before the camera \"clicks\" (clock edge).</p> <pre><code>     \u2190 t_setup \u2192\nD:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2191 D must be stable before this point\nCLK: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2191\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                      \u2191 Clock edge\n</code></pre> <p>If data arrives too late (violates setup time), bad things happen:</p> <ul> <li>The flip-flop might capture the wrong value</li> <li>The flip-flop might enter a metastable state (more on this later)</li> <li>The captured value might be unpredictable</li> </ul> <p>Typical setup times for modern flip-flops range from 0.1 ns to several nanoseconds, depending on the technology.</p> <p>Setup Violations Are Dangerous</p> <p>Setup time violations don't usually cause obvious immediate failures. The flip-flop might work 99% of the time and mysteriously fail the other 1%. This makes setup violations among the most insidious digital bugs.</p>"},{"location":"chapters/08-flip-flops-timing/#hold-time-datas-afterglow","title":"Hold Time: Data's Afterglow","text":"<p>Hold time (\\(t_{hold}\\) or \\(t_h\\)) is the minimum time that data must remain stable after the clock edge.</p> <p>Even after the clock edge \"captures\" the data, the flip-flop needs a moment to complete the internal process. If data changes too quickly after the edge, the capture might be corrupted.</p> <pre><code>                    \u2190 t_hold \u2192\nD:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\n                              \u2191 D must stay stable after this point\nCLK: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2191\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2191 Clock edge\n</code></pre> <p>Hold time violations are particularly nasty because they often involve fast paths\u2014signals that arrive too quickly, not too slowly. While setup time issues can be fixed by slowing down the clock, hold time issues require adding delay to fast paths.</p> <p>Modern flip-flops often have zero or even negative hold times (meaning data can change before the clock edge finishes, as long as setup was met). But older or specialized flip-flops may have significant hold requirements.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-setup-and-hold-time-visualizer","title":"Diagram: Setup and Hold Time Visualizer","text":"Setup and Hold Time Interactive <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how setup and hold time constraints affect flip-flop reliability, identifying when timing margins are met or violated.</p> <p>Instructional Rationale: Interactive timing diagram with adjustable data arrival time lets students explore the boundaries of safe operation and see what happens at violations.</p> <p>Canvas Layout:</p> <ul> <li>Top: Large timing diagram with CLK, D, Q waveforms</li> <li>Middle: Adjustable data transition time slider</li> <li>Bottom: Timing analysis showing margins and violation status</li> <li>Side: Flip-flop timing specifications (t_setup, t_hold)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Slider to adjust when D changes relative to clock edge</li> <li>Setup margin display (positive = OK, negative = violation)</li> <li>Hold margin display (positive = OK, negative = violation)</li> <li>\"Danger zone\" highlight on timing diagram</li> <li>Captured value display (correct, wrong, or \"uncertain\" for metastable)</li> <li>Reset button for clean waveform</li> </ul> <p>Data Visibility:</p> <ul> <li>Current setup margin (time before edge minus t_setup requirement)</li> <li>Current hold margin (time after edge minus t_hold requirement)</li> <li>Violation warnings with specific violation type</li> <li>Safe operating region marked on diagram</li> <li>Flip-flop specifications panel</li> </ul> <p>Visual Style:</p> <ul> <li>Professional timing diagram appearance</li> <li>Setup window shaded in one color</li> <li>Hold window shaded in another color</li> <li>Violation regions in red</li> <li>Margin numbers displayed at measurement points</li> <li>Uncertain/metastable output shown with wavy line</li> </ul> <p>Implementation: p5.js with timing calculation and violation detection</p>"},{"location":"chapters/08-flip-flops-timing/#clock-to-q-delay-when-output-finally-responds","title":"Clock-to-Q Delay: When Output Finally Responds","text":"<p>Clock-to-Q delay (\\(t_{CQ}\\) or \\(t_{prop}\\)) is the time from the clock edge until the output Q actually changes to reflect the captured value.</p> <p>Even after a valid clock edge with proper setup and hold timing, the flip-flop doesn't update instantaneously. The internal transistors need time to switch:</p> <pre><code>CLK: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2191\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                     \u2191 Clock edge\nQ:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2190\u2500\u2500t_CQ\u2500\u2500\u2192\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                     \u2502          \u2514\u2500\u2500 Output changes here\n</code></pre> <p>Clock-to-Q delay sets a fundamental limit on system speed. If you have a chain of flip-flops with combinational logic between them:</p> <pre><code>[FF1] \u2192 [Combinational Logic] \u2192 [FF2]\n         \u2190 t_logic \u2192\n</code></pre> <p>The total path delay from one flip-flop to the next is:</p> \\[t_{path} = t_{CQ} + t_{logic}\\] <p>This must be less than the clock period minus the setup time of FF2:</p> \\[t_{CQ} + t_{logic} &lt; T_{clock} - t_{setup}\\] <p>This inequality is the fundamental timing constraint of synchronous design!</p> <p>Clock-to-Q delay typically ranges from 0.1 ns to a few nanoseconds, depending on the flip-flop technology.</p>"},{"location":"chapters/08-flip-flops-timing/#timing-diagrams-the-visual-language-of-time","title":"Timing Diagrams: The Visual Language of Time","text":"<p>A timing diagram is the primary tool for understanding and communicating the temporal behavior of digital circuits. It shows how signals change over time and their relationships to each other.</p> <p>Reading timing diagrams:</p> <ul> <li>Time flows left to right (horizontal axis)</li> <li>Signal level is vertical (high at top, low at bottom)</li> <li>Transitions show as diagonal lines (instantaneous would be vertical)</li> <li>Unknown/don't-care shown as hatched or X</li> <li>High-impedance (tri-state) shown as middle level or Z</li> </ul> <p>Key elements to identify:</p> <pre><code>Signal_A: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2190 t \u2192\n         \u2191        \u2191     \u2191\n     Stable High  \u2502     Stable Low\n               Transition\n</code></pre> <p>For flip-flop timing:</p> <pre><code>CLK:     \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2510\n      \u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\n          \u2191       \u2191       \u2191       \u2191\n     Edge 1   Edge 2  Edge 3  Edge 4\n\nD:    \u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\u2190t_su\u2192\u2191\u2190t_h\u2192\u2502\n               \u2191\n          Valid capture\n\nQ:    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\u2190t_CQ \u2192|\n</code></pre> <p>When drawing timing diagrams:</p> <ol> <li>Start with the clock\u2014it's the reference for everything</li> <li>Add input signals with proper setup/hold relationships</li> <li>Add output signals showing clock-to-Q delay</li> <li>Mark any causation relationships with arrows</li> </ol>"},{"location":"chapters/08-flip-flops-timing/#diagram-timing-diagram-builder","title":"Diagram: Timing Diagram Builder","text":"Interactive Timing Diagram Tool <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Interpret</p> <p>Learning Objective: Students will be able to interpret and construct timing diagrams showing the relationships between clock, data, and output signals with proper setup, hold, and clock-to-Q delays marked.</p> <p>Instructional Rationale: Building and annotating timing diagrams reinforces understanding of temporal relationships and prepares students for reading professional datasheets.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Multi-signal timing diagram canvas</li> <li>Left: Signal labels (CLK, D, Q, etc.)</li> <li>Right: Timing measurement tools</li> <li>Bottom: Measurement results and timing analysis</li> <li>Top: Time scale and zoom controls</li> </ul> <p>Interactive Elements:</p> <ul> <li>Add/remove signals</li> <li>Draw waveform transitions on each signal</li> <li>Automatic clock generation option</li> <li>Click two points to measure time between them</li> <li>Auto-annotate setup/hold/CQ delays</li> <li>Drag to adjust timing relationships</li> <li>Zoom in/out on time axis</li> <li>Export diagram as image</li> </ul> <p>Data Visibility:</p> <ul> <li>All signal waveforms</li> <li>Time axis with grid</li> <li>Measurement arrows with time values</li> <li>Setup/hold windows highlighted</li> <li>Clock edge markers</li> <li>Timing margin calculations</li> </ul> <p>Visual Style:</p> <ul> <li>Professional timing diagram appearance</li> <li>Grid lines for time reference</li> <li>Color coding by signal type</li> <li>Measurement arrows in distinct color</li> <li>Timing windows as shaded regions</li> <li>Clean labels and annotations</li> </ul> <p>Implementation: p5.js with waveform drawing and measurement tools</p>"},{"location":"chapters/08-flip-flops-timing/#timing-constraints-the-rules-of-the-game","title":"Timing Constraints: The Rules of the Game","text":"<p>Timing constraints are the specifications that must be satisfied for a synchronous circuit to work correctly. They define the rules of the game for getting data from one flip-flop to the next reliably.</p> <p>The fundamental constraints are:</p> <p>Setup Constraint: Data must arrive at the destination flip-flop early enough to satisfy its setup time requirement.</p> \\[t_{CQ} + t_{logic} + t_{routing} \\leq T_{clock} - t_{setup}\\] <p>Hold Constraint: Data must not arrive so fast that it violates hold time at the destination.</p> \\[t_{CQ} + t_{logic} + t_{routing} \\geq t_{hold}\\] <p>Where:</p> <ul> <li>\\(t_{CQ}\\) = Clock-to-Q delay of source flip-flop</li> <li>\\(t_{logic}\\) = Combinational logic delay</li> <li>\\(t_{routing}\\) = Wire/routing delay</li> <li>\\(T_{clock}\\) = Clock period</li> <li>\\(t_{setup}\\) = Setup time of destination flip-flop</li> <li>\\(t_{hold}\\) = Hold time of destination flip-flop</li> </ul> <p>These constraints determine your maximum clock frequency:</p> \\[f_{max} = \\frac{1}{t_{CQ} + t_{logic_{max}} + t_{routing} + t_{setup}}\\] <p>Real design tools (synthesis and place-and-route software) calculate these automatically and report \"timing slack\"\u2014the margin between the actual delay and the constraint. Positive slack means you're meeting timing; negative slack means you have a problem.</p> Slack Meaning Action Needed Positive Timing met None\u2014system works Zero Exactly on edge Risky\u2014add margin Negative Timing violated Fix required\u2014slow clock or optimize logic"},{"location":"chapters/08-flip-flops-timing/#timing-violations-when-things-go-wrong","title":"Timing Violations: When Things Go Wrong","text":"<p>A timing violation occurs when setup or hold constraints are not met. The consequences range from incorrect data capture to the dreaded metastability.</p> <p>Setup Violation: Data changes too close to (or after) the clock edge. The flip-flop might:</p> <ul> <li>Capture the old value instead of the new one</li> <li>Capture an intermediate \"garbage\" value</li> <li>Enter metastability</li> </ul> <p>Hold Violation: Data changes too soon after the clock edge. The flip-flop might:</p> <ul> <li>Capture the new value instead of the old one</li> <li>Corrupt the capture with the new data</li> <li>Enter metastability</li> </ul> <p>Signs of timing violations in real systems:</p> <ul> <li>Intermittent failures (\"works sometimes\")</li> <li>Temperature-dependent failures (timing changes with temperature)</li> <li>Failures at specific clock frequencies</li> <li>Failures that appear/disappear when you probe the circuit</li> </ul> <p>The Insidious Nature of Timing Violations</p> <p>Timing violations are particularly dangerous because they often pass testing but fail in the field. Your test environment might have slightly different voltage, temperature, or manufacturing variations than your deployed hardware. A circuit with marginal timing might work fine at 25\u00b0C on your bench but fail at 85\u00b0C in the customer's installation.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-timing-violation-detector","title":"Diagram: Timing Violation Detector","text":"Timing Violation Demonstration <p>Type: microsim</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: Assess</p> <p>Learning Objective: Students will be able to assess whether a given set of timing parameters will result in a setup or hold violation and predict the consequences of such violations.</p> <p>Instructional Rationale: Interactive parameter adjustment with immediate violation feedback develops intuition for timing margins and their importance in reliable design.</p> <p>Canvas Layout:</p> <ul> <li>Top: D flip-flop with configurable timing parameters</li> <li>Middle: Timing diagram showing current configuration</li> <li>Bottom: Timing analysis panel with pass/fail indicators</li> <li>Side: Parameter adjustment sliders</li> </ul> <p>Interactive Elements:</p> <ul> <li>Slider: Clock period</li> <li>Slider: Logic delay</li> <li>Slider: Data arrival time (relative to clock)</li> <li>Setup margin calculator (auto-updates)</li> <li>Hold margin calculator (auto-updates)</li> <li>Pass/Fail indicator for each constraint</li> <li>\"Simulate 100 captures\" showing reliability percentage</li> <li>Monte Carlo mode with timing variation</li> </ul> <p>Data Visibility:</p> <ul> <li>All timing parameters</li> <li>Setup margin (green if positive, red if negative)</li> <li>Hold margin (green if positive, red if negative)</li> <li>Timing path diagram</li> <li>Violation type indicator</li> <li>Reliability estimate</li> </ul> <p>Visual Style:</p> <ul> <li>Timing diagram with margin annotations</li> <li>Color-coded margins (green=safe, yellow=marginal, red=violated)</li> <li>Slider for each parameter</li> <li>Summary status lights (like traffic signals)</li> <li>Confidence percentage for marginal cases</li> </ul> <p>Implementation: p5.js with timing calculation and Monte Carlo simulation</p>"},{"location":"chapters/08-flip-flops-timing/#metastability-the-quantum-purgatory","title":"Metastability: The Quantum Purgatory","text":"<p>Metastability is what happens when a flip-flop receives data that violates setup or hold time. The flip-flop enters an indeterminate state\u2014neither clearly 0 nor clearly 1\u2014and may remain there for an unpredictable time before eventually settling to one value or the other.</p> <p>Think of it like a ball balanced perfectly on top of a hill between two valleys. Given enough time, it will eventually fall into one valley or the other, but while it's balanced, it's in a metastable state.</p> <pre><code>     /\\                      /\\\n    /  \\                    /  \\\n   /    \\     \u2192\u2192\u2192\u2192\u2192\u2192\u2192     /    \\\n  /      \\               /      \u25cf\n /   \u25cf    \\             /      /\n/          \\           /      \u2193\n Valley 0   Valley 1    Eventually settles\n                        (but when??)\n</code></pre> <p>The physics: when data transitions during the setup/hold window, the flip-flop's internal latches might both try to go to the same state or get stuck in a balanced condition. The random thermal noise in the circuit eventually tips the balance, but this takes time.</p> <p>The probability of metastability resolving decreases exponentially with time:</p> \\[P(metastable) \\propto e^{-t/\\tau}\\] <p>Where \\(\\tau\\) is a technology-dependent time constant (typically 0.1-1 ns for modern CMOS).</p> <p>Why is metastability dangerous?</p> <ol> <li>Unpredictable delay: The output might not resolve for many clock cycles</li> <li>Different logic sees different values: One downstream gate might see 0 while another sees 1</li> <li>Analog voltage levels: The metastable voltage might not be a valid logic level</li> <li>Hard to detect: Metastability is rare enough to slip through testing but common enough to cause field failures</li> </ol> <p>You Cannot Eliminate Metastability</p> <p>Metastability is a fundamental physical phenomenon. You cannot design it away with clever logic. You can only reduce its probability to acceptable levels and design systems that tolerate the occasional metastable event.</p>"},{"location":"chapters/08-flip-flops-timing/#mtbf-concept-measuring-reliability","title":"MTBF Concept: Measuring Reliability","text":"<p>MTBF (Mean Time Between Failures) is how we quantify the reliability impact of metastability. It tells us how often, on average, a metastable event will propagate through a synchronizer and cause a system failure.</p> <p>The MTBF for a flip-flop synchronizer is:</p> \\[MTBF = \\frac{e^{t_{resolution}/\\tau}}{f_{clock} \\cdot f_{async} \\cdot t_w}\\] <p>Where:</p> <ul> <li>\\(t_{resolution}\\) = Time allowed for metastability to resolve</li> <li>\\(\\tau\\) = Technology-dependent time constant</li> <li>\\(f_{clock}\\) = System clock frequency</li> <li>\\(f_{async}\\) = Frequency of asynchronous input transitions</li> <li>\\(t_w\\) = Metastability window width</li> </ul> <p>This formula shows key relationships:</p> <ul> <li>More resolution time \u2192 exponentially better MTBF</li> <li>Faster clock \u2192 worse MTBF (more opportunities for metastability)</li> <li>More frequent async events \u2192 worse MTBF</li> <li>Smaller metastability window \u2192 better MTBF</li> </ul> <p>What's an acceptable MTBF? It depends on the application:</p> Application Target MTBF Consumer electronics 100-1,000 years Server/networking 10,000+ years Medical/automotive 100,000+ years Space/military 1,000,000+ years <p>A single flip-flop might have an MTBF of only a few hours with direct async input. By using a two-stage synchronizer (double-flop), we can easily achieve MTBFs of centuries or more.</p>"},{"location":"chapters/08-flip-flops-timing/#synchronous-systems-marching-to-the-same-beat","title":"Synchronous Systems: Marching to the Same Beat","text":"<p>A synchronous system is one where all sequential elements (flip-flops, registers, memory) are controlled by the same clock or by clocks with a known, fixed relationship.</p> <p>Key characteristics of synchronous systems:</p> <ol> <li>Single clock domain: All flip-flops share the same clock</li> <li>Predictable timing: State changes occur only at clock edges</li> <li>Deterministic behavior: Same inputs always produce same outputs</li> <li>Analyzable: Static timing analysis can verify correct operation</li> </ol> <p>The synchronous design methodology dominates digital design because it:</p> <ul> <li>Eliminates most race conditions</li> <li>Makes timing verification tractable</li> <li>Allows high-level abstraction (RTL design)</li> <li>Enables powerful synthesis tools</li> </ul> <p>The synchronous assumption:</p> <ul> <li>Data propagates through combinational logic</li> <li>Logic settles before the next clock edge</li> <li>Flip-flops capture stable values</li> <li>The cycle repeats</li> </ul> <pre><code>         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                                     \u2502\n         \u2193                                     \u2502\n    [Flip-Flops] \u2192 [Combinational Logic] \u2192 [Flip-Flops]\n         \u2191                                     \u2191\n         \u2514\u2500\u2500\u2500\u2500 All triggered by same CLK \u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The Power of Synchronous Design</p> <p>Synchronous design is what makes modern complex chips possible. A billion-transistor processor would be impossible to verify without the synchronous abstraction\u2014we'd have to analyze every possible timing interaction. With synchronous design, we only need to verify that logic meets setup and hold constraints.</p>"},{"location":"chapters/08-flip-flops-timing/#asynchronous-inputs-the-outside-world-doesnt-care-about-your-clock","title":"Asynchronous Inputs: The Outside World Doesn't Care About Your Clock","text":"<p>An asynchronous input is any signal that can change at any time, independent of the system clock. The outside world\u2014buttons, sensors, communication lines, signals from other clock domains\u2014doesn't know or care about your clock timing.</p> <p>Asynchronous inputs are everywhere:</p> <ul> <li>User interfaces: Button presses, switch toggles</li> <li>External sensors: Temperature, motion, etc.</li> <li>Communication interfaces: Receive data from other systems</li> <li>Interrupts: Hardware events that need immediate attention</li> <li>Cross-domain signals: Data from a different clock domain</li> </ul> <p>The problem with asynchronous inputs:</p> <ul> <li>They can change at any moment, including during the setup/hold window</li> <li>This can cause metastability</li> <li>One flip-flop might see one value while another sees a different value</li> </ul> <p>You CANNOT directly use asynchronous signals to control synchronous logic. The signal must first be synchronized to your clock domain.</p> <pre><code>WRONG:\n  Async Input \u2192 Combinational Logic \u2192 Flip-Flop\n               (Metastability disaster!)\n\nRIGHT:\n  Async Input \u2192 [Synchronizer] \u2192 Combinational Logic \u2192 Flip-Flop\n                (Safe!)\n</code></pre> <p>Every Async Input Is a Potential Bug</p> <p>Every asynchronous input that enters your synchronous domain is an opportunity for metastability. Audit your design carefully to ensure ALL async inputs go through proper synchronizers. This includes reset signals, enables, and any external interface.</p>"},{"location":"chapters/08-flip-flops-timing/#synchronizer-circuits-the-border-patrol","title":"Synchronizer Circuits: The Border Patrol","text":"<p>A synchronizer circuit is a circuit that safely transfers a signal from an asynchronous domain (or different clock domain) into a synchronous clock domain while minimizing metastability risk.</p> <p>The simplest (but inadequate) synchronizer is a single flip-flop:</p> <pre><code>Async Input \u2192 [D-FF] \u2192 To synchronous logic\n               \u2191\n              CLK\n</code></pre> <p>This helps by restricting output changes to clock edges, but if the async input violates setup/hold time (which it will eventually), the flip-flop can go metastable. The metastable state might propagate to the downstream logic before it resolves.</p> <p>A single flip-flop synchronizer is almost never sufficient. The probability of metastability causing a system failure is too high for reliable operation.</p> <p>Requirements for a good synchronizer:</p> <ol> <li>Provides time for metastability to resolve</li> <li>Isolates metastable node from downstream logic</li> <li>Achieves acceptable MTBF for the application</li> <li>Adds minimal latency</li> <li>Works across all operating conditions</li> </ol> <p>The standard solution is the double-flop synchronizer.</p>"},{"location":"chapters/08-flip-flops-timing/#double-flop-synchronizer-the-standard-solution","title":"Double Flop Synchronizer: The Standard Solution","text":"<p>The double flop synchronizer is the industry-standard method for safely bringing asynchronous signals into a synchronous clock domain. It uses two flip-flops in series:</p> <pre><code>Async Input \u2192 [D-FF #1] \u2192 [D-FF #2] \u2192 To synchronous logic\n                 \u2191           \u2191\n                 \u2514\u2500\u2500 CLK \u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>How it works:</p> <ol> <li>First flip-flop captures the async input. It may go metastable.</li> <li>Full clock period passes while FF1's output is allowed to resolve.</li> <li>Second flip-flop captures FF1's (now resolved) output cleanly.</li> <li>Synchronized output goes to downstream logic.</li> </ol> <p>The key insight: FF1 has an entire clock period to resolve its metastability before FF2 samples it. This exponentially reduces the probability of metastability propagating.</p> <p>The MTBF improvement from adding the second flip-flop is dramatic:</p> \\[MTBF_{2-stage} = MTBF_{1-stage} \\cdot e^{T_{clock}/\\tau}\\] <p>With typical values (\\(\\tau\\) \u2248 0.1 ns, \\(T_{clock}\\) \u2248 10 ns):</p> \\[MTBF_{2-stage} \\approx MTBF_{1-stage} \\cdot e^{100} \\approx MTBF_{1-stage} \\cdot 10^{43}\\] <p>That's a factor of 10^43 improvement! If a single flip-flop had an MTBF of 1 microsecond, the two-stage synchronizer would have an MTBF longer than the age of the universe.</p>"},{"location":"chapters/08-flip-flops-timing/#diagram-double-flop-synchronizer","title":"Diagram: Double Flop Synchronizer","text":"Double Flop Synchronizer Operation <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how a double-flop synchronizer provides a full clock period for metastability resolution and dramatically improves reliability compared to a single flip-flop.</p> <p>Instructional Rationale: Step-by-step visualization of signal propagation through both flip-flops, including occasional metastable events that resolve before reaching the output, makes the protection mechanism clear.</p> <p>Canvas Layout:</p> <ul> <li>Top: Circuit diagram with two flip-flops in series</li> <li>Middle: Timing diagram showing async input, FF1 output, FF2 output</li> <li>Bottom: Metastability indicator and MTBF comparison</li> <li>Side: Resolution time counter</li> </ul> <p>Interactive Elements:</p> <ul> <li>Asynchronous input that can change at any time</li> <li>Clock running continuously</li> <li>\"Inject metastability\" button to show worst-case</li> <li>Resolution time display (how long FF1 takes to resolve)</li> <li>MTBF comparison slider (1 FF vs 2 FF)</li> <li>Statistics over many samples</li> </ul> <p>Data Visibility:</p> <ul> <li>Current value at each stage</li> <li>Time since last FF1 capture</li> <li>Whether FF1 is metastable</li> <li>FF2 always stable (resolved)</li> <li>MTBF improvement factor</li> <li>Latency through synchronizer (2 clock cycles)</li> </ul> <p>Visual Style:</p> <ul> <li>Two flip-flops clearly shown in series</li> <li>Metastable state shown as oscillating or middle-level signal</li> <li>Resolution animation showing gradual settling</li> <li>MTBF as logarithmic scale comparison</li> <li>Color coding: metastable (yellow), stable-0 (blue), stable-1 (orange)</li> </ul> <p>Implementation: p5.js with metastability simulation and resolution animation</p> <p>Design rules for double-flop synchronizers:</p> <ol> <li>Use two identical flip-flops from the same clock domain</li> <li>Place them close together (minimize wire delay between them)</li> <li>No logic between the flip-flops (direct connection only)</li> <li>Both flip-flops use the same clock edge</li> <li>Account for the 2-cycle latency in your design</li> </ol> <p>When is a double-flop synchronizer not enough?</p> <ul> <li>Extremely high-reliability applications might use 3 or more stages</li> <li>Multi-bit signals need special handling (more on this in later courses)</li> <li>Very high frequencies might not give enough resolution time</li> </ul> <p>The Two-Cycle Tax</p> <p>Every asynchronous input incurs a 2-cycle latency through the double-flop synchronizer. This is the cost of reliable synchronization. Design your system to tolerate this delay\u2014it's not optional, it's physics!</p>"},{"location":"chapters/08-flip-flops-timing/#putting-it-all-together-the-synchronous-design-flow","title":"Putting It All Together: The Synchronous Design Flow","text":"<p>Let's step back and see how all these concepts work together in a complete synchronous design.</p> <p>The Big Picture:</p> <pre><code>                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502    SYNCHRONOUS SYSTEM          \u2502\nAsync Input \u2192[Sync]\u2192[FF]\u2192[Logic]\u2192[FF]\u2192[Logic]\u2192[FF]\u2192 Output\n                     \u2191          \u2191          \u2191\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 CLK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Design Process:</p> <ol> <li>Identify async inputs: All external signals, cross-domain signals</li> <li>Add synchronizers: Double-flop synchronizer for each async input</li> <li>Design combinational logic: Boolean functions between flip-flops</li> <li>Verify timing: Ensure setup and hold constraints are met</li> <li>Calculate MTBF: Verify synchronizer reliability is adequate</li> <li>Add reset logic: Usually async assertion, sync release</li> </ol> <p>Key Equations:</p> <p>D Flip-Flop: \\(Q^+ = D\\) (at clock edge)</p> <p>JK Flip-Flop: \\(Q^+ = J \\cdot \\overline{Q} + \\overline{K} \\cdot Q\\)</p> <p>T Flip-Flop: \\(Q^+ = T \\oplus Q\\)</p> <p>Setup Constraint: \\(t_{CQ} + t_{logic} &lt; T_{clock} - t_{setup}\\)</p> <p>Hold Constraint: \\(t_{CQ} + t_{logic} &gt; t_{hold}\\)</p> <p>MTBF: \\(\\frac{e^{t_{resolution}/\\tau}}{f_{clock} \\cdot f_{async} \\cdot t_w}\\)</p> <p>Flip-Flop Selection Guide:</p> Need Best Choice Simple data storage D flip-flop Toggle/counting T flip-flop or JK in toggle mode Explicit set/reset control JK flip-flop Immediate initialization Add async preset/clear Safe clock-domain crossing Double-flop synchronizer"},{"location":"chapters/08-flip-flops-timing/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<p>As you work with flip-flops and timing, watch out for these pitfalls:</p> <ol> <li> <p>Forgetting setup/hold requirements: Every flip-flop has timing requirements. Data that arrives too late (setup) or changes too early (hold) will cause problems.</p> </li> <li> <p>Using asynchronous signals directly: Never connect an external signal directly to synchronous logic. Always synchronize first!</p> </li> <li> <p>Ignoring metastability: Metastability is real, even if you can't see it in simulation. Design for it.</p> </li> <li> <p>Using single flip-flop synchronizers: One flip-flop is almost never enough. Use double-flop synchronizers.</p> </li> <li> <p>Confusing latches and flip-flops: Latches are level-sensitive; flip-flops are edge-triggered. The terms are not interchangeable!</p> </li> <li> <p>Asserting both preset and clear: Just like S=R=1 in an SR latch, this is invalid. Design your logic to prevent it.</p> </li> <li> <p>Releasing async reset during metastability window: Use synchronous release for reset signals.</p> </li> <li> <p>Assuming infinite speed: Every gate has delay. Every wire has delay. Budget for it.</p> </li> </ol>"},{"location":"chapters/08-flip-flops-timing/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've mastered the edge\u2014literally. Edge-triggered flip-flops are the foundation of all modern synchronous digital systems.</p> <p>Core Concepts:</p> <ul> <li>Edge-triggering captures data at a precise moment, eliminating race-through</li> <li>D flip-flops are the workhorse: \\(Q^+ = D\\)</li> <li>JK flip-flops add toggle mode: \\(Q^+ = J \\cdot \\overline{Q} + \\overline{K} \\cdot Q\\)</li> <li>T flip-flops specialize in toggling: \\(Q^+ = T \\oplus Q\\)</li> <li>Master-slave configuration creates edge-triggering from latches</li> </ul> <p>Timing Fundamentals:</p> <ul> <li>Setup time: Data must be stable before the clock edge</li> <li>Hold time: Data must remain stable after the clock edge</li> <li>Clock-to-Q delay: Time for output to respond after clock edge</li> <li>Timing violations cause unpredictable behavior and metastability</li> </ul> <p>Control Inputs:</p> <ul> <li>Preset forces Q=1 immediately (asynchronous)</li> <li>Clear forces Q=0 immediately (asynchronous)</li> <li>Asynchronous reset works immediately; synchronous reset waits for clock</li> </ul> <p>Metastability and Synchronization:</p> <ul> <li>Metastability occurs when setup/hold is violated</li> <li>MTBF quantifies reliability (higher is better)</li> <li>Synchronous systems use a single clock for predictability</li> <li>Asynchronous inputs must be synchronized before use</li> <li>Double-flop synchronizer is the standard solution</li> </ul> <p>The Key Insight</p> <p>Timing is everything in digital design. The logic might be correct, but if the timing is wrong, the system fails. Master timing analysis, and you'll understand why some chips run at 5 GHz while others struggle at 100 MHz.</p> Graphic Novel Suggestion <p>A compelling graphic novel could follow the dramatic story of the engineers who developed the first reliable flip-flop circuits in the 1940s and 1950s. The narrative could center on the mysterious \"glitches\" that plagued early digital computers\u2014systems that would work perfectly for hours and then produce wrong answers seemingly at random. Through detective work involving oscilloscopes, careful measurements, and late nights in the lab, the engineers eventually discovered metastability\u2014a phenomenon that straddled the boundary between analog and digital, between physics and logic. The climax could feature the moment when the double-flop synchronizer was first proposed, finally taming the chaos of asynchronous inputs and enabling the reliable digital revolution we know today.</p>"},{"location":"chapters/08-flip-flops-timing/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Flip-Flop Selection <p>You need to build a 3-bit binary counter that counts from 0 to 7 and wraps around. Which flip-flop type would be most appropriate, and how would you configure the inputs?</p> <p>Solution: T flip-flops (or JK flip-flops in toggle mode) are ideal for counters. Configure each with T=1 (or J=K=1) for continuous toggling. Chain them so that each flip-flop toggles when all less-significant bits are 1. The count sequence will be 000 \u2192 001 \u2192 010 \u2192 011 \u2192 100 \u2192 101 \u2192 110 \u2192 111 \u2192 000...</p> Problem 2: Setup Time Analysis <p>A flip-flop has t_setup = 0.5 ns, t_CQ = 0.8 ns. The combinational logic between two flip-flops has a delay of 4.2 ns. What is the maximum clock frequency?</p> <p>Solution: Maximum clock frequency is limited by: \\(T_{min} = t_{CQ} + t_{logic} + t_{setup}\\) \\(T_{min} = 0.8 + 4.2 + 0.5 = 5.5\\) ns \\(f_{max} = 1/T_{min} = 1/(5.5 \\times 10^{-9}) = 182\\) MHz</p> Problem 3: Metastability and MTBF <p>A single flip-flop synchronizer has an MTBF of 1 hour. If you add a second flip-flop stage and the resolution time constant \u03c4 = 0.1 ns, with a clock period of 10 ns, what is the approximate new MTBF?</p> <p>Solution: The improvement factor is \\(e^{T_{clock}/\\tau} = e^{10/0.1} = e^{100} \\approx 2.7 \\times 10^{43}\\) New MTBF \u2248 1 hour \u00d7 2.7 \u00d7 10^43 \u2248 3 \u00d7 10^39 years This is far longer than the age of the universe (~14 billion years), demonstrating the dramatic effectiveness of the double-flop synchronizer.</p> Problem 4: JK Flip-Flop Behavior <p>A JK flip-flop currently has Q=1. Trace the output through the following sequence of inputs (assume positive edge triggered):</p> <ul> <li>Clock edge 1: J=0, K=0</li> <li>Clock edge 2: J=1, K=0</li> <li>Clock edge 3: J=1, K=1</li> <li>Clock edge 4: J=0, K=1</li> <li>Clock edge 5: J=1, K=1</li> </ul> <p>Solution:</p> <ul> <li>Initial: Q=1</li> <li>After edge 1: J=K=0 \u2192 Hold \u2192 Q=1</li> <li>After edge 2: J=1, K=0 \u2192 Set \u2192 Q=1 (already 1)</li> <li>After edge 3: J=K=1 \u2192 Toggle \u2192 Q=0</li> <li>After edge 4: J=0, K=1 \u2192 Reset \u2192 Q=0 (already 0)</li> <li>After edge 5: J=K=1 \u2192 Toggle \u2192 Q=1</li> </ul> Problem 5: Synchronizer Design <p>An external sensor produces a signal that can change at any time. Your system runs at 100 MHz. Why can't you use this signal directly in your combinational logic? What would you add to the design?</p> <p>Solution: The sensor signal is asynchronous\u2014it can change at any time, including during the setup/hold window of your flip-flops. This can cause metastability, leading to unpredictable behavior.</p> <p>Solution: Add a double-flop synchronizer (two D flip-flops in series, both clocked by your 100 MHz clock). This provides a full 10 ns clock period for any metastability to resolve before the signal reaches your synchronous logic. The cost is 2 clock cycles (20 ns) of latency.</p> Problem 6: Reset Strategy <p>Compare asynchronous and synchronous reset for a system that must start in a known state immediately after power-up, but must also avoid metastability during reset release.</p> <p>Solution: Use an \"asynchronous assert, synchronous release\" strategy:</p> <ul> <li>Assertion: When reset is pressed, it takes effect immediately (asynchronous) to guarantee the system reaches a known state even if the clock isn't running</li> <li>Release: When reset is released, the release is synchronized to the clock edge (synchronous) to avoid metastability during the transition back to normal operation</li> </ul> <p>This gives you the best of both worlds: guaranteed initialization at power-up and clean timing during normal operation.</p>"},{"location":"chapters/08-flip-flops-timing/quiz/","title":"Quiz: Flip-Flops and Timing","text":"<p>Test your understanding of flip-flop types, timing parameters, and synchronous design principles.</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#1-what-distinguishes-a-flip-flop-from-a-latch","title":"1. What distinguishes a flip-flop from a latch?","text":"<ol> <li>Flip-flops use more transistors</li> <li>Flip-flops are edge-triggered rather than level-sensitive</li> <li>Flip-flops can only store 1, not 0</li> <li>Flip-flops require higher voltage</li> </ol> Show Answer <p>The correct answer is B. Flip-flops are edge-triggered\u2014they sample input and update output only at clock transitions (rising or falling edge). Latches are level-sensitive\u2014they pass input to output during the entire enable period. Edge triggering provides precise timing control.</p> <p>Concept Tested: Edge Triggered</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#2-for-a-d-flip-flop-what-value-does-q-take-after-a-clock-edge","title":"2. For a D flip-flop, what value does Q take after a clock edge?","text":"<ol> <li>Always 0</li> <li>Always 1</li> <li>The value of D at the clock edge</li> <li>The complement of D</li> </ol> Show Answer <p>The correct answer is C. A D flip-flop captures the value present at its D input at the active clock edge and holds it until the next active edge. \"D\" stands for \"data\"\u2014whatever data is at D appears at Q after the clock.</p> <p>Concept Tested: D Flip-Flop</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#3-what-is-setup-time","title":"3. What is setup time?","text":"<ol> <li>The time to power on the chip</li> <li>The time data must be stable before the clock edge</li> <li>The time from clock edge to valid output</li> <li>The total time to configure the circuit</li> </ol> Show Answer <p>The correct answer is B. Setup time (tsu) is the minimum time the data input must be stable BEFORE the active clock edge. Violating setup time can result in incorrect data capture or metastability.</p> <p>Concept Tested: Setup Time</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#4-what-is-hold-time","title":"4. What is hold time?","text":"<ol> <li>The time the circuit holds its state without power</li> <li>The time data must remain stable after the clock edge</li> <li>The maximum operating time</li> <li>The time between clock edges</li> </ol> Show Answer <p>The correct answer is B. Hold time (th) is the minimum time the data input must remain stable AFTER the active clock edge. If data changes too quickly after the edge, the flip-flop may capture incorrect or metastable values.</p> <p>Concept Tested: Hold Time</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#5-what-is-metastability","title":"5. What is metastability?","text":"<ol> <li>A stable state between 0 and 1</li> <li>An unstable condition when setup/hold times are violated</li> <li>A type of flip-flop design</li> <li>Normal operating behavior</li> </ol> Show Answer <p>The correct answer is B. Metastability occurs when a flip-flop captures an input that is changing during the setup/hold window. The flip-flop may enter an intermediate state between 0 and 1, taking unpredictable time to resolve. It can cause system failures.</p> <p>Concept Tested: Metastability</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#6-what-is-the-jk-flip-flops-behavior-when-j1-and-k1","title":"6. What is the JK flip-flop's behavior when J=1 and K=1?","text":"<ol> <li>Q becomes 0</li> <li>Q becomes 1</li> <li>Q toggles (inverts)</li> <li>Invalid state</li> </ol> Show Answer <p>The correct answer is C. When both J and K are 1, the JK flip-flop toggles its output on each clock edge. This is the \"toggle mode\" that distinguishes JK from other flip-flops. Unlike the SR latch, J=K=1 is a valid, useful state.</p> <p>Concept Tested: JK Toggle Mode</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#7-what-is-clock-to-q-delay","title":"7. What is clock-to-Q delay?","text":"<ol> <li>The delay from input D to output Q</li> <li>The delay from active clock edge to stable output</li> <li>The time between two clock cycles</li> <li>The setup time plus hold time</li> </ol> Show Answer <p>The correct answer is B. Clock-to-Q delay (tcq) is the time from the active clock edge until the flip-flop output becomes stable and valid. It's a key timing parameter that affects the maximum operating frequency of synchronous circuits.</p> <p>Concept Tested: Clock-to-Q Delay</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#8-what-is-the-purpose-of-an-asynchronous-reset-on-a-flip-flop","title":"8. What is the purpose of an asynchronous reset on a flip-flop?","text":"<ol> <li>To clock the flip-flop faster</li> <li>To immediately force the output to a known state regardless of clock</li> <li>To increase power consumption</li> <li>To disable the clock input</li> </ol> Show Answer <p>The correct answer is B. An asynchronous reset forces the flip-flop output to 0 (or 1 for preset) immediately when asserted, without waiting for a clock edge. It provides instant initialization but requires careful timing analysis.</p> <p>Concept Tested: Asynchronous Reset</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#9-what-is-a-synchronous-reset","title":"9. What is a synchronous reset?","text":"<ol> <li>A reset that takes effect immediately</li> <li>A reset that takes effect only on the active clock edge</li> <li>A reset shared by multiple flip-flops</li> <li>A reset that varies with temperature</li> </ol> Show Answer <p>The correct answer is B. A synchronous reset only takes effect at the active clock edge, just like a normal data input. The reset signal is gated with the clock. This simplifies timing analysis but requires the clock to be running.</p> <p>Concept Tested: Synchronous Reset</p>"},{"location":"chapters/08-flip-flops-timing/quiz/#10-what-is-a-t-flip-flop-and-how-is-it-commonly-used","title":"10. What is a T flip-flop, and how is it commonly used?","text":"<ol> <li>A flip-flop with temperature sensing, used in thermal protection</li> <li>A flip-flop that toggles when T=1, used in counters</li> <li>A flip-flop with timing output, used in clocks</li> <li>A flip-flop with test mode, used in debugging</li> </ol> Show Answer <p>The correct answer is B. A T (Toggle) flip-flop inverts its output when T=1 and holds when T=0. It's commonly used in counter design because binary counting involves toggling bits at different rates. A JK flip-flop with J=K becomes a T flip-flop.</p> <p>Concept Tested: T Flip-Flop</p>"},{"location":"chapters/09-fsm-fundamentals/","title":"Finite State Machine Fundamentals","text":""},{"location":"chapters/09-fsm-fundamentals/#summary","title":"Summary","text":"<p>This chapter introduces finite state machines (FSMs), the core abstraction for designing sequential digital systems with well-defined behavior. Students will learn the FSM model including states, transitions, inputs, and outputs, understand the distinction between Moore machines (outputs depend only on state) and Mealy machines (outputs depend on state and inputs), and master state diagram and state table representations. The chapter covers state encoding strategies including binary, one-hot, and Gray code encoding, along with state assignment optimization and state minimization techniques.</p>"},{"location":"chapters/09-fsm-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Finite State Machine</li> <li>FSM State</li> <li>State Transition</li> <li>Current State</li> <li>Next State</li> <li>Next State Logic</li> <li>Output Logic</li> <li>Moore Machine</li> <li>Moore Output</li> <li>Mealy Machine</li> <li>Mealy Output</li> <li>State Diagram</li> <li>State Diagram Notation</li> <li>State Table</li> <li>State Encoding</li> <li>Binary Encoding</li> <li>One-Hot Encoding</li> <li>Gray Code Encoding</li> <li>State Assignment</li> <li>State Minimization</li> </ol>"},{"location":"chapters/09-fsm-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> <li>Chapter 7: Introduction to Sequential Logic</li> <li>Chapter 8: Flip-Flops and Timing</li> </ul>"},{"location":"chapters/09-fsm-fundamentals/#introduction-the-machine-that-remembers-where-its-been","title":"Introduction: The Machine That Remembers Where It's Been","text":"<p>Welcome to what might be the most empowering chapter in this entire course. You're about to learn how to design systems that think\u2014well, at least systems that can remember what they're doing and decide what to do next based on what's happened before.</p> <p>Consider a traffic light. It's not just randomly cycling colors. It knows it's currently showing green, it knows it should go yellow next, and it knows how long to wait. When a pedestrian presses the crossing button, it knows to factor that into its decision. That traffic light is running a finite state machine\u2014and by the end of this chapter, you'll be able to design one from scratch.</p> <p>Or think about your favorite video game. When your character is standing, they can jump, run, or duck. When they're jumping, they can't duck (physics, people!), but they can transition to falling. These relationships between actions form a state machine that governs everything from Mario's platforming to the AI controlling enemy behavior.</p> <p>Here's the beautiful secret: finite state machines are the bridge between the abstract world of flip-flops and the complex behaviors we see in real digital systems. They're the lingua franca of sequential design\u2014the language in which digital designers describe behavior before writing a single line of Verilog.</p> <p>Ready to speak fluent state machine? Let's go!</p>"},{"location":"chapters/09-fsm-fundamentals/#what-is-a-finite-state-machine","title":"What Is a Finite State Machine?","text":"<p>A Finite State Machine (FSM) is a mathematical model of computation that describes a system with a limited number of states, rules for transitioning between states, and (often) outputs that depend on the current state or transitions.</p> <p>The word \"finite\" is crucial: the machine can only be in one of a predetermined, countable number of states. Unlike a general-purpose computer that can represent arbitrary amounts of information in memory, an FSM has exactly \\(N\\) possible states, no more, no less.</p> <p>Every FSM has five essential components:</p> <ol> <li>States: The possible configurations the system can be in</li> <li>Inputs: External signals that affect transitions</li> <li>Outputs: Signals the system produces</li> <li>Transitions: Rules for moving between states</li> <li>Initial state: Where the system starts</li> </ol> <p>Think of an FSM like a board game where:</p> <ul> <li>The states are the squares on the board</li> <li>The inputs are the dice rolls or card draws</li> <li>The transitions are the rules saying \"if you're here and you roll this, go there\"</li> <li>The outputs might be \"collect $200\" or \"go to jail\"</li> <li>The initial state is \"Start\"</li> </ul> <p>The Power of Abstraction</p> <p>FSMs are powerful because they hide complexity. You don't need to think about flip-flops, timing, or gates when designing at the FSM level. You specify behavior, and then systematically derive the implementation.</p> <p>Here's a simple example\u2014a coin-operated turnstile:</p> Current State Input Next State Output Locked Push Locked Nothing (blocked) Locked Coin Unlocked Allow passage Unlocked Push Locked Person passes through Unlocked Coin Unlocked Nothing (coin returned) <p>Two states. Two inputs. Complete specification of behavior. That's the elegance of FSMs.</p>"},{"location":"chapters/09-fsm-fundamentals/#fsm-state-snapshots-of-your-system","title":"FSM State: Snapshots of Your System","text":"<p>An FSM State represents a unique configuration of the system\u2014a snapshot of everything the machine needs to remember to determine its future behavior.</p> <p>States capture memory in its most abstract form. When we say a traffic light is in the \"Green\" state, we're saying the system remembers it's showing green right now. When we say a vending machine is in the \"75 cents deposited\" state, it remembers exactly how much money has been inserted.</p> <p>Key properties of states:</p> <ul> <li>Mutually exclusive: The system is in exactly one state at any moment</li> <li>Collectively exhaustive: The states cover all possible situations</li> <li>Well-defined: Each state has clear meaning and implications</li> <li>Finite in number: There's a countable set of states</li> </ul> <p>States are typically given descriptive names that reflect their meaning:</p> <ul> <li>Traffic light: <code>GREEN</code>, <code>YELLOW</code>, <code>RED</code>, <code>WALK_SIGNAL</code></li> <li>Lock combination: <code>IDLE</code>, <code>FIRST_CORRECT</code>, <code>SECOND_CORRECT</code>, <code>UNLOCKED</code></li> <li>Elevator: <code>STOPPED_FLOOR_1</code>, <code>MOVING_UP</code>, <code>STOPPED_FLOOR_2</code>, <code>MOVING_DOWN</code></li> </ul> <p>States vs. State Variables</p> <p>We often implement states using flip-flops (state variables). A system with 4 states needs 2 flip-flops (since \\(2^2 = 4\\)). But conceptually, we think about the abstract states, not the flip-flop values. The encoding is a separate concern we'll tackle later.</p>"},{"location":"chapters/09-fsm-fundamentals/#diagram-fsm-state-concept-visualizer","title":"Diagram: FSM State Concept Visualizer","text":"FSM State Concept Visualizer <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain what an FSM state represents and how a system can only occupy one state at a time while transitioning between states based on inputs.</p> <p>Instructional Rationale: Visual representation of states as distinct \"locations\" with highlighting of the current state reinforces the concept that exactly one state is active at any moment.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Multiple state circles arranged visually</li> <li>Current state highlighted with distinct color</li> <li>Input controls at bottom</li> <li>State description panel on side</li> <li>Transition arrows showing possible next states</li> </ul> <p>Interactive Elements:</p> <ul> <li>Multiple input buttons to trigger transitions</li> <li>Current state displays its name and description</li> <li>Possible transitions highlighted from current state</li> <li>Transition animation when input triggers state change</li> <li>State history log showing sequence of states visited</li> <li>Reset button to return to initial state</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state name prominently displayed</li> <li>State description text</li> <li>Available inputs from current state</li> <li>Where each input will lead</li> <li>History of states visited</li> </ul> <p>Visual Style:</p> <ul> <li>States as colored circles with names inside</li> <li>Current state glowing or highlighted</li> <li>Arrows showing transitions with input labels</li> <li>Inactive states shown dimmer</li> <li>Clean, uncluttered layout emphasizing one-at-a-time nature</li> </ul> <p>Implementation: p5.js with state tracking and transition animation</p> <p>How many states do you need? That depends entirely on what your system needs to remember:</p> <ul> <li>Remembering one binary choice: 2 states (e.g., ON/OFF)</li> <li>Remembering a sequence position: As many states as sequence steps</li> <li>Remembering multiple independent things: States multiply (3 options \u00d7 4 options = 12 states)</li> </ul> <p>A system that needs to track both whether it's powered on (2 choices) and which of 4 modes it's in (4 choices) needs \\(2 \\times 4 = 8\\) states, not 6.</p>"},{"location":"chapters/09-fsm-fundamentals/#state-transition-the-rules-of-movement","title":"State Transition: The Rules of Movement","text":"<p>A State Transition defines how the system moves from one state to another based on inputs. Transitions are the dynamics of your FSM\u2014they answer the question \"what happens next?\"</p> <p>Every transition has three components:</p> <ol> <li>Source state: Where you're coming from</li> <li>Input condition: What triggers the transition</li> <li>Destination state: Where you're going</li> </ol> <p>We can write transitions in several ways:</p> <p>Text notation: <code>STATE_A --[input=1]--&gt; STATE_B</code></p> <p>Table notation:</p> Current State Input Next State STATE_A 1 STATE_B STATE_A 0 STATE_A <p>Equation notation: If in STATE_A and input=1, then next_state = STATE_B</p> <p>Important rules for transitions:</p> <ul> <li>Deterministic: For any state and input combination, there's exactly one transition (one next state)</li> <li>Complete: Every state must have a transition defined for every possible input</li> <li>Self-loops allowed: A state can transition to itself (stay in place)</li> </ul> <p>What happens if you don't define a transition for some input? That's a design error. The system won't know what to do, and in real hardware, undefined behavior leads to unpredictable results.</p> <p>Don't Forget the Default Cases</p> <p>When designing FSMs, it's easy to focus on the \"interesting\" transitions and forget the cases where nothing happens. Always ask: \"What should the system do if it's in state X and receives an unexpected input?\" Usually, the answer is \"stay in state X\" (a self-loop).</p> <p>Consider a simple sequence detector that looks for the pattern \"01\":</p> Current State Input Next State Interpretation IDLE 0 SAW_0 First 0 seen, looking for 1 IDLE 1 IDLE Wrong start, keep waiting SAW_0 0 SAW_0 Another 0, still valid start SAW_0 1 DETECTED Pattern complete! DETECTED 0 SAW_0 Start of new pattern DETECTED 1 IDLE Pattern broken, reset <p>Notice how every state-input pair has exactly one outcome. No ambiguity, no missing cases.</p>"},{"location":"chapters/09-fsm-fundamentals/#current-state-and-next-state-times-arrow","title":"Current State and Next State: Time's Arrow","text":"<p>In FSM design, we constantly distinguish between Current State (where we are now) and Next State (where we'll be after the clock edge).</p> <p>This distinction maps directly to our flip-flop knowledge from Chapter 8:</p> <ul> <li>Current state is stored in flip-flops (the \\(Q\\) outputs)</li> <li>Next state is computed by combinational logic (feeds the \\(D\\) inputs)</li> <li>At each clock edge, next state becomes current state</li> </ul> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nCurrent State \u2500\u2500\u2500\u2500\u2500\u2500\u2524                      \u2502\n(Q outputs)         \u2502   Combinational      \u251c\u2500\u2500\u2500\u2500 Next State\n                    \u2502   (Next State        \u2502     (D inputs)\nInputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    Logic)            \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u2514\u2500\u2500\u2500\u2500 fed back to flip-flops\n</code></pre> <p>This is the fundamental FSM equation in action:</p> \\[S^+ = f(S, I)\\] <p>Where:</p> <ul> <li>\\(S^+\\) is the next state</li> <li>\\(S\\) is the current state</li> <li>\\(I\\) is the current inputs</li> <li>\\(f\\) is the next-state function (defined by your transition table)</li> </ul> <p>At every clock edge, the flip-flops perform the update:</p> \\[S \\leftarrow S^+\\] <p>The separation between current and next state is what makes FSMs synchronous\u2014all state changes happen simultaneously at clock edges, not whenever some random signal changes.</p>"},{"location":"chapters/09-fsm-fundamentals/#diagram-current-state-to-next-state-flow","title":"Diagram: Current State to Next State Flow","text":"Current State to Next State Flow <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Describe</p> <p>Learning Objective: Students will be able to describe how the next state is computed from the current state and inputs, and how the clock edge causes the transition to occur.</p> <p>Instructional Rationale: Animating the flow from current state through next-state logic to next state, with clock edge triggering the update, makes the synchronous nature of FSMs concrete.</p> <p>Canvas Layout:</p> <ul> <li>Left: Current state register (flip-flops) with Q outputs</li> <li>Center: Next-state logic cloud with inputs feeding in</li> <li>Right: Next state values (D inputs to flip-flops)</li> <li>Bottom: Clock waveform with trigger button</li> <li>Top: Visual of current vs next state values</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input toggles to change external inputs</li> <li>Current state display</li> <li>Next state preview (computed but not yet latched)</li> <li>Clock edge button to trigger state update</li> <li>Animation showing data flow through the system</li> <li>Step-by-step mode vs continuous clock mode</li> <li>State equation display</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state (binary and symbolic name)</li> <li>All inputs</li> <li>Next state computation (shows logic)</li> <li>Next state result</li> <li>Comparison of current vs next</li> </ul> <p>Visual Style:</p> <ul> <li>Flip-flops shown as storage elements</li> <li>Combinational logic as cloud/box</li> <li>Data flow shown with animated arrows</li> <li>Clock edge as rising pulse</li> <li>State change animation at edge</li> <li>Color distinction between current (blue) and next (orange)</li> </ul> <p>Implementation: p5.js with synchronized state updates and flow animation</p> <p>Think of it this way: the current state is like your bank balance right now. The next state is what your balance will be after the next transaction (computed but not yet posted). The clock edge is when the bank \"posts\" the transaction and your balance actually changes.</p>"},{"location":"chapters/09-fsm-fundamentals/#next-state-logic-the-decision-maker","title":"Next State Logic: The Decision Maker","text":"<p>Next State Logic is the combinational circuit that computes what the next state should be based on the current state and inputs. It's the \"brain\" of your FSM.</p> <p>The next state logic implements the transition table we've been drawing. For each combination of current state and inputs, it produces the next state.</p> <p>Here's how it fits in the FSM architecture:</p> <pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502                                     \u2502\n           \u25bc                                     \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n    \u2502   Next     \u2502     \u2502    State      \u2502    \u2502 Output \u2502\n    \u2502   State    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Register    \u2502\u2500\u2500\u2500\u25b6\u2502  Logic \u2502\u2500\u2500\u25b6 Outputs\n    \u2502   Logic    \u2502     \u2502  (Flip-Flops) \u2502    \u2502        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u25b2                   \u2502\n           \u2502                   \u2502\n    Inputs \u2502                   \u2502 Current State\n           \u2502                   \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Designing next state logic:</p> <ol> <li>Start with the transition table</li> <li>Assign binary codes to states (state encoding)</li> <li>Write Boolean equations for each flip-flop input</li> <li>Simplify using K-maps or Boolean algebra</li> <li>Implement with gates</li> </ol> <p>Example: For a 2-bit state register (states encoded as 00, 01, 10, 11), you need equations for \\(D_1\\) and \\(D_0\\):</p> <p>[D_1 = f_1(Q_1, Q_0, inputs)] [D_0 = f_0(Q_1, Q_0, inputs)]</p> <p>These are just combinational logic functions\u2014the same kind you've been designing since Chapter 4!</p> <p>Next State Logic Is Just Combinational Logic</p> <p>Don't let the FSM terminology intimidate you. The \"next state logic\" is simply combinational logic that you already know how to design. The inputs are state bits and external inputs. The outputs are the D inputs to your flip-flops.</p>"},{"location":"chapters/09-fsm-fundamentals/#output-logic-speaking-to-the-world","title":"Output Logic: Speaking to the World","text":"<p>Output Logic is the combinational circuit that generates the FSM's outputs based on current state (and possibly inputs). It's how your FSM communicates its decisions to the outside world.</p> <p>Outputs might include:</p> <ul> <li>Control signals: Enable a counter, start a motor, trigger an alarm</li> <li>Status indicators: LEDs, displays, ready/busy flags</li> <li>Data selects: Mux controls, memory addresses</li> <li>Handshaking: Request, acknowledge, valid signals</li> </ul> <p>Output logic comes in two flavors, depending on whether outputs depend only on state (Moore) or on state plus inputs (Mealy). We'll explore this distinction shortly.</p> <p>The position of output logic in the architecture:</p> <pre><code>                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nCurrent State \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502              \u2502\n                                    \u2502   Output     \u2502\u2500\u2500\u25b6 Outputs\nInputs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   Logic     \u2502\n(only for Mealy machines)           \u2502              \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Like next state logic, output logic is purely combinational. You derive it from the output specifications in your state table.</p> <p>Example output equations for a traffic light controller:</p> <p>[RED = Q_1 \\cdot Q_0] [YELLOW = Q_1 \\cdot \\overline{Q_0}] [GREEN = \\overline{Q_1} \\cdot Q_0 + \\overline{Q_1} \\cdot \\overline{Q_0}]</p> <p>These equations turn on the appropriate light based on the encoded state value.</p>"},{"location":"chapters/09-fsm-fundamentals/#moore-machine-outputs-depend-only-on-state","title":"Moore Machine: Outputs Depend Only on State","text":"<p>A Moore Machine is an FSM where outputs depend only on the current state\u2014not on the inputs.</p> <p>Named after Edward Moore who formalized this model in 1956, Moore machines have a clean separation between what you're doing (state) and what you're reacting to (inputs).</p> <p>Key characteristics:</p> <ul> <li>Outputs change only when state changes</li> <li>Outputs are \"associated with\" states, not transitions</li> <li>Output logic uses only state bits as inputs</li> <li>Outputs are synchronous to the clock (change at clock edges)</li> </ul> <p>Moore machine architecture:</p> <pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502                                     \u2502\n           \u25bc                                     \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Next     \u2502     \u2502    State      \u2502    \u2502  Output   \u2502\n    \u2502   State    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Register    \u2502\u2500\u2500\u2500\u25b6\u2502   Logic   \u2502\u2500\u2500\u25b6 Outputs\n    \u2502   Logic    \u2502     \u2502  (Flip-Flops) \u2502    \u2502 (f of S)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u25b2                   \u2502\n    Inputs \u2502                   \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notice: Inputs feed into next state logic but NOT into output logic.</p> <p>In state diagrams, Moore outputs are written inside the state circles:</p> <pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502   STATE_A   \u2502\n        \u2502  Out=1      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Advantages of Moore machines:</p> <ul> <li>Outputs are glitch-free (change only at clock edges)</li> <li>Easier to debug (output tells you the state)</li> <li>Cleaner timing analysis</li> <li>More predictable for interface design</li> </ul> <p>Disadvantages:</p> <ul> <li>Often need more states to achieve same functionality as Mealy</li> <li>Outputs respond one clock cycle later to input changes</li> </ul> <p>Moore Machine Example: Traffic Light</p> <p>A traffic light controller is naturally a Moore machine. The light color (output) depends only on the state (which phase we're in), not on the inputs (car sensors). When you're in the GREEN state, the green light is on\u2014period. Input sensors affect transitions but not outputs.</p>"},{"location":"chapters/09-fsm-fundamentals/#moore-output-the-state-speaks","title":"Moore Output: The State Speaks","text":"<p>The Moore Output is defined as a function of state only:</p> \\[Output = g(S)\\] <p>Where \\(S\\) is the current state and \\(g\\) is the output function.</p> <p>Since there's no input dependency, the output is stable for the entire time the machine is in a given state. It changes only when the state changes (at clock edges).</p>"},{"location":"chapters/09-fsm-fundamentals/#diagram-moore-machine-simulator","title":"Diagram: Moore Machine Simulator","text":"Moore Machine Simulator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how Moore machine outputs depend only on the current state by manipulating inputs and observing that outputs change only when state changes, not when inputs change.</p> <p>Instructional Rationale: Interactive exploration where students change inputs and observe that outputs remain stable until the next clock edge (when state might change) reinforces the Moore machine definition.</p> <p>Canvas Layout:</p> <ul> <li>Left: State diagram with states and transitions</li> <li>Center: Current state highlighted with output displayed</li> <li>Right: Timing diagram showing inputs, state, and outputs</li> <li>Bottom: Input controls and clock trigger</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input toggle buttons</li> <li>Clock edge button</li> <li>Current state indicator</li> <li>Output value display</li> <li>Timing diagram that builds over time</li> <li>Highlight showing output comes from state, not inputs</li> <li>\"Why didn't output change?\" callouts when input changes but output doesn't</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state and its associated outputs</li> <li>Input values</li> <li>When outputs change (only at state transitions)</li> <li>Output equation showing state-only dependency</li> <li>Timing relationship between clock, state, and outputs</li> </ul> <p>Visual Style:</p> <ul> <li>State diagram with outputs shown inside states</li> <li>Current state glowing</li> <li>Output values prominently displayed</li> <li>Timing diagram with clear cause-effect marking</li> <li>Arrows from state to output (not from inputs to output)</li> </ul> <p>Implementation: p5.js with Moore machine simulation and timing diagram</p> <p>Consider a simple 2-state Moore machine:</p> State State Encoding Output IDLE 0 0 ACTIVE 1 1 <p>The output equation is trivially:</p> \\[Output = Q\\] <p>For a more complex Moore machine with 4 states and 2 outputs:</p> State Encoding (Q1 Q0) LED_A LED_B OFF 00 0 0 STANDBY 01 0 1 RUNNING 10 1 0 ERROR 11 1 1 <p>Output equations:</p> <p>[LED_A = Q_1] [LED_B = Q_0]</p> <p>Simple, clean, and glitch-free.</p>"},{"location":"chapters/09-fsm-fundamentals/#mealy-machine-outputs-react-immediately","title":"Mealy Machine: Outputs React Immediately","text":"<p>A Mealy Machine is an FSM where outputs depend on both the current state and the current inputs.</p> <p>Named after George Mealy who described this model in 1955, Mealy machines can produce outputs that react immediately to inputs, without waiting for a clock edge.</p> <p>Key characteristics:</p> <ul> <li>Outputs can change whenever inputs change (even between clock edges)</li> <li>Outputs are \"associated with\" transitions, not just states</li> <li>Output logic uses both state bits and inputs</li> <li>Outputs are asynchronous with respect to the clock</li> </ul> <p>Mealy machine architecture:</p> <pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502                                     \u2502\n           \u25bc                                     \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n    \u2502   Next     \u2502     \u2502    State      \u2502         \u2502\n    \u2502   State    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Register    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502   Logic    \u2502     \u2502  (Flip-Flops) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u25b2                   \u2502\n    Inputs \u2502                   \u2502\n           \u2502                   \u25bc\n           \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   Output    \u2502\u2500\u2500\u25b6 Outputs\n                        \u2502 Logic (f of \u2502\n                        \u2502  S AND I)   \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In state diagrams, Mealy outputs are written on the transition arrows:</p> <pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   Input/Output   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 STATE_A \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 STATE_B \u2502\n        \u2502         \u2502      1/Y         \u2502         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Advantages of Mealy machines:</p> <ul> <li>Often fewer states needed for same functionality</li> <li>Outputs respond to inputs within the same clock cycle</li> <li>More \"reactive\" behavior</li> </ul> <p>Disadvantages:</p> <ul> <li>Outputs can glitch if inputs are noisy or glitchy</li> <li>Timing analysis more complex</li> <li>Outputs may have combinational delay after input changes</li> </ul> <p>Mealy Output Glitches</p> <p>Because Mealy outputs depend on combinational logic from inputs, they can produce glitches\u2014brief incorrect values during input transitions. If your outputs drive other sequential logic, these glitches might get captured, causing errors. Register Mealy outputs if this is a concern.</p>"},{"location":"chapters/09-fsm-fundamentals/#mealy-output-react-and-respond","title":"Mealy Output: React and Respond","text":"<p>The Mealy Output is defined as a function of both state and inputs:</p> \\[Output = h(S, I)\\] <p>Where \\(S\\) is the current state, \\(I\\) is the inputs, and \\(h\\) is the output function.</p>"},{"location":"chapters/09-fsm-fundamentals/#diagram-mealy-machine-simulator","title":"Diagram: Mealy Machine Simulator","text":"Mealy Machine Simulator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how Mealy machine outputs depend on both current state AND inputs by observing output changes that occur immediately when inputs change, without waiting for a clock edge.</p> <p>Instructional Rationale: Contrasting Mealy behavior with Moore behavior (where outputs don't change between clock edges) makes the distinction clear and memorable.</p> <p>Canvas Layout:</p> <ul> <li>Left: State diagram with transitions labeled Input/Output</li> <li>Center: Current state with live output calculation</li> <li>Right: Timing diagram showing immediate output response</li> <li>Bottom: Input controls and clock trigger</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input toggle buttons (outputs change immediately!)</li> <li>Clock edge button (for state transitions)</li> <li>Current state indicator</li> <li>Output value display (updates asynchronously to inputs)</li> <li>Timing diagram showing output changes between clock edges</li> <li>Side-by-side comparison mode with equivalent Moore machine</li> <li>Glitch simulation option</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state</li> <li>Input values</li> <li>Output values (computed from state AND inputs)</li> <li>Output equation showing both dependencies</li> <li>When outputs change (can be between clock edges)</li> <li>Highlight showing output reacts to input changes</li> </ul> <p>Visual Style:</p> <ul> <li>State diagram with Input/Output on transitions</li> <li>Current transition highlighted when triggered</li> <li>Output values update immediately with input changes</li> <li>Timing diagram shows asynchronous output behavior</li> <li>Clear visual difference from Moore simulator</li> </ul> <p>Implementation: p5.js with Mealy machine simulation and immediate output updates</p> <p>Example: Consider a Mealy machine for a door access controller</p> State Input Output Next State LOCKED correct_code=0 unlock=0 LOCKED LOCKED correct_code=1 unlock=1 UNLOCKED UNLOCKED timeout=0 unlock=1 UNLOCKED UNLOCKED timeout=1 unlock=0 LOCKED <p>In the LOCKED state with correct_code=1, the door unlocks immediately (before the next clock edge), then the state transitions to UNLOCKED.</p> <p>The output equation:</p> \\[unlock = (LOCKED \\cdot correct\\_code) + (UNLOCKED \\cdot \\overline{timeout})\\] <p>Or in terms of state bits:</p> \\[unlock = (\\overline{Q} \\cdot correct\\_code) + (Q \\cdot \\overline{timeout})\\] <p>Notice how the output changes immediately when <code>correct_code</code> goes high, without waiting for a clock edge. This is the defining characteristic of Mealy machines.</p>"},{"location":"chapters/09-fsm-fundamentals/#moore-vs-mealy-the-great-debate","title":"Moore vs Mealy: The Great Debate","text":"<p>Here's a side-by-side comparison to help you choose:</p> Feature Moore Machine Mealy Machine Outputs depend on State only State AND inputs Output timing Synchronous (at clock edges) Asynchronous (can change anytime) Output glitches None (clean) Possible (need care) Number of states Usually more Usually fewer Response latency One clock cycle Same clock cycle State diagrams Outputs inside states Outputs on transitions Debugging Easier (state = output) Harder (need inputs too) <p>When to use Moore:</p> <ul> <li>Outputs must be glitch-free</li> <li>Interfacing with other synchronous systems</li> <li>Simpler debugging is valuable</li> <li>One clock cycle latency is acceptable</li> </ul> <p>When to use Mealy:</p> <ul> <li>Minimum state count is important</li> <li>Immediate response to inputs required</li> <li>Outputs are registered before use anyway</li> <li>State machine is simple enough that glitches aren't a concern</li> </ul> <p>The Hybrid Approach</p> <p>Many real designs use registered Mealy outputs\u2014compute outputs as Mealy (from state and inputs) but register them through flip-flops before sending them out. This gives you the state efficiency of Mealy with the clean timing of Moore.</p> <p>Here's a classic example showing the state difference:</p> <p>Sequence detector for \"11\" (detect when two 1s in a row)</p> <p>Moore version (3 states):</p> <ul> <li>S0: Haven't seen anything useful</li> <li>S1: Saw one 1</li> <li>S2: Saw two 1s in a row \u2192 output = 1</li> </ul> <p>Mealy version (2 states):</p> <ul> <li>S0: Haven't seen a 1 recently</li> <li>S1: Just saw a 1 \u2192 if input=1, output=1 (detecting the pattern right now!)</li> </ul> <p>The Mealy machine needs one fewer state because it can output the detection signal during the second 1, rather than waiting for a dedicated \"detected\" state.</p>"},{"location":"chapters/09-fsm-fundamentals/#state-diagram-a-picture-worth-a-thousand-gates","title":"State Diagram: A Picture Worth a Thousand Gates","text":"<p>A State Diagram is the graphical representation of an FSM, showing states as circles (or rounded rectangles) and transitions as arrows between them.</p> <p>State diagrams are the most common way to specify FSM behavior during the design phase. They're intuitive, compact, and catch missing transitions at a glance.</p> <p>Elements of a state diagram:</p> <ul> <li>States: Circles or ovals with state name inside</li> <li>Initial state: Indicated by an arrow from nowhere (or filled dot)</li> <li>Transitions: Arrows from source state to destination state</li> <li>Transition labels: Input conditions that trigger the transition</li> <li>Outputs: Inside states (Moore) or on transitions (Mealy)</li> </ul>"},{"location":"chapters/09-fsm-fundamentals/#diagram-state-diagram-builder","title":"Diagram: State Diagram Builder","text":"Interactive State Diagram <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine state diagrams to trace execution paths, verify completeness, and identify potential design issues such as missing transitions or unreachable states.</p> <p>Instructional Rationale: Interactive state diagram with animation of current state and transition highlighting builds intuition for how FSMs execute over time.</p> <p>Canvas Layout:</p> <ul> <li>Main area: State diagram canvas with draggable states</li> <li>Current state highlighted with animation</li> <li>Input sequence panel at bottom</li> <li>Execution trace panel on right</li> <li>Validation messages for completeness</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click states to view details</li> <li>Hover transitions to see conditions</li> <li>Input sequence entry (type binary string)</li> <li>Play/step through execution</li> <li>Highlight current state and taken transition</li> <li>Warning indicators for incomplete transitions</li> <li>Reachability analysis button</li> </ul> <p>Data Visibility:</p> <ul> <li>All states with names and outputs</li> <li>All transitions with conditions</li> <li>Current state (highlighted)</li> <li>Input sequence being processed</li> <li>Execution trace (state history)</li> <li>Completeness check results</li> </ul> <p>Visual Style:</p> <ul> <li>Clean state diagram with standard notation</li> <li>Current state with glow/pulse animation</li> <li>Active transition arrow highlighted</li> <li>Input/output labeling consistent with selected mode (Moore/Mealy)</li> <li>Grid snap for neat layout</li> <li>Color coding by state type (initial, accepting, normal)</li> </ul> <p>Implementation: p5.js with state machine execution engine</p> <p>Here's an example state diagram for a simple counter that counts 0\u21921\u21922\u21923\u21920:</p> <pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                                 \u2502\n        \u25bc                                 \u2502\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2500\u2500\u25b6\u2502  S0     \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   S1    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   S2    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   S3    \u2502\n   \u2502 count=0 \u2502     \u2502 count=1 \u2502     \u2502 count=2 \u2502     \u2502 count=3 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2514\u2500\u2500 Initial state arrow\n</code></pre> <p>(All transitions are unconditional on clock edge)</p> <p>For a more complex example with conditional transitions:</p> <pre><code>            Input=0              Input=0\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502         \u25bc          \u2502         \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2500\u2500\u25b6\u2502  IDLE   \u2502\u2500Input=1\u2500\u25b6\u2502 SAW_1   \u2502\u2500Input=1\u2500\u25b6\u2502DETECTED \u2502\n   \u2502  out=0  \u2502          \u2502  out=0  \u2502          \u2502  out=1  \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502                   \u2502\n                              \u2502    Input=0        \u2502\n                              \u25bc                   \u2502\n                         (back to IDLE)\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>State diagrams make it easy to verify:</p> <ul> <li>Completeness: Every state has a transition for every input</li> <li>Reachability: Can every state be reached from the initial state?</li> <li>No dead ends: Can the machine escape from every state?</li> </ul>"},{"location":"chapters/09-fsm-fundamentals/#state-diagram-notation-speaking-the-language","title":"State Diagram Notation: Speaking the Language","text":"<p>State Diagram Notation refers to the specific conventions used to represent states, transitions, and outputs in a state diagram.</p> <p>While there's no single universal standard, common conventions include:</p> <p>State representation:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 STATE_NAME   \u2502  \u2190 State name\n\u2502 Output=value \u2502  \u2190 Moore outputs (optional here)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Transition representation:</p> <pre><code>\u2500\u2500\u2500\u2500 Input_condition \u2500\u2500\u2500\u2500\u25b6\n          \u2502\n    Input/Output  \u2190 Mealy notation (Input/Output)\n</code></pre> <p>Common notations for transitions:</p> Notation Meaning <code>X=1</code> Transition when input X equals 1 <code>X</code> Same as X=1 (shorthand) <code>X'</code> or <code>~X</code> Transition when X equals 0 <code>XY</code> Transition when X AND Y are both 1 <code>X+Y</code> Transition when X OR Y is 1 <code>*</code> Always (unconditional transition) <code>else</code> Any input not covered by other transitions <p>Moore notation example:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  GREEN  \u2502\u2500\u2500\u2500tmr\u2500\u2500\u2500\u2500\u25b6\u2502 YELLOW  \u2502\n\u2502 light=G \u2502           \u2502 light=Y \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Mealy notation example:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  IDLE   \u2502\u2500\u2500req/ack\u2500\u25b6\u2502 ACTIVE  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The <code>req/ack</code> means: when input <code>req</code>=1, transition and output <code>ack</code>=1.</p> <p>Initial state indicators:</p> <ul> <li>Arrow from nowhere pointing to initial state</li> <li>Filled circle with arrow to initial state</li> <li>Double-circle around initial state</li> <li>Label \"START\" or \"RESET\"</li> </ul> <p>Multiple transitions with same destination:</p> <pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502     \u2502\n    X=0 \u2502     \u2502 X=1\n        \u25bc     \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   NEXT      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Or combined:</p> <pre><code>    \u2500\u2500\u2500 X=0, X=1 \u2500\u2500\u2500\u25b6 (meaning \"always\")\n</code></pre> <p>Notation Varies by Industry</p> <p>EE courses often use the simple notation shown here. Industrial tools like Simulink or Quartus may use different conventions. The concepts are the same\u2014just learn the specific notation required for your tools.</p>"},{"location":"chapters/09-fsm-fundamentals/#state-table-the-complete-specification","title":"State Table: The Complete Specification","text":"<p>A State Table is a tabular representation of an FSM that explicitly lists every combination of current state and inputs, along with the resulting next state and outputs.</p> <p>State tables are more verbose than state diagrams but are essential for:</p> <ul> <li>Systematic derivation of Boolean equations</li> <li>Verification that all cases are covered</li> <li>Input to CAD tools that synthesize hardware</li> </ul> <p>A complete state table has columns for:</p> <ul> <li>Current state</li> <li>Each input (or input combination)</li> <li>Next state</li> <li>Each output</li> </ul> <p>Moore machine state table format:</p> Current State Input Next State Output (determined by state only) <p>Note: In a Moore table, output can be listed separately since it depends only on current state.</p> <p>Mealy machine state table format:</p> Current State Input Next State Output (output varies with input combination) <p>Example: Sequence detector for \"01\" pattern</p> <p>Moore-style state table:</p> Current State State Encoding Input X Next State Output Z IDLE 00 0 SAW_0 0 IDLE 00 1 IDLE 0 SAW_0 01 0 SAW_0 0 SAW_0 01 1 FOUND 0 FOUND 10 0 SAW_0 1 FOUND 10 1 IDLE 1 <p>From this table, we can derive:</p> <p>Next state equations:</p> \\[Q_1^+ = Q_0 \\cdot X\\] \\[Q_0^+ = \\overline{X}\\] <p>Output equation:</p> \\[Z = Q_1\\]"},{"location":"chapters/09-fsm-fundamentals/#diagram-state-table-to-circuit","title":"Diagram: State Table to Circuit","text":"State Table to Circuit Derivation <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Implement</p> <p>Learning Objective: Students will be able to implement an FSM circuit from a state table by deriving next-state and output equations and connecting them to flip-flops.</p> <p>Instructional Rationale: Step-by-step derivation from state table through Boolean equations to circuit implementation makes the design process concrete and repeatable.</p> <p>Canvas Layout:</p> <ul> <li>Left: Editable state table</li> <li>Center: K-map or equation derivation area</li> <li>Right: Generated circuit schematic</li> <li>Bottom: Simulation controls to verify the design</li> </ul> <p>Interactive Elements:</p> <ul> <li>Edit state table entries</li> <li>Auto-generate K-maps for next state and outputs</li> <li>Highlight which row of table applies to current state/input</li> <li>Step through: table \u2192 K-map \u2192 equation \u2192 circuit</li> <li>Simulate the resulting circuit</li> <li>Compare simulation results to table specification</li> </ul> <p>Data Visibility:</p> <ul> <li>State table with all entries</li> <li>Derived Boolean equations</li> <li>K-maps showing minimization</li> <li>Circuit schematic</li> <li>Current state/input/output during simulation</li> <li>Match/mismatch indicator between spec and implementation</li> </ul> <p>Visual Style:</p> <ul> <li>Clean tabular display</li> <li>K-maps with standard formatting</li> <li>Circuit schematic with D flip-flops and gates</li> <li>Highlighting to show derivation steps</li> <li>Animation of simulation through the circuit</li> </ul> <p>Implementation: p5.js with K-map solver and circuit rendering</p> <p>The beauty of state tables is their completeness\u2014every possible combination is explicitly defined, leaving no ambiguity.</p>"},{"location":"chapters/09-fsm-fundamentals/#state-encoding-giving-states-binary-names","title":"State Encoding: Giving States Binary Names","text":"<p>State Encoding is the process of assigning binary codes (flip-flop values) to abstract states. Since flip-flops store binary values, we need to translate state names like \"IDLE\" and \"RUNNING\" into patterns like \"00\" and \"01\".</p> <p>For an FSM with \\(N\\) states, we need at least \\(\\lceil \\log_2 N \\rceil\\) flip-flops.</p> Number of States Minimum Flip-Flops Needed 2 1 3-4 2 5-8 3 9-16 4 17-32 5 <p>The encoding choice significantly affects:</p> <ul> <li>Circuit complexity: Some encodings lead to simpler next-state logic</li> <li>Hazards and glitches: Some encodings minimize output glitches</li> <li>Speed: More flip-flops mean wider datapaths but potentially simpler logic</li> <li>Power consumption: One-hot encoding has more flip-flops but fewer transitions</li> </ul> <p>Common encoding strategies:</p> <ol> <li>Binary encoding: Minimum flip-flops, states numbered 0, 1, 2, ...</li> <li>One-hot encoding: One flip-flop per state, exactly one is hot</li> <li>Gray code encoding: Adjacent states differ by only one bit</li> </ol> <p>Let's explore each in detail.</p>"},{"location":"chapters/09-fsm-fundamentals/#binary-encoding-the-compact-choice","title":"Binary Encoding: The Compact Choice","text":"<p>Binary Encoding (also called dense encoding) uses the minimum number of flip-flops by assigning sequential binary numbers to states.</p> <p>For 4 states:</p> State Binary Code S0 00 S1 01 S2 10 S3 11 <p>Advantages:</p> <ul> <li>Minimum number of flip-flops</li> <li>Natural if states represent a count</li> <li>Commonly supported by synthesis tools</li> </ul> <p>Disadvantages:</p> <ul> <li>Next-state logic can be complex</li> <li>Multiple bits may change simultaneously (glitch potential)</li> <li>Decoding state requires logic</li> </ul> <p>Binary encoding example for a 3-state FSM:</p> State Code (Q1 Q0) IDLE 00 PROCESS 01 DONE 10 <p>Code \"11\" is unused\u2014a \"don't care\" that can simplify next-state logic.</p>"},{"location":"chapters/09-fsm-fundamentals/#diagram-state-encoding-comparison","title":"Diagram: State Encoding Comparison","text":"State Encoding Comparison Tool <p>Type: microsim</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare binary, one-hot, and Gray code encodings for the same FSM, evaluating trade-offs in flip-flop count, next-state logic complexity, and transition behavior.</p> <p>Instructional Rationale: Side-by-side comparison of the same FSM with different encodings reveals how encoding choice affects implementation complexity and circuit behavior.</p> <p>Canvas Layout:</p> <ul> <li>Top: FSM state diagram (same for all encodings)</li> <li>Center: Three columns showing Binary, One-Hot, and Gray encodings</li> <li>Each column shows: encoding table, flip-flop count, logic complexity estimate</li> <li>Bottom: Transition animation showing bit changes</li> </ul> <p>Interactive Elements:</p> <ul> <li>Select different FSMs to encode</li> <li>Cycle through states to see bit patterns</li> <li>Count simultaneous bit transitions</li> <li>Toggle between encodings</li> <li>Show/hide derived logic equations</li> <li>Complexity metric comparison</li> </ul> <p>Data Visibility:</p> <ul> <li>All state encodings side by side</li> <li>Number of flip-flops for each</li> <li>Number of gates (estimated) for each</li> <li>Bit transitions per state change</li> <li>Which encoding is \"best\" for different criteria</li> </ul> <p>Visual Style:</p> <ul> <li>Clean comparison table layout</li> <li>Color-coded encodings</li> <li>Transition visualization showing changing bits</li> <li>Complexity bar chart comparison</li> <li>Highlight differences between encodings</li> </ul> <p>Implementation: p5.js with encoding generator and complexity estimator</p>"},{"location":"chapters/09-fsm-fundamentals/#one-hot-encoding-one-bit-per-state","title":"One-Hot Encoding: One Bit Per State","text":"<p>One-Hot Encoding uses one flip-flop per state. Exactly one flip-flop is \"1\" (hot) at any time, identifying the current state.</p> <p>For 4 states:</p> State One-Hot Code S0 0001 S1 0010 S2 0100 S3 1000 <p>Advantages:</p> <ul> <li>Very simple next-state logic (often just AND-OR)</li> <li>Easy to decode current state (just read the hot bit)</li> <li>Simple output logic</li> <li>Only one bit changes per transition (no glitches)</li> </ul> <p>Disadvantages:</p> <ul> <li>Many more flip-flops (one per state)</li> <li>Wasted encoding space (\\(2^N\\) codes, only \\(N\\) used)</li> <li>Invalid states possible if multiple bits become hot</li> </ul> <p>One-hot is especially popular in FPGAs where flip-flops are abundant but complex logic is expensive.</p> <p>Next-state equations are trivial:</p> <p>To set state S2 hot:</p> \\[Q_{S2}^+ = (\\text{S1 hot AND transition\\_to\\_S2}) + (\\text{S0 hot AND transition\\_to\\_S2}) + ...\\] <p>Each equation is just an OR of the incoming transition conditions.</p> <p>FPGAs Love One-Hot</p> <p>Modern FPGAs have lots of flip-flops but limited routing and logic resources. One-hot encoding trades flip-flops for simpler logic, often resulting in faster and smaller designs on FPGAs. Many synthesis tools default to one-hot for FSMs.</p>"},{"location":"chapters/09-fsm-fundamentals/#gray-code-encoding-smooth-transitions","title":"Gray Code Encoding: Smooth Transitions","text":"<p>Gray Code Encoding assigns codes so that adjacent states (states connected by transitions) differ by only one bit.</p> <p>Standard Gray code for 4 states:</p> State Gray Code S0 00 S1 01 S2 11 S3 10 <p>Notice: S0\u2192S1\u2192S2\u2192S3\u2192S0 each changes only one bit.</p> <p>Advantages:</p> <ul> <li>Only one bit changes per transition (minimal switching)</li> <li>Reduces glitches on outputs</li> <li>Lower power consumption (fewer transistor switches)</li> <li>Avoids hazards in asynchronous interfaces</li> </ul> <p>Disadvantages:</p> <ul> <li>Only works perfectly for cyclic sequences</li> <li>Irregular FSMs may not benefit</li> <li>Can't always achieve single-bit transitions for all state pairs</li> </ul> <p>Gray code is particularly useful for:</p> <ul> <li>Counters (where states are sequential)</li> <li>Asynchronous domain crossings (single-bit changes are safer)</li> <li>Low-power designs</li> <li>ADC/DAC encoder wheels</li> </ul> <p>Example: Gray-coded 3-bit counter</p> Count Binary Gray 0 000 000 1 001 001 2 010 011 3 011 010 4 100 110 5 101 111 6 110 101 7 111 100 <p>Binary 3\u21924 changes THREE bits (011\u2192100). Gray 3\u21924 changes ONE bit (010\u2192110). Much safer for asynchronous reads!</p>"},{"location":"chapters/09-fsm-fundamentals/#state-assignment-optimizing-the-encoding","title":"State Assignment: Optimizing the Encoding","text":"<p>State Assignment is the process of choosing which specific binary code to assign to each state to optimize the circuit for some criterion (usually minimum gate count or maximum speed).</p> <p>Beyond the basic encoding strategies, you can further optimize by:</p> <ol> <li>Analyzing transition patterns: Put frequently transitioning states close together (differ by fewer bits)</li> <li>Output-oriented assignment: States with same outputs get similar codes</li> <li>Don't-care exploitation: Unused codes can simplify logic</li> <li>Adjacent encoding: States that share transitions get adjacent codes</li> </ol> <p>Classical state assignment rules (heuristics):</p> <ul> <li>Rule 1: States with the same next state should be adjacent (differ by one bit)</li> <li>Rule 2: States that are next states of the same state should be adjacent</li> <li>Rule 3: States with the same output should be adjacent (for Moore machines)</li> </ul> <p>These rules help group 1s together in K-maps, enabling larger groupings and simpler equations.</p> <p>Example: Consider two possible encodings for the same 4-state FSM:</p> <p>Encoding A (arbitrary): | State | Code | |-------|------| | IDLE | 00 | | READ | 01 | | WRITE | 10 | | DONE | 11 |</p> <p>Encoding B (optimized based on transitions): | State | Code | |-------|------| | IDLE | 00 | | READ | 01 | | DONE | 11 | | WRITE | 10 |</p> <p>If IDLE\u2192READ and READ\u2192DONE are the most common transitions, Encoding B keeps them adjacent (one bit change).</p> <p>Let the Tools Help</p> <p>Modern synthesis tools have sophisticated state assignment algorithms. For small FSMs, manual optimization is educational. For large FSMs, let the tools do the heavy lifting\u2014they can evaluate millions of possible assignments.</p>"},{"location":"chapters/09-fsm-fundamentals/#state-minimization-fewer-states-simpler-circuits","title":"State Minimization: Fewer States, Simpler Circuits","text":"<p>State Minimization is the process of reducing the number of states in an FSM without changing its external behavior.</p> <p>Why minimize states?</p> <ul> <li>Fewer states = fewer flip-flops</li> <li>Simpler next-state and output logic</li> <li>Faster circuits</li> <li>Lower power consumption</li> </ul> <p>Two states are equivalent if:</p> <ol> <li>They produce the same outputs for all inputs</li> <li>They transition to equivalent next states for all inputs</li> </ol> <p>If two states are equivalent, we can merge them into one.</p> <p>Algorithm for state minimization:</p> <ol> <li>Group states by outputs: States with different outputs can't be equivalent</li> <li>Refine by next-state behavior: Split groups where states go to non-equivalent next states</li> <li>Repeat until stable: When no more splitting is needed, remaining groups contain equivalent states</li> <li>Merge equivalent states: Replace each group with a single state</li> </ol> <p>Example of minimizable FSM:</p> <p>Original (4 states):</p> State Input=0 Input=1 Output A B C 0 B B C 0 C D C 1 D D C 1 <p>Analysis:</p> <ul> <li>A and B have same outputs (0) and same transitions \u2192 EQUIVALENT</li> <li>C and D have same outputs (1) and same transitions \u2192 EQUIVALENT</li> </ul> <p>Minimized (2 states):</p> State Input=0 Input=1 Output AB AB CD 0 CD CD CD 1 <p>We went from 4 states (2 flip-flops) to 2 states (1 flip-flop)!</p>"},{"location":"chapters/09-fsm-fundamentals/#diagram-state-minimization-visualizer","title":"Diagram: State Minimization Visualizer","text":"State Minimization Step-by-Step <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Differentiate</p> <p>Learning Objective: Students will be able to differentiate between equivalent and non-equivalent states by applying the state minimization algorithm and identifying which states can be merged.</p> <p>Instructional Rationale: Step-by-step visualization of the partitioning algorithm, showing how groups are split based on distinguishing sequences, makes the abstract algorithm concrete.</p> <p>Canvas Layout:</p> <ul> <li>Left: Original state table</li> <li>Center: Partitioning process visualization</li> <li>Right: Minimized state table</li> <li>Bottom: Step-by-step controls and explanation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Step through minimization algorithm</li> <li>Highlight current partition groups</li> <li>Show why groups split (distinguishing input sequences)</li> <li>Compare original and minimized FSM</li> <li>Verify equivalence through simulation</li> <li>Try custom FSMs</li> </ul> <p>Data Visibility:</p> <ul> <li>Original states and transitions</li> <li>Current partition (equivalent state groups)</li> <li>Reason for each split</li> <li>Final equivalence classes</li> <li>Minimized FSM</li> <li>State count reduction</li> </ul> <p>Visual Style:</p> <ul> <li>Color-coded equivalence classes</li> <li>Partition tree showing splits</li> <li>Before/after state diagrams</li> <li>Clear step indicators</li> <li>Merge animation for equivalent states</li> </ul> <p>Implementation: p5.js with partition refinement algorithm</p> <p>State minimization is especially important when:</p> <ul> <li>The FSM was specified without concern for redundancy</li> <li>Converting from one representation to another introduced extra states</li> <li>Multiple designers contributed states that duplicate functionality</li> </ul> <p>Minimize Before Encoding</p> <p>Always minimize your FSM before choosing a state encoding. There's no point optimizing the encoding for states you'll end up eliminating!</p>"},{"location":"chapters/09-fsm-fundamentals/#the-fsm-design-process-from-words-to-gates","title":"The FSM Design Process: From Words to Gates","text":"<p>Let's put everything together with a complete FSM design flow:</p> <p>Step 1: Understand the problem</p> <ul> <li>What are the inputs and outputs?</li> <li>What sequence of operations is needed?</li> <li>What must the system \"remember\"?</li> </ul> <p>Step 2: Draw the state diagram</p> <ul> <li>Identify the states (distinct situations)</li> <li>Draw transitions (what causes state changes)</li> <li>Label outputs (Moore: inside states; Mealy: on transitions)</li> <li>Mark the initial state</li> </ul> <p>Step 3: Create the state table</p> <ul> <li>List all state-input combinations</li> <li>Fill in next states and outputs</li> <li>Verify completeness (no missing entries)</li> </ul> <p>Step 4: Minimize states (optional but recommended)</p> <ul> <li>Find and merge equivalent states</li> <li>Simplify the state table</li> </ul> <p>Step 5: Choose state encoding</p> <ul> <li>Select binary, one-hot, Gray, or custom</li> <li>Assign codes to each state</li> </ul> <p>Step 6: Derive next-state equations</p> <ul> <li>Use K-maps or Boolean algebra</li> <li>Simplify the equations</li> </ul> <p>Step 7: Derive output equations</p> <ul> <li>Moore: Function of state only</li> <li>Mealy: Function of state and inputs</li> </ul> <p>Step 8: Implement the circuit</p> <ul> <li>D flip-flops for state storage</li> <li>Combinational logic for next-state and outputs</li> <li>Don't forget the reset!</li> </ul> <p>Step 9: Verify</p> <ul> <li>Simulate with test inputs</li> <li>Check all transitions</li> <li>Verify timing requirements</li> </ul>"},{"location":"chapters/09-fsm-fundamentals/#diagram-complete-fsm-design-flow","title":"Diagram: Complete FSM Design Flow","text":"Complete FSM Design Workflow <p>Type: workflow</p> <p>Bloom Level: Create (L6) Bloom Verb: Design</p> <p>Learning Objective: Students will be able to design a complete FSM from a word problem by following the systematic design flow from problem statement through state diagram, state table, encoding, equations, to circuit implementation.</p> <p>Instructional Rationale: Guided workflow that takes students through each step of FSM design, with verification at each stage, builds confidence in the complete design process.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Current design stage with workspace</li> <li>Left sidebar: Stage navigation (8 steps)</li> <li>Right sidebar: Design artifacts (state diagram, table, equations)</li> <li>Bottom: Verification and navigation controls</li> </ul> <p>Interactive Elements:</p> <ul> <li>Select from example problems or enter custom</li> <li>Draw/edit state diagram</li> <li>Edit state table entries</li> <li>Choose encoding strategy</li> <li>Derive equations (auto-check for errors)</li> <li>Generate circuit schematic</li> <li>Simulate the result</li> <li>Verify against original specification</li> </ul> <p>Data Visibility:</p> <ul> <li>Current design stage</li> <li>All artifacts created so far</li> <li>Consistency checks between stages</li> <li>Error indicators</li> <li>Simulation results vs. expected behavior</li> </ul> <p>Visual Style:</p> <ul> <li>Workflow progress indicator</li> <li>Clean workspace for each stage</li> <li>Artifacts persist in sidebar as you progress</li> <li>Verification checkmarks</li> <li>Final circuit with highlighted correspondence to earlier stages</li> </ul> <p>Implementation: p5.js with multi-stage design environment</p>"},{"location":"chapters/09-fsm-fundamentals/#example-designing-a-vending-machine-controller","title":"Example: Designing a Vending Machine Controller","text":"<p>Let's design a simple vending machine FSM from scratch. The machine:</p> <ul> <li>Accepts nickels (5\u00a2) and dimes (10\u00a2)</li> <li>Dispenses a 15\u00a2 item when enough money is inserted</li> <li>Gives change if overpaid (20\u00a2 inserted)</li> </ul> <p>Step 1: Inputs and Outputs</p> <p>Inputs:</p> <ul> <li>N: Nickel inserted</li> <li>D: Dime inserted</li> </ul> <p>Outputs:</p> <ul> <li>DISPENSE: Release the item</li> <li>CHANGE: Give a nickel back</li> </ul> <p>Step 2: State Diagram</p> <pre><code>                    \u250c\u2500N/\u2500\u2510\n                    \u2502    \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502     0\u00a2      \u2502\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  (start)    \u2502\n              \u2502 DISP=0,CH=0 \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 D\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 N\n              \u2502           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u25bc           \u2502        \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502    10\u00a2    \u2502     \u2502  \u2502     5\u00a2    \u2502\n        \u2502 DISP=0    \u2502     \u2502  \u2502 DISP=0    \u2502\n        \u2502 CH=0      \u2502     \u2502  \u2502 CH=0      \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502           \u2502        \u2502\n           N  \u2502 D         \u2502 N      \u2502 D\n              \u2502           \u2502        \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                                \u2502\n        \u25bc           \u25bc                    \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   15\u00a2     \u2502  \u2502   20\u00a2     \u2502    \u2502   15\u00a2     \u2502\n   \u2502 DISP=1    \u2502  \u2502 DISP=1    \u2502    \u2502 DISP=1    \u2502\n   \u2502 CH=0      \u2502  \u2502 CH=1      \u2502    \u2502 CH=0      \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502              \u2502                \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n                       \u25bc\n                  (back to 0\u00a2)\n</code></pre> <p>Actually, let me simplify this with a cleaner state table approach.</p> <p>States:</p> State Amount Collected Encoding S0 0\u00a2 00 S5 5\u00a2 01 S10 10\u00a2 10 S15 15\u00a2 (dispense!) 11 <p>Step 3: State Table (Mealy-style for immediate dispense)</p> Current N D Next DISPENSE CHANGE S0 0 0 S0 0 0 S0 1 0 S5 0 0 S0 0 1 S10 0 0 S5 0 0 S5 0 0 S5 1 0 S10 0 0 S5 0 1 S0 1 0 S10 0 0 S10 0 0 S10 1 0 S0 1 0 S10 0 1 S0 1 1 <p>Step 4-5: Already minimized, using binary encoding above</p> <p>Step 6-7: Derive equations</p> <p>Next-state equations:</p> \\[Q_1^+ = \\overline{Q_1} \\cdot Q_0 \\cdot N + \\overline{Q_1} \\cdot \\overline{Q_0} \\cdot D + Q_1 \\cdot \\overline{Q_0} \\cdot \\overline{N} \\cdot \\overline{D}\\] \\[Q_0^+ = \\overline{Q_1} \\cdot \\overline{Q_0} \\cdot N + \\overline{Q_1} \\cdot Q_0 \\cdot \\overline{N} \\cdot \\overline{D}\\] <p>Output equations:</p> \\[DISPENSE = Q_0 \\cdot D + Q_1 \\cdot N + Q_1 \\cdot D\\] \\[CHANGE = Q_1 \\cdot \\overline{Q_0} \\cdot D\\] <p>Step 8: Circuit Implementation</p> <p>Two D flip-flops, AND-OR logic for next state and outputs, and we're done!</p>"},{"location":"chapters/09-fsm-fundamentals/#common-fsm-design-patterns","title":"Common FSM Design Patterns","text":"<p>Here are some patterns you'll see repeatedly:</p> <p>Counter FSM: States represent count values; transitions increment on clock edge.</p> <p>Sequence Detector: States track progress through a target pattern; output activates when pattern complete.</p> <p>Controller: States represent phases of operation; transitions based on completion signals.</p> <p>Protocol Handler: States represent protocol stages (idle, request, acknowledge, data, done).</p> <p>Debouncer: States filter out rapid bounces from mechanical switches.</p> <p>Pattern: The Debounce FSM</p> <p>Mechanical buttons bounce\u2014they make and break contact multiple times when pressed. An FSM can filter this by requiring the button to be stable for several clock cycles before registering a press:</p> <p>States: IDLE \u2192 COUNT_1 \u2192 COUNT_2 \u2192 COUNT_3 \u2192 PRESSED</p> <p>Only after three consecutive cycles of button=1 do we acknowledge the press. Random bounces reset back to IDLE.</p>"},{"location":"chapters/09-fsm-fundamentals/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've just acquired one of the most powerful tools in digital design. Finite state machines are everywhere\u2014from the microcode controlling your CPU to the protocol handlers managing your network traffic.</p> <p>Core Concepts:</p> <ul> <li>FSM: A mathematical model with finite states, inputs, outputs, and transitions</li> <li>State: A snapshot of what the system remembers</li> <li>Transition: Movement from one state to another based on inputs</li> <li>Current vs Next state: The synchronous update model</li> </ul> <p>Two Flavors:</p> <ul> <li>Moore machines: Outputs depend only on state (clean, predictable)</li> <li>Mealy machines: Outputs depend on state and inputs (reactive, fewer states)</li> </ul> <p>Design Representations:</p> <ul> <li>State diagrams: Visual, intuitive, good for design</li> <li>State tables: Complete, systematic, good for implementation</li> </ul> <p>Encoding Choices:</p> <ul> <li>Binary: Minimum flip-flops, compact</li> <li>One-hot: Simple logic, fast, FPGA-friendly</li> <li>Gray code: Single-bit transitions, glitch-free</li> </ul> <p>Optimization:</p> <ul> <li>State minimization: Eliminate equivalent states</li> <li>State assignment: Choose codes to minimize logic</li> </ul> <p>The Design Flow:</p> <ol> <li>Understand the problem</li> <li>Draw state diagram</li> <li>Create state table</li> <li>Minimize states</li> <li>Choose encoding</li> <li>Derive equations</li> <li>Implement circuit</li> <li>Verify!</li> </ol> <p>The Big Picture</p> <p>FSMs bridge the gap between abstract behavior (\"count up, then reset\") and concrete implementation (flip-flops and gates). Master FSM design, and you can implement any well-defined sequential behavior in hardware.</p> Graphic Novel Suggestion <p>An engaging graphic novel could tell the story of Edward Moore and George Mealy, the two researchers who formalized the mathematical models of sequential machines in the 1950s. Set against the backdrop of the early computing era at Bell Labs and IBM, the narrative could follow their parallel journeys to understanding how to describe systems that remember. The dramatic tension could build around the question: \"Can any computation be described as a finite state machine?\"\u2014leading to the profound realization that while FSMs are powerful, they have fundamental limits (cue: the pumping lemma and the Chomsky hierarchy). The climax could show how their seemingly theoretical work became the foundation for everything from traffic light controllers to the protocol stacks that power the internet.</p>"},{"location":"chapters/09-fsm-fundamentals/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Moore vs Mealy Identification <p>A system outputs a 1 whenever it sees the input sequence \"10\". Identify whether the following description is Moore or Mealy:</p> <p>\"In the state after seeing '1', if the input is '0', output 1 immediately while transitioning to the initial state.\"</p> <p>Solution: This is a Mealy machine. The output (1) depends on both the current state (\"after seeing 1\") AND the current input (\"input is 0\"). In a Moore machine, the output would have to wait for the next state.</p> Problem 2: State Counting <p>How many states are needed for an FSM that remembers the last 3 bits of input?</p> <p>Solution: Each bit can be 0 or 1, so 3 bits have \\(2^3 = 8\\) possible combinations. The FSM needs 8 states to remember all possible 3-bit histories: 000, 001, 010, 011, 100, 101, 110, 111.</p> Problem 3: Encoding Selection <p>A 6-state FSM will be implemented on an FPGA with abundant flip-flops but expensive routing. Which encoding would you recommend?</p> <p>Solution: One-hot encoding is ideal for FPGAs with many flip-flops but limited logic/routing resources. One-hot uses 6 flip-flops (instead of 3 for binary) but has simpler next-state logic that requires less routing. Each next-state equation is just an OR of incoming transitions.</p> Problem 4: Next State Equation Derivation <p>Given this state table, derive the next-state equation for Q (using D flip-flop):</p> Current Q Input X Next Q 0 0 0 0 1 1 1 0 1 1 1 0 <p>Solution: Looking at when Next Q = 1: - Q=0, X=1 \u2192 1 - Q=1, X=0 \u2192 1</p> <p>The equation is: [D = \\overline{Q} \\cdot X + Q \\cdot \\overline{X} = Q \\oplus X]</p> <p>This is a T flip-flop behavior\u2014toggle when X=1!</p> Problem 5: State Minimization <p>States A and B both have output = 0. A goes to C on input 0 and D on input 1. B goes to C on input 0 and D on input 1. Are A and B equivalent?</p> <p>Solution: Yes, A and B are equivalent: 1. Same outputs (0) 2. Same next states for all inputs (both go to C on 0, both go to D on 1)</p> <p>They can be merged into a single state.</p> Problem 6: Complete FSM Design <p>Design an FSM that outputs 1 whenever the total number of 1s seen so far is a multiple of 3 (including 0). Show the state diagram and derive the next-state equations using binary encoding.</p> <p>Solution:</p> <p>States (count mod 3): - S0: Count \u2261 0 (mod 3), Output = 1 - S1: Count \u2261 1 (mod 3), Output = 0 - S2: Count \u2261 2 (mod 3), Output = 0</p> <p>Transitions: - From any state, input 0 \u2192 stay in same state - From S0, input 1 \u2192 S1 - From S1, input 1 \u2192 S2 - From S2, input 1 \u2192 S0</p> <p>Encoding: S0=00, S1=01, S2=10</p> <p>State Table:</p> Q1 Q0 X Q1+ Q0+ 00 0 00 00 1 01 01 0 01 01 1 10 10 0 10 10 1 00 <p>Next-state equations:</p> \\[Q_1^+ = \\overline{Q_1} \\cdot Q_0 \\cdot X + Q_1 \\cdot \\overline{Q_0} \\cdot \\overline{X}\\] \\[Q_0^+ = \\overline{Q_1} \\cdot \\overline{Q_0} \\cdot X + \\overline{Q_1} \\cdot Q_0 \\cdot \\overline{X}\\] <p>Output equation:</p> \\[Y = \\overline{Q_1} \\cdot \\overline{Q_0}\\]"},{"location":"chapters/09-fsm-fundamentals/quiz/","title":"Quiz: FSM Fundamentals","text":"<p>Test your understanding of finite state machines, Moore and Mealy models, and state encoding strategies.</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#1-what-are-the-five-essential-components-of-a-finite-state-machine","title":"1. What are the five essential components of a finite state machine?","text":"<ol> <li>Clock, data, address, control, power</li> <li>States, inputs, outputs, transitions, initial state</li> <li>Flip-flops, gates, wires, clock, reset</li> <li>Encoder, decoder, register, counter, mux</li> </ol> Show Answer <p>The correct answer is B. Every FSM has: states (possible configurations), inputs (external signals affecting behavior), outputs (signals produced), transitions (rules for moving between states), and an initial state (starting configuration).</p> <p>Concept Tested: Finite State Machine</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#2-in-a-moore-machine-what-determines-the-outputs","title":"2. In a Moore machine, what determines the outputs?","text":"<ol> <li>Only the current inputs</li> <li>Only the current state</li> <li>Both current state and current inputs</li> <li>The previous outputs</li> </ol> Show Answer <p>The correct answer is B. In a Moore machine, outputs depend ONLY on the current state. Outputs are associated with states, not transitions. This means outputs change only when the state changes (at clock edges), providing clean, glitch-free timing.</p> <p>Concept Tested: Moore Machine</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#3-how-does-a-mealy-machine-differ-from-a-moore-machine","title":"3. How does a Mealy machine differ from a Moore machine?","text":"<ol> <li>Mealy machines have more states</li> <li>Mealy outputs depend on both state AND inputs</li> <li>Mealy machines are faster</li> <li>Mealy machines don't need flip-flops</li> </ol> Show Answer <p>The correct answer is B. In a Mealy machine, outputs depend on both the current state AND the current inputs. This means outputs can change asynchronously (whenever inputs change), potentially responding faster than Moore machines but with more complex timing.</p> <p>Concept Tested: Mealy Machine</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#4-what-information-does-a-state-diagram-convey","title":"4. What information does a state diagram convey?","text":"<ol> <li>The physical layout of the circuit</li> <li>States, transitions, conditions, and outputs</li> <li>The timing of clock signals</li> <li>The power consumption per state</li> </ol> Show Answer <p>The correct answer is B. A state diagram is a graphical representation showing states as circles, transitions as arrows, conditions on the arrows (input values), and outputs (either in states for Moore or on arrows for Mealy).</p> <p>Concept Tested: State Diagram</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#5-what-is-one-hot-encoding-for-state-machines","title":"5. What is one-hot encoding for state machines?","text":"<ol> <li>Using one flip-flop for all states</li> <li>Using one flip-flop per state with exactly one active</li> <li>Encoding states as consecutive binary numbers</li> <li>Using temperature to determine state</li> </ol> Show Answer <p>The correct answer is B. In one-hot encoding, each state has its own flip-flop, and exactly one flip-flop is \"hot\" (set to 1) at any time. This uses more flip-flops but simplifies next-state and output logic, often beneficial in FPGAs.</p> <p>Concept Tested: One-Hot Encoding</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#6-what-is-the-advantage-of-binary-encoding-over-one-hot-encoding","title":"6. What is the advantage of binary encoding over one-hot encoding?","text":"<ol> <li>Simpler next-state logic</li> <li>Fewer flip-flops required</li> <li>Faster operation</li> <li>Lower power consumption</li> </ol> Show Answer <p>The correct answer is B. Binary encoding uses log\u2082(N) flip-flops for N states, compared to N flip-flops for one-hot. For 8 states, binary uses 3 flip-flops; one-hot uses 8. However, binary encoding typically requires more complex next-state decoding logic.</p> <p>Concept Tested: Binary Encoding</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#7-what-is-the-purpose-of-state-minimization","title":"7. What is the purpose of state minimization?","text":"<ol> <li>To make the state machine run faster</li> <li>To reduce the number of states while preserving behavior</li> <li>To use fewer input signals</li> <li>To eliminate the clock signal</li> </ol> Show Answer <p>The correct answer is B. State minimization identifies and merges equivalent states\u2014states that produce identical outputs and have identical transitions for all inputs. Fewer states means fewer flip-flops and potentially simpler logic.</p> <p>Concept Tested: State Minimization</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#8-in-state-diagram-notation-what-do-the-arrows-represent","title":"8. In state diagram notation, what do the arrows represent?","text":"<ol> <li>Power supply connections</li> <li>State transitions with their conditions</li> <li>Clock signals</li> <li>Data flow between flip-flops</li> </ol> Show Answer <p>The correct answer is B. Arrows in state diagrams represent transitions between states. They are labeled with the input condition(s) that cause the transition and, for Mealy machines, the output produced during that transition.</p> <p>Concept Tested: State Diagram Notation</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#9-what-does-a-state-table-contain","title":"9. What does a state table contain?","text":"<ol> <li>Only the current state values</li> <li>Current state, input combinations, next state, and outputs</li> <li>Only the flip-flop excitation equations</li> <li>The physical coordinates of each state</li> </ol> Show Answer <p>The correct answer is B. A state table systematically lists every combination of current state and input, showing the resulting next state and outputs for each. It's equivalent to a state diagram but in tabular form, making it easier to derive logic equations.</p> <p>Concept Tested: State Table</p>"},{"location":"chapters/09-fsm-fundamentals/quiz/#10-why-might-gray-code-encoding-be-chosen-for-state-machines","title":"10. Why might Gray code encoding be chosen for state machines?","text":"<ol> <li>It uses the fewest flip-flops</li> <li>Only one bit changes between adjacent states, reducing glitches</li> <li>It's required by Verilog synthesis tools</li> <li>It produces the fastest circuits</li> </ol> Show Answer <p>The correct answer is B. Gray code encoding ensures only one flip-flop changes during each state transition. This reduces switching noise, power consumption, and hazards\u2014particularly useful for FSMs with outputs decoded from state bits or when crossing clock domains.</p> <p>Concept Tested: Gray Code Encoding</p>"},{"location":"chapters/10-fsm-design-applications/","title":"FSM Design and Applications","text":""},{"location":"chapters/10-fsm-design-applications/#summary","title":"Summary","text":"<p>This chapter applies FSM theory to practical design problems, teaching students the complete workflow from specification to implementation. Students will learn to derive next-state and output equations from state tables, follow the systematic FSM design process, and verify FSM designs for correctness. The chapter includes practical applications including sequence detectors with overlapping and non-overlapping detection modes, pattern recognition FSMs, and classic controller examples such as traffic light controllers and vending machine FSMs.</p>"},{"location":"chapters/10-fsm-design-applications/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>Next State Equation</li> <li>Output Equation</li> <li>FSM Design Process</li> <li>FSM Verification</li> <li>Sequence Detector</li> <li>Pattern Recognition FSM</li> <li>Overlapping Detection</li> <li>Non-Overlapping Detection</li> <li>Traffic Light Controller</li> <li>Vending Machine FSM</li> </ol>"},{"location":"chapters/10-fsm-design-applications/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 9: Finite State Machine Fundamentals</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#introduction-from-blueprint-to-building","title":"Introduction: From Blueprint to Building","text":"<p>In Chapter 9, you learned the vocabulary and grammar of finite state machines\u2014states, transitions, Moore versus Mealy, encoding strategies. You learned to read state diagrams like a native speaker. Now it's time to write them.</p> <p>Think of it this way: Chapter 9 taught you what an FSM is. This chapter teaches you what you can do with one.</p> <p>Consider your morning routine. You probably have a fairly systematic process: alarm rings, you decide whether to snooze (a decision based on current state and inputs!), eventually you get up, shower, dress, eat, and leave. Each step depends on completing the previous one. You're running a finite state machine in your head\u2014and you've been doing it since before you could spell \"sequential logic.\"</p> <p>The magic happens when we translate these human-intuitive processes into digital hardware. That's what this chapter is about: taking a word problem (\"build me a traffic light controller\") and systematically transforming it into flip-flops and gates that actually work.</p> <p>By the end of this chapter, you'll be able to:</p> <ul> <li>Derive Boolean equations for next-state and output logic</li> <li>Follow a systematic design process from specification to implementation</li> <li>Build sequence detectors that find patterns in data streams</li> <li>Design real-world controllers like traffic lights and vending machines</li> <li>Verify that your FSM actually does what the specification says</li> </ul> <p>Ready to become an FSM architect? Let's build something!</p>"},{"location":"chapters/10-fsm-design-applications/#next-state-equation-the-heart-of-sequential-logic","title":"Next State Equation: The Heart of Sequential Logic","text":"<p>The next state equation is a Boolean expression that computes what state the FSM will enter on the next clock edge, based on the current state and inputs.</p> <p>Remember from Chapter 9 that FSMs have this fundamental structure:</p> \\[S^+ = f(S, I)\\] <p>Where \\(S^+\\) is the next state, \\(S\\) is the current state, and \\(I\\) represents the inputs. The next state equation is simply the Boolean implementation of this function \\(f\\).</p> <p>Since states are stored in flip-flops, and we typically use D flip-flops, the next state equation directly gives us the D input for each flip-flop:</p> \\[D_i = f_i(Q_{n-1}, Q_{n-2}, ..., Q_0, inputs)\\] <p>Here's the practical insight: the next state equation is just combinational logic. You've been designing combinational circuits since Chapter 4. The only difference is that some of the inputs to this combinational circuit happen to be the outputs of flip-flops.</p>"},{"location":"chapters/10-fsm-design-applications/#deriving-next-state-equations-a-worked-example","title":"Deriving Next State Equations: A Worked Example","text":"<p>Let's derive next state equations for a simple 3-state FSM that detects the input sequence \"01\":</p> State Encoding (Q1 Q0) Meaning IDLE 00 Waiting for 0 SAW_0 01 Just saw 0, looking for 1 FOUND 10 Pattern detected! <p>State transition table:</p> Current State Q1 Q0 Input X Next State Q1+ Q0+ IDLE 00 0 SAW_0 01 IDLE 00 1 IDLE 00 SAW_0 01 0 SAW_0 01 SAW_0 01 1 FOUND 10 FOUND 10 0 SAW_0 01 FOUND 10 1 IDLE 00 <p>Now we can derive \\(Q_1^+\\) and \\(Q_0^+\\) using K-maps or inspection.</p> <p>For \\(Q_1^+\\) (when does \\(Q_1\\) become 1?):</p> <p>Looking at the table, \\(Q_1^+ = 1\\) only when we're in SAW_0 (Q1=0, Q0=1) and X=1.</p> \\[Q_1^+ = \\overline{Q_1} \\cdot Q_0 \\cdot X\\] <p>For \\(Q_0^+\\) (when does \\(Q_0\\) become 1?):</p> <p>\\(Q_0^+ = 1\\) in these cases:</p> <ul> <li>IDLE with X=0: \\(\\overline{Q_1} \\cdot \\overline{Q_0} \\cdot \\overline{X}\\)</li> <li>SAW_0 with X=0: \\(\\overline{Q_1} \\cdot Q_0 \\cdot \\overline{X}\\)</li> <li>FOUND with X=0: \\(Q_1 \\cdot \\overline{Q_0} \\cdot \\overline{X}\\)</li> </ul> <p>Simplifying (notice \\(\\overline{X}\\) is common to all terms):</p> \\[Q_0^+ = \\overline{X}\\] <p>That's a beautiful result\u2014the next value of Q0 is simply the complement of the input!</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-next-state-equation-derivation","title":"Diagram: Next State Equation Derivation","text":"Next State Equation Derivation Tool <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Derive</p> <p>Learning Objective: Students will be able to derive next-state equations from a state transition table by identifying when each flip-flop output should be 1 and expressing it as a Boolean function of current state and inputs.</p> <p>Instructional Rationale: Step-by-step derivation with K-map visualization shows how the abstract state table becomes concrete Boolean equations, making the connection between specification and implementation explicit.</p> <p>Canvas Layout:</p> <ul> <li>Left panel: Editable state transition table</li> <li>Center panel: K-maps for each next-state variable</li> <li>Right panel: Derived equations with simplification steps</li> <li>Bottom: Generated circuit showing next-state logic</li> </ul> <p>Interactive Elements:</p> <ul> <li>Edit state table entries and see K-maps update</li> <li>Click K-map cells to see corresponding table rows</li> <li>Toggle between SOP and POS forms</li> <li>Show/hide simplification steps</li> <li>Compare unsimplified vs simplified equations</li> <li>Verify equation against original table</li> </ul> <p>Data Visibility:</p> <ul> <li>State table with binary encoding</li> <li>K-map with grouped terms highlighted</li> <li>Boolean equation in multiple forms</li> <li>Gate count for each form</li> <li>Verification results</li> </ul> <p>Visual Style:</p> <ul> <li>Clean tabular display</li> <li>K-maps with standard grouping colors</li> <li>Equations rendered in readable format</li> <li>Circuit schematic with labeled connections</li> <li>Color-coded correspondence between table, K-map, and equation</li> </ul> <p>Implementation: p5.js with K-map solver and equation simplification</p> <p>K-maps Are Your Best Friend</p> <p>For FSMs with 2-4 state variables and a few inputs, K-maps are the fastest way to derive minimized next-state equations. For larger FSMs, let synthesis tools do the heavy lifting\u2014but understanding K-maps helps you verify the tools are giving you good results.</p>"},{"location":"chapters/10-fsm-design-applications/#output-equation-speaking-to-the-outside-world","title":"Output Equation: Speaking to the Outside World","text":"<p>The output equation computes the FSM's outputs based on the current state (for Moore machines) or the current state and inputs (for Mealy machines).</p> <p>For a Moore machine:</p> \\[Output = g(S)\\] <p>For a Mealy machine:</p> \\[Output = h(S, I)\\] <p>Just like next-state equations, output equations are pure combinational logic. The only difference is what they depend on.</p>"},{"location":"chapters/10-fsm-design-applications/#moore-output-equations","title":"Moore Output Equations","text":"<p>For our sequence detector, let's make it a Moore machine where the output Z indicates \"pattern found\":</p> State Encoding (Q1 Q0) Output Z IDLE 00 0 SAW_0 01 0 FOUND 10 1 <p>The output equation is simply:</p> \\[Z = Q_1 \\cdot \\overline{Q_0}\\] <p>Or, since we're only using encoding 10 for FOUND (and 11 is unused), we could simplify to:</p> \\[Z = Q_1\\] <p>This works because the only state where Q1=1 is FOUND.</p>"},{"location":"chapters/10-fsm-design-applications/#mealy-output-equations","title":"Mealy Output Equations","text":"<p>If we redesign as a Mealy machine, we can output Z=1 during the transition from SAW_0 to FOUND, not after:</p> Current State Q1 Q0 Input X Output Z IDLE 00 0 0 IDLE 00 1 0 SAW_0 01 0 0 SAW_0 01 1 1 FOUND 10 0 0 FOUND 10 1 0 <p>The output equation:</p> \\[Z = \\overline{Q_1} \\cdot Q_0 \\cdot X\\] <p>Notice how the Mealy output depends on the input X as well as the state. The output activates immediately when we're in SAW_0 and see a 1, rather than waiting for the next clock cycle.</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-moore-vs-mealy-output-timing","title":"Diagram: Moore vs Mealy Output Timing","text":"Moore vs Mealy Output Timing Comparison <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare the timing behavior of Moore and Mealy output equations by observing when outputs change relative to clock edges and input changes.</p> <p>Instructional Rationale: Side-by-side timing diagrams of the same FSM implemented as both Moore and Mealy clearly demonstrates the one-clock-cycle latency difference.</p> <p>Canvas Layout:</p> <ul> <li>Top: Shared input waveform and clock</li> <li>Middle: Moore implementation with state and output waveforms</li> <li>Bottom: Mealy implementation with state and output waveforms</li> <li>Right: Equation display for each implementation</li> </ul> <p>Interactive Elements:</p> <ul> <li>Play/pause simulation</li> <li>Step through clock cycles</li> <li>Toggle input values</li> <li>Highlight the timing difference when pattern is detected</li> <li>Show output equations for each type</li> <li>Marker showing the one-cycle difference</li> </ul> <p>Data Visibility:</p> <ul> <li>Clock waveform</li> <li>Input X waveform</li> <li>Moore: state waveform, output waveform (synchronized to clock)</li> <li>Mealy: state waveform, output waveform (reacts to input)</li> <li>Annotations showing cause of each output change</li> </ul> <p>Visual Style:</p> <ul> <li>Standard timing diagram format</li> <li>Color coding: clock (black), input (blue), state (green), output (red)</li> <li>Vertical dotted lines at clock edges</li> <li>Highlight boxes around timing differences</li> <li>Equations displayed alongside waveforms</li> </ul> <p>Implementation: p5.js with synchronized timing diagram animation</p>"},{"location":"chapters/10-fsm-design-applications/#the-fsm-design-process-your-recipe-for-success","title":"The FSM Design Process: Your Recipe for Success","text":"<p>The FSM design process is a systematic methodology for transforming a word problem into a working digital circuit. Following this process consistently helps you avoid errors and ensures your design is complete.</p> <p>Here's the step-by-step recipe:</p> <p>Step 1: Understand the Specification</p> <ul> <li>What are the inputs? (names, meanings, timing)</li> <li>What are the outputs? (names, meanings, when they should activate)</li> <li>What behavior is required? (sequences, conditions, edge cases)</li> <li>Moore or Mealy? (do outputs need immediate response?)</li> </ul> <p>Step 2: Define the States</p> <ul> <li>What does the system need to \"remember\"?</li> <li>Each distinct memory configuration is a state</li> <li>Give states meaningful names</li> <li>Identify the initial/reset state</li> </ul> <p>Step 3: Draw the State Diagram</p> <ul> <li>Draw circles for each state</li> <li>Add transitions with input conditions</li> <li>Label outputs (inside states for Moore, on arrows for Mealy)</li> <li>Mark the initial state with an arrow</li> </ul> <p>Step 4: Create the State Table</p> <ul> <li>List every state \u00d7 input combination</li> <li>Fill in next state for each combination</li> <li>Fill in outputs (checking Moore vs Mealy)</li> <li>Verify every row is complete\u2014no missing cases!</li> </ul> <p>Step 5: Choose State Encoding</p> <ul> <li>Binary: minimum flip-flops, more complex logic</li> <li>One-hot: one flip-flop per state, simpler logic</li> <li>Gray: single-bit transitions, good for certain patterns</li> <li>Consider synthesis target (ASIC vs FPGA)</li> </ul> <p>Step 6: Derive Next-State Equations</p> <ul> <li>Create K-maps or truth tables for each flip-flop D input</li> <li>Minimize the equations</li> <li>Verify against original state table</li> </ul> <p>Step 7: Derive Output Equations</p> <ul> <li>Create K-maps from output columns</li> <li>Moore: function of state bits only</li> <li>Mealy: function of state bits AND inputs</li> <li>Minimize the equations</li> </ul> <p>Step 8: Implement the Circuit</p> <ul> <li>D flip-flops for state register</li> <li>Combinational logic for next-state equations</li> <li>Combinational logic for output equations</li> <li>Reset logic for initialization</li> </ul> <p>Step 9: Verify the Design</p> <ul> <li>Simulate with test vectors</li> <li>Check every transition</li> <li>Verify reset behavior</li> <li>Test edge cases and error conditions</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#diagram-fsm-design-process-flowchart","title":"Diagram: FSM Design Process Flowchart","text":"Interactive FSM Design Process <p>Type: workflow</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute the complete FSM design process by following the systematic workflow from specification through implementation, producing a verified circuit design.</p> <p>Instructional Rationale: An interactive workflow that guides students through each design step, with validation at each stage, builds confidence and reinforces the systematic approach.</p> <p>Canvas Layout:</p> <ul> <li>Left sidebar: Process steps (9 steps) with progress indicators</li> <li>Main area: Current step workspace</li> <li>Right sidebar: Accumulated design artifacts</li> <li>Bottom: Navigation and validation controls</li> </ul> <p>Interactive Elements:</p> <ul> <li>Select from example problems or enter custom specification</li> <li>Guided workspace for each step</li> <li>Automatic validation before advancing</li> <li>View and edit previous steps</li> <li>Generate artifacts (state diagram, table, equations, circuit)</li> <li>Final verification simulation</li> </ul> <p>Data Visibility:</p> <ul> <li>Current step requirements and guidance</li> <li>Design artifacts generated so far</li> <li>Validation status for each step</li> <li>Consistency checks between artifacts</li> <li>Error messages with hints</li> </ul> <p>Visual Style:</p> <ul> <li>Clean step-by-step interface</li> <li>Progress bar showing completion</li> <li>Checkmarks for validated steps</li> <li>Artifacts displayed with clear formatting</li> <li>Final circuit schematic at completion</li> </ul> <p>Implementation: p5.js with multi-stage design environment</p> <p>The design process might seem like a lot of steps, but each step is straightforward on its own. The key is to be systematic and complete each step fully before moving to the next. Skipping steps or combining them often leads to errors that are hard to track down later.</p> <p>Complete Every Row</p> <p>The most common FSM design error is leaving holes in the state table\u2014undefined behavior for some state \u00d7 input combination. When you implement the circuit, these cases will have some behavior (probably not what you wanted). Always check that every row is filled in!</p>"},{"location":"chapters/10-fsm-design-applications/#fsm-verification-trust-but-verify","title":"FSM Verification: Trust but Verify","text":"<p>FSM verification is the process of confirming that an FSM implementation correctly matches its specification. Verification catches errors before they become bugs in silicon.</p> <p>Verification happens at multiple levels:</p>"},{"location":"chapters/10-fsm-design-applications/#specification-level-verification","title":"Specification-Level Verification","text":"<p>Before you even start implementing, verify your state diagram/table against the original requirements:</p> <ul> <li>Does the FSM handle every input condition?</li> <li>Are all edge cases covered?</li> <li>Is the reset behavior correct?</li> <li>Do the outputs match what's expected?</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#implementation-verification","title":"Implementation Verification","text":"<p>After deriving equations and implementing the circuit:</p> <ul> <li>Equation checking: Do the next-state equations produce the correct next state for every table row?</li> <li>Output checking: Do output equations produce correct outputs for every state (Moore) or state+input (Mealy)?</li> <li>Coverage: Have you tested every transition, not just the \"interesting\" ones?</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#simulation-verification","title":"Simulation Verification","text":"<p>Create test vectors that exercise the FSM:</p> <ol> <li>Reset test: Apply reset, verify initial state</li> <li>All-transitions test: Visit every transition at least once</li> <li>Sequence tests: Apply known input sequences, verify output sequences</li> <li>Corner case tests: What happens with unusual input patterns?</li> </ol> <p>A useful verification approach is exhaustive testing for small FSMs: apply every possible input sequence up to some length and verify correct behavior. For a 4-state FSM with 1 input, there are only \\(4 \\times 2 = 8\\) state-input combinations to test.</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-fsm-verification-simulator","title":"Diagram: FSM Verification Simulator","text":"FSM Verification and Testing Tool <p>Type: microsim</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: Validate</p> <p>Learning Objective: Students will be able to validate an FSM implementation by applying test vectors, comparing actual behavior to expected behavior, and identifying any discrepancies between specification and implementation.</p> <p>Instructional Rationale: Interactive verification where students can test their own FSM designs builds debugging skills and reinforces the importance of systematic testing.</p> <p>Canvas Layout:</p> <ul> <li>Left: FSM specification (state diagram or table)</li> <li>Center: Test vector input area and simulation controls</li> <li>Right: Results display with pass/fail indicators</li> <li>Bottom: Detailed trace showing expected vs actual</li> </ul> <p>Interactive Elements:</p> <ul> <li>Enter or load FSM specification</li> <li>Input test vectors manually or auto-generate</li> <li>Run single test or batch test</li> <li>Compare expected output to actual output</li> <li>Highlight failing tests</li> <li>Show transition trace for debugging</li> <li>Coverage report showing tested transitions</li> </ul> <p>Data Visibility:</p> <ul> <li>Test vector (input sequence)</li> <li>Expected state sequence</li> <li>Actual state sequence</li> <li>Expected output sequence</li> <li>Actual output sequence</li> <li>Pass/fail status for each vector</li> <li>Overall coverage metrics</li> </ul> <p>Visual Style:</p> <ul> <li>Clear tabular test results</li> <li>Green/red highlighting for pass/fail</li> <li>State diagram with tested transitions highlighted</li> <li>Coverage percentage display</li> <li>Detailed error messages for failures</li> </ul> <p>Implementation: p5.js with FSM simulator and test framework</p>"},{"location":"chapters/10-fsm-design-applications/#formal-verification-brief-introduction","title":"Formal Verification (Brief Introduction)","text":"<p>For critical applications (aerospace, medical, automotive), simulation isn't enough. Formal verification uses mathematical techniques to prove that the implementation matches the specification for all possible inputs, not just the ones you tested.</p> <p>Tools like model checkers can verify properties such as:</p> <ul> <li>\"The FSM never enters state X if input Y has been seen\"</li> <li>\"From every reachable state, the FSM can eventually return to IDLE\"</li> <li>\"Output Z is never asserted for more than 3 consecutive cycles\"</li> </ul> <p>Formal verification is beyond the scope of this course, but knowing it exists is valuable. When you're designing the braking system for a car, \"we tested it a bunch and it seemed to work\" isn't good enough!</p> <p>Test the Transitions, Not Just the States</p> <p>A common verification mistake is testing that the FSM can reach each state, without testing all the transitions. An FSM might correctly reach states A, B, and C, but have a bug in the transition from B to C when input X=1. Test every edge in the state diagram.</p>"},{"location":"chapters/10-fsm-design-applications/#sequence-detector-finding-patterns-in-data-streams","title":"Sequence Detector: Finding Patterns in Data Streams","text":"<p>A sequence detector is an FSM that monitors an input stream and outputs a signal when a specific pattern is detected. Sequence detectors are fundamental building blocks in:</p> <ul> <li>Serial communication (detecting start bits, patterns, framing)</li> <li>Pattern matching (searching data for signatures)</li> <li>Protocol decoding (recognizing command sequences)</li> <li>Security (detecting attack signatures)</li> </ul> <p>The basic structure of a sequence detector:</p> <ul> <li>One input bit (the data stream)</li> <li>One output bit (asserted when pattern found)</li> <li>States representing \"how much of the pattern we've seen\"</li> </ul> <p>Let's design a detector for the pattern \"101\":</p> <p>States:</p> <ul> <li>S0 (IDLE): Haven't matched anything useful</li> <li>S1: Just saw \"1\"</li> <li>S2: Just saw \"10\"</li> <li>S3: Just saw \"101\" \u2014 pattern found!</li> </ul> <p>The key insight is that each state represents partial progress toward the complete pattern. We need to track how many bits of the target pattern we've successfully matched.</p> <p>State Diagram:</p> <pre><code>        \u250c\u25000\u2500\u2510                            \u250c\u25001\u2500\u2510\n        \u2502   \u25bc                            \u2502   \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    1    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   0   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   1   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2500\u2500\u25b6\u2502   S0    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   S1    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   S2    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   S3    \u2502\n   \u2502  out=0  \u2502         \u2502  out=0  \u2502       \u2502  out=0  \u2502       \u2502  out=1  \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25b2                   \u2502 1              \u25b2 0               \u2502\n        \u2502                   \u2502                \u2502                 \u2502\n        \u2502                   \u2514\u2500\u2500 stays \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Wait\u2014that diagram has a problem! What happens after we detect the pattern? We need to define transitions from S3 back into the pattern matching process. This brings us to an important distinction...</p>"},{"location":"chapters/10-fsm-design-applications/#overlapping-detection-vs-non-overlapping-detection","title":"Overlapping Detection vs Non-Overlapping Detection","text":"<p>When designing sequence detectors, you must decide: after detecting the pattern, can a new pattern overlap with the one just found?</p>"},{"location":"chapters/10-fsm-design-applications/#non-overlapping-detection","title":"Non-Overlapping Detection","text":"<p>In non-overlapping detection, after detecting a pattern, the FSM resets and starts looking for a completely new occurrence. No part of the just-detected pattern can be used for the next detection.</p> <p>For pattern \"101\" with non-overlapping detection:</p> <p>Input stream: <code>1 0 1 0 1 0 1</code> <code>\u2191---\u2191     \u2191---\u2191</code> <code>First     Second</code> <code>detect    detect</code></p> <p>The FSM resets after each detection, so \"10101\" doesn't count as two overlapping \"101\" patterns.</p>"},{"location":"chapters/10-fsm-design-applications/#overlapping-detection","title":"Overlapping Detection","text":"<p>In overlapping detection, the suffix of one detected pattern can be the prefix of the next. This is useful when patterns can share characters.</p> <p>For pattern \"101\" with overlapping detection:</p> <p>Input stream: <code>1 0 1 0 1</code> <code>\u2191---\u2191</code> <code>First detect</code> <code>\u2191---\u2191</code> <code>Second detect!</code></p> <p>After detecting \"101\", we've already seen \"1\"\u2014the start of another potential \"101\"! The overlapping detector recognizes this and immediately starts matching from S1, not S0.</p>"},{"location":"chapters/10-fsm-design-applications/#implementation-differences","title":"Implementation Differences","text":"<p>The difference is in the transitions from the detection state:</p> <p>Non-overlapping (S3 always goes back to start):</p> From S3 Input Next State S3 0 S0 S3 1 S0 <p>Overlapping (S3 considers the input as potentially starting new pattern):</p> From S3 Input Next State S3 0 S2 (we just saw \"1\", now \"10\") S3 1 S1 (the \"1\" starts a new pattern) <p>In the overlapping case, the \"1\" at the end of \"101\" is reused as the beginning of the next potential \"101\".</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-overlapping-vs-non-overlapping-detector","title":"Diagram: Overlapping vs Non-Overlapping Detector","text":"Overlapping vs Non-Overlapping Sequence Detection <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Differentiate</p> <p>Learning Objective: Students will be able to differentiate between overlapping and non-overlapping sequence detection by comparing how each approach handles input streams where patterns share prefix/suffix characters.</p> <p>Instructional Rationale: Side-by-side comparison with the same input stream shows exactly when and why the two approaches produce different outputs.</p> <p>Canvas Layout:</p> <ul> <li>Top: Input stream display with editable bits</li> <li>Middle-left: Non-overlapping detector state diagram and trace</li> <li>Middle-right: Overlapping detector state diagram and trace</li> <li>Bottom: Output comparison showing detection events</li> </ul> <p>Interactive Elements:</p> <ul> <li>Edit input stream or use preset patterns</li> <li>Step through one bit at a time</li> <li>Run automatically</li> <li>Highlight current state in both diagrams</li> <li>Show when outputs differ</li> <li>Count total detections for each type</li> <li>Choose different patterns to detect</li> </ul> <p>Data Visibility:</p> <ul> <li>Input bit stream with position marker</li> <li>Current state for both detectors</li> <li>Output signal for both detectors</li> <li>Detection count for both</li> <li>Visual highlighting when they differ</li> <li>Transition history</li> </ul> <p>Visual Style:</p> <ul> <li>Parallel state diagrams with current state highlighted</li> <li>Input stream as horizontal bit sequence</li> <li>Output waveforms below each detector</li> <li>Color coding when outputs differ</li> <li>Detection markers on input stream</li> </ul> <p>Implementation: p5.js with dual FSM simulation</p> <p>Here's a practical example. Searching a string for all occurrences of \"AA\":</p> <ul> <li>In \"AAA\", non-overlapping finds ONE match (positions 0-1), then resets</li> <li>In \"AAA\", overlapping finds TWO matches (positions 0-1 AND positions 1-2)</li> </ul> <p>Which one you use depends on the application. For searching DNA sequences, you probably want overlapping. For framing serial data, you probably want non-overlapping.</p> <p>Overlap Requires Careful Transition Design</p> <p>The tricky part of overlapping detection is figuring out where to go after detecting the pattern. You need to ask: \"After seeing the complete pattern, what state would I be in if this last portion had been the start of a new pattern?\" The answer often requires reusing suffix as prefix.</p>"},{"location":"chapters/10-fsm-design-applications/#pattern-recognition-fsm-beyond-simple-sequences","title":"Pattern Recognition FSM: Beyond Simple Sequences","text":"<p>A pattern recognition FSM extends the sequence detector concept to more complex patterns, possibly with multiple input bits, wildcards, or alternative paths.</p> <p>While simple sequence detectors look for a fixed string like \"101\", pattern recognition FSMs can handle:</p> <ul> <li>Multiple input bits: Pattern \"AB\" where A and B are different inputs</li> <li>Don't-care positions: Pattern \"1X1\" matching \"101\" or \"111\"</li> <li>Alternative patterns: Detect \"101\" OR \"110\"</li> <li>Counted repetitions: Detect \"1\" repeated 3 or more times</li> <li>Complex protocols: Handshake sequences with acknowledgments</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#example-detecting-rising-edge","title":"Example: Detecting \"Rising Edge\"","text":"<p>A simple but useful pattern recognizer detects a \"rising edge\"\u2014the input transitioning from 0 to 1.</p> <p>States:</p> <ul> <li>LOW: Input was 0 on last cycle</li> <li>HIGH: Input was 1 on last cycle</li> </ul> <p>Transitions and Outputs (Mealy):</p> State Input Next State Output (edge detected) LOW 0 LOW 0 LOW 1 HIGH 1 \u2190 Edge detected! HIGH 0 LOW 0 HIGH 1 HIGH 0 <p>This 2-state FSM produces a one-cycle pulse whenever the input transitions from 0 to 1. Simple, useful, and found in countless digital designs.</p>"},{"location":"chapters/10-fsm-design-applications/#example-detecting-either-00-or-11","title":"Example: Detecting Either \"00\" or \"11\"","text":"<p>Let's design a pattern FSM that detects two consecutive identical bits:</p> <p>States:</p> <ul> <li>IDLE: Just started or just detected (waiting)</li> <li>SAW_0: Last bit was 0</li> <li>SAW_1: Last bit was 1</li> </ul> <p>Transitions (Moore machine):</p> State Input Next State Output IDLE 0 SAW_0 0 IDLE 1 SAW_1 0 SAW_0 0 IDLE 1 (detected \"00\") SAW_0 1 SAW_1 0 SAW_1 0 SAW_0 0 SAW_1 1 IDLE 1 (detected \"11\") <p>This FSM has two paths to the detection output\u2014one through SAW_0 and one through SAW_1. Pattern FSMs often have this multi-path structure.</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-pattern-recognition-fsm-builder","title":"Diagram: Pattern Recognition FSM Builder","text":"Pattern Recognition FSM Design Tool <p>Type: microsim</p> <p>Bloom Level: Create (L6) Bloom Verb: Design</p> <p>Learning Objective: Students will be able to design pattern recognition FSMs by specifying target patterns (including multi-bit inputs, alternatives, and don't-cares) and generating the corresponding state diagram and implementation.</p> <p>Instructional Rationale: Creative tool for designing custom pattern FSMs lets students explore how different pattern requirements affect FSM complexity and structure.</p> <p>Canvas Layout:</p> <ul> <li>Top: Pattern specification input (with syntax for alternatives, wildcards)</li> <li>Center: Generated state diagram</li> <li>Right: State table for the pattern</li> <li>Bottom: Test area to verify pattern detection</li> </ul> <p>Interactive Elements:</p> <ul> <li>Enter pattern specification</li> <li>Generate FSM automatically</li> <li>Manually edit/adjust generated FSM</li> <li>Test with sample input streams</li> <li>Show all paths that lead to detection</li> <li>Export as Verilog or truth table</li> </ul> <p>Data Visibility:</p> <ul> <li>Pattern specification</li> <li>Number of states required</li> <li>State diagram with labeled transitions</li> <li>State table</li> <li>Test results</li> </ul> <p>Visual Style:</p> <ul> <li>Pattern input with syntax highlighting</li> <li>Clean state diagram layout</li> <li>Multiple detection paths highlighted differently</li> <li>Test simulation with step-through</li> </ul> <p>Implementation: p5.js with pattern parser and FSM generator</p>"},{"location":"chapters/10-fsm-design-applications/#the-traffic-light-controller-a-classic-example","title":"The Traffic Light Controller: A Classic Example","text":"<p>The traffic light controller is the \"Hello World\" of FSM design. Every digital design course teaches it, and for good reason\u2014it's practical, relatable, and complex enough to illustrate real FSM design challenges.</p>"},{"location":"chapters/10-fsm-design-applications/#problem-specification","title":"Problem Specification","text":"<p>Design a controller for a simple intersection with:</p> <ul> <li>Two traffic lights: Main Street (NS) and Side Street (EW)</li> <li>Inputs:</li> <li>CLK: System clock (assume 1 Hz for simplicity)</li> <li>SENSOR: 1 if a car is waiting on the side street</li> <li>Outputs:</li> <li>NS_GREEN, NS_YELLOW, NS_RED</li> <li>EW_GREEN, EW_YELLOW, EW_RED</li> <li>Requirements:</li> <li>Main street is normally green</li> <li>If sensor detects a car on side street, eventually switch</li> <li>Yellow lights last 3 seconds</li> <li>Green lights last at least 10 seconds</li> <li>Never have both directions green simultaneously!</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#state-design","title":"State Design","text":"<p>What does the controller need to remember?</p> <ul> <li>Which direction currently has right-of-way</li> <li>Whether we're in green, yellow, or red phase</li> <li>How long we've been in the current phase (for timing)</li> </ul> <p>We could encode the timer as part of the state, but that would create many states (NS_GREEN_1, NS_GREEN_2, ... NS_GREEN_10). A better approach: use a separate counter and just track the phase.</p> <p>States:</p> <ul> <li>NS_GREEN: Main street has green, side street has red</li> <li>NS_YELLOW: Main street has yellow (about to go red)</li> <li>EW_GREEN: Side street has green, main street has red</li> <li>EW_YELLOW: Side street has yellow (about to go red)</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#timing-logic","title":"Timing Logic","text":"<p>For timing, we use a counter that counts clock cycles. The FSM receives a TIMER_DONE signal from the counter and can RESET the timer on state transitions.</p> <p>This is a common pattern: separate the FSM (state transitions) from the datapath (counting). The FSM becomes simpler because it doesn't need to track every count value\u2014just \"timer done\" or \"timer not done.\"</p>"},{"location":"chapters/10-fsm-design-applications/#state-diagram","title":"State Diagram","text":"<pre><code>                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502   NS_GREEN     \u2502\n                         \u2502 NS=G, EW=R     \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 Timer=10s      \u2502                    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n                                 \u2502 Timer_done AND Sensor       \u2502\n                                 \u25bc                             \u2502\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502\n                         \u2502   NS_YELLOW    \u2502                    \u2502\n                         \u2502 NS=Y, EW=R     \u2502                    \u2502\n                         \u2502 Timer=3s       \u2502                    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n                                 \u2502 Timer_done                  \u2502\n                                 \u25bc                             \u2502\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502\n                         \u2502   EW_GREEN     \u2502                    \u2502\n                         \u2502 NS=R, EW=G     \u2502                    \u2502\n                         \u2502 Timer=10s      \u2502                    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n                                 \u2502 Timer_done                  \u2502\n                                 \u25bc                             \u2502\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502\n                         \u2502   EW_YELLOW    \u2502                    \u2502\n                         \u2502 NS=R, EW=Y     \u2502                    \u2502\n                         \u2502 Timer=3s       \u2502                    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   Timer_done\n</code></pre>"},{"location":"chapters/10-fsm-design-applications/#state-table","title":"State Table","text":"State Timer_done Sensor Next State NS Light EW Light NS_GREEN 0 X NS_GREEN G R NS_GREEN 1 0 NS_GREEN G R NS_GREEN 1 1 NS_YELLOW Y R NS_YELLOW 0 X NS_YELLOW Y R NS_YELLOW 1 X EW_GREEN R G EW_GREEN 0 X EW_GREEN R G EW_GREEN 1 X EW_YELLOW R Y EW_YELLOW 0 X EW_YELLOW R Y EW_YELLOW 1 X NS_GREEN G R"},{"location":"chapters/10-fsm-design-applications/#output-logic-moore","title":"Output Logic (Moore)","text":"<p>With binary encoding (NS_GREEN=00, NS_YELLOW=01, EW_GREEN=10, EW_YELLOW=11):</p> <p>[NS_GREEN = \\overline{Q_1} \\cdot \\overline{Q_0}] [NS_YELLOW = \\overline{Q_1} \\cdot Q_0] [NS_RED = Q_1] [EW_GREEN = Q_1 \\cdot \\overline{Q_0}] [EW_YELLOW = Q_1 \\cdot Q_0] [EW_RED = \\overline{Q_1}]</p> <p>Or more simply:</p> <p>[NS_RED = Q_1] [EW_RED = \\overline{Q_1}]</p> <p>These equations guarantee the safety property: exactly one direction has red when the other doesn't.</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-traffic-light-controller-simulator","title":"Diagram: Traffic Light Controller Simulator","text":"Interactive Traffic Light Controller <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Implement</p> <p>Learning Objective: Students will be able to implement and operate a traffic light controller FSM by observing how sensor inputs trigger state transitions and how timing constraints are maintained through the FSM structure.</p> <p>Instructional Rationale: Visual simulation of traffic lights responding to sensor inputs makes the abstract FSM tangible and shows why proper sequencing matters for safety.</p> <p>Canvas Layout:</p> <ul> <li>Center: Intersection visualization with traffic lights and cars</li> <li>Right: State diagram with current state highlighted</li> <li>Bottom: Timeline showing state transitions and light changes</li> <li>Left: Control panel (sensor simulation, speed control)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle car sensor on/off</li> <li>Adjust simulation speed</li> <li>Pause and step through transitions</li> <li>Show timing countdown</li> <li>Highlight safety properties (never both green)</li> <li>Inject faults to see what goes wrong</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state name</li> <li>Timer value</li> <li>Sensor status</li> <li>Light colors for both directions</li> <li>Transition about to occur</li> <li>Safety property verification</li> </ul> <p>Visual Style:</p> <ul> <li>Realistic intersection with colored lights</li> <li>Cars appearing/disappearing on side street</li> <li>Timer countdown display</li> <li>State diagram with animated transitions</li> <li>Safety indicators (green checkmark when safe)</li> </ul> <p>Implementation: p5.js with intersection graphics and FSM simulation</p>"},{"location":"chapters/10-fsm-design-applications/#safety-analysis","title":"Safety Analysis","text":"<p>A key property of traffic light controllers is safety: never allow conflicting green lights. How do we verify this?</p> <p>Looking at our states:</p> <ul> <li>NS_GREEN: NS=G, EW=R \u2713</li> <li>NS_YELLOW: NS=Y, EW=R \u2713</li> <li>EW_GREEN: NS=R, EW=G \u2713</li> <li>EW_YELLOW: NS=R, EW=Y \u2713</li> </ul> <p>Every state has at least one direction red. Safety property: verified!</p> <p>But wait\u2014what about during transitions? In real hardware, there might be a brief moment when flip-flops are switching. Could we have NS=G and EW=G for a glitch?</p> <p>This is why we use synchronous design (all changes on clock edges) and often add an \"all-red\" state during transitions. Real traffic controllers are carefully designed and tested for these edge cases.</p> <p>Real Traffic Controllers Are More Complex</p> <p>The example here is simplified for teaching. Real traffic controllers handle pedestrian signals, left turn arrows, emergency vehicle preemption, adaptive timing based on traffic flow, failure modes (flash red), and much more. But they're still FSMs at heart\u2014just bigger ones!</p>"},{"location":"chapters/10-fsm-design-applications/#the-vending-machine-fsm-money-in-product-out","title":"The Vending Machine FSM: Money In, Product Out","text":"<p>The vending machine FSM is another classic example that demonstrates FSMs handling cumulative input (counting money) and producing actions (dispensing product, giving change).</p>"},{"location":"chapters/10-fsm-design-applications/#problem-specification_1","title":"Problem Specification","text":"<p>Design a vending machine controller for:</p> <ul> <li>Product price: 25 cents</li> <li>Accepted coins: Nickel (5\u00a2), Dime (10\u00a2), Quarter (25\u00a2)</li> <li>Inputs:</li> <li>N: Nickel inserted</li> <li>D: Dime inserted</li> <li>Q: Quarter inserted</li> <li>Outputs:</li> <li>DISPENSE: Release the product</li> <li>CHANGE_5: Return a nickel</li> <li>CHANGE_10: Return a dime</li> </ul> <p>Assume only one coin can be inserted per clock cycle.</p>"},{"location":"chapters/10-fsm-design-applications/#state-design_1","title":"State Design","text":"<p>States represent accumulated money:</p> State Amount Encoding S0 0\u00a2 000 S5 5\u00a2 001 S10 10\u00a2 010 S15 15\u00a2 011 S20 20\u00a2 100 <p>When we reach 25\u00a2 or more, we dispense and return to S0 (giving change if overpaid).</p>"},{"location":"chapters/10-fsm-design-applications/#state-transitions","title":"State Transitions","text":"Current Coin Next Dispense Change S0 None S0 0 0 S0 N S5 0 0 S0 D S10 0 0 S0 Q S0 1 0 S5 None S5 0 0 S5 N S10 0 0 S5 D S15 0 0 S5 Q S0 1 5\u00a2 S10 None S10 0 0 S10 N S15 0 0 S10 D S20 0 0 S10 Q S0 1 10\u00a2 S15 None S15 0 0 S15 N S20 0 0 S15 D S0 1 0 S15 Q S0 1 15\u00a2 S20 None S20 0 0 S20 N S0 1 0 S20 D S0 1 5\u00a2 S20 Q S0 1 20\u00a2"},{"location":"chapters/10-fsm-design-applications/#moore-vs-mealy-consideration","title":"Moore vs Mealy Consideration","text":"<p>Should the vending machine be Moore or Mealy?</p> <p>Moore approach: Separate states for \"dispense and give change\" conditions. Would need additional states like \"S25_NO_CHANGE\", \"S30_RETURN_5\", etc.</p> <p>Mealy approach: Output depends on state AND coin input. Dispense and change happen on the transition that reaches/exceeds 25\u00a2.</p> <p>The Mealy approach is cleaner here\u2014we avoid extra states and the outputs are naturally associated with the \"purchase complete\" transitions.</p>"},{"location":"chapters/10-fsm-design-applications/#diagram-vending-machine-simulator","title":"Diagram: Vending Machine Simulator","text":"Interactive Vending Machine FSM <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute vending machine transactions by inserting coins and observing how the FSM tracks accumulated value, triggers product dispensing at the threshold, and calculates correct change.</p> <p>Instructional Rationale: Interactive vending simulation makes the cumulative nature of the FSM clear\u2014students see how partial payments are tracked and how different coin combinations reach the same goal.</p> <p>Canvas Layout:</p> <ul> <li>Left: Vending machine graphic with coin slot and product display</li> <li>Center: State diagram with current state and balance highlighted</li> <li>Right: Transaction log showing coins inserted, dispensed product, change returned</li> <li>Bottom: Coin insertion buttons (N, D, Q) and reset</li> </ul> <p>Interactive Elements:</p> <ul> <li>Insert coins with button clicks</li> <li>Watch balance accumulate</li> <li>See product dispense animation</li> <li>See change returned animation</li> <li>View state transitions in real time</li> <li>Try different coin combinations</li> <li>See total transactions completed</li> </ul> <p>Data Visibility:</p> <ul> <li>Current balance</li> <li>Current state</li> <li>What each coin will do (preview)</li> <li>Product dispensed count</li> <li>Change given breakdown</li> <li>State transition about to occur</li> </ul> <p>Visual Style:</p> <ul> <li>Colorful vending machine graphic</li> <li>Animated coin insertion</li> <li>Animated product drop</li> <li>Animated change return</li> <li>State diagram with glowing current state</li> <li>Balance display (like real machine)</li> </ul> <p>Implementation: p5.js with vending machine graphics and FSM simulation</p>"},{"location":"chapters/10-fsm-design-applications/#deriving-the-equations","title":"Deriving the Equations","text":"<p>Let's derive some key equations. For the DISPENSE output (Mealy):</p> <p>DISPENSE = 1 when:</p> <ul> <li>S0 and Q (25\u00a2 reached exactly)</li> <li>S5 and Q (30\u00a2 reached)</li> <li>S10 and Q (35\u00a2 reached)</li> <li>S10 and D (reaching 20\u00a2... wait, that's not 25\u00a2)</li> </ul> <p>Let me recalculate. DISPENSE when total \u2265 25\u00a2:</p> <ul> <li>S0 + Q = 25\u00a2 \u2713</li> <li>S5 + D + D = 25\u00a2... but we can only insert one coin at a time</li> <li>S5 + Q = 30\u00a2 \u2713</li> <li>S10 + D + N = 25\u00a2... two coins</li> <li>S10 + Q = 35\u00a2 \u2713</li> <li>S15 + D = 25\u00a2 \u2713</li> <li>S15 + Q = 40\u00a2 \u2713</li> <li>S20 + N = 25\u00a2 \u2713</li> <li>S20 + D = 30\u00a2 \u2713</li> <li>S20 + Q = 45\u00a2 \u2713</li> </ul> <p>Using encoding (S0=000, S5=001, S10=010, S15=011, S20=100):</p> \\[DISPENSE = Q + (Q_2 \\cdot \\overline{Q_1} \\cdot \\overline{Q_0}) + ...\\] <p>The full equation gets complex, but that's okay\u2014K-maps and synthesis tools handle it.</p> <p>Let the Tools Help</p> <p>For FSMs with more than 4-5 states and multiple inputs, manually deriving equations is error-prone. Use truth tables, K-maps, or (best of all) Verilog with synthesis tools. The concepts matter; the arithmetic can be automated.</p>"},{"location":"chapters/10-fsm-design-applications/#putting-it-all-together-the-design-flow-in-action","title":"Putting It All Together: The Design Flow in Action","text":"<p>Let's walk through a complete design example from start to finish.</p>"},{"location":"chapters/10-fsm-design-applications/#problem-garage-door-controller","title":"Problem: Garage Door Controller","text":"<p>Design an FSM for a garage door controller:</p> <ul> <li>Inputs:</li> <li>BTN: Button pressed (1 = pressed this cycle)</li> <li>TOP: Door reached top limit sensor</li> <li>BOT: Door reached bottom limit sensor</li> <li>Outputs:</li> <li>MOTOR_UP: Run motor to raise door</li> <li>MOTOR_DOWN: Run motor to lower door</li> <li>Behavior:</li> <li>Door starts closed (at bottom)</li> <li>Press button once: door opens until TOP sensor</li> <li>Press button while opening: door stops</li> <li>Press button when stopped (middle): door closes</li> <li>Press button while closing: door stops</li> <li>Press button when stopped (middle): door opens</li> <li>Press button when fully open: door closes</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#step-1-define-states","title":"Step 1: Define States","text":"<p>What must the system remember?</p> <ul> <li>Is the door moving? Which direction?</li> <li>Is the door stopped? Where was it going before it stopped?</li> <li>Is the door fully open or closed?</li> </ul> <p>States:</p> <ul> <li>CLOSED: Door at bottom, not moving</li> <li>OPENING: Door moving up</li> <li>OPEN: Door at top, not moving</li> <li>CLOSING: Door moving down</li> <li>STOPPED_GOING_UP: Stopped mid-travel, was opening</li> <li>STOPPED_GOING_DOWN: Stopped mid-travel, was closing</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#step-2-state-diagram","title":"Step 2: State Diagram","text":"<pre><code>                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                     \u2502                BTN                   \u2502\n                     \u25bc                                      \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502   CLOSED   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500BTN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  OPENING   \u2502\n              \u2502 Motor=OFF  \u2502                         \u2502 Motor=UP   \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u25b2                                     \u2502  \u2502\n                     \u2502                               TOP   \u2502  \u2502 BTN\n                     \u2502                                     \u25bc  \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  CLOSING   \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500BTN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502    OPEN    \u2502\n              \u2502 Motor=DOWN \u2502                         \u2502 Motor=OFF  \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502    \u2502                                     \u25b2\n            BOT \u2502    \u2502 BTN                                 \u2502\n                \u25bc    \u25bc                                     \u2502\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         BTN              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n           \u2502   CLOSED   \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502STOPPED_DOWN\u2502\n           \u2502            \u2502                          \u2502 Motor=OFF  \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                          \u25b2\n                                                          \u2502 BTN\n                                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n                                                   \u2502STOPPED_UP  \u2502\n                                                   \u2502 Motor=OFF  \u2502\n                                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>(This diagram is simplified; the complete version includes all transitions.)</p>"},{"location":"chapters/10-fsm-design-applications/#step-3-complete-state-table","title":"Step 3: Complete State Table","text":"State BTN TOP BOT Next State MOTOR CLOSED 0 X X CLOSED OFF CLOSED 1 X X OPENING UP OPENING 0 0 X OPENING UP OPENING 0 1 X OPEN OFF OPENING 1 X X STOPPED_UP OFF OPEN 0 X X OPEN OFF OPEN 1 X X CLOSING DOWN CLOSING 0 X 0 CLOSING DOWN CLOSING 0 X 1 CLOSED OFF CLOSING 1 X X STOPPED_DOWN OFF STOPPED_UP 0 X X STOPPED_UP OFF STOPPED_UP 1 X X CLOSING DOWN STOPPED_DOWN 0 X X STOPPED_DOWN OFF STOPPED_DOWN 1 X X OPENING UP"},{"location":"chapters/10-fsm-design-applications/#step-4-choose-encoding","title":"Step 4: Choose Encoding","text":"<p>6 states \u2192 need 3 flip-flops (minimum). Using binary:</p> State Q2 Q1 Q0 CLOSED 000 OPENING 001 OPEN 010 CLOSING 011 STOPPED_UP 100 STOPPED_DOWN 101"},{"location":"chapters/10-fsm-design-applications/#step-5-derive-equations","title":"Step 5: Derive Equations","text":"<p>From the state table:</p> <p>MOTOR_UP (when in OPENING):</p> \\[MOTOR\\_UP = \\overline{Q_2} \\cdot \\overline{Q_1} \\cdot Q_0\\] <p>MOTOR_DOWN (when in CLOSING):</p> \\[MOTOR\\_DOWN = \\overline{Q_2} \\cdot Q_1 \\cdot Q_0\\] <p>The next-state equations would follow similarly, using K-maps to minimize.</p>"},{"location":"chapters/10-fsm-design-applications/#step-6-implementation","title":"Step 6: Implementation","text":"<p>The circuit consists of:</p> <ul> <li>3 D flip-flops for state storage</li> <li>Combinational logic for next-state (inputs: Q2, Q1, Q0, BTN, TOP, BOT)</li> <li>Combinational logic for outputs (inputs: Q2, Q1, Q0)</li> <li>Reset logic to initialize to CLOSED (000)</li> </ul>"},{"location":"chapters/10-fsm-design-applications/#step-7-verify","title":"Step 7: Verify","text":"<p>Test vectors should include:</p> <ul> <li>Normal operation: closed \u2192 open \u2192 closed</li> <li>Stop and reverse: start opening, stop, then close</li> <li>Limit switch behavior: motor stops at limits</li> <li>Multiple button presses in sequence</li> <li>Button press at each state</li> </ul> <p>Design Complete!</p> <p>We've taken a word problem (garage door controller) through the entire FSM design process to equations ready for implementation. This same process works for any FSM\u2014simple or complex.</p>"},{"location":"chapters/10-fsm-design-applications/#common-design-patterns-and-tips","title":"Common Design Patterns and Tips","text":"<p>Here are some patterns you'll see repeatedly in FSM design:</p>"},{"location":"chapters/10-fsm-design-applications/#the-debounce-fsm","title":"The Debounce FSM","text":"<p>Mechanical buttons \"bounce\"\u2014rapidly switching between on and off when pressed. An FSM can filter this:</p> <pre><code>IDLE \u2500\u2500(btn=1)\u2500\u2500\u25b6 MAYBE_1 \u2500\u2500(btn=1)\u2500\u2500\u25b6 MAYBE_2 \u2500\u2500(btn=1)\u2500\u2500\u25b6 PRESSED\n         \u25b2                    \u2502                    \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500(btn=0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Only after seeing button=1 for 3+ consecutive cycles do we register a press. Random bounces reset to IDLE.</p>"},{"location":"chapters/10-fsm-design-applications/#the-handshake-fsm","title":"The Handshake FSM","text":"<p>For coordinating between systems with request/acknowledge:</p> <pre><code>IDLE \u2500\u2500(req)\u2500\u2500\u25b6 ACTIVE \u2500\u2500(ack)\u2500\u2500\u25b6 WAIT \u2500\u2500(~req)\u2500\u2500\u25b6 IDLE\n</code></pre> <p>The FSM ensures proper sequencing: request must come before acknowledge, and request must drop before the next transaction.</p>"},{"location":"chapters/10-fsm-design-applications/#the-watchdog-fsm","title":"The Watchdog FSM","text":"<p>Monitors for timeouts or hung conditions:</p> <pre><code>NORMAL \u2500\u2500(no_activity)\u2500\u2500\u25b6 WARNING \u2500\u2500(timeout)\u2500\u2500\u25b6 RESET\n    \u25b2                         \u2502\n    \u2514\u2500\u2500\u2500\u2500(activity)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If there's activity, stay normal. If no activity for too long, issue a warning, then reset the system.</p>"},{"location":"chapters/10-fsm-design-applications/#tips-for-clean-fsm-design","title":"Tips for Clean FSM Design","text":"<ol> <li> <p>Name states clearly: Use descriptive names (WAIT_FOR_ACK not S3)</p> </li> <li> <p>Start with the happy path: Design the normal operation first, then add error handling</p> </li> <li> <p>Don't forget reset: Every FSM needs a well-defined initial state</p> </li> <li> <p>Check for dead ends: Ensure every state has an exit path</p> </li> <li> <p>Verify completeness: Every state \u00d7 input combination must be defined</p> </li> <li> <p>Keep it simple: If you have more than 10-15 states, consider hierarchical FSMs</p> </li> <li> <p>Document the FSM: State diagrams are great documentation\u2014keep them updated!</p> </li> </ol>"},{"location":"chapters/10-fsm-design-applications/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations\u2014you now have the complete toolkit for designing finite state machines from concept to implementation!</p> <p>Equations Are Just Combinational Logic:</p> <ul> <li>Next-state equations compute D flip-flop inputs</li> <li>Output equations compute FSM outputs</li> <li>Both use standard Boolean minimization techniques</li> </ul> <p>The Design Process Is Systematic:</p> <ol> <li>Understand the specification</li> <li>Define states and draw the state diagram</li> <li>Create a complete state table</li> <li>Choose encoding and derive equations</li> <li>Implement and verify</li> </ol> <p>Sequence Detectors Are Everywhere:</p> <ul> <li>Track partial pattern matches as states</li> <li>Choose overlapping or non-overlapping based on application</li> <li>Pattern FSMs extend to complex multi-pattern recognition</li> </ul> <p>Classic Examples Teach Universal Patterns:</p> <ul> <li>Traffic lights: Safety-critical timing with phase sequences</li> <li>Vending machines: Cumulative inputs leading to actions</li> <li>Garage doors: User interface with stop/reverse logic</li> </ul> <p>Verification Is Essential:</p> <ul> <li>Test every transition, not just every state</li> <li>Check edge cases and error conditions</li> <li>For critical systems, consider formal verification</li> </ul> <p>The FSMs you've learned to design are the building blocks of all complex digital systems. The controller in your phone, the protocol handlers in your network interface, the timing logic in your display\u2014all FSMs. Master these fundamentals, and you have the tools to design any sequential digital system.</p> Graphic Novel Suggestion <p>An engaging graphic novel could follow a team of engineers designing the controller for a Mars rover, where every FSM must be perfect because there's no \"oops, let me fix that\" when you're 140 million miles from the nearest repair shop. The narrative could show how they used formal verification to prove that the rover's movement FSM would never allow driving while the drill was deployed, how they tested every transition through simulation, and the tense moment when a real mission anomaly was traced to an FSM they'd verified but implemented with a subtle encoding bug. The lesson: FSMs are powerful, but verification is everything.</p>"},{"location":"chapters/10-fsm-design-applications/#practice-problems","title":"Practice Problems","text":"<p>Test your mastery of FSM design with these exercises:</p> Problem 1: Derive Next-State Equations <p>Given this state table for a 2-state, 1-input FSM:</p> Q X Q+ 0 0 0 0 1 1 1 0 1 1 1 0 <p>Derive the next-state equation for D.</p> <p>Solution: Looking at when Q+ = 1: - Q=0, X=1 - Q=1, X=0</p> <p>These are the two cases where Q and X differ, so:</p> \\[D = Q \\oplus X = \\overline{Q} \\cdot X + Q \\cdot \\overline{X}\\] <p>This is XOR\u2014the FSM toggles when X=1.</p> Problem 2: Overlapping vs Non-Overlapping <p>For the pattern \"101\", how many times would each detector type output 1 for input \"10101\"?</p> <p>Solution:</p> <p>Non-overlapping: - 101 found at positions 0-2, output 1 - Reset, look for new pattern starting at position 3 - Only \"01\" remaining, no complete pattern - Total: 1 detection</p> <p>Overlapping: - 101 found at positions 0-2, output 1 - The \"01\" is reused as start of new pattern - 101 found at positions 2-4, output 1 - Total: 2 detections</p> Problem 3: Traffic Light Safety <p>Prove that the traffic light controller from this chapter never has both directions green simultaneously.</p> <p>Solution: Examining each state: - NS_GREEN: NS=Green, EW=Red \u2713 - NS_YELLOW: NS=Yellow, EW=Red \u2713 - EW_GREEN: NS=Red, EW=Green \u2713 - EW_YELLOW: NS=Red, EW=Yellow \u2713</p> <p>In every state, at least one direction is Red or Yellow. There is no state where both are Green. Therefore, the FSM is safe by design.</p> <p>The key is that we have 4 distinct states, each with a fixed output assignment, and we verified all 4.</p> Problem 4: Vending Machine Change <p>In the vending machine FSM, what change should be returned if a quarter is inserted when the machine is in state S15 (15\u00a2 accumulated)?</p> <p>Solution: S15 + Quarter = 15\u00a2 + 25\u00a2 = 40\u00a2</p> <p>Product costs 25\u00a2, so: - Dispense product (25\u00a2 value given) - Return 40\u00a2 - 25\u00a2 = 15\u00a2 in change</p> <p>15\u00a2 = 10\u00a2 + 5\u00a2, so: - CHANGE_10 = 1 (return a dime) - CHANGE_5 = 1 (return a nickel)</p> Problem 5: Complete FSM Design <p>Design an FSM that outputs 1 for exactly one clock cycle after seeing the input sequence \"110\". Use overlapping detection.</p> <p>Solution:</p> <p>States: - S0: Initial/haven't matched anything useful - S1: Saw \"1\" - S2: Saw \"11\" - S3: Saw \"110\" \u2192 output 1</p> <p>State Table (overlapping):</p> State Input X Next State Output Z S0 0 S0 0 S0 1 S1 0 S1 0 S0 0 S1 1 S2 0 S2 0 S3 0 S2 1 S2 0 S3 0 S0 1 S3 1 S1 1 <p>Note: In S3, we output 1. For overlapping: - If X=1 after \"110\", the new \"1\" could start another \"110\", so go to S1 - If X=0 after \"110\", reset to S0 (the \"0\" can't help start \"110\")</p> <p>Encoding (Q1 Q0): S0=00, S1=01, S2=10, S3=11</p> <p>Next-state equations:</p> \\[Q_1^+ = Q_0 \\cdot X + Q_1 \\cdot \\overline{X}\\] \\[Q_0^+ = \\overline{Q_1} \\cdot X + Q_1 \\cdot Q_0 \\cdot X\\] <p>Output equation (Moore):</p> \\[Z = Q_1 \\cdot Q_0\\] Problem 6: Design Challenge <p>Design an FSM for a combination lock with the sequence 1-2-1 (three inputs: buttons 0, 1, 2). Output UNLOCK=1 when correct sequence entered. Include a wrong-input reset.</p> <p>Solution Sketch:</p> <p>States: - LOCKED: Waiting for first correct input - SAW_1: First \"1\" received correctly - SAW_12: Sequence \"1-2\" received correctly - UNLOCKED: Full sequence \"1-2-1\" received</p> <p>Transitions: - LOCKED: button 1 \u2192 SAW_1; button 0 or 2 \u2192 LOCKED - SAW_1: button 2 \u2192 SAW_12; button 0 or 1 \u2192 LOCKED - SAW_12: button 1 \u2192 UNLOCKED; button 0 or 2 \u2192 LOCKED - UNLOCKED: any button \u2192 LOCKED (auto-relock)</p> <p>This gives a 4-state FSM with 2 flip-flops. The wrong-input reset is handled by transitions back to LOCKED from any intermediate state.</p>"},{"location":"chapters/10-fsm-design-applications/quiz/","title":"Quiz: FSM Design and Applications","text":"<p>Test your understanding of FSM design methodology, sequence detectors, and practical controller examples.</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#1-what-is-a-next-state-equation-in-fsm-design","title":"1. What is a next-state equation in FSM design?","text":"<ol> <li>An equation that calculates the output value</li> <li>A Boolean expression that computes the next state based on current state and inputs</li> <li>A formula for determining the number of flip-flops needed</li> <li>An equation for minimizing the number of states</li> </ol> Show Answer <p>The correct answer is B. The next-state equation is a Boolean expression that computes what state the FSM will enter on the next clock edge, based on the current state and inputs. These equations become the D inputs to the state register flip-flops.</p> <p>Concept Tested: Next State Equation</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#2-how-do-moore-and-mealy-machines-differ-in-their-output-equations","title":"2. How do Moore and Mealy machines differ in their output equations?","text":"<ol> <li>Moore outputs are faster than Mealy outputs</li> <li>Moore outputs depend only on state; Mealy outputs depend on state AND inputs</li> <li>Moore machines have no outputs</li> <li>Mealy outputs are always registered</li> </ol> Show Answer <p>The correct answer is B. In a Moore machine, outputs depend ONLY on the current state (Output = g(S)). In a Mealy machine, outputs depend on both current state AND current inputs (Output = h(S, I)), which allows faster response but can introduce glitches.</p> <p>Concept Tested: Output Equation</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#3-what-is-the-first-step-in-the-systematic-fsm-design-process","title":"3. What is the first step in the systematic FSM design process?","text":"<ol> <li>Draw the state diagram</li> <li>Choose state encoding</li> <li>Understand the specification and identify inputs/outputs</li> <li>Derive next-state equations</li> </ol> Show Answer <p>The correct answer is C. The FSM design process begins with understanding the specification\u2014identifying inputs, outputs, required behavior, and whether Moore or Mealy is appropriate. This understanding guides all subsequent steps.</p> <p>Concept Tested: FSM Design Process</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#4-why-is-fsm-verification-important","title":"4. Why is FSM verification important?","text":"<ol> <li>To make the FSM run faster</li> <li>To confirm the implementation correctly matches the specification</li> <li>To reduce the number of states</li> <li>To eliminate the need for simulation</li> </ol> Show Answer <p>The correct answer is B. FSM verification confirms that the implementation correctly matches its specification. This includes testing every transition, checking reset behavior, and verifying outputs\u2014catching errors before they become bugs in hardware.</p> <p>Concept Tested: FSM Verification</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#5-what-does-a-sequence-detector-fsm-do","title":"5. What does a sequence detector FSM do?","text":"<ol> <li>Counts the total number of 1s in an input stream</li> <li>Monitors an input stream and outputs a signal when a specific pattern is detected</li> <li>Generates random bit sequences</li> <li>Sorts input values in order</li> </ol> Show Answer <p>The correct answer is B. A sequence detector monitors an input bit stream and asserts an output signal when a specific target pattern (like \"101\") is detected. States represent partial progress toward matching the complete pattern.</p> <p>Concept Tested: Sequence Detector</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#6-what-is-the-difference-between-overlapping-and-non-overlapping-pattern-detection","title":"6. What is the difference between overlapping and non-overlapping pattern detection?","text":"<ol> <li>Overlapping uses more flip-flops</li> <li>In overlapping detection, the suffix of one pattern can be the prefix of the next</li> <li>Non-overlapping detection is always faster</li> <li>Overlapping detection only works with Mealy machines</li> </ol> Show Answer <p>The correct answer is B. In overlapping detection, after finding a pattern, part of it can count toward the next match. For pattern \"101\" in stream \"10101\", overlapping finds TWO matches (positions 0-2 and 2-4) because the final \"1\" of the first match starts the next pattern.</p> <p>Concept Tested: Overlapping Detection</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#7-in-a-traffic-light-controller-fsm-what-is-the-critical-safety-property","title":"7. In a traffic light controller FSM, what is the critical safety property?","text":"<ol> <li>Lights change as fast as possible</li> <li>Both directions are never green simultaneously</li> <li>Yellow lights last exactly 3 seconds</li> <li>The controller uses minimal flip-flops</li> </ol> Show Answer <p>The correct answer is B. The critical safety property is that conflicting green lights never occur simultaneously. This is verified by examining each state and confirming that at least one direction always has red (or yellow) when the other has any non-red light.</p> <p>Concept Tested: Traffic Light Controller</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#8-in-a-vending-machine-fsm-what-do-the-states-typically-represent","title":"8. In a vending machine FSM, what do the states typically represent?","text":"<ol> <li>Different products available</li> <li>The accumulated money amount</li> <li>The time since last transaction</li> <li>The number of items dispensed</li> </ol> Show Answer <p>The correct answer is B. Vending machine FSM states represent the accumulated money amount (0\u00a2, 5\u00a2, 10\u00a2, 15\u00a2, 20\u00a2, etc.). Transitions occur as coins are inserted, and the FSM dispenses the product and returns change when the threshold is reached.</p> <p>Concept Tested: Vending Machine FSM</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#9-what-is-a-pattern-recognition-fsm-capable-of-beyond-simple-sequence-detection","title":"9. What is a pattern recognition FSM capable of beyond simple sequence detection?","text":"<ol> <li>Only detecting single-bit patterns</li> <li>Detecting patterns with multiple inputs, wildcards, or alternative paths</li> <li>Generating pseudo-random numbers</li> <li>Compressing data automatically</li> </ol> Show Answer <p>The correct answer is B. Pattern recognition FSMs extend sequence detection to handle multiple input bits, don't-care positions (wildcards like \"1X1\"), alternative patterns (detect \"101\" OR \"110\"), counted repetitions, and complex protocol sequences.</p> <p>Concept Tested: Pattern Recognition FSM</p>"},{"location":"chapters/10-fsm-design-applications/quiz/#10-what-is-the-most-common-fsm-design-error-when-creating-state-tables","title":"10. What is the most common FSM design error when creating state tables?","text":"<ol> <li>Using too many states</li> <li>Leaving undefined behavior for some state \u00d7 input combinations</li> <li>Making the FSM too fast</li> <li>Using one-hot encoding</li> </ol> Show Answer <p>The correct answer is B. The most common error is leaving holes in the state table\u2014undefined behavior for some state \u00d7 input combinations. When implemented, these cases will have some behavior (often incorrect), leading to hard-to-debug problems.</p> <p>Concept Tested: FSM Design Process</p>"},{"location":"chapters/11-registers-counters-datapath/","title":"Registers, Counters, and Datapath","text":""},{"location":"chapters/11-registers-counters-datapath/#summary","title":"Summary","text":"<p>This chapter covers the sequential building blocks that form the foundation of digital datapath design. Students will learn about registers including parallel load and shift registers with various configurations (SISO, SIPO, PISO, PIPO), bidirectional and universal shift registers, and control signals for enable, load, and clear operations. Counter design is thoroughly covered including up, down, and up-down counters, mod-N counters, BCD and decade counters, and specialized counters like ring and Johnson counters. The chapter concludes with datapath concepts, control units, and register transfer level (RTL) abstraction.</p>"},{"location":"chapters/11-registers-counters-datapath/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 29 concepts from the learning graph:</p> <ol> <li>Counter</li> <li>Up Counter</li> <li>Down Counter</li> <li>Up-Down Counter</li> <li>Mod-N Counter</li> <li>Binary Counter</li> <li>BCD Counter</li> <li>Decade Counter</li> <li>Ring Counter</li> <li>Johnson Counter</li> <li>Counter State Diagram</li> <li>Counter Overflow</li> <li>Register</li> <li>Parallel Load Register</li> <li>Shift Register</li> <li>Serial In Serial Out</li> <li>Serial In Parallel Out</li> <li>Parallel In Serial Out</li> <li>Parallel In Parallel Out</li> <li>Bidirectional Shift</li> <li>Universal Shift Register</li> <li>Enable Signal</li> <li>Load Signal</li> <li>Clear Signal</li> <li>Register File</li> <li>Datapath Concept</li> <li>Control Unit</li> <li>Register Transfer Level</li> <li>RTL Notation</li> </ol>"},{"location":"chapters/11-registers-counters-datapath/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 8: Flip-Flops and Timing</li> <li>Chapter 9: Finite State Machine Fundamentals</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#introduction-building-blocks-that-remember-and-count","title":"Introduction: Building Blocks That Remember and Count","text":"<p>Welcome to the chapter where flip-flops graduate from being solo performers to joining an orchestra! You've mastered individual flip-flops\u2014those tiny one-bit memory cells that hold either a 0 or a 1. Now it's time to see what happens when you gang them together to create registers (memory units that remember entire words) and counters (circuits that can count events).</p> <p>Think of a flip-flop as a single Post-It note that can remember one bit. A register is like a whole notebook\u2014you can store eight bits, sixteen bits, or even more. A counter is like a mechanical tally counter at the door of a concert venue: click, click, click, keeping track of how many people entered.</p> <p>But here's where it gets really exciting: registers and counters are the bread and butter of datapath design. The datapath is the part of a processor that actually moves and manipulates data\u2014adding numbers, shifting bits, storing intermediate results. If the CPU were a kitchen, the datapath would be the prep station, cutting board, and mixing bowls where all the actual cooking happens.</p> <p>By the end of this chapter, you'll understand how registers hold data, how counters sequence through states, and how the datapath ties it all together with a control unit calling the shots. You're building the foundation for understanding how computers actually compute!</p> <p>Ready to start counting? Let's shift into high gear!</p>"},{"location":"chapters/11-registers-counters-datapath/#registers-your-circuits-notebook","title":"Registers: Your Circuit's Notebook","text":""},{"location":"chapters/11-registers-counters-datapath/#what-is-a-register","title":"What is a Register?","text":"<p>A Register is a group of flip-flops that work together to store multiple bits of data as a single unit. While a single D flip-flop stores one bit, a register stores an entire binary word\u2014typically 4, 8, 16, 32, or 64 bits wide.</p> <p>Registers are fundamental building blocks in digital systems. Every piece of data your computer manipulates\u2014from the characters you type to the pixels on your screen\u2014passes through registers at some point.</p> <p>Key characteristics of registers:</p> <ul> <li>Parallel storage: All flip-flops in the register share the same clock signal</li> <li>Word-oriented: The register stores and retrieves an entire word at once (or can shift data serially)</li> <li>Controlled access: Enable, load, and clear signals determine when and how data moves</li> </ul> <p>Here's what an 8-bit register looks like conceptually:</p> Bit Position D\u2087 D\u2086 D\u2085 D\u2084 D\u2083 D\u2082 D\u2081 D\u2080 Flip-flop FF\u2087 FF\u2086 FF\u2085 FF\u2084 FF\u2083 FF\u2082 FF\u2081 FF\u2080 Output Q\u2087 Q\u2086 Q\u2085 Q\u2084 Q\u2083 Q\u2082 Q\u2081 Q\u2080 <p>When the clock edge arrives (and the register is enabled), all eight flip-flops simultaneously capture their respective input bits. The stored word is available at the Q outputs until the next load operation.</p> <p>Registers vs. Memory</p> <p>Registers and RAM both store data, but they serve different purposes. Registers are fast, expensive, and directly connected to the datapath\u2014there are typically only a handful in a CPU. RAM is slower, cheaper per bit, and stores much more data. Think of registers as the items on your desk (immediately accessible) versus RAM as books on your bookshelf (requires walking over to retrieve).</p>"},{"location":"chapters/11-registers-counters-datapath/#control-signals-enable-load-and-clear","title":"Control Signals: Enable, Load, and Clear","text":"<p>Registers don't just blindly capture data on every clock edge. They have control signals that determine their behavior:</p>"},{"location":"chapters/11-registers-counters-datapath/#enable-signal","title":"Enable Signal","text":"<p>The Enable Signal (sometimes called Clock Enable, CE, or EN) controls whether the register responds to the clock. When enable is inactive, the register ignores clock edges and retains its current value\u2014like putting the register on pause.</p> \\[Q^+ = \\begin{cases} D &amp; \\text{if } EN = 1 \\\\ Q &amp; \\text{if } EN = 0 \\end{cases}\\] <p>Enable is useful when:</p> <ul> <li>Multiple registers share a clock but should update at different times</li> <li>The register should hold its value while other processing occurs</li> <li>Power savings are needed (disabled flip-flops don't switch)</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#load-signal","title":"Load Signal","text":"<p>The Load Signal (sometimes called LD or LOAD) tells the register to capture new data from its inputs. This is often combined with enable functionality.</p> <p>In some designs, load and enable are the same signal. In others, they're separate: enable might gate the clock while load selects between keeping the current value versus accepting new input.</p> <p>A register with both enable and load might work like this:</p> EN LOAD Behavior 0 X Hold (ignore clock) 1 0 Hold (clock active, no load) 1 1 Load new data"},{"location":"chapters/11-registers-counters-datapath/#clear-signal","title":"Clear Signal","text":"<p>The Clear Signal (sometimes called CLR, RST, or RESET) forces all flip-flops in the register to 0, regardless of the data inputs. Clear can be:</p> <ul> <li>Asynchronous: Happens immediately when clear is asserted, ignoring the clock</li> <li>Synchronous: Happens on the next clock edge when clear is asserted</li> </ul> <p>Asynchronous clear is essential for system reset\u2014you need to establish a known state when power is applied. Synchronous clear is safer for normal operation since it avoids timing hazards.</p> \\[Q^+ = \\begin{cases} 0 &amp; \\text{if } CLR = 1 \\\\ D &amp; \\text{if } CLR = 0 \\text{ and } LOAD = 1 \\\\ Q &amp; \\text{otherwise} \\end{cases}\\]"},{"location":"chapters/11-registers-counters-datapath/#diagram-register-control-signals","title":"Diagram: Register Control Signals","text":"Register Control Signals Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use enable, load, and clear signals to control when and how a register stores data, predicting the register's behavior for different signal combinations.</p> <p>Instructional Rationale: Interactive manipulation of control signals with immediate visual feedback on register contents builds intuition for how these signals interact.</p> <p>Canvas Layout:</p> <ul> <li>Center: 4-bit register with visible flip-flop states</li> <li>Top: Data input switches (4 bits)</li> <li>Left: Control signal toggles (Enable, Load, Clear)</li> <li>Right: Output display showing stored value</li> <li>Bottom: Clock edge button and timing diagram</li> </ul> <p>Interactive Elements:</p> <ul> <li>4 toggle switches for data input (D3-D0)</li> <li>Enable toggle with indicator</li> <li>Load toggle with indicator</li> <li>Clear button (momentary)</li> <li>Clock edge button to trigger update</li> <li>Visual representation of flip-flop states</li> <li>Timing diagram showing signal relationships</li> <li>Prediction mode: guess output before clicking clock</li> </ul> <p>Data Visibility:</p> <ul> <li>Current data input value (binary and hex)</li> <li>Current register contents (binary and hex)</li> <li>Control signal states</li> <li>What will happen on next clock edge</li> <li>Timing diagram showing history</li> </ul> <p>Visual Style:</p> <ul> <li>Register shown as connected flip-flops</li> <li>Control signals as labeled input lines</li> <li>Data flows visualized with arrows</li> <li>Clear changes shown immediately vs synchronized</li> <li>Color: green=enabled, red=disabled, blue=data</li> </ul> <p>Implementation: p5.js with register simulation and timing diagram</p>"},{"location":"chapters/11-registers-counters-datapath/#parallel-load-register","title":"Parallel Load Register","text":"<p>A Parallel Load Register accepts all input bits simultaneously (in parallel) on a clock edge. This is the most common type of register, used when you need to store a complete word of data at once.</p> <p>The key feature is that all bits are loaded at the same instant\u2014there's no sequential bit-by-bit transfer. When the load signal is active and the clock edge arrives, every flip-flop captures its corresponding input.</p> <pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502         4-bit Parallel Load         \u2502\nD3 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u25ba[D Q]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\u2500\u2500\u2500\u2500 Q3\nD2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u25ba[D Q]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\u2500\u2500\u2500\u2500 Q2\nD1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u25ba[D Q]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\u2500\u2500\u2500\u2500 Q1\nD0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u25ba[D Q]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\u2500\u2500\u2500\u2500 Q0\n           \u2502          \u25b2     \u25b2     \u25b2              \u2502\nLOAD \u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502     \u2502              \u2502\nCLR \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502              \u2502\nCLK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The behavior is straightforward:</p> CLR LOAD Clock Action 1 X \u2191 Q \u2190 0000 (synchronous clear) 0 1 \u2191 Q \u2190 D (load data) 0 0 \u2191 Q \u2190 Q (hold) <p>In Verilog, a 4-bit parallel load register is elegantly simple:</p> <pre><code>module parallel_load_reg (\n    input wire clk,\n    input wire clr,\n    input wire load,\n    input wire [3:0] d,\n    output reg [3:0] q\n);\n    always @(posedge clk) begin\n        if (clr)\n            q &lt;= 4'b0000;\n        else if (load)\n            q &lt;= d;\n        // else hold current value (implicit)\n    end\nendmodule\n</code></pre> <p>Implicit Hold Behavior</p> <p>When neither clear nor load is active, the register simply holds its value. In Verilog, this \"else hold\" behavior is implicit when you don't specify an else clause\u2014the synthesis tool infers that Q should retain its value.</p>"},{"location":"chapters/11-registers-counters-datapath/#shift-registers-data-on-the-move","title":"Shift Registers: Data on the Move","text":"<p>While parallel load registers move data all at once, Shift Registers move data one bit at a time, shifting the contents left or right on each clock cycle. This seemingly simple operation enables an incredible range of applications, from serial communication to multiplication and division.</p>"},{"location":"chapters/11-registers-counters-datapath/#the-four-flavors-of-shift-registers","title":"The Four Flavors of Shift Registers","text":"<p>Shift registers come in four configurations, depending on how data enters and exits:</p>"},{"location":"chapters/11-registers-counters-datapath/#serial-in-serial-out-siso","title":"Serial In Serial Out (SISO)","text":"<p>A Serial In Serial Out shift register accepts one bit at a time at one end and outputs one bit at a time at the other end. Data flows through the register like cars in a tunnel\u2014in one end, out the other.</p> <pre><code>Serial In \u2192 [D\u2080] \u2192 [D\u2081] \u2192 [D\u2082] \u2192 [D\u2083] \u2192 Serial Out\n            \u2191       \u2191       \u2191       \u2191\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      CLK\n</code></pre> <p>SISO registers are used for:</p> <ul> <li>Delay lines: Delay a signal by N clock cycles</li> <li>Serial transmission: Send data one bit at a time over a single wire</li> <li>Circular buffers: When output is fed back to input</li> </ul> <p>The data takes N clock cycles to travel through an N-bit register\u2014perfect when you need a precisely timed delay.</p>"},{"location":"chapters/11-registers-counters-datapath/#serial-in-parallel-out-sipo","title":"Serial In Parallel Out (SIPO)","text":"<p>A Serial In Parallel Out shift register accepts data one bit at a time but provides access to all stored bits simultaneously as outputs. Data streams in serially, then the complete word is read in parallel.</p> <pre><code>                    Q\u2083    Q\u2082    Q\u2081    Q\u2080\n                     \u2193     \u2193     \u2193     \u2193\nSerial In \u2192 [D\u2080] \u2192 [D\u2081] \u2192 [D\u2082] \u2192 [D\u2083]\n                    \u2191      \u2191      \u2191      \u2191\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              CLK\n</code></pre> <p>SIPO is essential for:</p> <ul> <li>Serial-to-parallel conversion: Receive serial data (like UART), output parallel word</li> <li>Data collection: Gather bits over time, then process all at once</li> <li>SPI/I2C receivers: Accept data from serial bus, present as parallel byte</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#parallel-in-serial-out-piso","title":"Parallel In Serial Out (PISO)","text":"<p>A Parallel In Serial Out shift register loads an entire word at once, then shifts it out one bit at a time. This is the opposite of SIPO\u2014data enters in parallel and leaves serially.</p> <pre><code>           D\u2083    D\u2082    D\u2081    D\u2080\n            \u2193     \u2193     \u2193     \u2193\n          [D\u2080] \u2192 [D\u2081] \u2192 [D\u2082] \u2192 [D\u2083] \u2192 Serial Out\n            \u2191      \u2191      \u2191      \u2191\nLOAD \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nCLK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>PISO is used for:</p> <ul> <li>Parallel-to-serial conversion: Take parallel word, transmit serially</li> <li>SPI/UART transmitters: Load byte to send, shift it out bit by bit</li> <li>Reducing pin count: Transmit 8 bits over 1 wire instead of 8</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#parallel-in-parallel-out-pipo","title":"Parallel In Parallel Out (PIPO)","text":"<p>A Parallel In Parallel Out register is essentially the same as our parallel load register\u2014data enters in parallel and exits in parallel. While it can also shift, the primary mode is complete word transfers.</p> <pre><code>           D\u2083    D\u2082    D\u2081    D\u2080\n            \u2193     \u2193     \u2193     \u2193\n          [FF] \u2500 [FF] \u2500 [FF] \u2500 [FF]\n            \u2193     \u2193     \u2193     \u2193\n           Q\u2083    Q\u2082    Q\u2081    Q\u2080\n</code></pre> <p>PIPO with shift capability is essentially a universal shift register (covered soon).</p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-shift-register-modes-comparison","title":"Diagram: Shift Register Modes Comparison","text":"Shift Register Modes Interactive <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare SISO, SIPO, PISO, and PIPO shift register modes, explaining how data flows in each configuration and identifying appropriate applications.</p> <p>Instructional Rationale: Side-by-side visualization of all four modes with animated data flow makes the distinctions clear and memorable.</p> <p>Canvas Layout:</p> <ul> <li>Four columns, one for each mode (SISO, SIPO, PISO, PIPO)</li> <li>Each shows 4-bit register with input/output paths</li> <li>Bottom: shared clock control and data input</li> <li>Top: mode descriptions and use cases</li> </ul> <p>Interactive Elements:</p> <ul> <li>Mode selector to highlight one mode at a time</li> <li>Clock edge button to shift data</li> <li>Serial input bit toggle (for SISO/SIPO)</li> <li>Parallel input switches (for PISO/PIPO)</li> <li>Animation showing data movement</li> <li>Step counter showing clock cycles elapsed</li> <li>Reset button</li> </ul> <p>Data Visibility:</p> <ul> <li>Current register contents in all modes</li> <li>Input being entered</li> <li>Output being produced</li> <li>Clock cycle count</li> <li>Comparison of how same data appears in each mode</li> </ul> <p>Visual Style:</p> <ul> <li>Consistent register representation across all modes</li> <li>Data bits as colored boxes moving through register</li> <li>Arrows showing data flow direction</li> <li>Highlight input and output paths differently</li> <li>Animation of bit-by-bit vs parallel transfer</li> </ul> <p>Implementation: p5.js with four register simulations and synchronized clock</p>"},{"location":"chapters/11-registers-counters-datapath/#bidirectional-shift","title":"Bidirectional Shift","text":"<p>A Bidirectional Shift register can shift data either left or right based on a direction control signal. This flexibility is valuable for arithmetic operations and data manipulation.</p> <p>Direction control works like this:</p> DIR Action 0 Shift Right: Each bit moves to lower position, new bit enters at MSB 1 Shift Left: Each bit moves to higher position, new bit enters at LSB <p>The implementation adds a multiplexer at each flip-flop's input:</p> <pre><code>For bit position i:\nD[i] = (DIR == 0) ? Q[i+1] : Q[i-1]\n</code></pre> <p>On shift right, bit i receives the value from bit i+1 (the bit to its left). On shift left, bit i receives the value from bit i-1 (the bit to its right).</p> <p>Arithmetic with Shifts</p> <p>Shifting left by one position multiplies by 2 (assuming no overflow). Shifting right by one position divides by 2 (with truncation). A bidirectional shift register can implement fast multiply/divide by powers of 2!</p> <ul> <li>0101 (5) shift left \u2192 1010 (10)</li> <li>1100 (12) shift right \u2192 0110 (6)</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#universal-shift-register","title":"Universal Shift Register","text":"<p>The Universal Shift Register combines all shift register capabilities into one versatile component. It can:</p> <ul> <li>Hold (no change)</li> <li>Load in parallel</li> <li>Shift left</li> <li>Shift right</li> </ul> <p>This is controlled by a 2-bit mode select input:</p> S\u2081 S\u2080 Mode 0 0 Hold (no change) 0 1 Shift Right 1 0 Shift Left 1 1 Parallel Load <p>The universal shift register is a workhorse component in datapath design because it handles so many operations with a single piece of hardware.</p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-universal-shift-register","title":"Diagram: Universal Shift Register","text":"Universal Shift Register Simulator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate all four modes of a universal shift register (hold, shift left, shift right, parallel load) by setting mode controls and observing the resulting data transformations.</p> <p>Instructional Rationale: Interactive control over all modes with immediate visual feedback on register contents builds proficiency with this versatile component.</p> <p>Canvas Layout:</p> <ul> <li>Center: 4-bit register with visible contents</li> <li>Top: Mode selector (4 options)</li> <li>Left: Serial inputs (left and right)</li> <li>Top-Center: Parallel data inputs</li> <li>Right: Outputs (parallel and serial)</li> <li>Bottom: Clock control and state history</li> </ul> <p>Interactive Elements:</p> <ul> <li>Mode selection dropdown or buttons</li> <li>Parallel input data entry</li> <li>Serial input left bit toggle</li> <li>Serial input right bit toggle</li> <li>Clock edge button</li> <li>Clear button</li> <li>History panel showing last 8 states</li> <li>Mode indicator showing current operation</li> </ul> <p>Data Visibility:</p> <ul> <li>Current mode selected</li> <li>Input values (parallel and serial)</li> <li>Current register contents</li> <li>What will happen on next clock edge</li> <li>Output values</li> <li>Operation history</li> </ul> <p>Visual Style:</p> <ul> <li>Register as row of connected boxes</li> <li>Mode selection highlighted</li> <li>Data flow arrows appropriate for current mode</li> <li>Serial inputs at left/right ends</li> <li>Parallel outputs above each cell</li> <li>Animation for shift and load operations</li> </ul> <p>Implementation: p5.js with 74194-style universal shift register simulation</p> <p>The 74LS194 is a classic universal shift register IC that implements exactly this functionality. In FPGA and ASIC design, universal shift registers are synthesized from the behavioral description\u2014you write what you want, and the tools figure out the multiplexers and flip-flops.</p>"},{"location":"chapters/11-registers-counters-datapath/#counters-circuits-that-count","title":"Counters: Circuits That Count","text":"<p>Now let's turn to circuits that don't just store data\u2014they sequence through values automatically. A Counter is a sequential circuit that goes through a predetermined sequence of states on successive clock pulses.</p>"},{"location":"chapters/11-registers-counters-datapath/#what-is-a-counter","title":"What is a Counter?","text":"<p>At its core, a counter is an FSM with a simple, regular structure. Instead of arbitrary transitions between states, counters follow a counting sequence\u2014typically incrementing or decrementing by one on each clock cycle.</p> <p>Counters have applications everywhere:</p> <ul> <li>Event counting: How many button presses? How many pulses from a sensor?</li> <li>Timing: Count clock cycles to measure time intervals</li> <li>Sequencing: Generate control sequences for state machines</li> <li>Address generation: Step through memory addresses</li> <li>Frequency division: Clock output toggles at a fraction of input frequency</li> </ul> <p>Key counter parameters:</p> Parameter Description Modulus (mod-N) Number of unique states (e.g., mod-8 counts 0-7) Direction Up, down, or up-down (bidirectional) Type Binary, BCD, ring, Johnson, etc. Synchronous/Async All flip-flops clock together or in cascade"},{"location":"chapters/11-registers-counters-datapath/#binary-counter","title":"Binary Counter","text":"<p>A Binary Counter counts in standard binary sequence. An n-bit binary counter has \\(2^n\\) states and counts from 0 to \\(2^n - 1\\) before wrapping around.</p> <p>A 4-bit binary counter sequence:</p> Clock Cycle Q\u2083 Q\u2082 Q\u2081 Q\u2080 Decimal 0 0 0 0 0 0 1 0 0 0 1 1 2 0 0 1 0 2 3 0 0 1 1 3 ... ... ... ... ... ... 14 1 1 1 0 14 15 1 1 1 1 15 16 0 0 0 0 0 (wrap) <p>Notice how Q\u2080 toggles every clock cycle, Q\u2081 toggles every 2 cycles, Q\u2082 every 4 cycles, and Q\u2083 every 8 cycles. This is the natural binary counting pattern.</p>"},{"location":"chapters/11-registers-counters-datapath/#up-counter","title":"Up Counter","text":"<p>An Up Counter increments its value by one on each clock pulse. Starting from 0, it counts upward: 0, 1, 2, 3, ... until it reaches its maximum value, then wraps back to 0.</p> <p>The fundamental equation:</p> \\[Count^+ = Count + 1\\] <p>With wraparound:</p> \\[Count^+ = (Count + 1) \\mod 2^n\\] <p>where n is the number of bits.</p> <p>For a synchronous up counter, the design uses T flip-flops (or D flip-flops with XOR feedback):</p> <ul> <li>Q\u2080: Toggle every clock cycle (T\u2080 = 1)</li> <li>Q\u2081: Toggle when Q\u2080 = 1 (T\u2081 = Q\u2080)</li> <li>Q\u2082: Toggle when Q\u2080Q\u2081 = 1 (T\u2082 = Q\u2080 \u00b7 Q\u2081)</li> <li>Q\u2083: Toggle when Q\u2080Q\u2081Q\u2082 = 1 (T\u2083 = Q\u2080 \u00b7 Q\u2081 \u00b7 Q\u2082)</li> </ul> <p>The general pattern: bit i toggles when all lower bits are 1.</p>"},{"location":"chapters/11-registers-counters-datapath/#down-counter","title":"Down Counter","text":"<p>A Down Counter decrements its value by one on each clock pulse. Starting from its maximum value, it counts downward: 15, 14, 13, ... 1, 0, then wraps to the maximum.</p> <p>The fundamental equation:</p> \\[Count^+ = Count - 1\\] <p>With wraparound:</p> \\[Count^+ = (Count - 1) \\mod 2^n\\] <p>For a down counter, the toggle conditions change:</p> <ul> <li>Q\u2080: Toggle every clock (same as up counter)</li> <li>Q\u2081: Toggle when Q\u2080 = 0 (T\u2081 = Q\u0304\u2080)</li> <li>Q\u2082: Toggle when Q\u2080Q\u2081 = 0 (T\u2082 = Q\u0304\u2080 \u00b7 Q\u0304\u2081)</li> <li>Q\u2083: Toggle when Q\u2080Q\u2081Q\u2082 = 0 (T\u2083 = Q\u0304\u2080 \u00b7 Q\u0304\u2081 \u00b7 Q\u0304\u2082)</li> </ul> <p>The pattern: bit i toggles when all lower bits are 0 (about to borrow).</p>"},{"location":"chapters/11-registers-counters-datapath/#up-down-counter","title":"Up-Down Counter","text":"<p>An Up-Down Counter (also called a bidirectional counter) can count in either direction, controlled by a direction input (often called UP/DOWN or DIR).</p> DIR Action 1 Count up on clock edge 0 Count down on clock edge <p>The toggle logic combines both conditions:</p> \\[T_i = (DIR \\cdot Q_0 \\cdot Q_1 \\cdots Q_{i-1}) + (\\overline{DIR} \\cdot \\overline{Q_0} \\cdot \\overline{Q_1} \\cdots \\overline{Q_{i-1}})\\] <p>This can be simplified using XOR:</p> \\[T_i = Q_0 \\oplus \\overline{DIR}) \\cdot (Q_1 \\oplus \\overline{DIR}) \\cdots (Q_{i-1} \\oplus \\overline{DIR})\\] <p>Direction Changes Mid-Count</p> <p>An up-down counter can reverse direction at any time. If you're counting up: 3, 4, 5... and suddenly change direction, you'll count down: 5, 4, 3... This is useful for applications like position tracking where the direction of motion can reverse.</p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-up-down-counter","title":"Diagram: Up-Down Counter","text":"Up-Down Counter Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Practice</p> <p>Learning Objective: Students will be able to practice operating an up-down counter by changing direction and observing the count sequence, including boundary behavior when wrapping.</p> <p>Instructional Rationale: Interactive control over direction with visible count sequence and wrap behavior demonstrates bidirectional counting dynamics.</p> <p>Canvas Layout:</p> <ul> <li>Center: 4-bit counter display (binary and decimal)</li> <li>Left: Direction control toggle (UP/DOWN)</li> <li>Right: Count history showing sequence</li> <li>Bottom: Clock control with enable</li> </ul> <p>Interactive Elements:</p> <ul> <li>Direction toggle switch</li> <li>Clock step button</li> <li>Auto-clock mode with speed control</li> <li>Enable toggle to pause counting</li> <li>Clear/Reset button</li> <li>History panel showing last 16 values</li> <li>Visual indicator of count direction</li> </ul> <p>Data Visibility:</p> <ul> <li>Current count (binary and decimal)</li> <li>Current direction</li> <li>Next value preview</li> <li>Count sequence history</li> <li>Overflow/underflow indicators</li> </ul> <p>Visual Style:</p> <ul> <li>Binary display as row of bits</li> <li>Decimal display prominently</li> <li>Direction shown with arrow icon</li> <li>Count history as scrolling list or graph</li> <li>Wrap animation when reaching limits</li> </ul> <p>Implementation: p5.js with bidirectional counter simulation</p>"},{"location":"chapters/11-registers-counters-datapath/#counter-state-diagram","title":"Counter State Diagram","text":"<p>A Counter State Diagram shows the sequence of states a counter passes through and the transitions between them. For a simple counter, this forms a cycle.</p> <p>A 3-bit up counter state diagram:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                                          \u2502\n    \u25bc                                          \u2502\n   000 \u2500\u2500\u2500\u2500\u2500\u25b6 001 \u2500\u2500\u2500\u2500\u2500\u25b6 010 \u2500\u2500\u2500\u2500\u2500\u25b6 011       \u2502\n                                    \u2502          \u2502\n                                    \u25bc          \u2502\n   111 \u25c0\u2500\u2500\u2500\u2500\u2500 110 \u25c0\u2500\u2500\u2500\u2500\u2500 101 \u25c0\u2500\u2500\u2500\u2500\u2500 100       \u2502\n    \u2502                                          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Every state has exactly one successor (the next count value), and the diagram forms a closed loop\u2014the counter cycles forever.</p> <p>For an up-down counter, the state diagram shows transitions in both directions, but only one direction is active at any time based on the DIR signal.</p>"},{"location":"chapters/11-registers-counters-datapath/#counter-overflow","title":"Counter Overflow","text":"<p>Counter Overflow occurs when a counter reaches its maximum value and wraps around to zero (for up counters) or when it reaches zero and wraps to the maximum (for down counters).</p> <p>Overflow is detected by:</p> <ul> <li>Terminal count (TC): Signal that goes high when counter reaches its maximum</li> <li>Ripple carry (RCO): Carry output for cascading counters</li> </ul> <p>For a 4-bit up counter:</p> \\[TC = Q_3 \\cdot Q_2 \\cdot Q_1 \\cdot Q_0\\] <p>TC = 1 only when count = 1111 (15).</p> <p>For a down counter:</p> \\[TC = \\overline{Q_3} \\cdot \\overline{Q_2} \\cdot \\overline{Q_1} \\cdot \\overline{Q_0}\\] <p>TC = 1 only when count = 0000 (0).</p> <p>Overflow Handling</p> <p>Counter overflow can be either a feature or a bug. For a free-running timer, you want it to wrap. For counting items in a buffer, overflow might indicate an error condition. Always consider what should happen when your counter maxes out!</p> <p>Overflow detection enables:</p> <ul> <li>Counter cascading: Chain multiple counters for wider range</li> <li>Event triggering: Signal when a specific count is reached</li> <li>Error detection: Flag when a counted quantity exceeds limits</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#mod-n-counter","title":"Mod-N Counter","text":"<p>A Mod-N Counter counts from 0 to N-1, then resets to 0\u2014it cycles through exactly N states. The \"modulus\" is the number of states before repeating.</p> <p>Special cases:</p> <ul> <li>Mod-16: Standard 4-bit binary counter (cycles through 16 states)</li> <li>Mod-10: Decade counter (counts 0-9)</li> <li>Mod-60: Seconds or minutes counter (counts 0-59)</li> <li>Mod-24: Hours counter (counts 0-23)</li> </ul> <p>To create a mod-N counter from a larger binary counter, you need to force a reset when the count reaches N:</p> <pre><code>           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502    4-bit Up     \u2502\nCLK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    Counter      \u251c\u2500\u2500\u2500\u2500 Q\u2083Q\u2082Q\u2081Q\u2080\n           \u2502                 \u2502\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 CLR             \u2502\n   \u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502                \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500 When Q\u2083Q\u2082Q\u2081Q\u2080 = N, pulse CLR\n</code></pre> <p>For example, a mod-12 counter using a 4-bit counter:</p> \\[CLR = Q_3 \\cdot \\overline{Q_2} \\cdot Q_1 \\cdot \\overline{Q_0}\\] <p>This detects 1100 (12) and resets the counter to 0000.</p> <p>Glitch-Free Mod-N Design</p> <p>The self-clearing method can cause a brief glitch (counter shows N for a tiny moment before resetting). For glitch-free operation, use synchronous design where the next-state logic directly computes the wraparound.</p>"},{"location":"chapters/11-registers-counters-datapath/#bcd-counter-and-decade-counter","title":"BCD Counter and Decade Counter","text":"<p>A BCD Counter counts in Binary-Coded Decimal\u2014each digit is represented by 4 bits, counting 0-9 only. This makes it easy to display counts in decimal.</p> <p>A Decade Counter is a mod-10 counter that counts from 0 to 9, then resets. It's the building block for BCD counters.</p> <p>Single decade counter sequence:</p> Clock Q\u2083 Q\u2082 Q\u2081 Q\u2080 Decimal 0 0 0 0 0 0 1 0 0 0 1 1 2 0 0 1 0 2 ... ... ... ... ... ... 9 1 0 0 1 9 10 0 0 0 0 0 (wrap) <p>BCD counters cascade to count larger numbers. For a 2-digit display (00-99), you chain two decade counters:</p> <pre><code>CLK \u2500\u2500\u2500\u2500\u2500\u2524 Units \u251c\u2500\u2500\u2500\u2500\u2500\u2524 Tens \u251c\u2500\u2500\u2500\u2500\u2500\u25b6\n          (0-9)   RCO   (0-9)   RCO\n</code></pre> <p>When the units counter rolls over from 9 to 0, its ripple carry increments the tens counter.</p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-bcd-decade-counter","title":"Diagram: BCD Decade Counter","text":"BCD Decade Counter with Display <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use BCD decade counters to count in decimal, observing the 0-9 cycle and understanding how the count is displayed.</p> <p>Instructional Rationale: Visual connection between BCD bits and decimal display reinforces understanding of binary-coded decimal representation.</p> <p>Canvas Layout:</p> <ul> <li>Center: 4-bit BCD register with individual bits shown</li> <li>Top: 7-segment display showing decimal digit</li> <li>Left: Clock control</li> <li>Right: Count history</li> <li>Bottom: Binary to decimal conversion table</li> </ul> <p>Interactive Elements:</p> <ul> <li>Clock step button</li> <li>Auto-count mode with speed control</li> <li>Reset button</li> <li>Visual 7-segment display</li> <li>BCD bit indicators</li> <li>Invalid state indicator (for &gt;9)</li> <li>Cascaded mode showing two digits</li> </ul> <p>Data Visibility:</p> <ul> <li>Current BCD value (4 bits)</li> <li>Decimal digit displayed</li> <li>Next value preview</li> <li>Rollover indication when hitting 9</li> <li>Count cycle position (0-9)</li> </ul> <p>Visual Style:</p> <ul> <li>Classic 7-segment display appearance</li> <li>BCD bits as LED-style indicators</li> <li>Rollover animation when 9\u21920</li> <li>Clear visual grouping of bits and display</li> <li>Color coding for active segments</li> </ul> <p>Implementation: p5.js with decade counter and 7-segment rendering</p>"},{"location":"chapters/11-registers-counters-datapath/#ring-counter","title":"Ring Counter","text":"<p>A Ring Counter is a shift register with its output connected back to its input, forming a circular pattern. Only one bit is set to 1 at any time, and this 1 \"rotates\" around the register.</p> <p>An 8-bit ring counter sequence:</p> Clock Q\u2087 Q\u2086 Q\u2085 Q\u2084 Q\u2083 Q\u2082 Q\u2081 Q\u2080 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 2 0 0 0 0 0 1 0 0 3 0 0 0 0 1 0 0 0 4 0 0 0 1 0 0 0 0 5 0 0 1 0 0 0 0 0 6 0 1 0 0 0 0 0 0 7 1 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 1 <p>Ring counter characteristics:</p> <ul> <li>N flip-flops for N states: Inefficient use of hardware</li> <li>One-hot encoding: Each state has exactly one bit set</li> <li>Simple decoding: State = which output is 1</li> <li>Needs initialization: Must set one bit to 1 at startup</li> </ul> <p>Ring counters are used for:</p> <ul> <li>Stepper motor control: Activate one phase at a time</li> <li>Round-robin arbitration: Give each requestor a turn</li> <li>Timing generators: Create sequential timing pulses</li> </ul>"},{"location":"chapters/11-registers-counters-datapath/#johnson-counter","title":"Johnson Counter","text":"<p>A Johnson Counter (also called a twisted ring counter or M\u00f6bius counter) is a ring counter with the complement of the last bit fed back to the first bit. This doubles the number of states compared to a ring counter.</p> <p>An 4-bit Johnson counter sequence:</p> Clock Q\u2083 Q\u2082 Q\u2081 Q\u2080 0 0 0 0 0 1 1 0 0 0 2 1 1 0 0 3 1 1 1 0 4 1 1 1 1 5 0 1 1 1 6 0 0 1 1 7 0 0 0 1 8 0 0 0 0 <p>Johnson counter characteristics:</p> <ul> <li>N flip-flops give 2N states: Better than ring counter</li> <li>Adjacent states differ by one bit: Gray-code-like</li> <li>Unused states: N-bit Johnson uses 2N of 2^N possible states</li> <li>Simple feedback: Just invert the last output</li> </ul> <p>The 2N states cycle through a pattern where 1s \"fill in\" from left to right, then 0s \"fill in\" the same way.</p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-ring-vs-johnson-counter-comparison","title":"Diagram: Ring vs Johnson Counter Comparison","text":"Ring vs Johnson Counter Comparison <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare ring and Johnson counters, explaining the difference in feedback mechanism, state sequences, and the number of states each provides for a given number of flip-flops.</p> <p>Instructional Rationale: Side-by-side visualization of both counter types with the same number of flip-flops highlights the key differences in feedback and state utilization.</p> <p>Canvas Layout:</p> <ul> <li>Left: 4-bit ring counter with state sequence</li> <li>Right: 4-bit Johnson counter with state sequence</li> <li>Bottom: Shared clock control</li> <li>Center: State count comparison</li> </ul> <p>Interactive Elements:</p> <ul> <li>Synchronized or independent clock stepping</li> <li>Clear/Reset to initial state</li> <li>Visual highlighting of feedback connection</li> <li>State sequence display (table or circular)</li> <li>Unused state indicator for Johnson</li> <li>Animation of bit flow</li> </ul> <p>Data Visibility:</p> <ul> <li>Current state of both counters</li> <li>Feedback bit (normal vs inverted)</li> <li>Number of valid states (4 vs 8)</li> <li>State position in cycle</li> <li>State sequence history</li> </ul> <p>Visual Style:</p> <ul> <li>Registers shown as connected flip-flops</li> <li>Feedback path prominently shown</li> <li>Inverter visible in Johnson counter path</li> <li>Current state highlighted</li> <li>State sequence as circular diagram</li> </ul> <p>Implementation: p5.js with both counter simulations side by side</p>"},{"location":"chapters/11-registers-counters-datapath/#register-files-organized-storage","title":"Register Files: Organized Storage","text":"<p>A Register File is a collection of registers organized as an addressable array. Instead of accessing registers individually by name, you specify a register number (address), and the register file provides access to that register's data.</p> <p>Register files are essential components in CPUs, where they hold operands for ALU operations. A typical instruction like \"ADD R1, R2, R3\" means \"add the contents of register 2 and register 3, store in register 1.\"</p> <p>Register file structure:</p> <pre><code>         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nWrite    \u2502                                 \u2502\nData \u2500\u2500\u2500\u2500\u2524 Register 0 (R0)                 \u2502\n         \u2502 Register 1 (R1)                 \u2502\nRead     \u2502 Register 2 (R2)                 \u251c\u2500\u2500\u2500\u2500 Read Data A\nAddr A \u2500\u2500\u2524 Register 3 (R3)                 \u2502\n         \u2502 ...                             \u251c\u2500\u2500\u2500\u2500 Read Data B\nRead     \u2502 Register N-1                    \u2502\nAddr B \u2500\u2500\u2524                                 \u2502\n         \u2502                                 \u2502\nWrite \u2500\u2500\u2500\u2524 WE (Write Enable)               \u2502\nAddr \u2500\u2500\u2500\u2500\u2524                                 \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key features:</p> <ul> <li>Multiple read ports: Often 2 reads per cycle for two operands</li> <li>One write port: Typically one register written per cycle</li> <li>Address decoding: Select which register to access</li> <li>Write enable: Control when writes actually happen</li> </ul> <p>A register file with 8 registers of 4 bits each:</p> Parameter Value Number of registers 8 Bits per register 4 Address width 3 bits (log\u20828) Read ports 2 Write ports 1 <p>The address decoder selects which register to read or write:</p> Address Register 000 R0 001 R1 010 R2 ... ... 111 R7"},{"location":"chapters/11-registers-counters-datapath/#diagram-register-file","title":"Diagram: Register File","text":"Register File Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use a register file by reading from two addresses simultaneously and writing to a third, understanding how the address lines select which register is accessed.</p> <p>Instructional Rationale: Interactive read/write operations with visible address decoding builds understanding of how register files work in processor datapaths.</p> <p>Canvas Layout:</p> <ul> <li>Center: Array of 8 registers showing contents</li> <li>Left: Read port A controls (address, output)</li> <li>Right: Read port B controls (address, output)</li> <li>Bottom: Write port controls (address, data, enable)</li> <li>Top: Clock and operation status</li> </ul> <p>Interactive Elements:</p> <ul> <li>Read address A selector (0-7)</li> <li>Read address B selector (0-7)</li> <li>Write address selector (0-7)</li> <li>Write data input</li> <li>Write enable toggle</li> <li>Clock step button</li> <li>Read outputs displayed immediately</li> <li>Write happens on clock edge</li> </ul> <p>Data Visibility:</p> <ul> <li>All register contents visible</li> <li>Selected registers highlighted</li> <li>Read values shown at ports</li> <li>Pending write indication</li> <li>Register address labels</li> </ul> <p>Visual Style:</p> <ul> <li>Registers as row of labeled boxes</li> <li>Address selection as highlighting</li> <li>Read paths shown as lines from register to output</li> <li>Write path shown with data flowing to register</li> <li>Decoder represented visually</li> </ul> <p>Implementation: p5.js with 8x4 register file simulation</p>"},{"location":"chapters/11-registers-counters-datapath/#the-datapath-where-computation-happens","title":"The Datapath: Where Computation Happens","text":"<p>Now we arrive at the grand synthesis: the Datapath. The datapath is the part of a digital system that performs data processing operations\u2014arithmetic, logic, shifting, and data movement. It's the \"doing\" part of the processor.</p>"},{"location":"chapters/11-registers-counters-datapath/#datapath-concept","title":"Datapath Concept","text":"<p>A Datapath consists of:</p> <ul> <li>Registers: Store operands and results</li> <li>Functional units: ALUs, shifters, multipliers that transform data</li> <li>Interconnects: Buses and multiplexers that route data between components</li> <li>Control points: Signals that select operations and data paths</li> </ul> <p>The datapath is directed by the Control Unit, which provides the signals telling the datapath what to do each clock cycle.</p> <pre><code>             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2502                 DATAPATH                      \u2502\n             \u2502                                               \u2502\n             \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n             \u2502  \u2502Register\u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502     \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502Register\u2502     \u2502\nControl \u2500\u2500\u2500\u2500\u25b6\u2502  \u2502 File   \u2502      \u2502 ALU \u2502      \u2502  (Dest)\u2502     \u2502\nSignals      \u2502  \u2502        \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502     \u2502      \u2502        \u2502     \u2502\n             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n             \u2502       \u25b2             \u25b2              \u2502          \u2502\n             \u2502       \u2502             \u2502              \u2502          \u2502\n             \u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n             \u2502              Result Feedback                  \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>A simple datapath for executing R-type ALU instructions:</p> <ol> <li>Read two operands from register file</li> <li>Pass operands through ALU</li> <li>Write result back to register file</li> </ol> <p>All controlled by signals that specify which registers to read, what ALU operation to perform, and where to write the result.</p>"},{"location":"chapters/11-registers-counters-datapath/#control-unit","title":"Control Unit","text":"<p>The Control Unit is the FSM that orchestrates the datapath. It generates the control signals that tell each datapath component what to do.</p> <p>Control unit responsibilities:</p> <ul> <li>Decode instructions: Interpret what operation is requested</li> <li>Sequence operations: Multi-cycle operations require multiple steps</li> <li>Generate control signals: Enable registers, select MUX inputs, specify ALU operation</li> <li>Handle special cases: Branches, exceptions, stalls</li> </ul> <p>The control unit is typically implemented as a finite state machine (as we learned in Chapter 9) or as a lookup table that maps instruction opcodes to control signals.</p> <p>A simple control signal table:</p> Instruction RegWrite ALUOp MemRead MemWrite ADD 1 ADD 0 0 SUB 1 SUB 0 0 LOAD 1 ADD 1 0 STORE 0 ADD 0 1 <p>Each row defines the control signals for one instruction type.</p> <p>Hardwired vs Microprogrammed Control</p> <p>Control units come in two flavors:</p> <ul> <li>Hardwired: Control logic is combinational logic\u2014fast but inflexible</li> <li>Microprogrammed: Control signals stored in a ROM\u2014slower but easily modified</li> </ul> <p>Modern RISC processors use hardwired control. Complex CISC processors often use microprogrammed control for their complex instructions.</p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-datapath-with-control-unit","title":"Diagram: Datapath with Control Unit","text":"Datapath with Control Unit Visualization <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine how the control unit generates signals that direct data flow through the datapath, tracing the execution of simple operations through registers and functional units.</p> <p>Instructional Rationale: Animated visualization of data movement through the datapath with highlighted control signals shows the connection between control and data operations.</p> <p>Canvas Layout:</p> <ul> <li>Center: Simplified datapath (register file, ALU, multiplexers)</li> <li>Top: Instruction input and decode</li> <li>Right: Control signal panel showing active signals</li> <li>Bottom: Clock control and execution trace</li> </ul> <p>Interactive Elements:</p> <ul> <li>Instruction selector (ADD, SUB, AND, OR, LOAD, STORE)</li> <li>Register file contents display</li> <li>Step through execution</li> <li>Control signals highlighted as they activate</li> <li>Data path highlighting showing active routes</li> <li>Result displayed after execution</li> <li>Multi-cycle instruction stepping</li> </ul> <p>Data Visibility:</p> <ul> <li>Current instruction being executed</li> <li>Active control signals (color-coded)</li> <li>Data values on buses</li> <li>Register contents before and after</li> <li>ALU operation and result</li> <li>Memory address and data (for LOAD/STORE)</li> </ul> <p>Visual Style:</p> <ul> <li>Block diagram style datapath</li> <li>Control signals as labeled lines with active/inactive coloring</li> <li>Data buses showing current values</li> <li>Active paths highlighted</li> <li>Control unit as separate FSM block</li> <li>Animation of data movement</li> </ul> <p>Implementation: p5.js with simplified MIPS-style datapath simulation</p>"},{"location":"chapters/11-registers-counters-datapath/#register-transfer-level-rtl","title":"Register Transfer Level (RTL)","text":""},{"location":"chapters/11-registers-counters-datapath/#what-is-rtl","title":"What is RTL?","text":"<p>Register Transfer Level (RTL) is an abstraction that describes digital circuits in terms of:</p> <ul> <li>Registers: Storage elements that hold data</li> <li>Transfers: Movement of data between registers</li> <li>Operations: Transformations applied during transfer</li> </ul> <p>RTL is the primary abstraction used in hardware description languages like Verilog and VHDL. When you write synthesizable Verilog, you're writing at the RTL level.</p> <p>RTL abstracts away:</p> <ul> <li>Specific gate implementations</li> <li>Transistor-level details</li> <li>Physical placement and routing</li> </ul> <p>RTL specifies:</p> <ul> <li>What registers exist</li> <li>When data transfers occur</li> <li>What operations are performed</li> </ul> <p>Example RTL operations:</p> RTL Expression Meaning R1 \u2190 R2 Copy contents of R2 to R1 R1 \u2190 R2 + R3 Add R2 and R3, store in R1 R1 \u2190 R1 &lt;&lt; 1 Shift R1 left by 1 bit R1 \u2190 M[R2] Load memory at address R2 into R1"},{"location":"chapters/11-registers-counters-datapath/#rtl-notation","title":"RTL Notation","text":"<p>RTL Notation provides a standardized way to express register transfers:</p> <ul> <li>Register names: R0, R1, ACC, PC, MAR, etc.</li> <li>Transfer operator: \u2190 (arrow pointing to destination)</li> <li>Conditional transfers: condition: R1 \u2190 R2</li> <li>Parallel transfers: Separate with commas</li> <li>Timing: Transfers in one line happen simultaneously</li> </ul> <p>Basic RTL notation examples:</p> <p>Unconditional transfer: <pre><code>R1 \u2190 R2\n</code></pre> Copy R2's contents to R1 on the next clock edge.</p> <p>Conditional transfer: <pre><code>Load: R1 \u2190 M[MAR]\n</code></pre> If Load signal is active, load memory contents at address MAR into R1.</p> <p>Transfer with operation: <pre><code>R1 \u2190 R1 + R2\n</code></pre> Add R1 and R2, store result in R1.</p> <p>Parallel transfers: <pre><code>R1 \u2190 R2, R2 \u2190 R1\n</code></pre> Swap R1 and R2 (both transfers happen simultaneously on the same clock edge).</p> <p>Compound operations: <pre><code>T1: MAR \u2190 PC\nT2: MBR \u2190 M[MAR], PC \u2190 PC + 1\nT3: IR \u2190 MBR\n</code></pre> Three-step instruction fetch sequence, one step per clock cycle.</p> <p>RTL vs Verilog</p> <p>RTL notation is more abstract than Verilog. RTL says \"what\" without saying \"how.\" Verilog is RTL notation with syntax strict enough that tools can synthesize hardware from it.</p> <p>RTL: <code>R1 \u2190 R2 + R3</code> Verilog: <code>always @(posedge clk) R1 &lt;= R2 + R3;</code></p>"},{"location":"chapters/11-registers-counters-datapath/#diagram-rtl-operations-visualizer","title":"Diagram: RTL Operations Visualizer","text":"RTL Operations Interactive <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Execute</p> <p>Learning Objective: Students will be able to execute RTL operations step by step, predicting register contents after each transfer and understanding the difference between sequential and parallel transfers.</p> <p>Instructional Rationale: Step-through execution of RTL statements with visible register state changes makes the abstract notation concrete.</p> <p>Canvas Layout:</p> <ul> <li>Left: RTL statement sequence</li> <li>Center: Register bank showing current values</li> <li>Right: Transfer animation area</li> <li>Bottom: Clock control and execution trace</li> </ul> <p>Interactive Elements:</p> <ul> <li>Select from predefined RTL sequences</li> <li>Step through transfers one at a time</li> <li>Highlight source and destination registers</li> <li>Show data flow animation</li> <li>Parallel transfer indicator</li> <li>Reset registers</li> <li>Edit register initial values</li> </ul> <p>Data Visibility:</p> <ul> <li>Current RTL statement highlighted</li> <li>Source register(s) and values</li> <li>Operation being performed</li> <li>Destination register</li> <li>Before/after register values</li> <li>Transfer type (conditional, parallel, etc.)</li> </ul> <p>Visual Style:</p> <ul> <li>Registers as labeled boxes with values</li> <li>Data flow as animated arrows</li> <li>Source highlighted in blue</li> <li>Destination highlighted in green</li> <li>Operation symbol shown on path</li> <li>Parallel transfers shown simultaneously</li> </ul> <p>Implementation: p5.js with RTL interpreter and register visualization</p>"},{"location":"chapters/11-registers-counters-datapath/#rtl-design-flow","title":"RTL Design Flow","text":"<p>RTL is the starting point for hardware implementation:</p> <ol> <li>Specification: Define required behavior in words</li> <li>RTL description: Express as register transfers</li> <li>HDL coding: Translate RTL to Verilog/VHDL</li> <li>Synthesis: Convert HDL to gate-level netlist</li> <li>Implementation: Map to FPGA or fabricate as ASIC</li> </ol> <p>This flow allows designers to think at a higher level of abstraction while still producing actual hardware.</p>"},{"location":"chapters/11-registers-counters-datapath/#putting-it-all-together-a-simple-cpu-datapath","title":"Putting It All Together: A Simple CPU Datapath","text":"<p>Let's see how registers, counters, and datapath concepts combine in a simple CPU:</p> <p>Components:</p> <ul> <li>PC (Program Counter): Register that holds the address of the next instruction</li> <li>IR (Instruction Register): Register that holds the current instruction</li> <li>Register File: Holds operands and results</li> <li>ALU: Performs arithmetic and logic operations</li> <li>Control Unit: FSM that sequences operations</li> </ul> <p>Simplified fetch-execute cycle in RTL:</p> <pre><code>// Fetch\nT0: MAR \u2190 PC\nT1: IR \u2190 M[MAR], PC \u2190 PC + 1\n\n// Decode (combinational, control unit interprets IR)\n\n// Execute (example: ADD R1, R2, R3)\nT2: A \u2190 R[IR.rs1], B \u2190 R[IR.rs2]\nT3: R[IR.rd] \u2190 A + B\n</code></pre> <p>This simple sequence shows:</p> <ul> <li>Register transfers: PC to MAR, memory to IR</li> <li>Counter increment: PC \u2190 PC + 1</li> <li>Parallel operations: Fetch and increment happen together</li> <li>Datapath routing: Register file to ALU to register file</li> </ul> <p>The control unit is an FSM that cycles through T0, T1, T2, T3 states, generating the appropriate control signals at each step.</p>"},{"location":"chapters/11-registers-counters-datapath/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've now mastered the building blocks that turn flip-flops into functional computer components. Let's review what you've learned:</p> <p>Registers:</p> <ul> <li>Groups of flip-flops storing multi-bit words</li> <li>Control signals: Enable, Load, Clear</li> <li>Parallel load for simultaneous data capture</li> </ul> <p>Shift Registers:</p> <ul> <li>SISO, SIPO, PISO, PIPO configurations</li> <li>Serial-to-parallel and parallel-to-serial conversion</li> <li>Bidirectional shift for left/right movement</li> <li>Universal shift register does it all</li> </ul> <p>Counters:</p> <ul> <li>Up, down, and up-down counting</li> <li>Binary counters for standard sequences</li> <li>Mod-N counters for custom modulus</li> <li>BCD/decade counters for decimal display</li> <li>Ring and Johnson counters for special sequences</li> <li>Overflow/terminal count detection</li> </ul> <p>Datapath:</p> <ul> <li>Registers + functional units + interconnects</li> <li>Controlled by the control unit FSM</li> <li>RTL describes register-to-register operations</li> </ul> <p>Register File:</p> <ul> <li>Addressable array of registers</li> <li>Multiple read ports, typically one write port</li> <li>Foundation of processor register storage</li> </ul> <p>RTL Abstraction:</p> <ul> <li>Describes circuits as register transfers</li> <li>Foundation for HDL coding and synthesis</li> <li>Bridges behavior and implementation</li> </ul> <p>The Big Picture</p> <p>You now understand how simple flip-flops combine into registers that store data, counters that track sequences, and datapaths that process information. These are the building blocks inside every CPU, GPU, and digital system. When you hear \"the processor fetched the instruction and incremented the program counter,\" you know exactly what's happening at the register transfer level!</p> Graphic Novel Suggestion <p>An engaging graphic novel could follow the journey of a single byte of data as it travels through a computer system\u2014from keyboard press to register to memory and back. The narrative could personify the registers as patient librarians, the counters as diligent timekeepers, and the control unit as the orchestra conductor coordinating everything. Key historical figures like Maurice Wilkes (who pioneered microprogramming) and John von Neumann (whose architecture defined the stored-program computer) could appear as mentors explaining why these abstractions matter. The climax could show the first successful execution of a simple program, with all the datapath components working in harmony.</p>"},{"location":"chapters/11-registers-counters-datapath/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Shift Register Type <p>A communication receiver needs to accept data one bit at a time from a serial line, then process all 8 bits at once when a complete byte has arrived. Which type of shift register should be used?</p> <p>Solution: This requires a Serial In Parallel Out (SIPO) shift register. Data enters serially (one bit per clock), and after 8 clock cycles, all 8 bits are available at the parallel outputs for processing.</p> Problem 2: Counter Modulus <p>Design a counter that counts 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, ... (mod-6). How many flip-flops are needed, and what value triggers the reset?</p> <p>Solution: A mod-6 counter needs 3 flip-flops (since \\(2^2 = 4 &lt; 6 \\leq 8 = 2^3\\)).</p> <p>The counter counts 000 \u2192 001 \u2192 010 \u2192 011 \u2192 100 \u2192 101 \u2192 000...</p> <p>Reset is triggered when the count reaches 110 (6 in binary):</p> \\[RESET = Q_2 \\cdot Q_1 \\cdot \\overline{Q_0}\\] <p>Wait\u2014that's 110 which is 6. But we want to reset before displaying 6. Using synchronous design, when the count is 101 (5), the next state should be 000 instead of 110.</p> Problem 3: Ring vs Johnson States <p>Compare the number of states in a 5-bit ring counter versus a 5-bit Johnson counter.</p> <p>Solution: - 5-bit Ring Counter: 5 states (the single 1 rotates through 5 positions) - 5-bit Johnson Counter: 10 states (2N = 2 \u00d7 5)</p> <p>The Johnson counter gets twice as many states from the same hardware because it fills with 1s then fills with 0s, creating 2N distinct patterns.</p> Problem 4: RTL Expression <p>Write the RTL expression for swapping the contents of registers R1 and R2 without using a temporary register.</p> <p>Solution: <pre><code>R1 \u2190 R2, R2 \u2190 R1\n</code></pre></p> <p>In RTL, transfers listed on the same line (separated by commas) happen simultaneously on the same clock edge. Both R1 and R2 are read before either is written, enabling the swap without a temporary.</p> Problem 5: Universal Shift Register Mode <p>A 4-bit universal shift register contains 1010. The mode is set to \"shift left\" and the left serial input is 1. What is the register contents after one clock cycle?</p> <p>Solution: Shift left: Each bit moves to a higher position, and the serial input enters at the LSB.</p> <p>Before: 1010 After: 0101 (the leftmost 1 shifts out, new 1 enters from right)</p> <p>Wait, let me reconsider. Shift left means: - Q3 \u2190 Q2 (1 \u2190 0) - Q2 \u2190 Q1 (0 \u2190 1) - Q1 \u2190 Q0 (1 \u2190 0) - Q0 \u2190 Serial_Left (0 \u2190 1)</p> <p>Result: 0101</p> Problem 6: Register File Access <p>A register file has 16 registers and 2 read ports. How many address bits are needed for each read port? If a processor instruction specifies two source registers and one destination register, how many register address bits are in the instruction format?</p> <p>Solution: - Each port needs \\(\\log_2 16 = 4\\) address bits - Total register address bits in instruction: 4 + 4 + 4 = 12 bits (2 source addresses + 1 destination address)</p> <p>This is why RISC processors with 32 registers need 5-bit register fields, and instructions that specify 3 registers use 15 bits just for register addressing!</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/","title":"Quiz: Registers, Counters, and Datapath","text":"<p>Test your understanding of registers, shift registers, counters, and datapath concepts.</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#1-what-is-the-purpose-of-the-enable-signal-on-a-register","title":"1. What is the purpose of the enable signal on a register?","text":"<ol> <li>To increase the register's storage capacity</li> <li>To control whether the register responds to clock edges</li> <li>To reset the register to zero</li> <li>To select between multiple input sources</li> </ol> Show Answer <p>The correct answer is B. The enable signal controls whether the register responds to clock edges. When enable is inactive, the register ignores clock edges and retains its current value, allowing selective updates.</p> <p>Concept Tested: Enable Signal</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#2-which-shift-register-type-accepts-data-serially-and-provides-all-bits-as-parallel-outputs","title":"2. Which shift register type accepts data serially and provides all bits as parallel outputs?","text":"<ol> <li>SISO (Serial In Serial Out)</li> <li>SIPO (Serial In Parallel Out)</li> <li>PISO (Parallel In Serial Out)</li> <li>PIPO (Parallel In Parallel Out)</li> </ol> Show Answer <p>The correct answer is B. A Serial In Parallel Out (SIPO) shift register accepts data one bit at a time but provides access to all stored bits simultaneously as outputs. It's essential for serial-to-parallel conversion in communication interfaces.</p> <p>Concept Tested: Serial In Parallel Out</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#3-what-makes-a-universal-shift-register-universal","title":"3. What makes a universal shift register \"universal\"?","text":"<ol> <li>It works with any clock frequency</li> <li>It can hold, shift left, shift right, or parallel load</li> <li>It automatically adapts to any data width</li> <li>It works without a clock signal</li> </ol> Show Answer <p>The correct answer is B. A universal shift register combines all shift register capabilities\u2014hold (no change), shift left, shift right, and parallel load\u2014controlled by mode select inputs. This versatility makes it useful for many datapath operations.</p> <p>Concept Tested: Universal Shift Register</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#4-what-is-counter-overflow","title":"4. What is counter overflow?","text":"<ol> <li>When the counter uses too much power</li> <li>When the counter reaches its maximum and wraps to zero (or vice versa)</li> <li>When two counters are connected together</li> <li>When the counter runs too fast</li> </ol> Show Answer <p>The correct answer is B. Counter overflow occurs when an up-counter reaches its maximum value (all 1s) and wraps around to zero, or when a down-counter reaches zero and wraps to its maximum. Terminal count signals detect this condition.</p> <p>Concept Tested: Counter Overflow</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#5-a-mod-12-counter-counts-through-how-many-unique-states","title":"5. A mod-12 counter counts through how many unique states?","text":"<ol> <li>11 states (0 to 10)</li> <li>12 states (0 to 11)</li> <li>13 states (0 to 12)</li> <li>16 states (0 to 15)</li> </ol> Show Answer <p>The correct answer is B. A mod-N counter counts through exactly N unique states. A mod-12 counter cycles through states 0, 1, 2, ... 11, then resets to 0\u2014a total of 12 distinct states.</p> <p>Concept Tested: Mod-N Counter</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#6-how-many-states-does-a-4-bit-ring-counter-have","title":"6. How many states does a 4-bit ring counter have?","text":"<ol> <li>4 states</li> <li>8 states</li> <li>16 states</li> <li>2 states</li> </ol> Show Answer <p>The correct answer is A. A ring counter has N states for N flip-flops. Only one bit is set to 1 at any time, and this 1 rotates around the register. A 4-bit ring counter has 4 states (one-hot encoding).</p> <p>Concept Tested: Ring Counter</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#7-what-advantage-does-a-johnson-counter-have-over-a-ring-counter-with-the-same-number-of-flip-flops","title":"7. What advantage does a Johnson counter have over a ring counter with the same number of flip-flops?","text":"<ol> <li>It runs at twice the speed</li> <li>It provides twice as many states (2N states from N flip-flops)</li> <li>It uses less power</li> <li>It requires no initialization</li> </ol> Show Answer <p>The correct answer is B. A Johnson counter (twisted ring counter) provides 2N states from N flip-flops, compared to N states for a standard ring counter. The inverted feedback doubles the state count while maintaining simple decoding.</p> <p>Concept Tested: Johnson Counter</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#8-what-does-a-register-file-provide-that-individual-registers-do-not","title":"8. What does a register file provide that individual registers do not?","text":"<ol> <li>Higher storage capacity per bit</li> <li>Addressable access to multiple registers through port addresses</li> <li>Faster clock speeds</li> <li>Built-in arithmetic operations</li> </ol> Show Answer <p>The correct answer is B. A register file organizes multiple registers as an addressable array. By specifying a register address, you can read from or write to a specific register, essential for processor datapaths where instructions specify register numbers.</p> <p>Concept Tested: Register File</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#9-what-does-rtl-notation-r1-r2-r3-describe","title":"9. What does RTL notation R1 \u2190 R2 + R3 describe?","text":"<ol> <li>Three registers are connected in series</li> <li>Add contents of R2 and R3, store result in R1</li> <li>Move data from R1 to R2 to R3</li> <li>Compare R2 and R3, set flag in R1</li> </ol> Show Answer <p>The correct answer is B. RTL (Register Transfer Level) notation uses the arrow (\u2190) to show the destination on the left receiving the result of the operation on the right. R1 \u2190 R2 + R3 means add R2 and R3, store in R1 on the next clock edge.</p> <p>Concept Tested: RTL Notation</p>"},{"location":"chapters/11-registers-counters-datapath/quiz/#10-what-is-the-relationship-between-the-control-unit-and-the-datapath","title":"10. What is the relationship between the control unit and the datapath?","text":"<ol> <li>They are the same component</li> <li>The control unit generates signals that direct datapath operations</li> <li>The datapath controls when the control unit updates</li> <li>They operate completely independently</li> </ol> Show Answer <p>The correct answer is B. The control unit is an FSM that orchestrates the datapath by generating control signals. These signals tell the datapath components what to do each clock cycle\u2014which registers to read, what ALU operation to perform, where to write results.</p> <p>Concept Tested: Control Unit</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/","title":"Verilog HDL Fundamentals","text":""},{"location":"chapters/12-verilog-hdl-fundamentals/#summary","title":"Summary","text":"<p>This chapter introduces Verilog as a hardware description language, emphasizing that HDLs describe hardware behavior rather than software execution. Students will learn the fundamental distinction between HDL and programming languages, Verilog module structure and syntax, port declarations (input, output, inout), data types including wire and reg, parameters for configurable designs, continuous assignments using the assign statement, initial blocks for simulation, and module instantiation for building hierarchical designs. These fundamentals prepare students for behavioral and structural modeling.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>Verilog HDL</li> <li>HDL vs Programming</li> <li>Module Definition</li> <li>Port Declaration</li> <li>Input Port</li> <li>Output Port</li> <li>Inout Port</li> <li>Wire Data Type</li> <li>Reg Data Type</li> <li>Parameter</li> <li>Assign Statement</li> <li>Continuous Assignment</li> <li>Initial Block</li> <li>Module Instantiation</li> </ol>"},{"location":"chapters/12-verilog-hdl-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> <li>Chapter 7: Introduction to Sequential Logic</li> <li>Chapter 11: Registers, Counters, and Datapath</li> </ul>"},{"location":"chapters/12-verilog-hdl-fundamentals/#introduction-speaking-hardwares-native-language","title":"Introduction: Speaking Hardware's Native Language","text":"<p>Welcome to the chapter where you stop drawing circuits and start writing them. If the previous chapters were about understanding the grammar of digital logic\u2014gates, flip-flops, state machines\u2014this chapter is where you learn to compose entire sentences, paragraphs, and essays in the language that hardware actually understands.</p> <p>Think of it this way: you've learned how to think about digital circuits, but professionals don't draw thousands of gates by hand. They describe what they want in a Hardware Description Language (HDL), and then sophisticated tools translate those descriptions into actual silicon or FPGA configurations. It's like having a magical translator who can turn your written wishes into real, functioning circuits.</p> <p>Verilog is one of the two dominant HDLs in the industry (the other being VHDL). It was created at Gateway Design Automation in 1984, became an IEEE standard in 1995, and has been the lingua franca of chip design ever since. Every processor in your laptop, every graphics card, every smartphone chip\u2014chances are, Verilog was involved in its creation.</p> <p>Here's the beautiful irony: Verilog looks like a programming language, feels like a programming language, and will trick you into thinking it is a programming language. But it's not. It's something far more interesting. By the end of this chapter, you'll understand why that distinction matters\u2014and why mastering it gives you a superpower that software-only developers simply don't have.</p> <p>Ready to write some hardware? Let's begin.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#what-is-verilog-hdl","title":"What Is Verilog HDL?","text":"<p>Verilog HDL (Hardware Description Language) is a textual language for describing digital circuits. It allows designers to specify the structure and behavior of electronic systems in a way that can be simulated, synthesized into actual hardware, or both.</p> <p>The key word here is description. Verilog describes hardware\u2014it tells the synthesis tools what circuits you want to exist. It's more like an architectural blueprint than a cooking recipe. A recipe says \"do this, then do that.\" A blueprint says \"there should be a wall here, a door there, and they should connect like this.\"</p> <p>Verilog was created with several goals in mind:</p> <ul> <li>Simulation: Test your design before building it</li> <li>Synthesis: Automatically generate gate-level circuits from behavioral descriptions</li> <li>Documentation: Provide a precise, unambiguous specification of circuit behavior</li> <li>Reuse: Build libraries of components that can be instantiated in multiple designs</li> </ul> <p>A simple Verilog module looks like this:</p> <pre><code>module and_gate(\n    input  a,\n    input  b,\n    output y\n);\n    assign y = a &amp; b;\nendmodule\n</code></pre> <p>This describes an AND gate. The <code>module</code> defines a component named <code>and_gate</code> with two inputs (<code>a</code> and <code>b</code>) and one output (<code>y</code>). The <code>assign</code> statement says that <code>y</code> should always equal <code>a AND b</code>. That's it\u2014a complete, synthesizable hardware description.</p> <p>Verilog Is Not Just Code\u2014It's a Circuit Specification</p> <p>When you write Verilog, you're not telling a computer what steps to execute. You're telling a synthesis tool what wires and gates to create. Every line of Verilog corresponds to actual hardware that will exist physically (or in an FPGA's configuration).</p> <p>The name \"Verilog\" comes from \"Verification Logic\"\u2014it was originally created for simulation and verification before synthesis became practical. Today, we use it for both.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#hdl-vs-programming-the-fundamental-divide","title":"HDL vs Programming: The Fundamental Divide","text":"<p>Understanding the difference between HDL and Programming is perhaps the most important conceptual leap in this chapter. Get this right, and everything else falls into place. Get it wrong, and you'll spend hours debugging \"code\" that doesn't work because it was never code in the first place.</p> <p>Software programming (C, Python, Java) describes a sequence of operations that a processor executes one at a time. The statements have an order\u2014first this, then that. Variables are memory locations that change over time as the program runs.</p> <p>Hardware description (Verilog, VHDL) describes a structure of interconnected components that all exist simultaneously. Everything happens at once. There's no \"first this, then that\"\u2014there's only \"this exists, and that exists, and they're connected.\"</p> <p>Let's see the difference with a concrete example:</p> <p>Software (Python): <pre><code>x = a + b\ny = x + c\nz = y + d\n</code></pre></p> <p>This executes sequentially. First calculate <code>x</code>, then use <code>x</code> to calculate <code>y</code>, then use <code>y</code> to calculate <code>z</code>. If you swap the lines, the program breaks.</p> <p>Hardware (Verilog): <pre><code>assign x = a + b;\nassign y = x + c;\nassign z = y + d;\n</code></pre></p> <p>These three lines describe three adders that exist simultaneously. The order of the lines doesn't matter\u2014they could be reversed, and the same hardware would be generated. All three additions happen at the same time, every nanosecond, forever.</p> <p>Here's a table highlighting the key differences:</p> Aspect Software Programming Hardware Description Execution model Sequential (one thing at a time) Concurrent (everything at once) Statements describe Steps to perform Structure that exists Variables represent Memory locations Wires or registers Order matters? Yes, critically Not for concurrent statements Time concept Implicit (program counter) Explicit (clock edges, delays) Resource usage Bounded by memory Bounded by chip area <p>The Most Common Mistake</p> <p>New Verilog programmers often write sequential-looking code and expect it to execute like software. For example, they write <code>x = a; x = b;</code> and expect <code>x</code> to become <code>a</code> first, then <code>b</code>. In synthesizable Verilog, this often results in only the last assignment being active\u2014because both \"happen at once,\" and only one can drive a wire.</p> <p>Think of it like this: software is a movie (a sequence of frames shown one after another), while hardware is a photograph (everything captured simultaneously). You can pause a movie at any moment. A photograph has no \"moments\"\u2014it's all there, all at once.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#diagram-hdl-vs-programming-mental-model","title":"Diagram: HDL vs Programming Mental Model","text":"HDL vs Programming Mental Model <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Contrast</p> <p>Learning Objective: Students will be able to contrast the execution model of software (sequential) with the description model of HDL (concurrent), understanding why statement order matters in one but not the other.</p> <p>Instructional Rationale: Side-by-side visualization showing software executing step-by-step while hardware operates continuously makes the fundamental difference viscerally clear.</p> <p>Canvas Layout:</p> <ul> <li>Left half: Software execution panel</li> <li>Right half: Hardware description panel</li> <li>Bottom: Shared input controls and comparison table</li> <li>Top: Clear labels \"Sequential Execution\" vs \"Concurrent Operation\"</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle inputs A, B, C, D with buttons</li> <li>Software side shows step-by-step execution with current line highlighted</li> <li>Hardware side shows all gates operating simultaneously</li> <li>Speed control for software animation</li> <li>Reset button</li> <li>\"Swap line order\" button to demonstrate order independence in HDL</li> </ul> <p>Data Visibility:</p> <ul> <li>Current values of all variables/wires</li> <li>Which software line is currently executing</li> <li>All hardware outputs updating in parallel</li> <li>Timing difference visualization</li> <li>Execution trace for software side</li> </ul> <p>Visual Style:</p> <ul> <li>Software panel: code listing with execution pointer</li> <li>Hardware panel: gate diagram with signal values</li> <li>Color coding: active operations highlighted</li> <li>Timing diagram at bottom showing when values change</li> <li>Clear visual for \"all at once\" vs \"one at a time\"</li> </ul> <p>Implementation: p5.js with dual simulation engines</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#module-definition-the-building-block-of-verilog","title":"Module Definition: The Building Block of Verilog","text":"<p>A Module Definition is the fundamental unit of hierarchy in Verilog. Every Verilog design is composed of modules, which can contain other modules, creating a hierarchical structure from simple gates up to complete systems.</p> <p>Think of modules like LEGO bricks. Each brick has a specific shape and function. You can combine bricks to make larger structures, and those structures can become components of even larger creations. The same AND gate module you define once can be used a thousand times throughout your design.</p> <p>The basic syntax of a module is:</p> <pre><code>module module_name(\n    // port list goes here\n);\n    // module body goes here\nendmodule\n</code></pre> <p>Every module has:</p> <ol> <li>A name: Unique identifier for this component</li> <li>A port list: The module's interface to the outside world</li> <li>A body: What the module actually does</li> <li>An <code>endmodule</code> keyword: Marks the end of the definition</li> </ol> <p>Here's a complete example\u2014a 2-to-1 multiplexer:</p> <pre><code>module mux2to1(\n    input  a,      // First data input\n    input  b,      // Second data input\n    input  sel,    // Selection signal\n    output y       // Output\n);\n    assign y = sel ? b : a;  // If sel=1, output b; else output a\nendmodule\n</code></pre> <p>Key points about modules:</p> <ul> <li>Module names should be descriptive and follow a consistent naming convention</li> <li>Comments (using <code>//</code> for single-line or <code>/* */</code> for multi-line) help document the design</li> <li>The port list defines the module's \"pins\"\u2014how it connects to the outside world</li> <li>The body defines the module's functionality</li> </ul> <p>Modules can be as simple as a single gate or as complex as an entire processor. The key is that each module encapsulates a specific function and exposes a clean interface.</p> <p>Modules Are Like Classes (Sort Of)</p> <p>If you know object-oriented programming, modules are somewhat like classes. They define a template that can be instantiated multiple times. However, unlike classes, modules don't have methods that get called\u2014they describe hardware that continuously exists and operates.</p> <p>A module can contain:</p> <ul> <li>Wire and register declarations</li> <li>Continuous assignments (<code>assign</code> statements)</li> <li>Procedural blocks (<code>always</code>, <code>initial</code>)</li> <li>Instantiations of other modules</li> <li>Parameters for configurability</li> </ul> <p>We'll explore each of these in this chapter.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#port-declaration-the-modules-interface","title":"Port Declaration: The Module's Interface","text":"<p>A Port Declaration specifies the inputs and outputs of a module\u2014its interface to the external world. Ports are like the pins on an integrated circuit chip. They're how signals get into and out of the module.</p> <p>Every port has three key properties:</p> <ol> <li>Direction: Input, output, or bidirectional (inout)</li> <li>Data type: Wire or reg (we'll cover these soon)</li> <li>Width: Single bit or multi-bit vector</li> </ol> <p>The modern Verilog syntax (ANSI-style) declares ports directly in the module header:</p> <pre><code>module adder(\n    input  [3:0] a,      // 4-bit input\n    input  [3:0] b,      // 4-bit input\n    output [4:0] sum     // 5-bit output (includes carry)\n);\n    assign sum = a + b;\nendmodule\n</code></pre> <p>The older, pre-ANSI style separates the port list from the declarations:</p> <pre><code>module adder(a, b, sum);\n    input  [3:0] a;\n    input  [3:0] b;\n    output [4:0] sum;\n\n    assign sum = a + b;\nendmodule\n</code></pre> <p>Both styles are valid, but ANSI-style is cleaner and preferred for new designs.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#diagram-port-declaration-anatomy","title":"Diagram: Port Declaration Anatomy","text":"Port Declaration Anatomy <p>Type: infographic</p> <p>Bloom Level: Remember (L1) Bloom Verb: Identify</p> <p>Learning Objective: Students will be able to identify the components of a Verilog port declaration including direction, data type, width specification, and port name.</p> <p>Instructional Rationale: Interactive diagram with hover explanations for each part of a port declaration makes syntax components memorable.</p> <p>Canvas Layout:</p> <ul> <li>Center: Enlarged code showing port declaration</li> <li>Hover zones over each component (direction, brackets, width, name)</li> <li>Right panel: Description of hovered element</li> <li>Bottom: Example variations</li> </ul> <p>Interactive Elements:</p> <ul> <li>Hover over any part of the declaration to see explanation</li> <li>Click to lock explanation in place</li> <li>Toggle between different declaration examples</li> <li>Show/hide optional components (width, data type)</li> <li>Quiz mode: identify parts by clicking</li> </ul> <p>Data Visibility:</p> <ul> <li>Full port declaration syntax</li> <li>Component breakdown (direction, type, width, name)</li> <li>Legal values for each component</li> <li>Common mistakes highlighted</li> </ul> <p>Visual Style:</p> <ul> <li>Color-coded syntax highlighting</li> <li>Smooth hover transitions</li> <li>Clean, readable font for code</li> <li>Annotation arrows pointing to elements</li> <li>Example gallery at bottom</li> </ul> <p>Implementation: p5.js with hover detection and info panels</p> <p>Multi-bit ports use vector notation with square brackets:</p> Notation Meaning <code>[7:0]</code> 8-bit vector, bit 7 is MSB, bit 0 is LSB <code>[0:7]</code> 8-bit vector, bit 0 is MSB, bit 7 is LSB <code>[3:0]</code> 4-bit vector (nibble) <code>[31:0]</code> 32-bit vector (word) <p>By convention, <code>[high:low]</code> is most common, with the higher index as the MSB.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#input-port-signals-coming-in","title":"Input Port: Signals Coming In","text":"<p>An Input Port is a port that receives signals from outside the module. The module can read from input ports but cannot drive them\u2014they are strictly for receiving data.</p> <p>Input ports are like the sensors on a robot: they observe the external world but don't change it. The signals come from somewhere else, and the module simply uses them.</p> <pre><code>module voter(\n    input a,           // Single-bit input\n    input b,           // Single-bit input\n    input c,           // Single-bit input\n    output majority    // Output: 1 if at least two inputs are 1\n);\n    assign majority = (a &amp; b) | (b &amp; c) | (a &amp; c);\nendmodule\n</code></pre> <p>Key points about input ports:</p> <ul> <li>They are implicitly of type <code>wire</code> (you can't assign to them with <code>=</code> in procedural blocks)</li> <li>They can be single-bit or multi-bit vectors</li> <li>They cannot appear on the left side of a procedural assignment</li> <li>They represent physical connections to external circuits</li> </ul> <p>In hardware terms, an input port is a wire coming into your module from somewhere else. You read the signal, but you don't control it.</p> <p>Treat Inputs as Read-Only</p> <p>If you try to assign a value to an input port inside your module, you'll get an error. Inputs are read-only. This makes sense\u2014you can't control the signal coming from outside your circuit.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#output-port-signals-going-out","title":"Output Port: Signals Going Out","text":"<p>An Output Port is a port that sends signals from inside the module to the outside world. The module drives output ports; external circuits read them.</p> <p>Output ports are like the robot's actuators: they affect the external world based on the module's internal decisions.</p> <pre><code>module comparator(\n    input  [7:0] a,\n    input  [7:0] b,\n    output       eq,    // 1 if a == b\n    output       lt,    // 1 if a &lt; b\n    output       gt     // 1 if a &gt; b\n);\n    assign eq = (a == b);\n    assign lt = (a &lt; b);\n    assign gt = (a &gt; b);\nendmodule\n</code></pre> <p>Output ports can be of type <code>wire</code> (driven by continuous assignments) or <code>reg</code> (driven by procedural blocks). In modern Verilog, you can use <code>logic</code> as a universal type, but we'll focus on wire and reg for now.</p> <p>Different ways to declare outputs:</p> <pre><code>output y;           // Implicitly wire, must use assign\noutput wire y;      // Explicitly wire, same as above\noutput reg y;       // Explicitly reg, can use in always blocks\noutput [7:0] data;  // 8-bit vector output\n</code></pre> <p>Key points about output ports:</p> <ul> <li>They are driven from inside the module</li> <li>External modules can read them but not drive them</li> <li>They represent physical connections to the outside world</li> </ul>"},{"location":"chapters/12-verilog-hdl-fundamentals/#inout-port-bidirectional-signals","title":"Inout Port: Bidirectional Signals","text":"<p>An Inout Port is a bidirectional port that can both send and receive signals. These are relatively rare and are used primarily for shared buses or specific protocols where multiple devices share a single wire.</p> <pre><code>module bus_driver(\n    input        enable,\n    input  [7:0] data_out,\n    output [7:0] data_in,\n    inout  [7:0] bus       // Bidirectional bus\n);\n    // Drive bus when enabled, else high-impedance\n    assign bus = enable ? data_out : 8'bz;\n\n    // Always read from bus\n    assign data_in = bus;\nendmodule\n</code></pre> <p>The key concept with bidirectional ports is tristate logic\u2014the ability to \"disconnect\" from a wire by outputting a high-impedance value (<code>z</code>). When a driver outputs <code>z</code>, it effectively removes itself from the bus, allowing other devices to drive it.</p> <p>Use Inout Sparingly</p> <p>Bidirectional ports are tricky to synthesize and debug. They're necessary for certain interfaces (like I2C, bidirectional data buses, or GPIO pins) but should be avoided when unidirectional alternatives exist. Most internal design uses dedicated input and output ports.</p> <p>Think of a bidirectional bus like a conversation where multiple people share one microphone. Only one person can talk at a time, and everyone else must stay quiet (high-impedance). If two people try to talk at once, chaos ensues (bus contention).</p> <p>Key properties of inout ports:</p> Property Description Direction Can be both input and output (but not simultaneously) Data type Always <code>wire</code> (must use continuous assignment) Tristate Must output <code>z</code> when not driving Contention risk Multiple drivers can cause undefined behavior"},{"location":"chapters/12-verilog-hdl-fundamentals/#wire-data-type-physical-connections","title":"Wire Data Type: Physical Connections","text":"<p>The Wire Data Type represents a physical connection between components\u2014a literal wire in your circuit. Wires don't store values; they transmit them continuously from their driver to wherever they're connected.</p> <p>Think of a wire like a pipe carrying water. The water doesn't \"stay\" in the pipe; it flows through continuously. Whatever the source produces, the wire carries to the destination\u2014instantly and continuously.</p> <pre><code>wire a;           // Single-bit wire\nwire [7:0] bus;   // 8-bit bus (collection of 8 wires)\nwire [3:0] x, y;  // Multiple wire declarations\n</code></pre> <p>Key characteristics of wires:</p> <ul> <li>Must be driven continuously: Wires need something actively driving them (a gate output, another module's output, or an assign statement)</li> <li>Cannot hold values: If nothing drives a wire, it has an undefined value (<code>x</code> in simulation)</li> <li>Multiple readers allowed: Many modules can connect to and read from a wire</li> <li>Single driver (usually): Normally, only one thing should drive a wire. Multiple drivers require special handling (tristate logic)</li> </ul> <p>Wires are assigned using <code>assign</code> statements (continuous assignment):</p> <pre><code>wire a, b, c;\nwire and_result;\nwire or_result;\n\nassign and_result = a &amp; b;    // AND gate drives this wire\nassign or_result = a | c;     // OR gate drives this wire\n</code></pre> <p>Wire = Pure Combinational</p> <p>Wires represent combinational connections. Their value changes instantaneously when their input changes. There's no memory, no delay (in functional terms), no clock involvement. If you need to remember a value, you need something else\u2014that's where <code>reg</code> comes in.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#diagram-wire-vs-reg-comparison","title":"Diagram: Wire vs Reg Comparison","text":"Wire vs Reg Interactive Comparison <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare wire and reg data types, understanding that wires carry continuous signals while reg types can hold values across clock cycles.</p> <p>Instructional Rationale: Side-by-side simulation showing how wires respond immediately to input changes while regs require clock edges to update demonstrates the fundamental behavioral difference.</p> <p>Canvas Layout:</p> <ul> <li>Left side: Wire demonstration with input/output</li> <li>Right side: Reg demonstration with clock and flip-flop</li> <li>Center: Comparison summary</li> <li>Bottom: Input controls and clock generator</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input toggle buttons affecting both sides</li> <li>Clock pulse button for reg side</li> <li>Continuous vs clocked mode toggle</li> <li>Value displays for wire and reg</li> <li>Animation showing signal propagation</li> <li>Timing diagram building over time</li> </ul> <p>Data Visibility:</p> <ul> <li>Current wire value (changes immediately with input)</li> <li>Current reg value (changes only at clock edge)</li> <li>Input values</li> <li>Clock state</li> <li>History of value changes</li> </ul> <p>Visual Style:</p> <ul> <li>Wire shown as simple connection line</li> <li>Reg shown with flip-flop symbol</li> <li>Color change on value transitions</li> <li>Timing diagram at bottom</li> <li>Clear labels distinguishing the two sides</li> </ul> <p>Implementation: p5.js with wire and reg simulation</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#reg-data-type-holding-values","title":"Reg Data Type: Holding Values","text":"<p>The Reg Data Type represents a variable that can hold a value. Despite its name, <code>reg</code> does not always synthesize to a register (flip-flop)\u2014it simply means \"a thing that can be assigned in a procedural block.\"</p> <p>This is one of Verilog's most confusing aspects for beginners, so let's be clear:</p> <ul> <li><code>reg</code> is a data type, not a hardware register</li> <li>Whether a <code>reg</code> becomes a flip-flop depends on how you use it</li> <li>A <code>reg</code> used in a combinational <code>always</code> block becomes wires</li> <li>A <code>reg</code> used in a clocked <code>always</code> block becomes a flip-flop</li> </ul> <pre><code>reg q;            // Single-bit reg\nreg [7:0] count;  // 8-bit reg\nreg [31:0] data;  // 32-bit reg\n</code></pre> <p>The key difference from wires:</p> Aspect Wire Reg Assignment method <code>assign</code> (continuous) <code>=</code> or <code>&lt;=</code> in procedural blocks Value retention Never (must be driven) Holds last assigned value Usage context Continuous assignment <code>always</code> and <code>initial</code> blocks Default synthesis Wires Wires OR flip-flops (depends on usage) <p>Here's the critical insight: a <code>reg</code> becomes a flip-flop only if there's a code path where it doesn't get assigned a new value. If the hardware needs to \"remember\" the old value, it synthesizes storage (a flip-flop).</p> <pre><code>// This synthesizes to combinational logic (no flip-flop)\nreg y;\nalways @(*) begin\n    y = a &amp; b;  // y is ALWAYS assigned, no memory needed\nend\n\n// This synthesizes to a flip-flop\nreg q;\nalways @(posedge clk) begin\n    q &lt;= d;  // q gets new value only at clock edge, needs storage\nend\n</code></pre> <p>Modern Alternative: logic</p> <p>SystemVerilog introduced the <code>logic</code> type, which can be used instead of both <code>wire</code> and <code>reg</code>. It's more flexible and less confusing. However, Verilog-2001 (which is commonly taught) uses <code>wire</code> and <code>reg</code>, so understanding both is essential.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#parameter-making-modules-configurable","title":"Parameter: Making Modules Configurable","text":"<p>A Parameter is a constant value that can be set when a module is instantiated, allowing you to create configurable, reusable modules. Parameters are like the settings on a machine\u2014they're fixed once the machine is built, but different machines can have different settings.</p> <pre><code>module counter #(\n    parameter WIDTH = 8,    // Default: 8-bit counter\n    parameter MAX_COUNT = 255\n)(\n    input              clk,\n    input              reset,\n    output [WIDTH-1:0] count\n);\n    // Implementation uses WIDTH and MAX_COUNT\nendmodule\n</code></pre> <p>Parameters are perfect for:</p> <ul> <li>Bus widths: Create 8-bit, 16-bit, or 32-bit versions of the same module</li> <li>Timing values: Configurable delays or counters</li> <li>Array sizes: Parameterized memory depths</li> <li>Feature selection: Enable or disable optional functionality</li> </ul> <p>When instantiating a parameterized module:</p> <pre><code>// 8-bit counter (using default)\ncounter c1(.clk(clk), .reset(rst), .count(cnt8));\n\n// 16-bit counter (overriding WIDTH)\ncounter #(.WIDTH(16), .MAX_COUNT(65535)) c2(\n    .clk(clk),\n    .reset(rst),\n    .count(cnt16)\n);\n</code></pre> <p>The <code>#(...)</code> syntax provides parameter values during instantiation.</p> <p>Local parameters (<code>localparam</code>) are similar but cannot be overridden:</p> <pre><code>localparam STATE_IDLE = 2'b00;\nlocalparam STATE_RUN  = 2'b01;\nlocalparam STATE_DONE = 2'b10;\n</code></pre> <p>Use <code>localparam</code> for internal constants that shouldn't be changed by users of your module.</p> <p>Design for Reuse</p> <p>When creating a module, ask yourself: \"What might someone want to change when using this?\" Make those things parameters. A well-parameterized module can be reused across projects without modification.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#assign-statement-continuous-connection","title":"Assign Statement: Continuous Connection","text":"<p>The Assign Statement creates a continuous connection between a wire and an expression. It describes combinational logic\u2014the output continuously reflects the inputs, with no memory or clock involved.</p> <pre><code>assign y = a &amp; b;          // AND gate\nassign sum = a + b;        // Adder\nassign mux_out = sel ? b : a;  // Multiplexer\n</code></pre> <p>Key properties of assign statements:</p> <ul> <li>Continuous evaluation: The right-hand side is constantly evaluated</li> <li>Instant propagation: Changes on the right appear on the left immediately</li> <li>No order dependence: Multiple assign statements execute \"simultaneously\"</li> <li>Wire outputs only: The left side must be a wire (or output port)</li> </ul> <p>You can use any valid expression on the right side:</p> <pre><code>// Arithmetic\nassign sum = a + b - c;\n\n// Logical\nassign result = (a &amp; b) | (~c &amp; d);\n\n// Comparison\nassign equal = (a == b);\nassign greater = (a &gt; b);\n\n// Conditional (ternary)\nassign out = enable ? data : 8'b0;\n\n// Reduction\nassign all_ones = &amp;data;  // AND all bits together\nassign parity = ^data;    // XOR all bits together\n</code></pre>"},{"location":"chapters/12-verilog-hdl-fundamentals/#diagram-continuous-assignment-behavior","title":"Diagram: Continuous Assignment Behavior","text":"Continuous Assignment Visualization <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how continuous assignments work by observing that changes in input signals immediately propagate to output signals without requiring clock edges.</p> <p>Instructional Rationale: Real-time visualization where students toggle inputs and see outputs change instantly reinforces the \"continuous\" nature of assign statements.</p> <p>Canvas Layout:</p> <ul> <li>Top: Verilog code showing assign statement</li> <li>Center: Gate-level visualization of the assignment</li> <li>Bottom left: Input toggle controls</li> <li>Bottom right: Output value display</li> <li>Side: Timing trace showing signal history</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for each input</li> <li>Output updates immediately when any input changes</li> <li>Highlight which inputs are affecting output</li> <li>Gate diagram shows signal flow</li> <li>Timing trace builds as inputs change</li> <li>Reset button to clear history</li> </ul> <p>Data Visibility:</p> <ul> <li>Current input values</li> <li>Current output value</li> <li>Expression being computed</li> <li>Gate-level equivalent</li> <li>Signal history on timing diagram</li> </ul> <p>Visual Style:</p> <ul> <li>Clean circuit diagram</li> <li>Animated signal propagation through gates</li> <li>Color coding for 0/1 values</li> <li>Real-time timing diagram</li> <li>Code highlighting showing active statement</li> </ul> <p>Implementation: p5.js with real-time signal simulation</p> <p>Multiple assign statements can reference the same signals:</p> <pre><code>wire [3:0] a, b;\nwire [4:0] sum;\nwire carry;\nwire zero;\n\nassign sum = a + b;\nassign carry = sum[4];\nassign zero = (sum == 5'b0);\n</code></pre> <p>All three assignments exist simultaneously\u2014<code>sum</code> is computed, and then both <code>carry</code> and <code>zero</code> are computed from <code>sum</code>, all in one combinational network.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#continuous-assignment-always-on-logic","title":"Continuous Assignment: Always-On Logic","text":"<p>Continuous Assignment is the broader concept that assign statements implement. It means the assignment is always active\u2014the output perpetually reflects the current value of the expression.</p> <p>This is fundamentally different from procedural assignment (like in software) where an assignment happens once and the variable retains that value until explicitly changed.</p> <p>Consider this contrast:</p> <p>Software (procedural): <pre><code>y = a + b  # Computed once, when this line executes\n# ... later ...\na = 5      # y is NOT updated\n</code></pre></p> <p>Verilog (continuous): <pre><code>assign y = a + b;  // y ALWAYS equals a+b\n// If a changes, y changes automatically\n</code></pre></p> <p>The \"continuous\" in continuous assignment means:</p> <ul> <li>The relationship is eternal (as long as the circuit exists)</li> <li>There's no moment when the assignment \"happens\"\u2014it just is</li> <li>Any input change causes immediate output update</li> </ul> <p>Think of it like a formula in a spreadsheet. When you write <code>=A1+B1</code> in cell C1, you're not telling the spreadsheet to compute the sum once. You're establishing a relationship that the spreadsheet maintains forever. Change A1 or B1, and C1 automatically updates. That's continuous assignment.</p> <p>Synthesis Creates Permanent Hardware</p> <p>Every continuous assignment synthesizes to actual gates that exist permanently in your design. The statement <code>assign y = a &amp; b;</code> doesn't run\u2014it creates an AND gate that's always there, always doing its job.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#initial-block-setting-up-simulation","title":"Initial Block: Setting Up Simulation","text":"<p>An Initial Block is a procedural block that executes once at the beginning of simulation (time zero). It's used primarily for testbenches\u2014not for synthesizable design.</p> <pre><code>initial begin\n    a = 0;\n    b = 0;\n    #10 a = 1;   // After 10 time units, set a=1\n    #10 b = 1;   // After 10 more time units, set b=1\n    #10 a = 0;   // And so on...\n    #10 b = 0;\n    #20 $finish; // End simulation\nend\n</code></pre> <p>Key points about initial blocks:</p> <ul> <li>Simulation only: Most initial blocks don't synthesize to hardware</li> <li>Executes once: Runs at simulation start, never again</li> <li>Sequential execution: Statements execute in order (like software!)</li> <li>Delay control: The <code>#</code> operator pauses for specified time units</li> <li>Testbench use: Perfect for generating test stimuli</li> </ul> <p>Initial blocks are invaluable for testing your designs:</p> <pre><code>module testbench;\n    reg clk;\n    reg reset;\n    reg [7:0] data_in;\n    wire [7:0] data_out;\n\n    // Instantiate device under test\n    my_module dut(\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;  // Toggle every 5 time units\n    end\n\n    // Test sequence\n    initial begin\n        reset = 1;\n        data_in = 8'h00;\n        #20 reset = 0;\n        #10 data_in = 8'hAB;\n        #10 data_in = 8'hCD;\n        #100 $finish;\n    end\nendmodule\n</code></pre> <p>Initial Blocks and Synthesis</p> <p>While most initial blocks aren't synthesizable, some FPGA tools support initial blocks for register initialization. However, this is tool-specific and not portable. For synthesizable reset behavior, use explicit reset signals in <code>always</code> blocks instead.</p> <p>The initial block is where Verilog admits it's a simulation language as well as an HDL. It lets you write sequential, procedural test code\u2014the kind of code that controls time rather than describing structure.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#diagram-initial-block-timeline","title":"Diagram: Initial Block Timeline","text":"Initial Block Execution Timeline <p>Type: timeline</p> <p>Bloom Level: Understand (L2) Bloom Verb: Interpret</p> <p>Learning Objective: Students will be able to interpret how initial blocks execute sequentially at simulation start, understanding delay controls and the difference from synthesizable always blocks.</p> <p>Instructional Rationale: Animated timeline showing statements executing in sequence with delays makes the procedural, simulation-only nature of initial blocks clear.</p> <p>Canvas Layout:</p> <ul> <li>Top: Verilog initial block code</li> <li>Center: Timeline showing execution progress</li> <li>Bottom: Signal waveforms changing over time</li> <li>Right: Current simulation time display</li> </ul> <p>Interactive Elements:</p> <ul> <li>Play/pause button for execution</li> <li>Step-through mode (execute one statement at a time)</li> <li>Speed control slider</li> <li>Current statement highlighting</li> <li>Simulation time counter</li> <li>Reset to start button</li> </ul> <p>Data Visibility:</p> <ul> <li>Current simulation time</li> <li>Which statement is executing</li> <li>All signal values over time</li> <li>Delay durations between statements</li> <li>Complete waveform history</li> </ul> <p>Visual Style:</p> <ul> <li>Code panel with current line highlighted</li> <li>Timeline with markers for each statement</li> <li>Waveform display synced with timeline</li> <li>Delay periods shown as time gaps</li> <li>Color coding for signal values</li> </ul> <p>Implementation: p5.js with simulation time engine</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#module-instantiation-building-hierarchies","title":"Module Instantiation: Building Hierarchies","text":"<p>Module Instantiation is how you create instances of modules\u2014placing copies of defined components in your design and connecting their ports. This is how you build complex systems from simpler pieces.</p> <p>Think of it like placing components on a circuit board. You have a library of parts (modules), and instantiation is the act of placing a part and wiring it up.</p> <p>Basic syntax:</p> <pre><code>module_name instance_name(\n    .port_name1(signal1),\n    .port_name2(signal2),\n    // ...\n);\n</code></pre> <p>Example\u2014building a 4-bit adder from 1-bit full adders:</p> <pre><code>module full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a &amp; b) | (cin &amp; (a ^ b));\nendmodule\n\nmodule adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire c1, c2, c3;  // Internal carry wires\n\n    // Instantiate four full adders\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin),  .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1),   .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2),   .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3),   .sum(sum[3]), .cout(cout));\nendmodule\n</code></pre> <p>The <code>.port_name(signal)</code> syntax is called named port connection. It's explicit about which port connects to which signal.</p> <p>There's also positional port connection:</p> <pre><code>full_adder fa0(a[0], b[0], cin, sum[0], c1);  // Order matters!\n</code></pre> <p>Named connections are preferred\u2014they're clearer and less error-prone.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#diagram-module-hierarchy-visualization","title":"Diagram: Module Hierarchy Visualization","text":"Module Hierarchy Visualization <p>Type: infographic</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Organize</p> <p>Learning Objective: Students will be able to organize a hierarchical design by identifying how modules instantiate other modules and how signals connect between levels of hierarchy.</p> <p>Instructional Rationale: Interactive hierarchy diagram showing parent-child module relationships with zoom into instantiation details makes structural design tangible.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Hierarchical tree view of modules</li> <li>Clicking a module expands to show internals</li> <li>Lines show instantiation relationships</li> <li>Side panel: Selected module details and port list</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click modules to expand/collapse</li> <li>Hover to see port connections</li> <li>Highlight signal paths through hierarchy</li> <li>Zoom in/out of hierarchy levels</li> <li>Filter by module type</li> <li>Show instance names vs module names</li> </ul> <p>Data Visibility:</p> <ul> <li>All modules and their instances</li> <li>Port connections at each level</li> <li>Signal names at boundaries</li> <li>Instance count for each module type</li> <li>Hierarchical path to any component</li> </ul> <p>Visual Style:</p> <ul> <li>Tree structure for hierarchy</li> <li>Colored boxes for different module types</li> <li>Connection lines with signal labels</li> <li>Nested views for expanded modules</li> <li>Clear parent-child relationships</li> </ul> <p>Implementation: p5.js with interactive tree visualization</p> <p>Hierarchical design is powerful because:</p> <ul> <li>Divide and conquer: Build and test small modules, then combine them</li> <li>Reuse: Write a module once, instantiate it many times</li> <li>Abstraction: Hide complexity inside modules</li> <li>Parallel development: Different team members can work on different modules</li> </ul> <p>You can instantiate the same module multiple times:</p> <pre><code>// Create two separate AND gates\nand_gate g1(.a(x), .b(y), .y(out1));\nand_gate g2(.a(p), .b(q), .y(out2));\n</code></pre> <p>Each instance (<code>g1</code>, <code>g2</code>) is a separate piece of hardware with its own signals.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#bringing-it-all-together-a-complete-design","title":"Bringing It All Together: A Complete Design","text":"<p>Let's combine everything we've learned into a complete, working example\u2014a parameterized shift register with parallel load.</p> <pre><code>// Parameterized shift register with parallel load\nmodule shift_register #(\n    parameter WIDTH = 8\n)(\n    input                  clk,\n    input                  reset,\n    input                  load,      // 1=parallel load, 0=shift\n    input                  shift_in,  // Serial input for shifting\n    input      [WIDTH-1:0] data_in,   // Parallel input\n    output reg [WIDTH-1:0] data_out,  // Current register contents\n    output                 shift_out  // Serial output (MSB)\n);\n\n    // Continuous assignment for serial output\n    assign shift_out = data_out[WIDTH-1];\n\n    // Sequential logic for the shift register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            data_out &lt;= {WIDTH{1'b0}};  // Clear all bits\n        end else if (load) begin\n            data_out &lt;= data_in;         // Parallel load\n        end else begin\n            data_out &lt;= {data_out[WIDTH-2:0], shift_in};  // Shift left\n        end\n    end\n\nendmodule\n</code></pre> <p>This single module demonstrates:</p> <ul> <li>Parameters: <code>WIDTH</code> makes the register size configurable</li> <li>Ports: Inputs, outputs, and vectors</li> <li>Wire (implicit): <code>shift_out</code> driven by <code>assign</code></li> <li>Reg: <code>data_out</code> assigned in an <code>always</code> block</li> <li>Continuous assignment: For <code>shift_out</code></li> <li>Sequential logic: Clocked <code>always</code> block with reset</li> </ul> <p>And here's a testbench using an initial block:</p> <pre><code>module shift_register_tb;\n    reg clk, reset, load, shift_in;\n    reg [7:0] data_in;\n    wire [7:0] data_out;\n    wire shift_out;\n\n    // Instantiate the device under test\n    shift_register #(.WIDTH(8)) dut(\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .shift_in(shift_in),\n        .data_in(data_in),\n        .data_out(data_out),\n        .shift_out(shift_out)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    // Test sequence\n    initial begin\n        // Initialize\n        reset = 1; load = 0; shift_in = 0; data_in = 8'h00;\n        #20 reset = 0;\n\n        // Test parallel load\n        load = 1; data_in = 8'hA5;\n        #10 load = 0;\n\n        // Test shifting\n        shift_in = 1;\n        #50;\n        shift_in = 0;\n        #50;\n\n        $finish;\n    end\nendmodule\n</code></pre>"},{"location":"chapters/12-verilog-hdl-fundamentals/#common-verilog-operators","title":"Common Verilog Operators","text":"<p>Here's a quick reference for operators you'll use frequently:</p> <p>Bitwise operators:</p> Operator Description Example <code>&amp;</code> AND <code>y = a &amp; b;</code> <code>\\|</code> OR <code>y = a \\| b;</code> <code>^</code> XOR <code>y = a ^ b;</code> <code>~</code> NOT <code>y = ~a;</code> <code>~&amp;</code> NAND <code>y = ~(a &amp; b);</code> <code>~\\|</code> NOR <code>y = ~(a \\| b);</code> <code>~^</code> or <code>^~</code> XNOR <code>y = a ~^ b;</code> <p>Reduction operators (reduce a vector to one bit):</p> Operator Description Example <code>&amp;a</code> AND all bits <code>assign all_ones = &amp;data;</code> <code>\\|a</code> OR all bits <code>assign any_one = \\|data;</code> <code>^a</code> XOR all bits (parity) <code>assign parity = ^data;</code> <p>Comparison operators:</p> Operator Description <code>==</code> Equal <code>!=</code> Not equal <code>&lt;</code> Less than <code>&gt;</code> Greater than <code>&lt;=</code> Less than or equal <code>&gt;=</code> Greater than or equal <p>Arithmetic operators:</p> Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>%</code> Modulus <p>Shift operators:</p> Operator Description Example <code>&lt;&lt;</code> Logical shift left <code>y = a &lt;&lt; 2;</code> <code>&gt;&gt;</code> Logical shift right <code>y = a &gt;&gt; 2;</code> <code>&lt;&lt;&lt;</code> Arithmetic shift left Same as <code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code> Arithmetic shift right Sign extends <p>Concatenation and replication:</p> <pre><code>{a, b}          // Concatenate a and b\n{4{1'b0}}       // Replicate: 4'b0000\n{8{1'b1}}       // Replicate: 8'b11111111\n{a, 2'b00}      // a followed by two zeros\n</code></pre>"},{"location":"chapters/12-verilog-hdl-fundamentals/#number-formats-in-verilog","title":"Number Formats in Verilog","text":"<p>Verilog has a specific syntax for specifying numeric literals:</p> <pre><code>&lt;size&gt;'&lt;radix&gt;&lt;value&gt;\n</code></pre> <p>Where:</p> <ul> <li>size: Number of bits (optional, defaults based on context)</li> <li>radix: Base (b=binary, o=octal, d=decimal, h=hexadecimal)</li> <li>value: The number in the specified base</li> </ul> <p>Examples:</p> Literal Value Bits <code>8'b10101010</code> 170 8 bits binary <code>8'hAA</code> 170 8 bits hex <code>8'd170</code> 170 8 bits decimal <code>4'b0101</code> 5 4 bits binary <code>1'b0</code> 0 1 bit <code>1'b1</code> 1 1 bit <code>32'hDEAD_BEEF</code> 32 bits hex (underscores for readability) <p>Special values:</p> <ul> <li><code>x</code> or <code>X</code>: Unknown value (used in simulation)</li> <li><code>z</code> or <code>Z</code>: High-impedance (disconnected)</li> </ul> <pre><code>8'bxxxx_xxxx   // All unknown\n8'bzzzz_zzzz   // All high-impedance\n8'b1010_xxzz   // Mixed\n</code></pre>"},{"location":"chapters/12-verilog-hdl-fundamentals/#common-beginner-mistakes","title":"Common Beginner Mistakes","text":"<p>Before we wrap up, let's address some mistakes that trip up almost everyone:</p> <p>Mistake 1: Forgetting that Verilog isn't software <pre><code>// WRONG: Thinking this executes in order\nalways @(*) begin\n    temp = a + b;\n    result = temp * c;\nend\n// This synthesizes to combinational logic, not sequential operations\n</code></pre></p> <p>Mistake 2: Multiple drivers on a wire <pre><code>// WRONG: Two things driving the same wire\nassign y = a &amp; b;\nassign y = c | d;  // Error! Which one wins?\n</code></pre></p> <p>Mistake 3: Using reg when wire is needed <pre><code>// WRONG: Trying to use reg with assign\nreg y;\nassign y = a &amp; b;  // Error! assign needs wire\n</code></pre></p> <p>Mistake 4: Forgetting sensitivity list <pre><code>// WRONG: Will not respond to input changes\nalways @(a) begin  // Missing b!\n    y = a &amp; b;\nend\n// Use @(*) to automatically include all inputs\n</code></pre></p> <p>Mistake 5: Blocking vs non-blocking assignment confusion <pre><code>// Sequential logic should use &lt;=\nalways @(posedge clk) begin\n    q = d;  // WRONG: Use &lt;= for sequential logic\nend\n\n// Correct:\nalways @(posedge clk) begin\n    q &lt;= d;  // Correct non-blocking assignment\nend\n</code></pre></p> <p>We'll explore the blocking (<code>=</code>) vs non-blocking (<code>&lt;=</code>) distinction in the next chapter on Verilog modeling styles.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations on taking your first steps into the world of Hardware Description Languages. You've learned the fundamental concepts that will carry you through the rest of your Verilog journey.</p> <p>Core Concepts:</p> <ul> <li>Verilog HDL describes hardware structure and behavior in text form</li> <li>HDL vs Programming: Verilog describes concurrent hardware, not sequential operations</li> <li>Modules are the building blocks, encapsulating functionality with defined interfaces</li> <li>Ports (input, output, inout) define how modules connect to the outside world</li> </ul> <p>Data Types:</p> <ul> <li>Wire: Continuous connections, must be driven, no storage</li> <li>Reg: Can hold values, used in procedural blocks</li> <li>Parameters: Constants that make modules configurable</li> </ul> <p>Assignment and Blocks:</p> <ul> <li>Continuous assignment (<code>assign</code>): Always-active combinational logic</li> <li>Initial blocks: Simulation-time sequential code for testbenches</li> <li>Module instantiation: Creating instances and building hierarchies</li> </ul> <p>Key Distinctions:</p> <ul> <li>Statements don't \"execute\"\u2014they describe structure</li> <li>Order of statements (usually) doesn't matter</li> <li>Everything happens concurrently unless explicitly sequenced</li> <li>Synthesis creates permanent hardware; simulation runs code</li> </ul> <p>The Verilog Mindset</p> <p>The key to mastering Verilog is thinking in hardware. Every line of code you write corresponds to real gates, wires, and flip-flops. When you write <code>assign y = a &amp; b;</code>, you're not telling a computer to compute something\u2014you're saying \"there exists an AND gate here, forever.\"</p> Graphic Novel Suggestion <p>An inspiring graphic novel could tell the story of Phil Moorby, the inventor of Verilog at Gateway Design Automation in 1984. Set against the backdrop of the burgeoning chip design industry, the narrative could follow Moorby's insight that designers needed a language to describe hardware, not just draw it. The dramatic tension could build around the challenge of simulating million-gate chips when computers were still relatively primitive, leading to clever optimizations that made Verilog practical. The story could include the acquisition by Cadence, the push to become an IEEE standard, and the eventual rivalry with VHDL\u2014showing how industry politics shaped the tools that would build the modern digital world.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Module Identification <p>Identify what's wrong with this module definition: <pre><code>module broken(\n    input a,\n    output b\n)\n    assign b = ~a;\nendmodule\n</code></pre></p> <p>Solution: The semicolon is missing after the port list. It should be: <pre><code>module broken(\n    input a,\n    output b\n);\n    assign b = ~a;\nendmodule\n</code></pre></p> Problem 2: Wire vs Reg <p>Which data type should be used for <code>y</code> in each case?</p> <p>Case 1: <code>assign y = a &amp; b;</code> Case 2: <code>always @(posedge clk) y &lt;= a;</code> Case 3: <code>always @(*) y = a | b;</code></p> <p>Solution: - Case 1: wire (continuous assignment requires wire) - Case 2: reg (procedural assignment in always block) - Case 3: reg (procedural assignment in always block)</p> <p>Note: In Case 3, even though it's combinational logic, the procedural assignment still requires reg.</p> Problem 3: Port Directions <p>A module has a clock input, a reset input, an 8-bit data input, an 8-bit data output, and a bidirectional 8-bit memory bus. Write the port declarations.</p> <p>Solution: <pre><code>module memory_interface(\n    input              clk,\n    input              reset,\n    input      [7:0]   data_in,\n    output reg [7:0]   data_out,\n    inout      [7:0]   mem_bus\n);\n</code></pre></p> Problem 4: Parameter Usage <p>Modify this fixed-width adder to be parameterized: <pre><code>module adder(\n    input  [7:0] a, b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n</code></pre></p> <p>Solution: <pre><code>module adder #(\n    parameter WIDTH = 8\n)(\n    input  [WIDTH-1:0] a, b,\n    output [WIDTH:0]   sum\n);\n    assign sum = a + b;\nendmodule\n</code></pre></p> Problem 5: Continuous vs Procedural <p>Which of these statements will work? Which will cause errors?</p> <p>A) <code>assign y = a &amp; b;</code> where y is a wire B) <code>assign y = a &amp; b;</code> where y is a reg C) <code>always @(*) y = a &amp; b;</code> where y is a wire D) <code>always @(*) y = a &amp; b;</code> where y is a reg</p> <p>Solution: - A) Works: assign with wire is correct - B) Error: assign cannot drive a reg - C) Error: procedural assignment cannot target a wire - D) Works: always block with reg is correct</p> Problem 6: Module Instantiation <p>Given this AND gate module: <pre><code>module and2(input a, input b, output y);\n    assign y = a &amp; b;\nendmodule\n</code></pre></p> <p>Write code to instantiate two AND gates and combine their outputs with an OR to create <code>result = (x &amp; y) | (p &amp; q)</code>.</p> <p>Solution: <pre><code>wire and1_out, and2_out;\n\nand2 gate1(.a(x), .b(y), .y(and1_out));\nand2 gate2(.a(p), .b(q), .y(and2_out));\n\nassign result = and1_out | and2_out;\n</code></pre></p> Problem 7: Number Formats <p>Express the decimal number 42 in all four Verilog number formats (binary, octal, decimal, hexadecimal) using 8 bits.</p> <p>Solution: - Binary: <code>8'b00101010</code> - Octal: <code>8'o52</code> - Decimal: <code>8'd42</code> - Hexadecimal: <code>8'h2A</code></p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/","title":"Quiz: Verilog HDL Fundamentals","text":"<p>Test your understanding of Verilog basics, modules, data types, and fundamental constructs.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#1-what-is-the-fundamental-difference-between-hdl-and-traditional-programming-languages","title":"1. What is the fundamental difference between HDL and traditional programming languages?","text":"<ol> <li>HDLs are slower to execute</li> <li>HDLs describe concurrent hardware structure, not sequential operations</li> <li>HDLs can only be used for simulation</li> <li>HDLs require more memory</li> </ol> Show Answer <p>The correct answer is B. Hardware Description Languages describe concurrent hardware\u2014everything happens simultaneously. Traditional programming describes sequential operations executed one at a time. This fundamental difference affects how you think about and write HDL code.</p> <p>Concept Tested: HDL vs Programming</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#2-what-are-the-essential-components-of-a-verilog-module","title":"2. What are the essential components of a Verilog module?","text":"<ol> <li>Header, variables, and return statement</li> <li>Module name, port list, body, and endmodule</li> <li>Class definition and methods</li> <li>Input buffer, processing core, and output buffer</li> </ol> Show Answer <p>The correct answer is B. A Verilog module requires a module name (identifier), a port list (the interface), a body (the implementation), and the endmodule keyword. Modules are the fundamental building blocks of Verilog designs.</p> <p>Concept Tested: Module Definition</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#3-which-port-direction-allows-signals-to-flow-both-into-and-out-of-a-module","title":"3. Which port direction allows signals to flow both into and out of a module?","text":"<ol> <li>input</li> <li>output</li> <li>inout</li> <li>bidirectional is not supported in Verilog</li> </ol> Show Answer <p>The correct answer is C. The inout port direction allows bidirectional signals, used for shared buses where multiple devices can drive the line. Inout ports require tristate logic and outputting high-impedance (Z) when not driving.</p> <p>Concept Tested: Inout Port</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#4-what-is-the-key-characteristic-of-the-wire-data-type-in-verilog","title":"4. What is the key characteristic of the wire data type in Verilog?","text":"<ol> <li>It stores values between clock edges</li> <li>It must be continuously driven and cannot hold values</li> <li>It can only carry single-bit signals</li> <li>It requires explicit initialization</li> </ol> Show Answer <p>The correct answer is B. A wire represents a physical connection that must be continuously driven. It transmits values from driver to destination but cannot store values. If nothing drives a wire, it has an undefined value (X).</p> <p>Concept Tested: Wire Data Type</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#5-when-does-a-reg-data-type-synthesize-to-an-actual-flip-flop","title":"5. When does a reg data type synthesize to an actual flip-flop?","text":"<ol> <li>Always\u2014reg always means register</li> <li>Only when used in a clocked always block where it may not be assigned</li> <li>Only when declared with the \"register\" keyword</li> <li>Never\u2014reg is simulation only</li> </ol> Show Answer <p>The correct answer is B. A reg becomes a flip-flop only when there's a code path where it isn't assigned a new value, requiring the hardware to \"remember\" the old value. A reg in a clocked always block with conditional assignment synthesizes to storage.</p> <p>Concept Tested: Reg Data Type</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#6-what-is-the-purpose-of-a-parameter-in-verilog","title":"6. What is the purpose of a parameter in Verilog?","text":"<ol> <li>To define variables that change during simulation</li> <li>To create configurable, reusable modules with values set at instantiation</li> <li>To declare input ports</li> <li>To specify simulation timing</li> </ol> Show Answer <p>The correct answer is B. Parameters are constants that can be set when a module is instantiated, enabling configurable, reusable designs. Common uses include bus widths, timing values, and array sizes that vary between instances.</p> <p>Concept Tested: Parameter</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#7-what-does-an-assign-statement-create-in-hardware","title":"7. What does an assign statement create in hardware?","text":"<ol> <li>A flip-flop</li> <li>A continuous combinational connection</li> <li>A clock signal</li> <li>A memory element</li> </ol> Show Answer <p>The correct answer is B. An assign statement creates a continuous, always-active combinational connection. The right-hand expression is constantly evaluated, and any input change immediately affects the output\u2014like physical wires and gates.</p> <p>Concept Tested: Assign Statement</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#8-what-is-the-primary-purpose-of-an-initial-block-in-verilog","title":"8. What is the primary purpose of an initial block in Verilog?","text":"<ol> <li>To initialize flip-flops in synthesized hardware</li> <li>To provide simulation-time setup and stimulus generation</li> <li>To define the module interface</li> <li>To create clock signals for synthesis</li> </ol> Show Answer <p>The correct answer is B. Initial blocks execute once at simulation start (time zero) and are primarily used in testbenches for initialization, clock generation, and stimulus application. They are generally not synthesizable.</p> <p>Concept Tested: Initial Block</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#9-what-does-module-instantiation-accomplish-in-verilog","title":"9. What does module instantiation accomplish in Verilog?","text":"<ol> <li>It compiles the module for simulation</li> <li>It creates instances of modules and connects their ports to signals</li> <li>It defines a new module type</li> <li>It generates documentation</li> </ol> Show Answer <p>The correct answer is B. Module instantiation creates copies of defined modules and wires their ports to signals in the parent module. This builds hierarchical designs where complex systems are composed of simpler, reusable components.</p> <p>Concept Tested: Module Instantiation</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/quiz/#10-in-the-literal-8ha5-what-do-the-components-represent","title":"10. In the literal 8'hA5, what do the components represent?","text":"<ol> <li>8 bits, hexadecimal radix, value A5 (165 decimal)</li> <li>8 bytes, high-speed mode, address 5</li> <li>Module instance 8, port h, signal A5</li> <li>8-character string \"hA5\"</li> </ol> Show Answer <p>The correct answer is A. Verilog number format is size'radix_value. Here: 8 = bit width, h = hexadecimal radix, A5 = value (165 in decimal, 10100101 in binary). Other radixes: b=binary, o=octal, d=decimal.</p> <p>Concept Tested: Verilog HDL</p>"},{"location":"chapters/13-verilog-modeling/","title":"Verilog Behavioral and Structural Modeling","text":""},{"location":"chapters/13-verilog-modeling/#summary","title":"Summary","text":"<p>This chapter covers advanced Verilog constructs for modeling digital systems at various levels of abstraction. Students will master the always block and sensitivity lists, understand the critical difference between blocking and non-blocking assignments, use if-else and case statements for decision logic, and write combinational always blocks (with @(*)) and sequential always blocks (with @(posedge clk)). The chapter covers three modeling styles: structural modeling using gate primitives and module instantiation, behavioral modeling using procedural statements, and gate-level Verilog. RTL Verilog and hierarchical design principles complete the coverage.</p>"},{"location":"chapters/13-verilog-modeling/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Always Block</li> <li>Sensitivity List</li> <li>Blocking Assignment</li> <li>Non-Blocking Assignment</li> <li>If-Else in Verilog</li> <li>Case Statement</li> <li>Combinational Always</li> <li>Sequential Always</li> <li>Posedge Keyword</li> <li>Negedge Keyword</li> <li>Structural Modeling</li> <li>Behavioral Modeling</li> <li>Gate-Level Verilog</li> <li>RTL Verilog</li> <li>Hierarchical Design</li> </ol>"},{"location":"chapters/13-verilog-modeling/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 12: Verilog HDL Fundamentals</li> </ul>"},{"location":"chapters/13-verilog-modeling/#introduction-the-art-of-describing-hardware","title":"Introduction: The Art of Describing Hardware","text":"<p>Welcome back, intrepid circuit designer! In Chapter 12, you learned to speak Verilog's basic vocabulary\u2014modules, ports, wires, and continuous assignments. Now it's time to become fluent. This chapter is where Verilog transforms from a simple gate-connection language into a powerful tool for describing behavior\u2014what your circuit does, not just how it's wired.</p> <p>Think of it like the difference between describing a car by listing every bolt and wire versus describing it by saying \"when you press the gas pedal, the car accelerates.\" Both descriptions are valid, but one is a lot easier to write and understand. That's the power of behavioral modeling.</p> <p>But here's the plot twist: Verilog lets you work at multiple levels of abstraction simultaneously. You can describe some parts of your design behaviorally (\"when the counter reaches 10, reset it\"), some parts structurally (\"connect this AND gate to that OR gate\"), and some parts at the gate level (\"use a NAND gate here\"). It's like being able to zoom in and out of a map\u2014sometimes you need to see the whole country, sometimes you need street-level detail.</p> <p>By the end of this chapter, you'll understand:</p> <ul> <li>How <code>always</code> blocks let you write procedural hardware descriptions</li> <li>The crucial (and frequently misunderstood) difference between <code>=</code> and <code>&lt;=</code></li> <li>When to use <code>if-else</code> versus <code>case</code> statements</li> <li>How to model both combinational and sequential logic behaviorally</li> <li>The three abstraction levels: gate-level, RTL, and behavioral</li> </ul> <p>Ready to level up your Verilog game? Let's dive in!</p>"},{"location":"chapters/13-verilog-modeling/#the-always-block-where-procedural-meets-parallel","title":"The Always Block: Where Procedural Meets Parallel","text":"<p>The Always Block is the heart of procedural Verilog. While <code>assign</code> statements describe continuous, always-active connections (like physical wires), <code>always</code> blocks describe processes that respond to specific events.</p> <p>Here's the basic syntax:</p> <pre><code>always @(sensitivity_list) begin\n    // procedural statements go here\nend\n</code></pre> <p>The <code>always</code> block is called \"always\" because it runs forever\u2014it's not a one-time thing like an <code>initial</code> block. Every time the conditions in the sensitivity list are met, the block executes again.</p> <p>Think of an <code>always</code> block like a watchful guardian. It sits there monitoring certain signals, and whenever those signals change in the specified way, it springs into action. Then it goes back to watching. Forever. (That's some serious dedication!)</p> <pre><code>// This always block responds to ANY change in a or b\nalways @(a or b) begin\n    y = a &amp; b;\nend\n\n// This always block responds ONLY to the rising edge of clk\nalways @(posedge clk) begin\n    q &lt;= d;\nend\n</code></pre> <p>Key properties of <code>always</code> blocks:</p> <ul> <li>Multiple always blocks run concurrently: Just like multiple <code>assign</code> statements, multiple <code>always</code> blocks all exist at once, running in parallel</li> <li>Statements inside execute sequentially: Within a single <code>always</code> block, statements execute top-to-bottom (like software)</li> <li>Can only assign to <code>reg</code> types: The left side of assignments in <code>always</code> blocks must be declared as <code>reg</code></li> <li>Must have a sensitivity list: This tells the simulator (and synthesizer) when to evaluate the block</li> </ul> <p>The Order Paradox</p> <p>Here's what trips up beginners: statements within an always block are sequential, but between always blocks, everything is concurrent. It's like having multiple short programs that all run at the same time, but each program internally executes line by line.</p>"},{"location":"chapters/13-verilog-modeling/#diagram-always-block-execution-model","title":"Diagram: Always Block Execution Model","text":"Always Block Execution Model <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how always blocks execute in response to sensitivity list triggers, understanding that multiple always blocks run concurrently while statements within each block execute sequentially.</p> <p>Instructional Rationale: Animated visualization showing multiple always blocks responding to signal changes, with internal sequential execution highlighted, clarifies the concurrent-yet-sequential nature of procedural Verilog.</p> <p>Canvas Layout:</p> <ul> <li>Left panel: Multiple always blocks shown as separate \"process boxes\"</li> <li>Center: Signal waveforms triggering block execution</li> <li>Right panel: Execution trace showing sequential steps within active block</li> <li>Bottom: Input controls for triggering signals</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for input signals</li> <li>Clock pulse button</li> <li>Highlight which always block is currently active</li> <li>Step-through mode showing sequential execution within block</li> <li>Concurrent execution indicator for multiple blocks</li> <li>Reset button</li> </ul> <p>Data Visibility:</p> <ul> <li>Current values of all signals</li> <li>Which sensitivity list conditions are met</li> <li>Execution order within active blocks</li> <li>Parallel execution between blocks</li> <li>Output values updating</li> </ul> <p>Visual Style:</p> <ul> <li>Always blocks as colored process rectangles</li> <li>Sensitivity list as \"trigger condition\" above each block</li> <li>Internal statements as numbered steps</li> <li>Active block highlighted with glow effect</li> <li>Waveform display showing signal changes</li> </ul> <p>Implementation: p5.js with multi-process simulation engine</p>"},{"location":"chapters/13-verilog-modeling/#sensitivity-list-the-trigger-conditions","title":"Sensitivity List: The Trigger Conditions","text":"<p>The Sensitivity List specifies which signal changes cause an <code>always</code> block to execute. It's the \"wake-up call\" for the block\u2014without the right sensitivity list, your block might never run, or might run at the wrong times.</p> <pre><code>// Old-style: explicit signal list\nalways @(a or b or c) begin\n    y = a &amp; b | c;\nend\n\n// Verilog-2001 style: automatic sensitivity list\nalways @(*) begin\n    y = a &amp; b | c;\nend\n\n// Edge-sensitive: responds to clock edges\nalways @(posedge clk) begin\n    q &lt;= d;\nend\n</code></pre> <p>The <code>@(*)</code> syntax (pronounced \"at star\" or \"at splat\") is a Verilog-2001 feature that automatically includes all signals read within the block. It's a lifesaver\u2014it prevents the common bug of forgetting a signal in the sensitivity list.</p> <p>There are two fundamentally different types of sensitivity lists:</p> Type Syntax Use Case Synthesizes To Level-sensitive <code>@(a or b)</code> or <code>@(*)</code> Combinational logic Gates/muxes Edge-sensitive <code>@(posedge clk)</code> Sequential logic Flip-flops <p>Always Use @(*) for Combinational Logic</p> <p>For combinational <code>always</code> blocks, always use <code>@(*)</code>. It automatically includes all the right signals and prevents subtle bugs. The explicit <code>@(a or b or c)</code> style is a relic from older Verilog and invites mistakes.</p> <p>What happens if your sensitivity list is incomplete? Consider this buggy code:</p> <pre><code>// BUG: Missing 'b' in sensitivity list!\nalways @(a) begin\n    y = a &amp; b;\nend\n</code></pre> <p>In simulation, <code>y</code> won't update when <code>b</code> changes (only when <code>a</code> changes). But synthesis might create correct hardware anyway, leading to a mismatch between simulation and hardware. This is one of the most frustrating bugs to track down.</p> <p>The golden rule: simulation behavior should match synthesis behavior. Using <code>@(*)</code> ensures this.</p>"},{"location":"chapters/13-verilog-modeling/#posedge-and-negedge-catching-the-edge","title":"Posedge and Negedge: Catching the Edge","text":"<p>Posedge (positive edge) and Negedge (negative edge) are keywords that specify edge-triggered sensitivity\u2014the block executes only when a signal transitions.</p> <pre><code>// Trigger on rising edge of clk\nalways @(posedge clk) begin\n    q &lt;= d;\nend\n\n// Trigger on falling edge of clk\nalways @(negedge clk) begin\n    q &lt;= d;\nend\n\n// Trigger on rising clk OR rising reset (async reset)\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q &lt;= 1'b0;\n    else\n        q &lt;= d;\nend\n</code></pre> <p>The difference between level-sensitive and edge-sensitive is crucial:</p> Sensitivity When It Triggers Hardware Result <code>@(a)</code> Any time <code>a</code> changes Combinational (transparent) <code>@(posedge a)</code> Only when <code>a</code> goes 0\u21921 Sequential (flip-flop) <code>@(negedge a)</code> Only when <code>a</code> goes 1\u21920 Sequential (flip-flop)"},{"location":"chapters/13-verilog-modeling/#diagram-edge-detection-visualizer","title":"Diagram: Edge Detection Visualizer","text":"Edge Detection Visualizer <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate the difference between posedge, negedge, and level-sensitive triggering by observing when outputs update in response to input transitions.</p> <p>Instructional Rationale: Interactive waveform showing exactly when each type of sensitivity triggers makes the edge vs. level distinction viscerally clear.</p> <p>Canvas Layout:</p> <ul> <li>Top: Input signal waveform with manual control</li> <li>Middle: Three parallel circuits (level, posedge, negedge)</li> <li>Bottom: Output waveforms for each circuit</li> <li>Side: Edge detection indicators</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle button for input signal</li> <li>Slow-motion transition mode</li> <li>Highlight exact moment of edge detection</li> <li>Count of edge triggers</li> <li>Comparison mode showing all three simultaneously</li> </ul> <p>Data Visibility:</p> <ul> <li>Input signal value and transitions</li> <li>When each sensitivity type triggers</li> <li>Output values for each type</li> <li>Edge detection moments marked</li> <li>Timing relationship between input and output</li> </ul> <p>Visual Style:</p> <ul> <li>Clean waveform display</li> <li>Edge markers as vertical lines</li> <li>Trigger moments highlighted with flash</li> <li>Color coding (blue=level, green=posedge, red=negedge)</li> <li>Timing cursor for exploration</li> </ul> <p>Implementation: p5.js with waveform animation</p> <p>Think of <code>posedge</code> like a turnstile that only counts when you push through it. It doesn't matter if you're standing there pushing constantly\u2014it only registers the moment of the push. The clock signal might be high for millions of nanoseconds, but the flip-flop only captures data at that one instant of the rising edge.</p> <p>Common edge-sensitive patterns:</p> <pre><code>// Synchronous reset (reset checked at clock edge)\nalways @(posedge clk) begin\n    if (reset)\n        count &lt;= 4'b0;\n    else\n        count &lt;= count + 1;\nend\n\n// Asynchronous reset (reset is in sensitivity list)\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count &lt;= 4'b0;\n    else\n        count &lt;= count + 1;\nend\n</code></pre> <p>Synthesis Implications</p> <p>When you use <code>posedge</code> or <code>negedge</code>, you're telling the synthesizer to create flip-flops. This is the only way to create sequential (memory) elements behaviorally. Level-sensitive always blocks synthesize to combinational logic.</p>"},{"location":"chapters/13-verilog-modeling/#blocking-assignment-sequential-within-the-block","title":"Blocking Assignment: Sequential Within the Block","text":"<p>Blocking Assignment uses the <code>=</code> operator and executes sequentially within an <code>always</code> block. The assignment \"blocks\" execution of the next statement until it completes.</p> <pre><code>always @(*) begin\n    temp = a + b;      // Step 1: compute a+b, store in temp\n    result = temp * c; // Step 2: use temp to compute result\nend\n</code></pre> <p>Think of blocking assignment like a cooking recipe: \"First crack the eggs, then add flour.\" You can't add flour before the eggs are cracked. Each step must complete before the next begins.</p> <p>Key characteristics of blocking assignments:</p> <ul> <li>Immediate update: The variable gets its new value immediately</li> <li>Sequential execution: Later statements see the new value</li> <li>Order matters: Swapping lines changes behavior</li> <li>Use for combinational logic: Appropriate in <code>@(*)</code> blocks</li> </ul> <p>Example showing order dependence:</p> <pre><code>// Version A\nalways @(*) begin\n    temp = a;\n    result = temp + b;  // result = a + b\nend\n\n// Version B (lines swapped - DIFFERENT BEHAVIOR!)\nalways @(*) begin\n    result = temp + b;  // result = OLD temp + b (BUG!)\n    temp = a;\nend\n</code></pre> <p>In Version B, <code>result</code> uses the old value of <code>temp</code> because the assignment to <code>temp</code> hasn't happened yet. This is why order matters with blocking assignments.</p> <p>Blocking + Clocked = Trouble</p> <p>Using blocking assignments (<code>=</code>) in clocked always blocks is legal but dangerous. It can create race conditions when multiple always blocks interact. The safe rule: use <code>=</code> only in combinational blocks, use <code>&lt;=</code> in sequential blocks.</p>"},{"location":"chapters/13-verilog-modeling/#non-blocking-assignment-parallel-updates","title":"Non-Blocking Assignment: Parallel Updates","text":"<p>Non-Blocking Assignment uses the <code>&lt;=</code> operator and schedules updates to happen simultaneously at the end of the current simulation time step. All right-hand sides are evaluated first, then all left-hand sides are updated together.</p> <pre><code>always @(posedge clk) begin\n    a &lt;= b;  // At clock edge: capture b's value for a\n    b &lt;= a;  // At clock edge: capture a's value for b (OLD a!)\nend\n</code></pre> <p>This is the magic of non-blocking: the two assignments above swap the values of <code>a</code> and <code>b</code>! Both right-hand sides are evaluated with the current values before either assignment takes effect.</p> <p>Think of non-blocking assignment like a synchronized dance move. Everyone reads their instruction at the same moment, then everyone moves at the same moment. Nobody sees anyone else's new position until the music stops.</p>"},{"location":"chapters/13-verilog-modeling/#diagram-blocking-vs-non-blocking-comparison","title":"Diagram: Blocking vs Non-Blocking Comparison","text":"Blocking vs Non-Blocking Assignment Comparison <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Differentiate</p> <p>Learning Objective: Students will be able to differentiate between blocking and non-blocking assignment behavior by observing how intermediate values propagate (or don't) within always blocks.</p> <p>Instructional Rationale: Side-by-side execution of identical code with = vs &lt;= reveals the critical behavioral difference, especially for swap patterns.</p> <p>Canvas Layout:</p> <ul> <li>Left panel: Blocking assignment example with step-through</li> <li>Right panel: Non-blocking assignment example with step-through</li> <li>Center: Value comparison showing differences</li> <li>Bottom: Simulation controls</li> </ul> <p>Interactive Elements:</p> <ul> <li>Clock trigger button</li> <li>Step-through execution mode</li> <li>Highlight current evaluation phase</li> <li>Show scheduled updates for non-blocking</li> <li>Value history display</li> <li>Reset button</li> </ul> <p>Data Visibility:</p> <ul> <li>Current values of all variables</li> <li>Intermediate values during blocking execution</li> <li>Scheduled updates for non-blocking</li> <li>Final values comparison</li> <li>Execution phase indicator (evaluate vs. update)</li> </ul> <p>Visual Style:</p> <ul> <li>Two-column comparison layout</li> <li>Variable values as prominent displays</li> <li>Arrows showing value flow</li> <li>Phase indicators (Read, Write, Complete)</li> <li>Color-coded differences</li> </ul> <p>Implementation: p5.js with dual simulation engines</p> <p>Here's the critical comparison:</p> Aspect Blocking (<code>=</code>) Non-Blocking (<code>&lt;=</code>) Execution Sequential within block Parallel update at end Intermediate values Visible to later statements Not visible (old values used) Order dependence Yes, order matters No, order doesn't matter Best for Combinational logic Sequential logic Swap behavior No swap (need temp) Natural swap <p>The classic swap example:</p> <pre><code>// Using blocking (DOESN'T swap!)\nalways @(posedge clk) begin\n    a = b;   // a becomes b\n    b = a;   // b becomes a, but a is already b, so b stays b!\nend\n\n// Using non-blocking (DOES swap!)\nalways @(posedge clk) begin\n    a &lt;= b;  // Schedule: a will become b's current value\n    b &lt;= a;  // Schedule: b will become a's current value (original a)\nend        // Now both updates happen: SWAP!\n</code></pre> <p>The Golden Rule of Assignments</p> <ul> <li>Use <code>=</code> (blocking) in combinational always blocks (<code>@(*)</code>)</li> <li>Use <code>&lt;=</code> (non-blocking) in sequential always blocks (<code>@(posedge clk)</code>)</li> <li>Never mix them in the same always block</li> <li>When in doubt, use <code>&lt;=</code> for sequential logic</li> </ul>"},{"location":"chapters/13-verilog-modeling/#if-else-in-verilog-decision-making","title":"If-Else in Verilog: Decision Making","text":"<p>If-Else in Verilog provides conditional execution within always blocks, just like in software programming languages. The syntax is nearly identical to C:</p> <pre><code>always @(*) begin\n    if (condition1) begin\n        // statements when condition1 is true\n    end else if (condition2) begin\n        // statements when condition2 is true\n    end else begin\n        // statements when all conditions are false\n    end\nend\n</code></pre> <p>The <code>begin</code>...<code>end</code> keywords are like curly braces in C\u2014they group multiple statements. For single statements, they're optional but recommended for clarity.</p> <p>Important rules for synthesizable if-else:</p> <ol> <li>Cover all cases: Always include a final <code>else</code> to avoid creating latches</li> <li>Priority encoding: Conditions are checked in order; first match wins</li> <li>Mutually exclusive is efficient: Non-overlapping conditions synthesize better</li> </ol> <pre><code>// 4-to-1 multiplexer using if-else\nalways @(*) begin\n    if (sel == 2'b00)\n        y = a;\n    else if (sel == 2'b01)\n        y = b;\n    else if (sel == 2'b10)\n        y = c;\n    else  // sel == 2'b11\n        y = d;\nend\n</code></pre>"},{"location":"chapters/13-verilog-modeling/#diagram-if-else-priority-chain","title":"Diagram: If-Else Priority Chain","text":"If-Else Priority Chain Visualization <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how if-else chains create priority-encoded logic by tracing through condition evaluation order.</p> <p>Instructional Rationale: Visual flow through if-else conditions with highlighting of which branch is taken reinforces the priority nature of cascaded conditions.</p> <p>Canvas Layout:</p> <ul> <li>Left: Condition evaluation flow chart</li> <li>Center: Current condition being tested (highlighted)</li> <li>Right: Output value based on selected branch</li> <li>Bottom: Input controls for conditions</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for each condition input</li> <li>Step-through mode showing evaluation order</li> <li>Highlight path taken through chain</li> <li>Show synthesized priority encoder</li> <li>Multiple examples (mux, priority encoder, etc.)</li> </ul> <p>Data Visibility:</p> <ul> <li>All condition values</li> <li>Evaluation order (1st, 2nd, 3rd...)</li> <li>Which condition matched first</li> <li>Output value</li> <li>Path through decision tree</li> </ul> <p>Visual Style:</p> <ul> <li>Decision tree/flowchart layout</li> <li>Arrows showing evaluation flow</li> <li>Green for matched condition</li> <li>Gray for skipped conditions</li> <li>Output box at each terminal</li> </ul> <p>Implementation: p5.js with decision tree animation</p> <p>The hardware synthesized from if-else is a priority multiplexer chain. Early conditions have higher priority\u2014if multiple conditions could be true, the first one wins:</p> <pre><code>// Priority encoder: first condition wins\nalways @(*) begin\n    if (req3)           // Highest priority\n        grant = 4'b1000;\n    else if (req2)\n        grant = 4'b0100;\n    else if (req1)\n        grant = 4'b0010;\n    else if (req0)      // Lowest priority\n        grant = 4'b0001;\n    else\n        grant = 4'b0000;\nend\n</code></pre> <p>The Latch Trap</p> <p>If you don't cover all possible input combinations with assignments, synthesis creates a latch\u2014a level-sensitive memory element that holds the old value. This is almost always a bug:</p> <pre><code>// BUG: Creates a latch!\nalways @(*) begin\n    if (enable)\n        y = data;  // What happens when enable=0? Latch!\nend\n\n// FIXED: Cover all cases\nalways @(*) begin\n    if (enable)\n        y = data;\n    else\n        y = 1'b0;  // Explicit default\nend\n</code></pre>"},{"location":"chapters/13-verilog-modeling/#case-statement-multi-way-selection","title":"Case Statement: Multi-Way Selection","text":"<p>The Case Statement provides cleaner multi-way selection than long if-else chains, especially when checking one expression against multiple values:</p> <pre><code>always @(*) begin\n    case (sel)\n        2'b00: y = a;\n        2'b01: y = b;\n        2'b10: y = c;\n        2'b11: y = d;\n        default: y = 1'b0;\n    endcase\nend\n</code></pre> <p>Case statements are perfect for:</p> <ul> <li>Multiplexers</li> <li>Decoders</li> <li>State machine next-state logic</li> <li>ALU operation selection</li> <li>Instruction decoders</li> </ul> <p>Verilog provides three case variants:</p> Variant Syntax X and Z handling Standard <code>case</code> X/Z match literally Casez <code>casez</code> Z (or ?) treated as don't-care Casex <code>casex</code> Both X and Z treated as don't-care <pre><code>// Using casez for don't-care bits\nalways @(*) begin\n    casez (opcode)\n        4'b0???: result = a + b;    // Any opcode starting with 0\n        4'b10??: result = a - b;    // Opcodes 10xx\n        4'b110?: result = a &amp; b;    // Opcodes 110x\n        4'b1110: result = a | b;    // Opcode 1110 exactly\n        4'b1111: result = ~a;       // Opcode 1111 exactly\n        default: result = 8'b0;\n    endcase\nend\n</code></pre> <p>Always Include default</p> <p>Even if you think you've covered all cases, include a <code>default</code> clause. It prevents latches if you miscounted, documents your intent, and handles unexpected X or Z values in simulation.</p>"},{"location":"chapters/13-verilog-modeling/#diagram-case-statement-decoder","title":"Diagram: Case Statement Decoder","text":"Case Statement Decoder Visualization <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use case statements to implement decoders and multiplexers by observing the direct mapping between case values and outputs.</p> <p>Instructional Rationale: Interactive decoder where students set selector inputs and see which case branch activates demonstrates the parallel-selection nature of case statements.</p> <p>Canvas Layout:</p> <ul> <li>Left: Case statement code with highlighting</li> <li>Center: Selector input controls</li> <li>Right: Output display showing selected case</li> <li>Bottom: Synthesized hardware view (mux/decoder)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Binary input for selector value</li> <li>Highlight matching case branch</li> <li>Show don't-care matching for casez</li> <li>Toggle between case/casez/casex</li> <li>Display synthesized circuit</li> </ul> <p>Data Visibility:</p> <ul> <li>Current selector value</li> <li>All case values</li> <li>Which case matches</li> <li>Output value</li> <li>Hardware representation</li> </ul> <p>Visual Style:</p> <ul> <li>Code panel with syntax highlighting</li> <li>Selector as binary switches</li> <li>Matched case highlighted green</li> <li>Output with visual indicator</li> <li>Circuit schematic at bottom</li> </ul> <p>Implementation: p5.js with case statement simulator</p> <p>Case vs. if-else: which to use?</p> Situation Use Case Use If-Else Checking one signal against multiple values \u2713 Multiple independent conditions \u2713 Priority needed (first match wins) \u2713 Equal-priority parallel decode \u2713 Don't-care bits in patterns \u2713 (casez)"},{"location":"chapters/13-verilog-modeling/#combinational-always-blocks","title":"Combinational Always Blocks","text":"<p>A Combinational Always block models combinational logic\u2014circuits with no memory, where outputs depend only on current inputs. Use <code>@(*)</code> sensitivity and blocking assignments.</p> <pre><code>// Combinational logic: 4-bit adder\nalways @(*) begin\n    sum = a + b;\n    carry = (a + b) &gt; 4'hF;\nend\n</code></pre> <p>Rules for combinational always blocks:</p> <ol> <li>Use <code>@(*)</code>: Automatic sensitivity list prevents bugs</li> <li>Use blocking <code>=</code>: Sequential evaluation is fine for combinational logic</li> <li>Assign all outputs in all paths: Prevent latch inference</li> <li>No feedback: Don't read a signal you're assigning (unless it's a temporary)</li> </ol> <p>Complete combinational example\u2014an ALU:</p> <pre><code>module alu(\n    input  [7:0] a, b,\n    input  [2:0] op,\n    output reg [7:0] result,\n    output reg       zero\n);\n\nalways @(*) begin\n    case (op)\n        3'b000: result = a + b;      // ADD\n        3'b001: result = a - b;      // SUB\n        3'b010: result = a &amp; b;      // AND\n        3'b011: result = a | b;      // OR\n        3'b100: result = a ^ b;      // XOR\n        3'b101: result = ~a;         // NOT\n        3'b110: result = a &lt;&lt; 1;     // Shift left\n        3'b111: result = a &gt;&gt; 1;     // Shift right\n        default: result = 8'b0;\n    endcase\n    zero = (result == 8'b0);\nend\n\nendmodule\n</code></pre> <p>Combinational = No Memory</p> <p>Combinational always blocks synthesize to gates, muxes, and arithmetic units\u2014never flip-flops. If you accidentally create a latch (by not assigning in all paths), that's a synthesis error, not a feature.</p>"},{"location":"chapters/13-verilog-modeling/#sequential-always-blocks","title":"Sequential Always Blocks","text":"<p>A Sequential Always block models sequential logic\u2014circuits with memory that update on clock edges. Use <code>@(posedge clk)</code> and non-blocking assignments.</p> <pre><code>// Sequential logic: D flip-flop\nalways @(posedge clk) begin\n    q &lt;= d;\nend\n</code></pre> <p>Rules for sequential always blocks:</p> <ol> <li>Use edge-sensitive triggers: <code>@(posedge clk)</code> or <code>@(negedge clk)</code></li> <li>Use non-blocking <code>&lt;=</code>: Prevents race conditions</li> <li>Not assigning is OK: Creates \"hold\" behavior (register keeps value)</li> <li>Reset is essential: Provide a way to initialize state</li> </ol> <p>Common sequential patterns:</p> <pre><code>// Register with synchronous reset\nalways @(posedge clk) begin\n    if (reset)\n        q &lt;= 8'b0;\n    else if (enable)\n        q &lt;= d;\n    // else: q holds its value (implicit in sequential blocks)\nend\n\n// Register with asynchronous reset\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q &lt;= 8'b0;\n    else\n        q &lt;= d;\nend\n</code></pre>"},{"location":"chapters/13-verilog-modeling/#diagram-sequential-always-timing","title":"Diagram: Sequential Always Timing","text":"Sequential Always Block Timing <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Describe</p> <p>Learning Objective: Students will be able to describe how sequential always blocks capture input values at clock edges, showing the one-cycle delay between input and output.</p> <p>Instructional Rationale: Timing diagram with interactive clock control reveals when data is captured versus when it appears at the output.</p> <p>Canvas Layout:</p> <ul> <li>Top: Clock waveform with manual control</li> <li>Middle: D flip-flop circuit representation</li> <li>Bottom: Input D and output Q waveforms</li> <li>Side: Current state display</li> </ul> <p>Interactive Elements:</p> <ul> <li>Manual clock edge button</li> <li>Free-running clock toggle with speed control</li> <li>Input D toggle</li> <li>Reset button</li> <li>Highlight capture moment</li> <li>Setup/hold time indicators</li> </ul> <p>Data Visibility:</p> <ul> <li>Clock value and edges</li> <li>D input value</li> <li>Q output value</li> <li>Capture moment highlighted</li> <li>One-cycle delay visible</li> </ul> <p>Visual Style:</p> <ul> <li>Clean waveform display</li> <li>Clock edges marked</li> <li>Capture points with vertical lines</li> <li>D-to-Q delay visible</li> <li>State display showing register contents</li> </ul> <p>Implementation: p5.js with clocked simulation</p> <p>Counter example with enable and load:</p> <pre><code>module counter #(\n    parameter WIDTH = 8\n)(\n    input                  clk,\n    input                  reset,\n    input                  enable,\n    input                  load,\n    input      [WIDTH-1:0] load_value,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count &lt;= {WIDTH{1'b0}};\n    else if (load)\n        count &lt;= load_value;\n    else if (enable)\n        count &lt;= count + 1;\n    // else: count holds its value\nend\n\nendmodule\n</code></pre>"},{"location":"chapters/13-verilog-modeling/#structural-modeling-building-from-components","title":"Structural Modeling: Building from Components","text":"<p>Structural Modeling describes a circuit by instantiating and connecting lower-level components. It's like building with LEGO\u2014you specify which pieces to use and how they connect.</p> <pre><code>// Structural: Build 4-bit adder from full adders\nmodule adder_4bit(\n    input  [3:0] a, b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire c1, c2, c3;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1),  .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2),  .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3),  .sum(sum[3]), .cout(cout));\nendmodule\n</code></pre> <p>Structural modeling is closest to how hardware actually works\u2014you're literally describing what components exist and how they're wired. It offers:</p> <ul> <li>Precise control: You know exactly what hardware will be generated</li> <li>Reusability: Instantiate the same module many times</li> <li>Hierarchy: Build complex systems from simpler parts</li> <li>Clarity: Easy to see the architecture</li> </ul> <p>The trade-off is verbosity\u2014structural models are longer than behavioral equivalents.</p>"},{"location":"chapters/13-verilog-modeling/#behavioral-modeling-describing-what-not-how","title":"Behavioral Modeling: Describing What, Not How","text":"<p>Behavioral Modeling describes what a circuit does without specifying its structure. The synthesizer figures out how to implement it.</p> <pre><code>// Behavioral: Just say what you want\nmodule adder_4bit(\n    input  [3:0] a, b,\n    input        cin,\n    output [4:0] sum\n);\n    assign sum = a + b + cin;  // One line!\nendmodule\n</code></pre> <p>That single <code>assign</code> statement synthesizes to the same ripple-carry adder as the structural version\u2014but it's much shorter to write!</p> <p>Behavioral modeling uses:</p> <ul> <li>Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>&amp;</code>, <code>|</code>, etc.</li> <li>Always blocks: For procedural descriptions</li> <li>If-else and case: For conditional logic</li> <li>Loops (in simulation): For repetitive patterns</li> </ul>"},{"location":"chapters/13-verilog-modeling/#diagram-structural-vs-behavioral-comparison","title":"Diagram: Structural vs Behavioral Comparison","text":"Structural vs Behavioral Modeling Comparison <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare structural and behavioral modeling approaches by observing that both produce equivalent hardware but with different code complexity and design control.</p> <p>Instructional Rationale: Side-by-side view of structural and behavioral descriptions of the same circuit, with synthesized hardware view, reveals the abstraction trade-off.</p> <p>Canvas Layout:</p> <ul> <li>Left panel: Structural code</li> <li>Right panel: Behavioral code</li> <li>Center: Synthesized hardware (same for both!)</li> <li>Bottom: Simulation controls and comparison</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input value controls</li> <li>Simulate both versions</li> <li>Compare outputs (should match)</li> <li>Toggle hardware view</li> <li>Code line highlighting</li> <li>Complexity metrics display</li> </ul> <p>Data Visibility:</p> <ul> <li>Both code versions</li> <li>Synthesized circuit</li> <li>Input/output values</li> <li>Verification that outputs match</li> <li>Code complexity comparison (lines, modules)</li> </ul> <p>Visual Style:</p> <ul> <li>Two-column code display</li> <li>Shared circuit schematic</li> <li>Matched highlighting between code and hardware</li> <li>Difference counter showing code size difference</li> </ul> <p>Implementation: p5.js with dual code panels and shared simulation</p> <p>When to use each style:</p> Modeling Style Best For Structural Precise control, reusing specific components, IP integration Behavioral Rapid development, high-level specification, arithmetic Mixed Most real designs\u2014behavioral for logic, structural for hierarchy"},{"location":"chapters/13-verilog-modeling/#gate-level-verilog-the-primitive-foundation","title":"Gate-Level Verilog: The Primitive Foundation","text":"<p>Gate-Level Verilog uses built-in gate primitives to describe circuits at the most fundamental level. It's like assembly language for hardware\u2014rarely written by hand, but important to understand.</p> <pre><code>// Gate-level: Full adder from gates\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    wire w1, w2, w3;\n\n    xor g1(w1, a, b);        // w1 = a XOR b\n    xor g2(sum, w1, cin);    // sum = w1 XOR cin\n    and g3(w2, a, b);        // w2 = a AND b\n    and g4(w3, w1, cin);     // w3 = w1 AND cin\n    or  g5(cout, w2, w3);    // cout = w2 OR w3\nendmodule\n</code></pre> <p>Verilog includes these gate primitives:</p> Primitive Inputs Function <code>and</code> 2+ AND of all inputs <code>or</code> 2+ OR of all inputs <code>xor</code> 2+ XOR of all inputs <code>nand</code> 2+ NAND of all inputs <code>nor</code> 2+ NOR of all inputs <code>xnor</code> 2+ XNOR of all inputs <code>not</code> 1 Inversion <code>buf</code> 1 Buffer (no inversion) <p>Gate primitive syntax:</p> <pre><code>gate_type instance_name(output, input1, input2, ...);\n\n// Examples:\nand  my_and(y, a, b);        // y = a &amp; b\nor   my_or(y, a, b, c);      // y = a | b | c\nxor  my_xor(y, a, b);        // y = a ^ b\nnand my_nand(y, a, b, c, d); // y = ~(a &amp; b &amp; c &amp; d)\nnot  my_not(y, a);           // y = ~a\n</code></pre> <p>Gate primitives have these characteristics:</p> <ul> <li>Output first: The first port is always the output</li> <li>N-input gates: <code>and</code>, <code>or</code>, etc. can have any number of inputs</li> <li>Optional instance names: <code>and (y, a, b);</code> is legal</li> <li>Built-in timing: Can specify delays for simulation</li> </ul> <p>When to Use Gate-Level</p> <p>Gate-level modeling is rarely written by hand today\u2014behavioral Verilog is faster to write and less error-prone. However, you'll encounter gate-level Verilog in: - Netlists generated by synthesis tools - Timing simulation files - Libraries from foundries - Educational examples showing hardware correspondence</p>"},{"location":"chapters/13-verilog-modeling/#rtl-verilog-the-sweet-spot","title":"RTL Verilog: The Sweet Spot","text":"<p>RTL Verilog (Register Transfer Level) is the practical middle ground between high-level behavioral modeling and low-level gate primitives. It describes how data moves between registers through combinational logic.</p> <p>RTL is defined by:</p> <ol> <li>Registers: Sequential elements (flip-flops) that store state</li> <li>Combinational logic: Operations between registers</li> <li>Clock-driven updates: Registers update on clock edges</li> </ol> <pre><code>// RTL style: Clear register-to-register flow\nmodule rtl_example(\n    input        clk,\n    input        reset,\n    input  [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    reg [7:0] stage1, stage2;  // Pipeline registers\n\n    // Stage 1: Add constant\n    always @(posedge clk) begin\n        if (reset)\n            stage1 &lt;= 8'b0;\n        else\n            stage1 &lt;= data_in + 8'd10;\n    end\n\n    // Stage 2: Multiply by 2\n    always @(posedge clk) begin\n        if (reset)\n            stage2 &lt;= 8'b0;\n        else\n            stage2 &lt;= stage1 &lt;&lt; 1;\n    end\n\n    // Output stage\n    always @(posedge clk) begin\n        if (reset)\n            data_out &lt;= 8'b0;\n        else\n            data_out &lt;= stage2;\n    end\n\nendmodule\n</code></pre> <p>The RTL paradigm matches how synthesis tools work:</p> <ol> <li>Identify the registers (sequential always blocks)</li> <li>Extract the combinational logic between registers</li> <li>Map combinational logic to gates</li> <li>Map registers to flip-flops</li> <li>Connect everything with wires</li> </ol>"},{"location":"chapters/13-verilog-modeling/#diagram-rtl-datapath-visualization","title":"Diagram: RTL Datapath Visualization","text":"RTL Datapath Visualization <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine RTL designs by identifying the registers, combinational logic blocks, and data flow paths that define register-transfer-level descriptions.</p> <p>Instructional Rationale: Interactive pipeline diagram showing data moving through registers on each clock cycle makes the register-transfer model concrete and traceable.</p> <p>Canvas Layout:</p> <ul> <li>Top: Pipeline diagram with registers and combinational blocks</li> <li>Middle: Data values at each stage</li> <li>Bottom: Clock control and waveforms</li> <li>Side: Stage-by-stage view</li> </ul> <p>Interactive Elements:</p> <ul> <li>Input data entry</li> <li>Clock step button</li> <li>Watch data flow through pipeline</li> <li>Highlight current register updates</li> <li>Reset button</li> <li>Multi-cycle animation mode</li> </ul> <p>Data Visibility:</p> <ul> <li>Input value</li> <li>Each register's contents</li> <li>Combinational operations between registers</li> <li>Output value</li> <li>Pipeline latency demonstration</li> </ul> <p>Visual Style:</p> <ul> <li>Boxes for registers (blue)</li> <li>Clouds for combinational logic (yellow)</li> <li>Arrows for data flow</li> <li>Values displayed inside elements</li> <li>Clock edge animation</li> </ul> <p>Implementation: p5.js with pipeline simulation</p> <p>RTL is the standard for synthesizable design because it:</p> <ul> <li>Maps directly to hardware structures</li> <li>Is predictable (you know what you'll get)</li> <li>Works with all synthesis tools</li> <li>Scales to complex designs</li> </ul>"},{"location":"chapters/13-verilog-modeling/#hierarchical-design-divide-and-conquer","title":"Hierarchical Design: Divide and Conquer","text":"<p>Hierarchical Design organizes complex systems into nested modules, where each module contains instances of other modules. It's the fundamental principle of managing complexity in digital design.</p> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502      Top Level      \u2502\n                    \u2502    (System)         \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502               \u2502               \u2502\n         \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n         \u2502  CPU    \u2502    \u2502 Memory  \u2502    \u2502  I/O    \u2502\n         \u2502 Module  \u2502    \u2502 Module  \u2502    \u2502 Module  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502         \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u25bc\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510\n\u2502  ALU  \u2502 \u2502 Regs \u2502 \u2502Control\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits of hierarchical design:</p> <ul> <li>Complexity management: Divide big problems into smaller ones</li> <li>Reusability: Write once, instantiate many times</li> <li>Team collaboration: Different engineers own different modules</li> <li>Testing: Verify modules independently before integration</li> <li>Maintainability: Changes are localized to specific modules</li> </ul> <p>Example of hierarchical CPU design:</p> <pre><code>// Top-level module\nmodule simple_cpu(\n    input        clk,\n    input        reset,\n    input  [7:0] instruction,\n    output [7:0] result\n);\n    wire [7:0] alu_a, alu_b, alu_result;\n    wire [2:0] alu_op;\n    wire       reg_write;\n\n    // Instantiate sub-modules\n    register_file regs(\n        .clk(clk),\n        .reset(reset),\n        .write_en(reg_write),\n        .write_data(alu_result),\n        .read_data_a(alu_a),\n        .read_data_b(alu_b)\n    );\n\n    alu alu_unit(\n        .a(alu_a),\n        .b(alu_b),\n        .op(alu_op),\n        .result(alu_result)\n    );\n\n    control_unit ctrl(\n        .instruction(instruction),\n        .alu_op(alu_op),\n        .reg_write(reg_write)\n    );\n\n    assign result = alu_result;\nendmodule\n</code></pre>"},{"location":"chapters/13-verilog-modeling/#diagram-hierarchical-design-explorer","title":"Diagram: Hierarchical Design Explorer","text":"Hierarchical Design Explorer <p>Type: infographic</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Organize</p> <p>Learning Objective: Students will be able to organize complex designs hierarchically by understanding how modules contain instances of other modules, creating a tree structure of design components.</p> <p>Instructional Rationale: Interactive hierarchy tree with zoom and expand capabilities demonstrates how large designs are decomposed into manageable modules.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Expandable hierarchy tree</li> <li>Click to zoom into module details</li> <li>Breadcrumb navigation showing current location</li> <li>Side panel: Selected module code and ports</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click to expand/collapse modules</li> <li>Zoom into module to see internals</li> <li>Navigate up/down hierarchy</li> <li>Highlight signal paths through hierarchy</li> <li>Show instance count at each level</li> <li>Search for specific modules</li> </ul> <p>Data Visibility:</p> <ul> <li>Full hierarchy tree</li> <li>Module names and types</li> <li>Instance counts</li> <li>Port connections</li> <li>Signal paths</li> </ul> <p>Visual Style:</p> <ul> <li>Tree structure with connecting lines</li> <li>Color coding by module type</li> <li>Expandable nodes</li> <li>Breadcrumb navigation</li> <li>Module detail panel</li> </ul> <p>Implementation: p5.js with tree visualization</p> <p>Design hierarchy guidelines:</p> <ol> <li>Single responsibility: Each module does one thing well</li> <li>Clear interfaces: Ports should be well-defined and documented</li> <li>Reasonable size: Modules of 50-200 lines are typical</li> <li>Consistent naming: Use clear, descriptive module and port names</li> <li>Parameterization: Make modules configurable with parameters</li> </ol> <p>Think Like an Architect</p> <p>Before writing any Verilog, sketch your hierarchy on paper. Draw boxes for modules, arrows for connections. This \"architectural thinking\" saves hours of debugging later. The best designers spend more time planning than coding.</p>"},{"location":"chapters/13-verilog-modeling/#putting-it-all-together-a-complete-example","title":"Putting It All Together: A Complete Example","text":"<p>Let's build a complete design using multiple modeling styles\u2014a simple UART transmitter:</p> <pre><code>//----------------------------------------------\n// UART Transmitter - Mixed Modeling Example\n//----------------------------------------------\nmodule uart_tx #(\n    parameter CLK_FREQ = 50_000_000,\n    parameter BAUD     = 115200\n)(\n    input        clk,\n    input        reset,\n    input        start,\n    input  [7:0] data,\n    output reg   tx,\n    output reg   busy\n);\n\n    // Derived parameters\n    localparam CLKS_PER_BIT = CLK_FREQ / BAUD;\n    localparam CNT_WIDTH    = $clog2(CLKS_PER_BIT);\n\n    // State encoding\n    localparam IDLE  = 2'b00;\n    localparam START = 2'b01;\n    localparam DATA  = 2'b10;\n    localparam STOP  = 2'b11;\n\n    // Registers\n    reg [1:0]           state;\n    reg [CNT_WIDTH-1:0] clk_count;\n    reg [2:0]           bit_index;\n    reg [7:0]           tx_data;\n\n    // Combinational: Next state logic\n    reg [1:0] next_state;\n    always @(*) begin\n        next_state = state;  // Default: stay in current state\n        case (state)\n            IDLE:  if (start) next_state = START;\n            START: if (clk_count == CLKS_PER_BIT-1) next_state = DATA;\n            DATA:  if (clk_count == CLKS_PER_BIT-1 &amp;&amp; bit_index == 7)\n                       next_state = STOP;\n            STOP:  if (clk_count == CLKS_PER_BIT-1) next_state = IDLE;\n        endcase\n    end\n\n    // Sequential: State register and counters\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state     &lt;= IDLE;\n            clk_count &lt;= 0;\n            bit_index &lt;= 0;\n            tx_data   &lt;= 8'b0;\n            tx        &lt;= 1'b1;  // Idle high\n            busy      &lt;= 1'b0;\n        end else begin\n            state &lt;= next_state;\n\n            case (state)\n                IDLE: begin\n                    tx   &lt;= 1'b1;\n                    busy &lt;= 1'b0;\n                    if (start) begin\n                        tx_data   &lt;= data;\n                        clk_count &lt;= 0;\n                        busy      &lt;= 1'b1;\n                    end\n                end\n\n                START: begin\n                    tx &lt;= 1'b0;  // Start bit\n                    if (clk_count &lt; CLKS_PER_BIT-1)\n                        clk_count &lt;= clk_count + 1;\n                    else begin\n                        clk_count &lt;= 0;\n                        bit_index &lt;= 0;\n                    end\n                end\n\n                DATA: begin\n                    tx &lt;= tx_data[bit_index];\n                    if (clk_count &lt; CLKS_PER_BIT-1)\n                        clk_count &lt;= clk_count + 1;\n                    else begin\n                        clk_count &lt;= 0;\n                        if (bit_index &lt; 7)\n                            bit_index &lt;= bit_index + 1;\n                    end\n                end\n\n                STOP: begin\n                    tx &lt;= 1'b1;  // Stop bit\n                    if (clk_count &lt; CLKS_PER_BIT-1)\n                        clk_count &lt;= clk_count + 1;\n                    else\n                        clk_count &lt;= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Behavioral modeling: Always blocks for state machine logic</li> <li>Parameterization: Configurable clock frequency and baud rate</li> <li>RTL style: Clear separation of combinational and sequential logic</li> <li>State machines: Proper encoding and transitions</li> <li>Both assignment types: <code>=</code> in combinational, <code>&lt;=</code> in sequential</li> </ul>"},{"location":"chapters/13-verilog-modeling/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've graduated from Verilog basics to professional-level modeling techniques. Let's recap the essential points:</p> <p>Always Blocks and Sensitivity:</p> <ul> <li><code>always @(*)</code> for combinational logic (level-sensitive)</li> <li><code>always @(posedge clk)</code> for sequential logic (edge-sensitive)</li> <li><code>@(*)</code> automatically includes all read signals\u2014use it!</li> </ul> <p>The Assignment Golden Rules:</p> <ul> <li>Use <code>=</code> (blocking) in combinational always blocks</li> <li>Use <code>&lt;=</code> (non-blocking) in sequential always blocks</li> <li>Never mix them in the same block</li> <li>Non-blocking enables safe concurrent updates</li> </ul> <p>Decision Structures:</p> <ul> <li><code>if-else</code> creates priority-encoded logic</li> <li><code>case</code> creates parallel selection</li> <li>Always cover all cases to avoid latches</li> <li>Use <code>casez</code> for don't-care matching</li> </ul> <p>Modeling Styles:</p> <ul> <li>Structural: Instantiate and connect components</li> <li>Behavioral: Describe what, let tools figure out how</li> <li>Gate-level: Use primitive gates (rarely hand-written)</li> <li>RTL: The practical middle ground for synthesis</li> </ul> <p>Hierarchical Design:</p> <ul> <li>Divide complex systems into manageable modules</li> <li>Clear interfaces enable team collaboration</li> <li>Reuse modules through instantiation</li> <li>Test modules independently</li> </ul> <p>The Professional Mindset</p> <p>Real designers use all these techniques, mixing them appropriately. Use behavioral modeling for complex logic, structural instantiation for reusable components, and always think hierarchically. The best Verilog code is readable, synthesizable, and maintainable.</p> Graphic Novel Suggestion <p>A compelling graphic novel could follow the journey of a chip design team at a startup in the late 1990s, racing to tape out their first ASIC before funding runs dry. The protagonist, a young engineer fresh from university, must master RTL design under pressure while dealing with the classic tensions: simulation vs. synthesis mismatches, timing closure nightmares, and the eternal blocking vs. non-blocking debugging session at 3 AM. The dramatic climax comes when a critical bug is discovered days before tape-out\u2014traced back to a missing signal in a sensitivity list. The resolution shows the team adopting <code>@(*)</code> and better coding standards, transforming their chaotic codebase into a maintainable design that launches successfully.</p>"},{"location":"chapters/13-verilog-modeling/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Sensitivity List Debugging <p>What's wrong with this code, and how would you fix it? <pre><code>always @(a) begin\n    y = a &amp; b | c;\nend\n</code></pre></p> <p>Solution: The sensitivity list only includes <code>a</code>, but the block also reads <code>b</code> and <code>c</code>. In simulation, <code>y</code> won't update when <code>b</code> or <code>c</code> changes. Fix: <pre><code>always @(*) begin\n    y = a &amp; b | c;\nend\n</code></pre> Always use <code>@(*)</code> for combinational logic to automatically include all inputs.</p> Problem 2: Blocking vs Non-Blocking <p>What values will <code>a</code> and <code>b</code> have after the clock edge if they both start at 0 and <code>x=5</code>, <code>y=3</code>?</p> <p>Version A: <pre><code>always @(posedge clk) begin\n    a = x;\n    b = a + y;\nend\n</code></pre></p> <p>Version B: <pre><code>always @(posedge clk) begin\n    a &lt;= x;\n    b &lt;= a + y;\nend\n</code></pre></p> <p>Solution: - Version A (blocking): <code>a=5</code>, <code>b=8</code> (5+3). Blocking means <code>b</code> sees the new value of <code>a</code>. - Version B (non-blocking): <code>a=5</code>, <code>b=3</code> (0+3). Non-blocking means <code>b</code> sees the old value of <code>a</code>.</p> <p>Version B is the correct style for sequential logic, but produces different results!</p> Problem 3: Latch Detection <p>Will this code create a latch? If so, fix it. <pre><code>always @(*) begin\n    if (sel)\n        y = a;\n    else if (mode)\n        y = b;\nend\n</code></pre></p> <p>Solution: Yes, this creates a latch! When <code>sel=0</code> AND <code>mode=0</code>, <code>y</code> is not assigned, so it must retain its old value (latch behavior).</p> <p>Fix: <pre><code>always @(*) begin\n    if (sel)\n        y = a;\n    else if (mode)\n        y = b;\n    else\n        y = 1'b0;  // Default case\nend\n</code></pre></p> Problem 4: Case Statement Design <p>Write a Verilog module for a 3-to-8 decoder using a case statement. The output should have exactly one bit high based on the 3-bit input.</p> <p>Solution: <pre><code>module decoder_3to8(\n    input      [2:0] sel,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = 8'b00000001;\n        3'b001: out = 8'b00000010;\n        3'b010: out = 8'b00000100;\n        3'b011: out = 8'b00001000;\n        3'b100: out = 8'b00010000;\n        3'b101: out = 8'b00100000;\n        3'b110: out = 8'b01000000;\n        3'b111: out = 8'b10000000;\n        default: out = 8'b00000000;\n    endcase\nend\n\nendmodule\n</code></pre></p> Problem 5: Edge Type Selection <p>For each scenario, choose the appropriate sensitivity list:</p> <p>A) A flip-flop that captures data on rising clock edge B) A combinational MUX C) A flip-flop with asynchronous active-low reset D) An SR latch (level-sensitive)</p> <p>Solution: - A) <code>@(posedge clk)</code> - B) <code>@(*)</code> - C) <code>@(posedge clk or negedge reset_n)</code> - D) <code>@(s or r)</code> or <code>@(*)</code> \u2014 but note: SR latches are generally avoided in synthesis</p> Problem 6: Structural vs Behavioral <p>Write TWO versions of a 2-input XOR gate: one structural (using gates) and one behavioral.</p> <p>Solution: Structural: <pre><code>module xor_structural(input a, b, output y);\n    wire nota, notb, and1, and2;\n    not  g1(nota, a);\n    not  g2(notb, b);\n    and  g3(and1, a, notb);\n    and  g4(and2, nota, b);\n    or   g5(y, and1, and2);\nendmodule\n</code></pre></p> <p>Behavioral: <pre><code>module xor_behavioral(input a, b, output y);\n    assign y = a ^ b;\nendmodule\n</code></pre> Both synthesize to equivalent hardware, but behavioral is much simpler!</p> Problem 7: Complete Module Design <p>Design a 4-bit up/down counter with synchronous load and enable: - When <code>load=1</code>: Load <code>data_in</code> into counter - When <code>enable=1</code> and <code>up=1</code>: Count up - When <code>enable=1</code> and <code>up=0</code>: Count down - When <code>enable=0</code>: Hold current value</p> <p>Solution: <pre><code>module up_down_counter(\n    input        clk,\n    input        reset,\n    input        load,\n    input        enable,\n    input        up,\n    input  [3:0] data_in,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count &lt;= 4'b0;\n    else if (load)\n        count &lt;= data_in;\n    else if (enable) begin\n        if (up)\n            count &lt;= count + 1;\n        else\n            count &lt;= count - 1;\n    end\n    // else: count holds (implicit in sequential blocks)\nend\n\nendmodule\n</code></pre></p>"},{"location":"chapters/13-verilog-modeling/quiz/","title":"Quiz: Verilog Behavioral and Structural Modeling","text":"<p>Test your understanding of always blocks, assignments, modeling styles, and design abstraction levels.</p>"},{"location":"chapters/13-verilog-modeling/quiz/#1-what-determines-when-an-always-block-executes","title":"1. What determines when an always block executes?","text":"<ol> <li>The module instantiation order</li> <li>The sensitivity list specifying trigger conditions</li> <li>The compiler optimization settings</li> <li>The system clock frequency</li> </ol> Show Answer <p>The correct answer is B. The sensitivity list (@(...)) specifies which signal changes or events trigger the always block to execute. It can be level-sensitive (@(*) or @(a or b)) or edge-sensitive (@(posedge clk)).</p> <p>Concept Tested: Sensitivity List</p>"},{"location":"chapters/13-verilog-modeling/quiz/#2-what-is-the-key-difference-between-blocking-and-non-blocking-assignments","title":"2. What is the key difference between blocking (=) and non-blocking (&lt;=) assignments?","text":"<ol> <li>Blocking is faster in simulation</li> <li>Blocking updates immediately; non-blocking schedules updates for the end of the time step</li> <li>Non-blocking uses less hardware</li> <li>Blocking only works in initial blocks</li> </ol> Show Answer <p>The correct answer is B. Blocking (=) updates the variable immediately, so later statements see the new value. Non-blocking (&lt;=) schedules updates to happen simultaneously at the end of the time step, so all assignments see the old values.</p> <p>Concept Tested: Blocking Assignment</p>"},{"location":"chapters/13-verilog-modeling/quiz/#3-what-golden-rule-should-be-followed-for-assignment-types-in-always-blocks","title":"3. What golden rule should be followed for assignment types in always blocks?","text":"<ol> <li>Always use blocking for all assignments</li> <li>Use blocking (=) for combinational logic, non-blocking (&lt;=) for sequential logic</li> <li>Use non-blocking for all assignments</li> <li>Mix them freely based on preference</li> </ol> Show Answer <p>The correct answer is B. Use blocking (=) in combinational always blocks (@(*)) and non-blocking (&lt;=) in sequential always blocks (@(posedge clk)). Never mix them in the same block. This prevents race conditions and matches simulation to synthesis.</p> <p>Concept Tested: Non-Blocking Assignment</p>"},{"location":"chapters/13-verilog-modeling/quiz/#4-what-happens-if-you-dont-cover-all-cases-in-a-combinational-always-block","title":"4. What happens if you don't cover all cases in a combinational always block?","text":"<ol> <li>The compiler reports an error</li> <li>A latch is inferred to hold the previous value</li> <li>The output defaults to zero</li> <li>The block is optimized away</li> </ol> Show Answer <p>The correct answer is B. If any code path doesn't assign a value, synthesis infers a latch\u2014a level-sensitive memory element that holds the old value. This is almost always a bug. Always include default cases or else clauses.</p> <p>Concept Tested: If-Else in Verilog</p>"},{"location":"chapters/13-verilog-modeling/quiz/#5-when-is-a-case-statement-preferred-over-an-if-else-chain","title":"5. When is a case statement preferred over an if-else chain?","text":"<ol> <li>When testing one expression against multiple specific values</li> <li>When implementing priority logic</li> <li>When dealing with floating-point numbers</li> <li>When the conditions are interdependent</li> </ol> Show Answer <p>The correct answer is A. Case statements are ideal for checking one signal against multiple specific values (like opcodes or state encodings). They create parallel selection logic, while if-else creates priority-encoded logic.</p> <p>Concept Tested: Case Statement</p>"},{"location":"chapters/13-verilog-modeling/quiz/#6-what-does-in-a-sensitivity-list-mean","title":"6. What does @(*) in a sensitivity list mean?","text":"<ol> <li>Trigger on all clock edges</li> <li>Automatically include all signals read in the block</li> <li>Trigger on all output changes</li> <li>Disable the sensitivity list</li> </ol> Show Answer <p>The correct answer is B. The @(*) syntax (Verilog-2001) automatically includes all signals read within the block in the sensitivity list. This prevents bugs from forgetting signals and ensures simulation matches synthesis.</p> <p>Concept Tested: Combinational Always</p>"},{"location":"chapters/13-verilog-modeling/quiz/#7-what-keyword-detects-a-rising-clock-edge-in-a-sequential-always-block","title":"7. What keyword detects a rising clock edge in a sequential always block?","text":"<ol> <li>rising</li> <li>posedge</li> <li>clockup</li> <li>positive</li> </ol> Show Answer <p>The correct answer is B. The posedge keyword specifies a positive (rising) edge trigger\u2014when the signal transitions from 0 to 1. It's the standard trigger for synchronous sequential logic: always @(posedge clk).</p> <p>Concept Tested: Posedge Keyword</p>"},{"location":"chapters/13-verilog-modeling/quiz/#8-what-is-structural-modeling-in-verilog","title":"8. What is structural modeling in Verilog?","text":"<ol> <li>Using comments to document the structure</li> <li>Describing a circuit by instantiating and connecting lower-level components</li> <li>Writing code that compiles faster</li> <li>Organizing files in a directory structure</li> </ol> Show Answer <p>The correct answer is B. Structural modeling explicitly describes a circuit by instantiating components (gates or modules) and connecting their ports with wires. It provides precise control over what hardware is generated.</p> <p>Concept Tested: Structural Modeling</p>"},{"location":"chapters/13-verilog-modeling/quiz/#9-what-characterizes-rtl-register-transfer-level-verilog","title":"9. What characterizes RTL (Register Transfer Level) Verilog?","text":"<ol> <li>It only uses gate primitives</li> <li>It describes data moving between registers through combinational logic</li> <li>It cannot be synthesized</li> <li>It requires a specific vendor's tools</li> </ol> Show Answer <p>The correct answer is B. RTL Verilog describes systems in terms of registers (storage), combinational logic (operations), and clock-driven transfers. It's the practical abstraction level for synthesizable design, matching how synthesis tools work.</p> <p>Concept Tested: RTL Verilog</p>"},{"location":"chapters/13-verilog-modeling/quiz/#10-what-is-the-main-benefit-of-hierarchical-design-in-verilog","title":"10. What is the main benefit of hierarchical design in Verilog?","text":"<ol> <li>Faster simulation speed</li> <li>Managing complexity through modular decomposition and reuse</li> <li>Smaller file sizes</li> <li>Automatic documentation generation</li> </ol> Show Answer <p>The correct answer is B. Hierarchical design divides complex systems into manageable modules, enables reuse of verified components, allows team collaboration, and supports independent testing. It's essential for any non-trivial design.</p> <p>Concept Tested: Hierarchical Design</p>"},{"location":"chapters/14-testbenches-simulation/","title":"Testbenches and Simulation","text":""},{"location":"chapters/14-testbenches-simulation/#summary","title":"Summary","text":"<p>This chapter covers the verification side of digital design, teaching students to validate their Verilog designs through simulation before hardware implementation. Students will learn to create testbenches, generate stimulus including clock signals and test vectors, build self-checking testbenches for automated verification, run simulations, and interpret results using waveform viewers for debugging. The chapter also covers the synthesis process, distinguishing between synthesizable and non-synthesizable code constructs, preparing students for FPGA implementation.</p>"},{"location":"chapters/14-testbenches-simulation/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 12 concepts from the learning graph:</p> <ol> <li>Testbench</li> <li>Stimulus Generation</li> <li>Clock Generation</li> <li>Test Vector</li> <li>Self-Checking Testbench</li> <li>Simulation</li> <li>Simulation Time</li> <li>Waveform Viewer</li> <li>Debugging Waveforms</li> <li>Synthesis</li> <li>Synthesizable Code</li> <li>Non-Synthesizable Code</li> </ol>"},{"location":"chapters/14-testbenches-simulation/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 12: Verilog HDL Fundamentals</li> <li>Chapter 13: Verilog Behavioral and Structural Modeling</li> </ul>"},{"location":"chapters/14-testbenches-simulation/#introduction-trust-but-verify","title":"Introduction: Trust, But Verify","text":"<p>Here's a sobering thought: even the world's best digital designers make mistakes. The difference between professionals and amateurs isn't that professionals never introduce bugs\u2014it's that they find those bugs before the silicon is cast in stone (or rather, cast in billions of tiny transistors).</p> <p>In software, a bug means a patch, an update, a \"please restart your application.\" In hardware, a bug discovered after manufacturing can mean millions of dollars in recalls, months of delays, or a very expensive doorstop. That's why verification\u2014proving that your design actually does what you intended\u2014consumes more than half of the engineering effort in professional chip design.</p> <p>Welcome to the world of testbenches and simulation, where paranoia is a virtue!</p> <p>Think of simulation as a dress rehearsal for your hardware. The design hasn't been built yet\u2014it exists only as Verilog code\u2014but the simulator pretends to execute it, cycle by cycle, checking whether it behaves correctly. If something goes wrong, you fix it in code rather than explaining to management why the chip needs a \"metal spin.\"</p> <p>This chapter teaches you to become your own worst critic. You'll learn to:</p> <ul> <li>Create testbenches that exercise every corner of your design</li> <li>Generate realistic stimulus patterns automatically</li> <li>Build self-checking systems that catch bugs without human intervention</li> <li>Read and debug waveform displays like a pro</li> <li>Understand what can be synthesized into hardware and what can't</li> </ul> <p>By the end, you'll have the skills to say with confidence: \"Yes, I tested that. Thoroughly.\"</p> <p>Let's make sure your designs work before they become hardware.</p>"},{"location":"chapters/14-testbenches-simulation/#what-is-a-testbench","title":"What Is a Testbench?","text":"<p>A Testbench is a Verilog module that provides stimulus to your design-under-test (DUT) and observes its outputs. Unlike synthesizable design modules, testbenches exist purely for verification\u2014they're the scaffolding that lets you exercise and examine your circuit before it becomes real hardware.</p> <p>Think of a testbench like a test fixture for electronics. If you've ever used a breadboard to test an IC by connecting it to switches, buttons, and LEDs, you've essentially built a physical testbench. A Verilog testbench is the same concept, but in simulation\u2014you provide inputs, watch outputs, and decide if the behavior is correct.</p> <p>Here's a minimal testbench structure:</p> <pre><code>module my_design_tb;  // No ports! Testbenches are self-contained\n\n    // Declare signals to connect to DUT\n    reg  clk;\n    reg  reset;\n    reg  [7:0] data_in;\n    wire [7:0] data_out;\n\n    // Instantiate the Device Under Test\n    my_design dut(\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Generate clock\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;  // 100 MHz clock\n    end\n\n    // Apply stimulus\n    initial begin\n        // Initialize inputs\n        reset = 1;\n        data_in = 8'h00;\n\n        // Release reset after some time\n        #20 reset = 0;\n\n        // Apply test patterns\n        #10 data_in = 8'hAB;\n        #10 data_in = 8'hCD;\n        #10 data_in = 8'hEF;\n\n        // End simulation\n        #100 $finish;\n    end\n\nendmodule\n</code></pre> <p>Key characteristics of testbenches:</p> <ul> <li>No port list: Testbenches are top-level modules with no external connections</li> <li>reg for inputs: Signals driving the DUT are declared as <code>reg</code> (because we assign them procedurally)</li> <li>wire for outputs: Signals coming from the DUT are <code>wire</code> (because the DUT drives them)</li> <li>Not synthesizable: Testbenches use constructs that only work in simulation</li> </ul> <p>The DUT Convention</p> <p>By convention, we name the instantiated design <code>dut</code> (Device Under Test) or <code>uut</code> (Unit Under Test). This makes it clear which module is being tested versus which is doing the testing.</p>"},{"location":"chapters/14-testbenches-simulation/#diagram-testbench-architecture","title":"Diagram: Testbench Architecture","text":"Testbench Architecture Visualization <p>Type: infographic</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain the relationship between a testbench and the device under test, understanding how stimulus flows into the DUT and responses flow out to verification logic.</p> <p>Instructional Rationale: Interactive block diagram showing testbench components (stimulus generator, DUT, response checker) with data flow arrows makes the testbench structure tangible.</p> <p>Canvas Layout:</p> <ul> <li>Center: DUT block with ports</li> <li>Left: Stimulus generator block</li> <li>Right: Response checker block</li> <li>Bottom: Shared clock generator</li> <li>Arrows showing signal flow</li> </ul> <p>Interactive Elements:</p> <ul> <li>Hover over components to see descriptions</li> <li>Click to highlight signal paths</li> <li>Show/hide internal details</li> <li>Animation mode showing stimulus flow</li> <li>Toggle between simple and self-checking testbench views</li> </ul> <p>Data Visibility:</p> <ul> <li>Component roles and responsibilities</li> <li>Signal connections between blocks</li> <li>Input/output relationships</li> <li>Verification flow</li> </ul> <p>Visual Style:</p> <ul> <li>Block diagram with clear boundaries</li> <li>Directional arrows for signal flow</li> <li>Color coding (blue=stimulus, green=DUT, red=checker)</li> <li>Clean, professional appearance</li> <li>Responsive to window resize</li> </ul> <p>Implementation: p5.js with interactive block diagram</p> <p>The typical testbench flow is:</p> <ol> <li>Initialize: Set all inputs to known values</li> <li>Reset: Assert reset to put DUT in known state</li> <li>Stimulate: Apply input patterns over time</li> <li>Observe: Watch outputs (manually or automatically)</li> <li>Complete: End simulation when testing is done</li> </ol>"},{"location":"chapters/14-testbenches-simulation/#stimulus-generation-feeding-the-beast","title":"Stimulus Generation: Feeding the Beast","text":"<p>Stimulus Generation is the art of creating input patterns that thoroughly exercise your design. Good stimulus covers normal operation, edge cases, error conditions, and corner cases\u2014basically, anything that might reveal a bug.</p> <p>There are several approaches to generating stimulus:</p> <p>Direct assignment (simplest): <pre><code>initial begin\n    data = 8'h00;\n    #10 data = 8'h55;\n    #10 data = 8'hAA;\n    #10 data = 8'hFF;\nend\n</code></pre></p> <p>Loops (for repetitive patterns): <pre><code>initial begin\n    for (i = 0; i &lt; 256; i = i + 1) begin\n        data = i;\n        #10;  // Wait between values\n    end\nend\n</code></pre></p> <p>Random values (for broader coverage): <pre><code>initial begin\n    repeat (100) begin\n        data = $random;  // Random 32-bit value\n        #10;\n    end\nend\n</code></pre></p> <p>File-based (for complex or recorded patterns): <pre><code>initial begin\n    $readmemh(\"test_vectors.hex\", test_data);\n    for (i = 0; i &lt; TEST_COUNT; i = i + 1) begin\n        data = test_data[i];\n        #10;\n    end\nend\n</code></pre></p> <p>Good stimulus generation follows these principles:</p> Principle Description Example Start known Begin from a defined state Assert reset first Cover boundaries Test at value limits 0, 1, max-1, max Exercise transitions Test state changes All FSM transitions Include invalid Test error handling Out-of-range inputs Be reproducible Same tests, same results Use seed for random <p>The 80/20 Rule of Testing</p> <p>80% of bugs are found by testing boundary conditions and transitions. Don't just test \"happy path\" scenarios\u2014test what happens when inputs are 0, maximum value, or change rapidly.</p> <p>Here's a more comprehensive stimulus example for an 8-bit counter:</p> <pre><code>initial begin\n    // Initialize\n    reset = 1;\n    enable = 0;\n    load = 0;\n    load_value = 8'h00;\n\n    // Test 1: Reset behavior\n    #20 reset = 0;\n\n    // Test 2: Enable counting\n    #10 enable = 1;\n    #100;  // Let it count for a while\n\n    // Test 3: Disable should hold value\n    enable = 0;\n    #50;  // Verify count doesn't change\n\n    // Test 4: Load functionality\n    load = 1;\n    load_value = 8'hFE;  // Near max\n    #10 load = 0;\n\n    // Test 5: Rollover at max\n    enable = 1;\n    #50;  // Should roll over from FF to 00\n\n    // Test 6: Reset during operation\n    #10 reset = 1;\n    #10 reset = 0;\n\n    #50 $finish;\nend\n</code></pre>"},{"location":"chapters/14-testbenches-simulation/#diagram-stimulus-pattern-generator","title":"Diagram: Stimulus Pattern Generator","text":"Stimulus Pattern Generator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how different stimulus generation techniques produce different input patterns by comparing direct assignment, loops, and random generation.</p> <p>Instructional Rationale: Interactive comparison of stimulus methods with visible pattern output shows the trade-offs between simplicity, coverage, and reproducibility.</p> <p>Canvas Layout:</p> <ul> <li>Left: Stimulus method selector (tabs)</li> <li>Center: Generated pattern visualization</li> <li>Right: Pattern statistics (coverage, unique values)</li> <li>Bottom: Verilog code for selected method</li> </ul> <p>Interactive Elements:</p> <ul> <li>Tab selection for method type</li> <li>Play/pause pattern generation</li> <li>Speed control for animation</li> <li>Reset to regenerate patterns</li> <li>Coverage histogram display</li> <li>Export pattern capability</li> </ul> <p>Data Visibility:</p> <ul> <li>Generated values over time</li> <li>Coverage percentage</li> <li>Repetition detection</li> <li>Pattern characteristics</li> <li>Corresponding Verilog code</li> </ul> <p>Visual Style:</p> <ul> <li>Value display as scrolling list</li> <li>Histogram of value distribution</li> <li>Color gradient for value magnitude</li> <li>Code panel with syntax highlighting</li> <li>Responsive layout</li> </ul> <p>Implementation: p5.js with multiple generation engines</p>"},{"location":"chapters/14-testbenches-simulation/#clock-generation-the-heartbeat","title":"Clock Generation: The Heartbeat","text":"<p>Clock Generation creates the clock signal that synchronizes all sequential logic in your design. Since clocks don't exist in the real world until you create them, your testbench must generate them.</p> <p>The classic clock generation pattern:</p> <pre><code>initial begin\n    clk = 0;\n    forever #5 clk = ~clk;  // Toggle every 5 time units\nend\n</code></pre> <p>This creates a clock with a period of 10 time units (5 high + 5 low).</p> <p>For more control over clock characteristics:</p> <pre><code>parameter CLK_PERIOD = 10;  // 10ns period = 100 MHz\n\ninitial begin\n    clk = 0;\n    forever #(CLK_PERIOD/2) clk = ~clk;\nend\n</code></pre> <p>You can also create clocks with non-50% duty cycles:</p> <pre><code>// 60% duty cycle clock\ninitial begin\n    clk = 0;\n    forever begin\n        #6 clk = 1;  // High for 6 time units\n        #4 clk = 0;  // Low for 4 time units\n    end\nend\n</code></pre> <p>Multiple clocks at different frequencies:</p> <pre><code>// Fast clock: 100 MHz\ninitial begin\n    clk_fast = 0;\n    forever #5 clk_fast = ~clk_fast;\nend\n\n// Slow clock: 10 MHz\ninitial begin\n    clk_slow = 0;\n    forever #50 clk_slow = ~clk_slow;\nend\n</code></pre> <p>Clock and Data Alignment</p> <p>Be careful about the timing relationship between your clock and data changes. Changing data exactly at the clock edge can cause race conditions in simulation. Best practice: change data slightly after the clock edge or use non-blocking assignments.</p> <p>A robust pattern that avoids race conditions:</p> <pre><code>initial begin\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\n// Change data after clock edge, not exactly at it\ninitial begin\n    reset = 1;\n    @(posedge clk);  // Wait for clock edge\n    #1;              // Small delay after edge\n    reset = 0;       // Now change data\n\n    @(posedge clk);\n    #1;\n    data = 8'hAB;\nend\n</code></pre>"},{"location":"chapters/14-testbenches-simulation/#diagram-clock-waveform-generator","title":"Diagram: Clock Waveform Generator","text":"Clock Waveform Generator <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use different clock generation parameters to create clocks with specific frequencies, duty cycles, and phases.</p> <p>Instructional Rationale: Interactive clock generator with adjustable parameters and real-time waveform display makes clock timing relationships concrete.</p> <p>Canvas Layout:</p> <ul> <li>Top: Waveform display showing generated clock</li> <li>Middle: Parameter controls (period, duty cycle, phase)</li> <li>Bottom: Generated Verilog code</li> </ul> <p>Interactive Elements:</p> <ul> <li>Sliders for period, duty cycle, phase</li> <li>Frequency calculator (period \u2194 frequency)</li> <li>Multiple clock mode (add second clock)</li> <li>Show timing measurements</li> <li>Copy Verilog code button</li> </ul> <p>Data Visibility:</p> <ul> <li>Clock waveform with timing markers</li> <li>Calculated frequency</li> <li>Duty cycle percentage</li> <li>Phase relationship (if two clocks)</li> <li>Generated Verilog code</li> </ul> <p>Visual Style:</p> <ul> <li>Clean waveform display</li> <li>Measurement annotations</li> <li>Real-time update on parameter change</li> <li>Professional timing diagram appearance</li> <li>Responsive canvas</li> </ul> <p>Implementation: p5.js with parametric clock generation</p>"},{"location":"chapters/14-testbenches-simulation/#test-vectors-organized-test-data","title":"Test Vectors: Organized Test Data","text":"<p>A Test Vector is a specific set of input values along with the expected output values for those inputs. Test vectors organize your test cases into a structured format that can be applied systematically and verified automatically.</p> <p>Simple test vectors in Verilog:</p> <pre><code>// Test vectors for a 2-bit adder: {a, b, expected_sum}\nreg [5:0] test_vectors [0:8];\n\ninitial begin\n    test_vectors[0] = {2'b00, 2'b00, 2'b00};  // 0 + 0 = 0\n    test_vectors[1] = {2'b00, 2'b01, 2'b01};  // 0 + 1 = 1\n    test_vectors[2] = {2'b01, 2'b00, 2'b01};  // 1 + 0 = 1\n    test_vectors[3] = {2'b01, 2'b01, 2'b10};  // 1 + 1 = 2\n    test_vectors[4] = {2'b10, 2'b01, 2'b11};  // 2 + 1 = 3\n    test_vectors[5] = {2'b11, 2'b00, 2'b11};  // 3 + 0 = 3\n    test_vectors[6] = {2'b11, 2'b01, 2'b00};  // 3 + 1 = 4 (overflow!)\n    test_vectors[7] = {2'b11, 2'b11, 2'b10};  // 3 + 3 = 6 (overflow!)\nend\n</code></pre> <p>Loading test vectors from a file is cleaner for large test suites:</p> <pre><code>// test_vectors.hex contains:\n// 00_00_00\n// 00_01_01\n// 01_01_02\n// ...\n\nreg [5:0] test_vectors [0:255];\ninitial $readmemh(\"test_vectors.hex\", test_vectors);\n</code></pre> <p>Applying test vectors systematically:</p> <pre><code>integer i;\nreg [1:0] a_test, b_test, expected_sum;\n\ninitial begin\n    for (i = 0; i &lt; 8; i = i + 1) begin\n        // Extract test vector components\n        a_test = test_vectors[i][5:4];\n        b_test = test_vectors[i][3:2];\n        expected_sum = test_vectors[i][1:0];\n\n        // Apply inputs\n        a = a_test;\n        b = b_test;\n\n        // Wait for combinational logic to settle\n        #5;\n\n        // Check result\n        if (sum !== expected_sum) begin\n            $display(\"ERROR: a=%d, b=%d, expected=%d, got=%d\",\n                     a_test, b_test, expected_sum, sum);\n        end\n    end\n\n    $display(\"Test complete!\");\n    $finish;\nend\n</code></pre> <p>Benefits of test vectors:</p> <ul> <li>Organized: All test cases in one place</li> <li>Reusable: Can share vectors between testbenches</li> <li>Maintainable: Easy to add new test cases</li> <li>Portable: Can be generated by external tools</li> <li>Documented: The vector file itself documents expected behavior</li> </ul> <p>Golden Reference Model</p> <p>A common practice is to generate test vectors using a software reference model (in Python, C, etc.) that computes the expected outputs. This \"golden model\" can produce thousands of test cases automatically, which you then verify against your Verilog implementation.</p>"},{"location":"chapters/14-testbenches-simulation/#self-checking-testbenches-automation-is-your-friend","title":"Self-Checking Testbenches: Automation Is Your Friend","text":"<p>A Self-Checking Testbench automatically verifies that the DUT produces correct outputs, reporting errors without human intervention. This is the difference between \"I looked at the waveforms and they seemed right\" and \"I verified 10,000 test cases and they all passed.\"</p> <p>The key insight: instead of manually examining waveforms, embed the expected behavior in the testbench itself.</p> <p>Basic self-checking pattern:</p> <pre><code>// Check after each test\ninitial begin\n    // Apply test\n    a = 8'h05;\n    b = 8'h03;\n    #10;\n\n    // Automatic check\n    if (sum !== 8'h08) begin\n        $display(\"FAIL: 5 + 3 should be 8, got %d\", sum);\n        error_count = error_count + 1;\n    end else begin\n        $display(\"PASS: 5 + 3 = 8\");\n    end\nend\n</code></pre> <p>More sophisticated self-checking with a reference model:</p> <pre><code>// Reference model function\nfunction [7:0] expected_alu_result;\n    input [7:0] a, b;\n    input [2:0] op;\n    begin\n        case (op)\n            3'b000: expected_alu_result = a + b;\n            3'b001: expected_alu_result = a - b;\n            3'b010: expected_alu_result = a &amp; b;\n            3'b011: expected_alu_result = a | b;\n            3'b100: expected_alu_result = a ^ b;\n            default: expected_alu_result = 8'h00;\n        endcase\n    end\nendfunction\n\n// Self-checking test loop\ninteger i, errors;\ninitial begin\n    errors = 0;\n\n    for (i = 0; i &lt; 1000; i = i + 1) begin\n        // Random test inputs\n        a_in = $random;\n        b_in = $random;\n        op_in = $random % 5;\n        #10;\n\n        // Compare against reference\n        if (result !== expected_alu_result(a_in, b_in, op_in)) begin\n            $display(\"ERROR at time %0t: a=%h, b=%h, op=%d\",\n                     $time, a_in, b_in, op_in);\n            $display(\"  Expected: %h, Got: %h\",\n                     expected_alu_result(a_in, b_in, op_in), result);\n            errors = errors + 1;\n        end\n    end\n\n    // Final report\n    if (errors == 0)\n        $display(\"SUCCESS: All 1000 tests passed!\");\n    else\n        $display(\"FAILED: %d errors detected\", errors);\n\n    $finish;\nend\n</code></pre>"},{"location":"chapters/14-testbenches-simulation/#diagram-self-checking-testbench-flow","title":"Diagram: Self-Checking Testbench Flow","text":"Self-Checking Testbench Flow <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare DUT outputs against expected values automatically, understanding how self-checking testbenches detect and report errors.</p> <p>Instructional Rationale: Animated testbench execution showing stimulus application, output capture, comparison, and pass/fail reporting demonstrates the complete verification loop.</p> <p>Canvas Layout:</p> <ul> <li>Top: Stimulus generator block</li> <li>Center: DUT with inputs and outputs</li> <li>Right: Reference model computing expected values</li> <li>Bottom: Comparator with pass/fail indicators</li> <li>Side: Error log display</li> </ul> <p>Interactive Elements:</p> <ul> <li>Step through test vectors one at a time</li> <li>Run all tests automatically</li> <li>Inject error into DUT (to see failure detection)</li> <li>View error log</li> <li>Statistics display (pass/fail counts)</li> <li>Reset and rerun</li> </ul> <p>Data Visibility:</p> <ul> <li>Current test vector</li> <li>Applied inputs</li> <li>DUT outputs</li> <li>Expected outputs</li> <li>Comparison result (pass/fail)</li> <li>Running totals</li> </ul> <p>Visual Style:</p> <ul> <li>Flow diagram with animated data movement</li> <li>Green checks for pass, red X for fail</li> <li>Progress bar for test completion</li> <li>Error highlighting</li> <li>Professional verification theme</li> </ul> <p>Implementation: p5.js with comparison engine and logging</p> <p>Elements of a professional self-checking testbench:</p> Element Purpose Example Error counter Track total failures <code>integer errors = 0;</code> Test counter Track coverage <code>integer tests = 0;</code> Timestamps Locate failures <code>$display(\"Time %0t:\", $time);</code> Verbose mode Detailed output for debugging <code>if (VERBOSE) $display(...);</code> Summary report Overall pass/fail Print at <code>$finish</code> <p>The Professional Standard</p> <p>In industry, designs are often verified with millions of test cycles. No human can check that many waveforms manually. Self-checking testbenches are not optional\u2014they're essential for any serious verification effort.</p>"},{"location":"chapters/14-testbenches-simulation/#simulation-running-your-design-without-hardware","title":"Simulation: Running Your Design (Without Hardware)","text":"<p>Simulation is the process of executing your Verilog code in a software environment that mimics hardware behavior. The simulator processes your design and testbench, computing signal values at each moment in simulated time.</p> <p>The simulation process:</p> <ol> <li>Compile: Parse Verilog files and build internal representation</li> <li>Elaborate: Instantiate all modules and resolve hierarchies</li> <li>Initialize: Set all signals to their starting values</li> <li>Execute: Process events in time order until simulation ends</li> <li>Report: Generate output files and waveform data</li> </ol> <p>Common Verilog simulators:</p> Simulator Vendor Notes ModelSim/Questa Siemens (Mentor) Industry standard, powerful VCS Synopsys High performance Xcelium Cadence Advanced features Icarus Verilog Open source Free, good for learning Verilator Open source Very fast, converts to C++ Vivado Simulator AMD (Xilinx) Built into Vivado <p>Running a simulation typically looks like:</p> <pre><code># Icarus Verilog example\niverilog -o sim.out design.v testbench.v\nvvp sim.out\n\n# ModelSim example\nvlog design.v testbench.v\nvsim work.testbench\nrun -all\n</code></pre> <p>The simulator executes concurrent processes (always blocks, continuous assignments) by processing events at each moment in time. When a signal changes, all processes sensitive to that signal are evaluated, potentially creating new events.</p> <p>Simulation Is Not Reality</p> <p>Simulation is an approximation of hardware behavior. Real hardware has physical delays, noise, temperature effects, and manufacturing variations that simulators ignore. A design that simulates perfectly might still fail in hardware due to timing issues. That's why we also have timing simulation with real delay values\u2014but that comes later in the design flow.</p> <p>Key simulation concepts:</p> <ul> <li>Event: A signal value change at a specific time</li> <li>Delta cycle: Time advances in infinitesimal steps to handle concurrent updates</li> <li>Blocking: Some constructs pause until a condition is met</li> <li>Timescale: Defines the unit of time (e.g., 1ns/1ps)</li> </ul> <p>Setting the timescale:</p> <pre><code>`timescale 1ns/1ps  // Time unit is 1ns, precision is 1ps\n\nmodule testbench;\n    initial begin\n        #10.5;  // Wait 10.5 nanoseconds\n        $display(\"Time is %0t\", $time);  // Prints \"Time is 10500\"\n    end\nendmodule\n</code></pre>"},{"location":"chapters/14-testbenches-simulation/#simulation-time-understanding-the-delay","title":"Simulation Time: Understanding the <code>#</code> Delay","text":"<p>Simulation Time is the virtual clock that advances during simulation. It's controlled by delay statements (<code>#</code>) and wait statements (<code>@</code>), and it has no relationship to how long the simulation takes to run on your computer.</p> <p>The <code>#</code> delay operator suspends execution for a specified number of time units:</p> <pre><code>initial begin\n    a = 0;     // Time 0\n    #10 a = 1; // Time 10\n    #5 a = 0;  // Time 15\n    #20 a = 1; // Time 35\nend\n</code></pre> <p>Multiple processes advance in parallel:</p> <pre><code>// Process 1\ninitial begin\n    x = 0;\n    #10 x = 1;\n    #10 x = 0;\nend\n\n// Process 2 (runs simultaneously!)\ninitial begin\n    y = 0;\n    #15 y = 1;\n    #5 y = 0;\nend\n</code></pre> <p>At each time step, the simulator:</p> <ol> <li>Executes all statements that are ready at this time</li> <li>Processes any resulting signal changes</li> <li>Advances time to the next scheduled event</li> </ol>"},{"location":"chapters/14-testbenches-simulation/#diagram-simulation-time-visualization","title":"Diagram: Simulation Time Visualization","text":"Simulation Time Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain how simulation time advances through delay statements and concurrent process execution.</p> <p>Instructional Rationale: Animated timeline showing multiple initial blocks advancing in parallel with delay annotations demonstrates the concurrent-yet-ordered nature of simulation.</p> <p>Canvas Layout:</p> <ul> <li>Top: Timeline with time markers</li> <li>Center: Multiple process tracks (like Gantt chart)</li> <li>Bottom: Current simulation time display</li> <li>Side: Event queue visualization</li> </ul> <p>Interactive Elements:</p> <ul> <li>Step forward in time</li> <li>Continuous play mode with speed control</li> <li>Pause at interesting moments</li> <li>Highlight current executing process</li> <li>Show event queue contents</li> <li>Reset to time 0</li> </ul> <p>Data Visibility:</p> <ul> <li>Current simulation time</li> <li>Each process's current statement</li> <li>Delay values between events</li> <li>Concurrent execution visualization</li> <li>Event queue contents</li> </ul> <p>Visual Style:</p> <ul> <li>Timeline with tick marks</li> <li>Process bars showing execution</li> <li>Delay annotations as arrows</li> <li>Current time as moving cursor</li> <li>Color coding for different processes</li> </ul> <p>Implementation: p5.js with discrete event simulation</p> <p>Important timing system tasks:</p> Task Purpose Example <code>$time</code> Current simulation time <code>$display(\"Time: %0t\", $time);</code> <code>$realtime</code> Time as real number <code>$display(\"Time: %0f\", $realtime);</code> <code>$finish</code> End simulation <code>#1000 $finish;</code> <code>$stop</code> Pause simulation <code>if (error) $stop;</code> <p>The wait statement (<code>@</code>) suspends until an event:</p> <pre><code>initial begin\n    @(posedge clk);    // Wait for rising edge\n    data = 8'hAB;\n    @(negedge reset);  // Wait for reset falling edge\n    @(done);           // Wait for any change on 'done'\nend\n</code></pre> <p>Combining delay and events:</p> <pre><code>initial begin\n    reset = 1;\n    #20;                    // Wait 20 time units\n    reset = 0;\n    @(posedge clk);         // Wait for clock edge\n    #1;                     // Small delay after edge\n    data = 8'hFF;\n    repeat(10) @(posedge clk);  // Wait for 10 clock cycles\n    $finish;\nend\n</code></pre>"},{"location":"chapters/14-testbenches-simulation/#waveform-viewer-seeing-is-believing","title":"Waveform Viewer: Seeing Is Believing","text":"<p>A Waveform Viewer displays signal values over time as graphical traces, allowing you to visualize how your design behaves during simulation. It's the oscilloscope of the simulation world.</p> <p>Waveform viewers show:</p> <ul> <li>Digital signals: Square waves transitioning between 0 and 1</li> <li>Multi-bit buses: Values as hex or decimal numbers</li> <li>Analog-style: Stepped plots for data values</li> <li>Hierarchical navigation: Browse into module instances</li> <li>Time cursors: Measure timing relationships</li> </ul> <p>To generate waveform data, your testbench typically includes:</p> <pre><code>initial begin\n    $dumpfile(\"simulation.vcd\");  // Output file name\n    $dumpvars(0, testbench);      // Dump all signals in testbench hierarchy\nend\n</code></pre> <p>The <code>$dumpvars</code> parameters control what gets captured:</p> Syntax Effect <code>$dumpvars(0, tb)</code> All signals in tb and all sub-modules <code>$dumpvars(1, tb)</code> Only signals directly in tb <code>$dumpvars(0, tb.dut)</code> All signals in dut and sub-modules <code>$dumpvars(0, tb.dut.alu)</code> Just the alu sub-module <p>Common waveform viewers:</p> <ul> <li>GTKWave: Free, open source, widely used</li> <li>ModelSim/Questa: Built into simulator</li> <li>Vivado Simulator: Integrated viewer</li> <li>WaveTrace: VS Code extension</li> <li>Surfer: Modern open source viewer</li> </ul>"},{"location":"chapters/14-testbenches-simulation/#diagram-waveform-viewer-interface","title":"Diagram: Waveform Viewer Interface","text":"Waveform Viewer Interface <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use waveform viewer features including zoom, pan, cursors, and signal selection to analyze simulation results.</p> <p>Instructional Rationale: Interactive waveform display with standard viewer controls teaches the mental model of waveform analysis that transfers to professional tools.</p> <p>Canvas Layout:</p> <ul> <li>Left: Signal list with hierarchy</li> <li>Center: Waveform display area</li> <li>Bottom: Time axis with zoom control</li> <li>Top: Toolbar with navigation buttons</li> <li>Side: Measurement display</li> </ul> <p>Interactive Elements:</p> <ul> <li>Zoom in/out on time axis</li> <li>Pan left/right</li> <li>Add/remove signals from view</li> <li>Place cursors for measurements</li> <li>Hover for value at time</li> <li>Click to select time point</li> <li>Expand bus signals to bits</li> </ul> <p>Data Visibility:</p> <ul> <li>Signal names and values</li> <li>Time cursor positions</li> <li>Delta between cursors</li> <li>Value at cursor time</li> <li>Signal transitions</li> <li>Bus values in hex/decimal</li> </ul> <p>Visual Style:</p> <ul> <li>Classic waveform viewer appearance</li> <li>Green/red for 1/0 values</li> <li>Yellow for unknown (X)</li> <li>Blue for high-impedance (Z)</li> <li>Professional, tool-like interface</li> <li>Responsive to window resize</li> </ul> <p>Implementation: p5.js with VCD parser and waveform rendering</p> <p>Typical waveform analysis tasks:</p> <ol> <li>Verify timing: Check setup/hold relationships</li> <li>Trace signals: Follow data through pipeline stages</li> <li>Find glitches: Look for unexpected transitions</li> <li>Debug logic: Find where signals take wrong values</li> <li>Measure latency: Count cycles from input to output</li> </ol> <p>Waveform Debugging Strategy</p> <p>When debugging, start at the output that's wrong and work backward. Add signals to the waveform display as you trace the data path. Eventually, you'll find the point where correct input produces incorrect output\u2014that's your bug location.</p>"},{"location":"chapters/14-testbenches-simulation/#debugging-waveforms-finding-the-bug","title":"Debugging Waveforms: Finding the Bug","text":"<p>Debugging Waveforms is the systematic process of using waveform displays to locate and understand design errors. It's part detective work, part pattern recognition, and part stubbornness.</p> <p>The debugging process:</p> <ol> <li>Identify symptom: What's wrong with the output?</li> <li>Hypothesize cause: What could make this happen?</li> <li>Add signals: Display relevant internal signals</li> <li>Trace backward: Find where correct becomes incorrect</li> <li>Understand bug: Why did this happen?</li> <li>Fix and verify: Correct the code and re-simulate</li> </ol> <p>Common bug patterns visible in waveforms:</p> Pattern Appears As Likely Cause Signal stuck at X Red/unknown trace Uninitialized register, unconnected wire Signal stuck at 0/1 Flat line Missing assignment, wrong sensitivity list Off-by-one timing Correct value, wrong cycle Clock domain error, pipeline miscount Glitch Brief spike Combinational race, missing register Wrong value Incorrect but stable Logic error, wrong operator <p>Example: Debugging a counter that counts incorrectly:</p> <pre><code>// Buggy counter - counts by 2 instead of 1!\nalways @(posedge clk) begin\n    if (reset)\n        count &lt;= 0;\n    else if (enable)\n        count &lt;= count + 2;  // BUG: Should be + 1\nend\n</code></pre> <p>In the waveform, you'd see count jumping: 0, 2, 4, 6... instead of 0, 1, 2, 3... The waveform makes this pattern immediately obvious, whereas a wrong single value might be missed.</p>"},{"location":"chapters/14-testbenches-simulation/#diagram-debug-workflow-visualization","title":"Diagram: Debug Workflow Visualization","text":"Debug Workflow Visualization <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Examine</p> <p>Learning Objective: Students will be able to examine waveforms systematically to trace incorrect outputs back to their root cause.</p> <p>Instructional Rationale: Interactive debugging scenario with guided trace-back process teaches the systematic approach professionals use.</p> <p>Canvas Layout:</p> <ul> <li>Top: Waveform display with bug symptom visible</li> <li>Center: Signal path diagram showing data flow</li> <li>Bottom: Hints and guidance panel</li> <li>Side: Signal selector for adding to view</li> </ul> <p>Interactive Elements:</p> <ul> <li>Identify the incorrect output</li> <li>Add internal signals to trace</li> <li>Follow the data path backward</li> <li>Find the bug source</li> <li>View corrected code</li> <li>Reset for new scenario</li> </ul> <p>Data Visibility:</p> <ul> <li>Initial waveform showing bug symptom</li> <li>Internal signals as added</li> <li>Correct vs incorrect values</li> <li>Path from source to output</li> <li>Bug location when found</li> </ul> <p>Visual Style:</p> <ul> <li>Waveform with error highlighting</li> <li>Signal path arrows</li> <li>\"Aha!\" moment visualization</li> <li>Before/after comparison</li> <li>Progressive disclosure</li> </ul> <p>Implementation: p5.js with guided debugging tutorial</p> <p>Key debugging techniques:</p> <ol> <li> <p>Binary search: If the design has many stages, add signals in the middle first to narrow down which half has the bug</p> </li> <li> <p>Known pattern: Apply simple, predictable inputs (like counting pattern) so expected outputs are easy to calculate</p> </li> <li> <p>Reset trace: Always verify reset works correctly before testing normal operation</p> </li> <li> <p>Edge focus: Many bugs occur at transitions\u2014state changes, counter rollovers, edge cases</p> </li> <li> <p>Compare to spec: Have the expected waveform in mind (or on paper) before looking at actual</p> </li> </ol> <p>The Two Most Common Verilog Bugs</p> <ol> <li>Wrong sensitivity list: Combinational block doesn't include all inputs, works in synthesis but not simulation</li> <li>Blocking vs non-blocking confusion: Using <code>=</code> instead of <code>&lt;=</code> in sequential logic causes race conditions</li> </ol>"},{"location":"chapters/14-testbenches-simulation/#synthesis-from-code-to-hardware","title":"Synthesis: From Code to Hardware","text":"<p>Synthesis is the process of translating your Verilog RTL code into actual hardware\u2014a netlist of gates, flip-flops, and other primitive elements that can be implemented in an FPGA or ASIC.</p> <p>The synthesis flow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Verilog RTL    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502    Synthesis    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502    Gate-Level   \u2502\n\u2502  (Your Code)    \u2502     \u2502      Tool       \u2502     \u2502     Netlist     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502  Technology     \u2502\n                        \u2502    Library      \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>What synthesis does:</p> <ol> <li>Parses your Verilog code</li> <li>Infers hardware structures (registers, muxes, adders)</li> <li>Optimizes for area, speed, or power</li> <li>Maps to available primitives in the target technology</li> <li>Outputs a netlist of connected components</li> </ol> <p>Synthesis tools include:</p> <ul> <li>Vivado Synthesis (AMD/Xilinx FPGAs)</li> <li>Quartus (Intel FPGAs)</li> <li>Design Compiler (Synopsys, for ASICs)</li> <li>Genus (Cadence, for ASICs)</li> <li>Yosys (Open source)</li> </ul> <p>The synthesis tool reads your behavioral Verilog and figures out what hardware to build:</p> You Write Synthesis Infers <code>assign y = a &amp; b;</code> AND gate <code>always @(posedge clk) q &lt;= d;</code> D flip-flop <code>if (sel) y = a; else y = b;</code> Multiplexer <code>y = a + b;</code> Adder circuit FSM with state register State encoding + logic <p>Synthesis Is Not Simulation</p> <p>Simulation runs your code. Synthesis transforms your code into hardware. Code that simulates correctly might not synthesize correctly (or at all) if it uses non-synthesizable constructs.</p>"},{"location":"chapters/14-testbenches-simulation/#synthesizable-code-what-can-become-hardware","title":"Synthesizable Code: What Can Become Hardware","text":"<p>Synthesizable Code is Verilog code that synthesis tools can convert into actual hardware. Not all valid Verilog is synthesizable\u2014some constructs exist only for simulation.</p> <p>Guidelines for synthesizable code:</p> <p>Always blocks must have proper sensitivity: <pre><code>// Synthesizable: complete sensitivity\nalways @(posedge clk) begin\n    q &lt;= d;\nend\n\nalways @(*) begin\n    y = a &amp; b;\nend\n\n// NOT synthesizable: incomplete sensitivity (simulation only)\nalways @(a) begin\n    y = a &amp; b;  // What about b?\nend\n</code></pre></p> <p>Use correct assignment types: <pre><code>// Synthesizable: proper blocking for combinational\nalways @(*) begin\n    temp = a + b;\n    result = temp * 2;\nend\n\n// Synthesizable: proper non-blocking for sequential\nalways @(posedge clk) begin\n    stage1 &lt;= data_in;\n    stage2 &lt;= stage1;\nend\n</code></pre></p> <p>Avoid latches (unless intentional): <pre><code>// Creates latch (usually unintended)\nalways @(*) begin\n    if (enable)\n        y = data;\n    // Missing else - y must hold value\nend\n\n// Fixed: no latch\nalways @(*) begin\n    if (enable)\n        y = data;\n    else\n        y = 1'b0;\nend\n</code></pre></p> <p>Synthesizable constructs:</p> Construct Synthesizable Notes <code>module</code>, <code>endmodule</code> Yes Design hierarchy <code>input</code>, <code>output</code>, <code>inout</code> Yes Port declarations <code>wire</code>, <code>reg</code> Yes Signal declarations <code>assign</code> Yes Combinational logic <code>always @(posedge clk)</code> Yes Sequential logic <code>always @(*)</code> Yes Combinational logic <code>if</code>, <code>else</code> Yes Multiplexers, priority <code>case</code> Yes Parallel selection <code>+</code>, <code>-</code>, <code>*</code> Yes Arithmetic <code>&amp;</code>, <code>\\|</code>, <code>^</code> Yes Logic gates <code>parameter</code>, <code>localparam</code> Yes Constants <code>for</code> (with fixed bounds) Yes Unrolled at synthesis <p>Think Hardware First</p> <p>Before writing code, ask: \"What hardware do I want?\" If you can't visualize the gates and flip-flops, reconsider your approach. Synthesizable code describes hardware structures, not algorithms.</p>"},{"location":"chapters/14-testbenches-simulation/#non-synthesizable-code-simulation-only","title":"Non-Synthesizable Code: Simulation Only","text":"<p>Non-Synthesizable Code includes Verilog constructs that work in simulation but cannot be translated into hardware. These constructs are essential for testbenches but must be kept out of your design modules.</p> <p>Common non-synthesizable constructs:</p> Construct Purpose Example <code>initial</code> Set starting values <code>initial clk = 0;</code> <code>#</code> delay Simulation timing <code>#10 a = 1;</code> <code>$display</code>, <code>$write</code> Print messages <code>$display(\"Hello\");</code> <code>$finish</code>, <code>$stop</code> Control simulation <code>#1000 $finish;</code> <code>$random</code> Generate random values <code>data = $random;</code> <code>$time</code>, <code>$realtime</code> Get simulation time <code>$display(\"T=%0t\", $time);</code> <code>$dumpfile</code>, <code>$dumpvars</code> Waveform output <code>$dumpfile(\"test.vcd\");</code> <code>$readmemh</code>, <code>$readmemb</code> Load memory from file <code>$readmemh(\"data.hex\", mem);</code> <code>forever</code> Infinite loop <code>forever #5 clk = ~clk;</code> <code>force</code>, <code>release</code> Override signals <code>force wire_x = 1;</code> <p>These constructs have no hardware equivalent:</p> <pre><code>// Non-synthesizable - only for testbenches!\ninitial begin\n    $display(\"Starting simulation...\");\n    clk = 0;\n    forever #5 clk = ~clk;\nend\n\ninitial begin\n    data = $random;\n    #100;\n    if (result !== expected)\n        $display(\"ERROR: mismatch at time %0t\", $time);\n    $finish;\nend\n</code></pre>"},{"location":"chapters/14-testbenches-simulation/#diagram-synthesizable-vs-non-synthesizable","title":"Diagram: Synthesizable vs Non-Synthesizable","text":"Synthesizable vs Non-Synthesizable Code <p>Type: infographic</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: Classify</p> <p>Learning Objective: Students will be able to classify Verilog constructs as synthesizable or non-synthesizable, understanding which belong in design modules versus testbenches.</p> <p>Instructional Rationale: Interactive classification exercise with immediate feedback trains the critical distinction between design code and verification code.</p> <p>Canvas Layout:</p> <ul> <li>Left: Code snippets to classify</li> <li>Center: Drag zone for synthesizable</li> <li>Right: Drag zone for non-synthesizable</li> <li>Bottom: Score and explanation panel</li> </ul> <p>Interactive Elements:</p> <ul> <li>Drag code snippets to categories</li> <li>Immediate feedback on correctness</li> <li>Explanation of why each is/isn't synthesizable</li> <li>Score tracking</li> <li>Hint system</li> <li>Reset for practice</li> </ul> <p>Data Visibility:</p> <ul> <li>Code snippets</li> <li>Correct categorization</li> <li>Explanation for each</li> <li>Running score</li> <li>Common mistakes highlighted</li> </ul> <p>Visual Style:</p> <ul> <li>Clean card-based code snippets</li> <li>Color feedback (green=correct, red=wrong)</li> <li>Explanation tooltips</li> <li>Progress indicator</li> <li>Responsive layout</li> </ul> <p>Implementation: p5.js with drag-and-drop interaction</p> <p>The key rule: Design modules must be synthesizable. Testbenches need not be.</p> <p>Keep your code organized:</p> <pre><code>// design.v - Only synthesizable code!\nmodule my_design(\n    input clk, reset,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        if (reset)\n            data_out &lt;= 8'b0;\n        else\n            data_out &lt;= data_in + 1;\n    end\nendmodule\n\n// testbench.v - Non-synthesizable is fine here\nmodule testbench;\n    reg clk, reset;\n    reg [7:0] data_in;\n    wire [7:0] data_out;\n\n    my_design dut(...);\n\n    initial begin  // Non-synthesizable\n        $dumpfile(\"test.vcd\");\n        $dumpvars(0, testbench);\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    initial begin\n        #100 $finish;  // Non-synthesizable\n    end\nendmodule\n</code></pre> <p>Don't Mix Design and Testbench</p> <p>Never put <code>$display</code>, <code>#</code> delays, or <code>initial</code> blocks (except for ROM initialization) in modules you intend to synthesize. Keep simulation-only constructs in separate testbench files.</p>"},{"location":"chapters/14-testbenches-simulation/#bringing-it-all-together-a-complete-verification-example","title":"Bringing It All Together: A Complete Verification Example","text":"<p>Let's build a complete testbench for a simple FIFO (First-In-First-Out) buffer:</p> <pre><code>//============================================\n// FIFO Design (Synthesizable)\n//============================================\nmodule fifo #(\n    parameter WIDTH = 8,\n    parameter DEPTH = 4\n)(\n    input                  clk,\n    input                  reset,\n    input                  wr_en,\n    input                  rd_en,\n    input      [WIDTH-1:0] wr_data,\n    output reg [WIDTH-1:0] rd_data,\n    output                 full,\n    output                 empty\n);\n\n    // Memory and pointers\n    reg [WIDTH-1:0] mem [0:DEPTH-1];\n    reg [$clog2(DEPTH):0] wr_ptr, rd_ptr;  // Extra bit for full/empty detection\n\n    // Full/empty logic\n    assign full  = (wr_ptr[$clog2(DEPTH)] != rd_ptr[$clog2(DEPTH)]) &amp;&amp;\n                   (wr_ptr[$clog2(DEPTH)-1:0] == rd_ptr[$clog2(DEPTH)-1:0]);\n    assign empty = (wr_ptr == rd_ptr);\n\n    // Write logic\n    always @(posedge clk) begin\n        if (reset)\n            wr_ptr &lt;= 0;\n        else if (wr_en &amp;&amp; !full) begin\n            mem[wr_ptr[$clog2(DEPTH)-1:0]] &lt;= wr_data;\n            wr_ptr &lt;= wr_ptr + 1;\n        end\n    end\n\n    // Read logic\n    always @(posedge clk) begin\n        if (reset)\n            rd_ptr &lt;= 0;\n        else if (rd_en &amp;&amp; !empty) begin\n            rd_data &lt;= mem[rd_ptr[$clog2(DEPTH)-1:0]];\n            rd_ptr &lt;= rd_ptr + 1;\n        end\n    end\n\nendmodule\n\n//============================================\n// FIFO Testbench (Non-Synthesizable)\n//============================================\n`timescale 1ns/1ps\n\nmodule fifo_tb;\n\n    // Parameters\n    parameter WIDTH = 8;\n    parameter DEPTH = 4;\n    parameter CLK_PERIOD = 10;\n\n    // Testbench signals\n    reg                  clk;\n    reg                  reset;\n    reg                  wr_en;\n    reg                  rd_en;\n    reg      [WIDTH-1:0] wr_data;\n    wire     [WIDTH-1:0] rd_data;\n    wire                 full;\n    wire                 empty;\n\n    // For self-checking\n    reg [WIDTH-1:0] expected_data [0:DEPTH-1];\n    integer wr_count, rd_count, errors;\n\n    // Instantiate DUT\n    fifo #(.WIDTH(WIDTH), .DEPTH(DEPTH)) dut(\n        .clk(clk),\n        .reset(reset),\n        .wr_en(wr_en),\n        .rd_en(rd_en),\n        .wr_data(wr_data),\n        .rd_data(rd_data),\n        .full(full),\n        .empty(empty)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #(CLK_PERIOD/2) clk = ~clk;\n    end\n\n    // Waveform dump\n    initial begin\n        $dumpfile(\"fifo_tb.vcd\");\n        $dumpvars(0, fifo_tb);\n    end\n\n    // Main test sequence\n    initial begin\n        // Initialize\n        reset = 1;\n        wr_en = 0;\n        rd_en = 0;\n        wr_data = 0;\n        wr_count = 0;\n        rd_count = 0;\n        errors = 0;\n\n        // Wait for reset\n        repeat(3) @(posedge clk);\n        reset = 0;\n        @(posedge clk);\n\n        // Test 1: Verify empty after reset\n        if (!empty) begin\n            $display(\"ERROR: FIFO not empty after reset!\");\n            errors = errors + 1;\n        end\n\n        // Test 2: Write until full\n        $display(\"\\n=== Test 2: Fill FIFO ===\");\n        while (!full) begin\n            @(posedge clk);\n            wr_en = 1;\n            wr_data = $random;\n            expected_data[wr_count % DEPTH] = wr_data;\n            $display(\"  Writing: %h\", wr_data);\n            wr_count = wr_count + 1;\n        end\n        @(posedge clk);\n        wr_en = 0;\n\n        // Verify full\n        if (!full) begin\n            $display(\"ERROR: FIFO not full after %d writes!\", wr_count);\n            errors = errors + 1;\n        end\n\n        // Test 3: Read and verify data\n        $display(\"\\n=== Test 3: Read and Verify ===\");\n        while (!empty) begin\n            @(posedge clk);\n            rd_en = 1;\n        end\n        @(posedge clk);\n        rd_en = 0;\n\n        // Wait for last read to complete\n        @(posedge clk);\n\n        // Test 4: Mixed read/write\n        $display(\"\\n=== Test 4: Mixed Operations ===\");\n        repeat(20) begin\n            @(posedge clk);\n            wr_en = ($random % 2) &amp;&amp; !full;\n            rd_en = ($random % 2) &amp;&amp; !empty;\n            wr_data = $random;\n\n            if (wr_en)\n                $display(\"  Write: %h\", wr_data);\n            if (rd_en)\n                $display(\"  Read: %h\", rd_data);\n        end\n        @(posedge clk);\n        wr_en = 0;\n        rd_en = 0;\n\n        // Final report\n        repeat(5) @(posedge clk);\n        $display(\"\\n========================================\");\n        if (errors == 0)\n            $display(\"SUCCESS: All tests passed!\");\n        else\n            $display(\"FAILED: %d errors detected\", errors);\n        $display(\"========================================\\n\");\n\n        $finish;\n    end\n\n    // Timeout watchdog\n    initial begin\n        #10000;\n        $display(\"ERROR: Simulation timeout!\");\n        $finish;\n    end\n\nendmodule\n</code></pre> <p>This testbench demonstrates:</p> <ul> <li>Clock generation with parameterized period</li> <li>Reset sequence</li> <li>Multiple test phases</li> <li>Random stimulus</li> <li>Self-checking logic</li> <li>Waveform generation</li> <li>Timeout protection</li> <li>Clear pass/fail reporting</li> </ul>"},{"location":"chapters/14-testbenches-simulation/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've learned the essential skills of digital design verification. Let's recap the key points:</p> <p>Testbench Fundamentals:</p> <ul> <li>Testbenches are non-synthesizable modules that test your design</li> <li>They provide stimulus, generate clocks, and observe outputs</li> <li>The DUT (Device Under Test) is instantiated inside the testbench</li> </ul> <p>Stimulus and Vectors:</p> <ul> <li>Generate stimulus through direct assignment, loops, random, or files</li> <li>Test vectors organize inputs and expected outputs</li> <li>Cover edge cases, boundaries, and error conditions</li> </ul> <p>Clock and Timing:</p> <ul> <li>Generate clocks with <code>initial</code> and <code>forever</code> blocks</li> <li>Use <code>#</code> delays for timing control</li> <li>Be careful about clock-data alignment (add small delays)</li> </ul> <p>Self-Checking:</p> <ul> <li>Compare DUT outputs against expected values automatically</li> <li>Use error counters and summary reports</li> <li>Reference models help verify complex logic</li> </ul> <p>Simulation:</p> <ul> <li>Simulators execute your design in virtual time</li> <li>Use <code>$dumpfile</code> and <code>$dumpvars</code> for waveforms</li> <li>Waveform viewers are essential for debugging</li> </ul> <p>Synthesizable Code:</p> <ul> <li>Only synthesizable constructs go in design modules</li> <li><code>initial</code>, <code>#</code> delays, and <code>$</code> tasks are simulation only</li> <li>Keep testbench code separate from design code</li> </ul> <p>The Verification Mindset</p> <p>Think of yourself as trying to break your design, not prove it works. Every test that passes without finding a bug is a missed opportunity. The goal isn't to write tests that pass\u2014it's to write tests that would fail if the design had a bug.</p> Graphic Novel Suggestion <p>An engaging graphic novel could follow the dramatic story of the Pentium FDIV bug of 1994, where a flaw in Intel's Pentium processor's floating-point division unit caused incorrect calculations. The narrative could show the verification engineers who\u2014in hindsight\u2014see where additional test vectors might have caught the bug. The tension builds as the bug is discovered by a mathematics professor, Intel initially dismisses it, and the eventual recall costs $475 million. The moral: \"Every test you don't run is a bug you might not find.\" The story could end with modern verification practices that emerged from this disaster, showing how the industry transformed testing from an afterthought to a primary engineering discipline.</p>"},{"location":"chapters/14-testbenches-simulation/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: Testbench Structure <p>What's wrong with this testbench? <pre><code>module my_tb(\n    output reg clk,\n    output reg reset\n);\n    my_design dut(.clk(clk), .reset(reset));\n\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\nendmodule\n</code></pre></p> <p>Solution: Testbenches should NOT have a port list! They are self-contained top-level modules. The <code>output reg clk</code> and <code>output reg reset</code> declarations are wrong. Fix: <pre><code>module my_tb;  // No ports!\n    reg clk;\n    reg reset;\n    // ...\n</code></pre></p> Problem 2: Clock Generation <p>Write clock generation code for a 50 MHz clock (20ns period).</p> <p>Solution: <pre><code>parameter CLK_PERIOD = 20;  // 20ns = 50 MHz\n\ninitial begin\n    clk = 0;\n    forever #(CLK_PERIOD/2) clk = ~clk;\nend\n</code></pre> Or more explicitly: <pre><code>initial begin\n    clk = 0;\n    forever #10 clk = ~clk;  // 10ns high, 10ns low = 20ns period\nend\n</code></pre></p> Problem 3: Self-Checking Logic <p>Add self-checking to verify this AND gate: <pre><code>module and_gate_tb;\n    reg a, b;\n    wire y;\n\n    and_gate dut(.a(a), .b(b), .y(y));\n\n    initial begin\n        // Test all input combinations\n        a = 0; b = 0; #10;\n        a = 0; b = 1; #10;\n        a = 1; b = 0; #10;\n        a = 1; b = 1; #10;\n        $finish;\n    end\nendmodule\n</code></pre></p> <p>Solution: <pre><code>module and_gate_tb;\n    reg a, b;\n    wire y;\n    integer errors = 0;\n\n    and_gate dut(.a(a), .b(b), .y(y));\n\n    initial begin\n        // Test all input combinations\n        a = 0; b = 0; #10;\n        if (y !== 0) begin errors = errors + 1; $display(\"FAIL: 0&amp;0\"); end\n\n        a = 0; b = 1; #10;\n        if (y !== 0) begin errors = errors + 1; $display(\"FAIL: 0&amp;1\"); end\n\n        a = 1; b = 0; #10;\n        if (y !== 0) begin errors = errors + 1; $display(\"FAIL: 1&amp;0\"); end\n\n        a = 1; b = 1; #10;\n        if (y !== 1) begin errors = errors + 1; $display(\"FAIL: 1&amp;1\"); end\n\n        if (errors == 0)\n            $display(\"PASS: All tests passed\");\n        else\n            $display(\"FAIL: %d errors\", errors);\n        $finish;\n    end\nendmodule\n</code></pre></p> Problem 4: Synthesizable Check <p>Which of these code fragments are synthesizable?</p> <p>A) <code>initial q = 0;</code> B) <code>always @(posedge clk) q &lt;= d;</code> C) <code>#10 a = 1;</code> D) <code>assign y = a &amp; b;</code> E) <code>$display(\"Value: %d\", x);</code></p> <p>Solution: - A) Generally No (some FPGAs support for initialization, but not portable) - B) Yes (D flip-flop) - C) No (<code>#</code> delays are simulation only) - D) Yes (AND gate) - E) No (<code>$display</code> is simulation only)</p> Problem 5: Debug Scenario <p>Your counter counts 0, 2, 4, 6 instead of 0, 1, 2, 3. What bug would you look for in the waveform?</p> <p>Solution: Look for: 1. The increment value - it's probably <code>count + 2</code> instead of <code>count + 1</code> 2. Double clock edges - maybe posedge AND negedge triggering 3. Enable signal toggling at unexpected times 4. Count register being loaded from wrong source</p> <p>In the waveform, trace the count value backward to the increment operation to find the wrong constant or the clock issue.</p> Problem 6: Test Vector Design <p>Design test vectors for a 2-bit comparator with outputs <code>eq</code> (equal), <code>lt</code> (less than), <code>gt</code> (greater than).</p> <p>Solution: <pre><code>// Test vectors: {a[1:0], b[1:0], expected_eq, expected_lt, expected_gt}\nreg [6:0] vectors [0:15];\n\ninitial begin\n    // All combinations of 2-bit inputs\n    vectors[0]  = {2'b00, 2'b00, 1'b1, 1'b0, 1'b0};  // 0 == 0\n    vectors[1]  = {2'b00, 2'b01, 1'b0, 1'b1, 1'b0};  // 0 &lt; 1\n    vectors[2]  = {2'b00, 2'b10, 1'b0, 1'b1, 1'b0};  // 0 &lt; 2\n    vectors[3]  = {2'b00, 2'b11, 1'b0, 1'b1, 1'b0};  // 0 &lt; 3\n    vectors[4]  = {2'b01, 2'b00, 1'b0, 1'b0, 1'b1};  // 1 &gt; 0\n    vectors[5]  = {2'b01, 2'b01, 1'b1, 1'b0, 1'b0};  // 1 == 1\n    vectors[6]  = {2'b01, 2'b10, 1'b0, 1'b1, 1'b0};  // 1 &lt; 2\n    vectors[7]  = {2'b01, 2'b11, 1'b0, 1'b1, 1'b0};  // 1 &lt; 3\n    vectors[8]  = {2'b10, 2'b00, 1'b0, 1'b0, 1'b1};  // 2 &gt; 0\n    vectors[9]  = {2'b10, 2'b01, 1'b0, 1'b0, 1'b1};  // 2 &gt; 1\n    vectors[10] = {2'b10, 2'b10, 1'b1, 1'b0, 1'b0};  // 2 == 2\n    vectors[11] = {2'b10, 2'b11, 1'b0, 1'b1, 1'b0};  // 2 &lt; 3\n    vectors[12] = {2'b11, 2'b00, 1'b0, 1'b0, 1'b1};  // 3 &gt; 0\n    vectors[13] = {2'b11, 2'b01, 1'b0, 1'b0, 1'b1};  // 3 &gt; 1\n    vectors[14] = {2'b11, 2'b10, 1'b0, 1'b0, 1'b1};  // 3 &gt; 2\n    vectors[15] = {2'b11, 2'b11, 1'b1, 1'b0, 1'b0};  // 3 == 3\nend\n</code></pre></p> Problem 7: Complete Testbench <p>Write a complete self-checking testbench for a 4-bit binary to BCD converter. The module converts binary 0-9 to BCD, and outputs 9 for inputs &gt; 9.</p> <p>Solution: <pre><code>`timescale 1ns/1ps\n\nmodule bin_to_bcd_tb;\n    reg [3:0] bin;\n    wire [3:0] bcd;\n    integer i, errors;\n\n    // Expected BCD values\n    reg [3:0] expected [0:15];\n\n    // DUT\n    bin_to_bcd dut(.bin(bin), .bcd(bcd));\n\n    // Initialize expected values\n    initial begin\n        for (i = 0; i &lt;= 9; i = i + 1)\n            expected[i] = i;\n        for (i = 10; i &lt;= 15; i = i + 1)\n            expected[i] = 9;  // Saturate at 9\n    end\n\n    // Test all values\n    initial begin\n        $dumpfile(\"bin_to_bcd_tb.vcd\");\n        $dumpvars(0, bin_to_bcd_tb);\n\n        errors = 0;\n\n        for (i = 0; i &lt;= 15; i = i + 1) begin\n            bin = i;\n            #10;\n\n            if (bcd !== expected[i]) begin\n                $display(\"ERROR: bin=%d, expected bcd=%d, got=%d\",\n                         bin, expected[i], bcd);\n                errors = errors + 1;\n            end else begin\n                $display(\"PASS: bin=%d -&gt; bcd=%d\", bin, bcd);\n            end\n        end\n\n        $display(\"\\n========================================\");\n        if (errors == 0)\n            $display(\"SUCCESS: All 16 tests passed!\");\n        else\n            $display(\"FAILED: %d errors\", errors);\n        $display(\"========================================\");\n\n        $finish;\n    end\n\nendmodule\n</code></pre></p>"},{"location":"chapters/14-testbenches-simulation/quiz/","title":"Quiz: Testbenches and Simulation","text":"<p>Test your understanding of verification, simulation, and synthesizable versus non-synthesizable Verilog.</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#1-what-is-the-purpose-of-a-testbench-in-verilog","title":"1. What is the purpose of a testbench in Verilog?","text":"<ol> <li>To synthesize the design faster</li> <li>To provide stimulus and observe outputs for verifying design correctness</li> <li>To reduce power consumption</li> <li>To generate documentation</li> </ol> Show Answer <p>The correct answer is B. A testbench is a Verilog module that provides stimulus to the device under test (DUT), observes its outputs, and verifies correct behavior. Testbenches exist purely for verification and are not synthesized.</p> <p>Concept Tested: Testbench</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#2-what-is-the-standard-way-to-generate-a-clock-signal-in-a-testbench","title":"2. What is the standard way to generate a clock signal in a testbench?","text":"<ol> <li>assign clk = 1;</li> <li>initial begin clk = 0; forever #5 clk = ~clk; end</li> <li>always @(clk) clk = ~clk;</li> <li>wire clk = oscillator;</li> </ol> Show Answer <p>The correct answer is B. The standard pattern uses an initial block with forever and delay to toggle the clock: initial begin clk = 0; forever #5 clk = ~clk; end. This creates a clock with period 10 time units.</p> <p>Concept Tested: Clock Generation</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#3-what-is-a-test-vector","title":"3. What is a test vector?","text":"<ol> <li>A direction indicator in the simulation</li> <li>A set of input values paired with expected output values</li> <li>A graphical display of signals</li> <li>A type of Verilog module</li> </ol> Show Answer <p>The correct answer is B. A test vector is a specific set of input values along with the expected output values for those inputs. Test vectors organize test cases into a structured format for systematic, automated verification.</p> <p>Concept Tested: Test Vector</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#4-what-makes-a-testbench-self-checking","title":"4. What makes a testbench \"self-checking\"?","text":"<ol> <li>It automatically fixes bugs in the design</li> <li>It compares DUT outputs against expected values and reports errors</li> <li>It verifies its own correctness</li> <li>It runs without user intervention</li> </ol> Show Answer <p>The correct answer is B. A self-checking testbench automatically compares DUT outputs against expected values (from a reference model or test vectors) and reports pass/fail without requiring manual waveform inspection.</p> <p>Concept Tested: Self-Checking Testbench</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#5-what-does-the-delay-operator-do-in-verilog-simulation","title":"5. What does the # delay operator do in Verilog simulation?","text":"<ol> <li>Generates a clock signal</li> <li>Suspends execution for a specified number of time units</li> <li>Creates a hardware delay element</li> <li>Prioritizes signal assignments</li> </ol> Show Answer <p>The correct answer is B. The # delay operator suspends execution for the specified number of time units. For example, #10 waits 10 time units before the next statement executes. This is for simulation only\u2014not synthesizable.</p> <p>Concept Tested: Simulation Time</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#6-what-verilog-construct-creates-waveform-output-files-for-viewing","title":"6. What Verilog construct creates waveform output files for viewing?","text":"<ol> <li>$display and $write</li> <li>$dumpfile and $dumpvars</li> <li>$monitor and $strobe</li> <li>assign and always</li> </ol> Show Answer <p>The correct answer is B. $dumpfile(\"name.vcd\") specifies the output file, and $dumpvars(0, module_name) specifies which signals to capture. The resulting VCD file can be viewed in waveform viewers like GTKWave.</p> <p>Concept Tested: Waveform Viewer</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#7-what-is-the-first-step-when-debugging-a-waveform-showing-incorrect-outputs","title":"7. What is the first step when debugging a waveform showing incorrect outputs?","text":"<ol> <li>Rewrite the entire design</li> <li>Start at the wrong output and trace backward to find where correct becomes incorrect</li> <li>Add more test vectors</li> <li>Change the clock frequency</li> </ol> Show Answer <p>The correct answer is B. Debug by starting at the incorrect output and tracing backward through the signal path. Add internal signals to the display until you find the point where correct input produces incorrect output\u2014that's your bug location.</p> <p>Concept Tested: Debugging Waveforms</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#8-what-does-synthesis-do-to-verilog-code","title":"8. What does synthesis do to Verilog code?","text":"<ol> <li>Runs the simulation faster</li> <li>Converts RTL Verilog into a gate-level netlist for hardware implementation</li> <li>Checks for syntax errors only</li> <li>Generates documentation</li> </ol> Show Answer <p>The correct answer is B. Synthesis transforms RTL Verilog into a netlist of gates, flip-flops, and other primitives that can be implemented in an FPGA or ASIC. It infers hardware structures from behavioral descriptions.</p> <p>Concept Tested: Synthesis</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#9-which-verilog-construct-is-not-synthesizable","title":"9. Which Verilog construct is NOT synthesizable?","text":"<ol> <li>always @(posedge clk)</li> <li>initial begin ... end with # delays</li> <li>assign y = a &amp; b;</li> <li>if-else statements</li> </ol> Show Answer <p>The correct answer is B. Initial blocks with # delays are simulation-only constructs\u2014they cannot be synthesized into hardware. The # delay has no hardware equivalent. Always, assign, and if-else are all synthesizable.</p> <p>Concept Tested: Non-Synthesizable Code</p>"},{"location":"chapters/14-testbenches-simulation/quiz/#10-what-is-the-key-rule-for-separating-design-and-testbench-code","title":"10. What is the key rule for separating design and testbench code?","text":"<ol> <li>Use different file extensions</li> <li>Keep all $system tasks, # delays, and initial blocks in testbenches only</li> <li>Write testbenches in a different language</li> <li>Never use modules in testbenches</li> </ol> Show Answer <p>The correct answer is B. Design modules must contain only synthesizable code. Non-synthesizable constructs ($display, $finish, # delays, most initial blocks) belong in testbench files only. This separation ensures designs can be synthesized.</p> <p>Concept Tested: Synthesizable Code</p>"},{"location":"chapters/15-fpga-lab-skills/","title":"FPGA Implementation and Laboratory Skills","text":""},{"location":"chapters/15-fpga-lab-skills/#summary","title":"Summary","text":"<p>This chapter bridges theory and practice by covering FPGA implementation and hands-on laboratory skills. Students will learn FPGA architecture including look-up tables (LUTs), flip-flops, and routing resources, the FPGA implementation flow, and pin assignment. Laboratory skills include breadboard prototyping, using logic probes and logic analyzers, working with LED indicators and switch inputs, and implementing switch debouncing. The chapter covers design verification approaches including functional and timing verification, design hierarchy and reuse principles, documentation practices, and the complete digital system design workflow.</p>"},{"location":"chapters/15-fpga-lab-skills/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>FPGA Architecture</li> <li>FPGA LUT</li> <li>FPGA Flip-Flop</li> <li>FPGA Routing</li> <li>FPGA Implementation</li> <li>Pin Assignment</li> <li>Breadboard Prototyping</li> <li>Logic Probe</li> <li>Logic Analyzer</li> <li>LED Indicator</li> <li>Switch Input</li> <li>Debouncing</li> <li>Design Verification</li> <li>Functional Verification</li> <li>Timing Verification</li> <li>Hardware-Software Boundary</li> <li>Abstraction Levels</li> <li>Design Hierarchy</li> <li>Design Reuse</li> <li>Design Documentation</li> <li>Digital System Design</li> </ol>"},{"location":"chapters/15-fpga-lab-skills/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 8: Flip-Flops and Timing</li> <li>Chapter 10: FSM Design and Applications</li> <li>Chapter 13: Verilog Behavioral and Structural Modeling</li> <li>Chapter 14: Testbenches and Simulation</li> </ul>"},{"location":"chapters/15-fpga-lab-skills/#introduction-from-simulation-to-reality","title":"Introduction: From Simulation to Reality","text":"<p>Here's a confession that every digital designer has made at least once: \"It worked in simulation!\" These four words, usually spoken with a mixture of frustration and bewilderment, mark the moment when theory meets the unforgiving reality of actual hardware.</p> <p>Welcome to the chapter where your designs stop living in the comfortable world of perfect simulations and start existing in the messy, wonderful, occasionally smoke-producing world of real electronics. This is where the rubber meets the road\u2014or more accurately, where the Verilog meets the silicon.</p> <p>Until now, you've been designing circuits that exist only as text files and waveforms. That's like learning to cook by reading recipes and imagining the taste. Now it's time to turn on the stove. FPGAs (Field-Programmable Gate Arrays) are your kitchen, and this chapter teaches you how to use the equipment without burning anything down. (Though if you do smell something burning, unplug it immediately. We'll wait.)</p> <p>The skills you'll learn here are the bridge between \"I understand digital logic\" and \"I can build working digital systems.\" By the end of this chapter, you'll understand how FPGAs work internally, how to get your designs running on real hardware, and how to debug the inevitable problems that arise when electrons start flowing through actual circuits.</p> <p>Ready to make something real? Let's dive in!</p>"},{"location":"chapters/15-fpga-lab-skills/#understanding-fpga-architecture","title":"Understanding FPGA Architecture","text":"<p>An FPGA (Field-Programmable Gate Array) is an integrated circuit designed to be configured by the customer after manufacturing\u2014hence \"field-programmable.\" Unlike an ASIC (Application-Specific Integrated Circuit), which is manufactured with fixed functionality, an FPGA can be reprogrammed to implement virtually any digital circuit.</p> <p>Think of an FPGA as a giant canvas of configurable logic. Imagine millions of tiny logic elements that can be connected however you want, like a massive electronic LEGO set. The \"programming\" of an FPGA isn't really programming in the software sense\u2014it's configuring the connections between these logic elements to create the circuit you designed in Verilog.</p> <p>The basic architecture of an FPGA consists of three main components:</p> <ul> <li>Configurable Logic Blocks (CLBs): The computational elements that implement your logic</li> <li>Routing Resources: The programmable interconnects that connect CLBs together</li> <li>I/O Blocks: The interface between internal logic and external pins</li> </ul> <p>Modern FPGAs also include specialized blocks for common functions:</p> Block Type Purpose Example Uses Block RAM (BRAM) On-chip memory FIFOs, caches, lookup tables DSP Slices Arithmetic operations Multiply-accumulate, filters Clock Management Clock generation/distribution PLLs, clock dividers High-Speed I/O Fast external communication PCIe, DDR memory interfaces <p>Why FPGAs Matter</p> <p>FPGAs occupy a unique position between software and custom hardware. They offer the performance of hardware with the flexibility of software (sort of). They're used everywhere from prototyping ASICs to production systems in data centers, telecommunications, and aerospace.</p>"},{"location":"chapters/15-fpga-lab-skills/#diagram-fpga-architecture-overview","title":"Diagram: FPGA Architecture Overview","text":"FPGA Architecture Overview <p>Type: infographic</p> <p>Bloom Level: Understand (L2) Bloom Verb: Explain</p> <p>Learning Objective: Students will be able to explain the major components of FPGA architecture including CLBs, routing resources, I/O blocks, and specialized blocks, understanding how they work together to implement digital circuits.</p> <p>Instructional Rationale: Interactive block diagram showing FPGA architecture with hover-to-explore functionality helps students understand the spatial organization and relationships between components.</p> <p>Canvas Layout:</p> <ul> <li>Center: Grid of CLBs representing the logic fabric</li> <li>Edges: I/O blocks around the perimeter</li> <li>Interconnections: Routing channels between CLBs</li> <li>Corner areas: Special blocks (BRAM, DSP, clock management)</li> <li>Legend: Component identification</li> </ul> <p>Interactive Elements:</p> <ul> <li>Hover over any block to see description and purpose</li> <li>Click on CLB to zoom into internal structure</li> <li>Highlight routing paths when hovering over connections</li> <li>Toggle to show different FPGA families</li> <li>Show/hide specialized blocks</li> </ul> <p>Data Visibility:</p> <ul> <li>Block types and their functions</li> <li>Relative quantities of each resource</li> <li>Connection patterns</li> <li>Resource utilization concept</li> </ul> <p>Visual Style:</p> <ul> <li>Clean grid layout</li> <li>Color coding by block type (blue=CLB, green=I/O, orange=BRAM, purple=DSP)</li> <li>Routing shown as grid channels</li> <li>Professional schematic appearance</li> <li>Responsive to window resize</li> </ul> <p>Implementation: p5.js with interactive hover/click regions</p>"},{"location":"chapters/15-fpga-lab-skills/#the-look-up-table-lut-the-heart-of-fpga-logic","title":"The Look-Up Table (LUT): The Heart of FPGA Logic","text":"<p>The FPGA LUT (Look-Up Table) is the fundamental building block for implementing combinational logic in an FPGA. A LUT is essentially a small memory that can be programmed to implement any Boolean function of its inputs.</p> <p>Here's the clever insight: any Boolean function of N inputs can be represented as a truth table with \\(2^N\\) entries. A LUT stores this truth table directly. When you apply inputs, the LUT simply looks up the output value\u2014no gates needed!</p> <p>Consider a 4-input LUT (the most common size):</p> <ul> <li>It has 4 inputs (A, B, C, D) and 1 output</li> <li>It can store \\(2^4 = 16\\) bits of configuration data</li> <li>Those 16 bits define the output for every possible input combination</li> <li>It can implement ANY 4-input Boolean function</li> </ul> <p>For example, to implement \\(F = AB + CD\\), the LUT would be programmed with:</p> A B C D F (stored in LUT) 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 1 1 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1 0 0 0 0 1 0 0 1 0 1 0 1 0 0 1 0 1 1 1 1 1 0 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 <p>The beauty of LUTs is their universality\u2014the same physical structure implements an AND gate, an XOR gate, a multiplexer, or any other function you can imagine. The FPGA tools figure out how to program each LUT to create your circuit.</p> <p>Modern FPGAs typically use 6-input LUTs (LUT6), which can implement any 6-input function. Some architectures allow a LUT6 to be split into two independent LUT5s for better resource utilization.</p>"},{"location":"chapters/15-fpga-lab-skills/#diagram-lut-function-implementation","title":"Diagram: LUT Function Implementation","text":"LUT Function Implementation <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Demonstrate</p> <p>Learning Objective: Students will be able to demonstrate how a LUT implements any Boolean function by programming truth table values and observing input-output behavior.</p> <p>Instructional Rationale: Interactive LUT simulator where students can program the truth table and toggle inputs shows the direct relationship between stored values and function behavior.</p> <p>Canvas Layout:</p> <ul> <li>Left: 4-input LUT schematic with input toggles</li> <li>Center: 16-entry truth table (editable)</li> <li>Right: Output display with current function description</li> <li>Bottom: Preset function buttons (AND, OR, XOR, MUX, custom)</li> </ul> <p>Interactive Elements:</p> <ul> <li>Toggle buttons for each input (A, B, C, D)</li> <li>Clickable truth table cells to set 0/1</li> <li>Preset function buttons to load common functions</li> <li>Boolean expression display showing current function</li> <li>Animation showing lookup process</li> <li>Clear and random fill buttons</li> </ul> <p>Data Visibility:</p> <ul> <li>Current input values</li> <li>Current output value</li> <li>Complete truth table</li> <li>Derived Boolean expression</li> <li>LUT utilization note</li> </ul> <p>Visual Style:</p> <ul> <li>Clean schematic representation</li> <li>Color-coded inputs (different colors)</li> <li>Highlight active truth table row</li> <li>Output prominently displayed</li> <li>Professional look matching vendor tools</li> </ul> <p>Implementation: p5.js with truth table editor and evaluation</p>"},{"location":"chapters/15-fpga-lab-skills/#fpga-flip-flops-the-storage-elements","title":"FPGA Flip-Flops: The Storage Elements","text":"<p>FPGA Flip-Flops are the storage elements that implement sequential logic. Each CLB contains not just LUTs but also flip-flops, allowing it to implement both combinational and sequential circuits.</p> <p>A typical FPGA CLB contains several flip-flops, often one per LUT. These flip-flops are usually D-type with configurable features:</p> <ul> <li>Clock input: Connected to the FPGA's clock distribution network</li> <li>Clock enable (CE): Allows selective updating</li> <li>Set/Reset: Can be synchronous or asynchronous</li> <li>Initial value: Can be configured to 0 or 1 at power-up</li> </ul> <p>The relationship between LUTs and flip-flops in a CLB:</p> <pre><code>          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nInputs \u2500\u2500\u25b6\u2502    LUT4     \u2502\u2500\u2500\u252c\u2500\u2500\u25b6 Combinational Output\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n                           \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              Clock \u2500\u2500\u2524   D    \u2502\u2500\u2500\u25b6 Registered Output\n                 CE \u2500\u2500\u2524  FF    \u2502\n              Reset \u2500\u2500\u2524        \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This architecture is powerful because it lets each CLB produce either:</p> <ol> <li>Combinational output: The LUT output bypasses the flip-flop</li> <li>Registered output: The LUT output is captured by the flip-flop</li> </ol> <p>The choice is made during FPGA configuration. Your Verilog code determines which is used:</p> <pre><code>// Combinational - uses LUT only\nassign y = a &amp; b;\n\n// Sequential - uses LUT + FF\nalways @(posedge clk)\n    q &lt;= a &amp; b;\n</code></pre> <p>Resource Efficiency</p> <p>Good FPGA designs balance LUT and flip-flop usage. If you use all your LUTs but few flip-flops (or vice versa), you're leaving resources underutilized. The synthesis tools try to optimize this, but design choices matter.</p>"},{"location":"chapters/15-fpga-lab-skills/#fpga-routing-connecting-the-pieces","title":"FPGA Routing: Connecting the Pieces","text":"<p>FPGA Routing refers to the programmable interconnect resources that connect CLBs, I/O blocks, and specialized blocks together. Routing is often the limiting factor in FPGA design\u2014not logic resources.</p> <p>The routing architecture typically includes:</p> <ul> <li>Local interconnects: Short connections within and between adjacent CLBs</li> <li>General routing: Longer connections spanning multiple CLBs</li> <li>Global routing: Very long connections for signals like clocks and resets</li> <li>Switch boxes: Programmable connection points where routes can turn or cross</li> </ul> <p>Here's why routing matters so much:</p> Factor Impact Signal delay Longer routes = more delay Timing closure Congested areas may fail timing Resource usage Routes consume real silicon area Power Signals switching through routes consume power <p>The FPGA implementation tools spend significant effort on routing. The process involves:</p> <ol> <li>Placement: Deciding where each CLB's logic goes</li> <li>Routing: Finding paths to connect everything</li> <li>Timing analysis: Checking if delays meet requirements</li> <li>Iteration: Moving things around to fix problems</li> </ol> <p>The 80% Utilization Trap</p> <p>A common mistake is designing until the FPGA is nearly full. FPGAs become very difficult to route above about 80% utilization because the remaining routing resources are scattered and fragmented. Leave headroom!</p>"},{"location":"chapters/15-fpga-lab-skills/#diagram-fpga-routing-visualization","title":"Diagram: FPGA Routing Visualization","text":"FPGA Routing Visualization <p>Type: microsim</p> <p>Bloom Level: Understand (L2) Bloom Verb: Describe</p> <p>Learning Objective: Students will be able to describe how routing resources connect logic blocks in an FPGA and explain why routing congestion affects timing.</p> <p>Instructional Rationale: Animated visualization of signal routing through switch boxes and wire segments demonstrates the physical path signals take and how congestion develops.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Grid of CLBs with routing channels</li> <li>Routing channels shown between CLBs</li> <li>Switch boxes at intersections</li> <li>Highlighted signal paths</li> <li>Congestion heat map overlay option</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click two CLBs to route a signal between them</li> <li>Show/hide congestion overlay</li> <li>Toggle between different routing scenarios</li> <li>Animation of signal propagation</li> <li>Slider for utilization level</li> <li>Clear routes button</li> </ul> <p>Data Visibility:</p> <ul> <li>Number of routing segments used</li> <li>Estimated signal delay</li> <li>Congestion level indicator</li> <li>Path length in CLB hops</li> <li>Alternative routes count</li> </ul> <p>Visual Style:</p> <ul> <li>Grid layout matching FPGA architecture</li> <li>Color-coded congestion (green=low, red=high)</li> <li>Animated signal flow</li> <li>Switch box detail on hover</li> <li>Professional FPGA tool aesthetic</li> </ul> <p>Implementation: p5.js with pathfinding and animation</p>"},{"location":"chapters/15-fpga-lab-skills/#the-fpga-implementation-flow","title":"The FPGA Implementation Flow","text":"<p>FPGA Implementation is the complete process of transforming your Verilog code into a working FPGA configuration. Understanding this flow helps you write better code and debug problems more effectively.</p> <p>The implementation flow consists of these major steps:</p> <ol> <li>Synthesis: Converts Verilog to a generic netlist of gates and flip-flops</li> <li>Technology Mapping: Maps the generic netlist to FPGA primitives (LUTs, FFs)</li> <li>Placement: Assigns each logic element to a specific CLB location</li> <li>Routing: Creates the physical connections between placed elements</li> <li>Bitstream Generation: Creates the file that configures the FPGA</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Verilog     \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Synthesis   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Netlist     \u2502\n\u2502   Source      \u2502     \u2502               \u2502     \u2502   (generic)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                   \u2502\n                                                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Bitstream    \u2502\u25c0\u2500\u2500\u2500\u2500\u2502    Route      \u2502\u25c0\u2500\u2500\u2500\u2500\u2502    Place      \u2502\n\u2502   (.bit)      \u2502     \u2502               \u2502     \u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   FPGA    \u2502\n   \u2502  Hardware \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each step produces reports that help you understand your design:</p> Step Key Reports What to Look For Synthesis Resource utilization LUTs, FFs, BRAM used Synthesis Inference messages What structures were inferred Place Placement report Critical paths, utilization by region Route Timing report Setup/hold slack, failing paths Route Power estimate Static and dynamic power <p>Read the Reports!</p> <p>The implementation reports contain gold. A 5-minute review of the synthesis report can reveal problems that would take hours to debug otherwise. Always check for unexpected latches, high fan-out signals, and inference warnings.</p>"},{"location":"chapters/15-fpga-lab-skills/#diagram-fpga-implementation-flow","title":"Diagram: FPGA Implementation Flow","text":"FPGA Implementation Flow <p>Type: workflow</p> <p>Bloom Level: Understand (L2) Bloom Verb: Summarize</p> <p>Learning Objective: Students will be able to summarize the major stages of FPGA implementation and identify the inputs and outputs of each stage.</p> <p>Instructional Rationale: Interactive flowchart with clickable stages reveals details about each step, helping students understand the transformation from Verilog to hardware.</p> <p>Canvas Layout:</p> <ul> <li>Horizontal workflow with major stages</li> <li>Input/output files shown at each stage</li> <li>Arrows showing data flow</li> <li>Detail panel for selected stage</li> <li>Progress indicator</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click each stage to see details</li> <li>Hover to see brief description</li> <li>Show example reports for each stage</li> <li>Animation showing data transformation</li> <li>Link to common problems at each stage</li> </ul> <p>Data Visibility:</p> <ul> <li>Stage name and purpose</li> <li>Input and output file types</li> <li>Key transformations performed</li> <li>Common issues at each stage</li> <li>Estimated time proportion</li> </ul> <p>Visual Style:</p> <ul> <li>Clean flowchart layout</li> <li>Color-coded stages (synthesis=blue, place=green, route=orange)</li> <li>Document icons for reports</li> <li>Professional appearance</li> <li>Responsive design</li> </ul> <p>Implementation: p5.js with interactive workflow visualization</p>"},{"location":"chapters/15-fpga-lab-skills/#pin-assignment-connecting-to-the-real-world","title":"Pin Assignment: Connecting to the Real World","text":"<p>Pin Assignment is the process of mapping your design's I/O signals to specific physical pins on the FPGA package. This is where your digital design meets the physical world\u2014and where many first-time mistakes happen.</p> <p>Pin assignment involves specifying:</p> <ul> <li>Which pin: The physical location (e.g., \"A3\", \"C5\", \"PIN_AA14\")</li> <li>I/O standard: The voltage levels and signaling (e.g., LVCMOS33, LVDS)</li> <li>Drive strength: How much current the pin can source/sink</li> <li>Slew rate: How fast the signal transitions</li> <li>Pull-up/down: Internal resistors for unconnected states</li> </ul> <p>Here's a typical pin assignment in a constraints file (XDC format for Xilinx):</p> <pre><code># Clock input\nset_property PACKAGE_PIN W5 [get_ports clk]\nset_property IOSTANDARD LVCMOS33 [get_ports clk]\n\n# LED outputs\nset_property PACKAGE_PIN U16 [get_ports {led[0]}]\nset_property PACKAGE_PIN E19 [get_ports {led[1]}]\nset_property PACKAGE_PIN U19 [get_ports {led[2]}]\nset_property PACKAGE_PIN V19 [get_ports {led[3]}]\nset_property IOSTANDARD LVCMOS33 [get_ports {led[*]}]\n\n# Push button inputs\nset_property PACKAGE_PIN T18 [get_ports btn_center]\nset_property IOSTANDARD LVCMOS33 [get_ports btn_center]\n</code></pre> <p>Critical pin assignment considerations:</p> Consideration Why It Matters Bank compatibility I/O pins are organized into banks with shared voltage Voltage matching Must match the voltage of external circuits Current limits Each bank has total current limits Special pins Some pins have dedicated functions (clocks, config) PCB routing Physical location affects board layout <p>The Magic Smoke Rule</p> <p>Never connect a 3.3V FPGA pin directly to a 5V signal. The FPGA will not appreciate it, and you may discover that electronics contain \"magic smoke\" that escapes when things go wrong. Always check voltage compatibility!</p> <p>Common development board pin functions:</p> <ul> <li>Clocks: Crystal oscillator input (typically 100 MHz)</li> <li>LEDs: Visual indicators for debugging</li> <li>Switches/Buttons: User input for testing</li> <li>Seven-segment displays: Numeric output</li> <li>GPIO headers: Connection to external circuits</li> <li>USB/UART: Communication with computer</li> </ul>"},{"location":"chapters/15-fpga-lab-skills/#breadboard-prototyping-building-circuits-by-hand","title":"Breadboard Prototyping: Building Circuits by Hand","text":"<p>Breadboard Prototyping is the art of building temporary circuits for testing and experimentation. Before committing to PCB fabrication, engineers prototype on breadboards to verify their designs work correctly.</p> <p>A solderless breadboard consists of:</p> <ul> <li>Terminal strips: Rows of connected holes for component insertion</li> <li>Power rails: Long strips for power distribution (usually marked + and -)</li> <li>Center gap: Divides the board, separating IC pin rows</li> </ul> <p>The internal connections follow this pattern:</p> <pre><code>Power Rails    Terminal Strips    Power Rails\n  + -        a b c d e  f g h i j    + -\n  \u2502 \u2502        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550    \u2502 \u2502\n  \u2502 \u2502        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550    \u2502 \u2502\n  \u2502 \u2502        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550    \u2502 \u2502\n  \u2502 \u2502           gap                  \u2502 \u2502\n</code></pre> <p>Key prototyping tips:</p> <ol> <li>Plan before building: Sketch your circuit layout first</li> <li>Use color-coded wires: Red for power, black for ground, other colors for signals</li> <li>Keep wires short: Long wires add noise and look messy</li> <li>Test incrementally: Verify each section before adding more</li> <li>Document connections: Take photos or notes as you build</li> </ol>"},{"location":"chapters/15-fpga-lab-skills/#diagram-breadboard-layout-guide","title":"Diagram: Breadboard Layout Guide","text":"Breadboard Layout Guide <p>Type: infographic</p> <p>Bloom Level: Remember (L1) Bloom Verb: Identify</p> <p>Learning Objective: Students will be able to identify the internal connection patterns of a solderless breadboard and correctly place components for proper connectivity.</p> <p>Instructional Rationale: Interactive breadboard visualization where students can explore connections by clicking helps build intuition for physical circuit construction.</p> <p>Canvas Layout:</p> <ul> <li>Main area: Realistic breadboard representation</li> <li>Connection highlighting on hover</li> <li>Component insertion demonstration</li> <li>Power rail identification</li> <li>Wiring examples</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click any hole to highlight connected holes</li> <li>Drag components (resistors, LEDs, ICs) onto board</li> <li>Toggle power rail connections</li> <li>Show/hide internal wiring</li> <li>Example circuits to load (LED circuit, IC placement)</li> </ul> <p>Data Visibility:</p> <ul> <li>Which holes are connected</li> <li>Power rail status</li> <li>Component pin connections</li> <li>Correct vs incorrect placement examples</li> </ul> <p>Visual Style:</p> <ul> <li>Realistic breadboard appearance</li> <li>Clear hole pattern</li> <li>Color-coded power rails (red/blue)</li> <li>Component outlines when dragging</li> <li>Responsive design</li> </ul> <p>Implementation: p5.js with grid-based interaction</p> <p>Common prototyping components and their uses:</p> Component Purpose Tips LEDs Visual indicators Always use current-limiting resistor (220\u03a9-1k\u03a9) Push buttons User input Connect between signal and ground, use pull-up Resistors Current limiting, pull-ups Read color codes or measure with multimeter Capacitors Decoupling, filtering Place near IC power pins (0.1\u00b5F typical) 74-series ICs Logic functions Check pinout diagram, note pin 1 orientation"},{"location":"chapters/15-fpga-lab-skills/#logic-probes-and-logic-analyzers","title":"Logic Probes and Logic Analyzers","text":"<p>When debugging digital circuits, you need tools to observe signal behavior. Logic Probes and Logic Analyzers are essential instruments for this purpose.</p> <p>A Logic Probe is a simple, pen-shaped tool that indicates the logic level of a single signal:</p> <ul> <li>High indicator: LED lights when signal is logic 1</li> <li>Low indicator: Different LED for logic 0</li> <li>Pulse detector: Indicates transitions (catches brief pulses)</li> <li>Threshold: Usually set for TTL or CMOS levels</li> </ul> <p>Logic probes are perfect for quick checks: \"Is this signal stuck high?\" \"Is the clock running?\"</p> <p>A Logic Analyzer is much more powerful, capturing multiple digital signals over time:</p> <ul> <li>Multiple channels: 8, 16, 32, or more simultaneous signals</li> <li>Triggering: Capture based on specific signal conditions</li> <li>Protocol decoding: Interpret I\u00b2C, SPI, UART, and other protocols</li> <li>Deep memory: Store long capture sequences</li> <li>Timing analysis: Measure pulse widths, frequencies, delays</li> </ul> <p>Comparison of debugging tools:</p> Feature Logic Probe Logic Analyzer Oscilloscope Channels 1 8-32+ 2-4 Signal type Digital only Digital only Analog + digital Cost $10-50 $100-10,000+ $300-50,000+ Best for Quick checks Protocol debug Signal integrity Portability Handheld Bench/USB Bench <p>The Budget Option</p> <p>Affordable USB logic analyzers (like those compatible with Sigrok) cost $10-50 and are excellent for learning. They connect to your computer and use free software for display and protocol decoding.</p>"},{"location":"chapters/15-fpga-lab-skills/#diagram-logic-analyzer-interface","title":"Diagram: Logic Analyzer Interface","text":"Logic Analyzer Interface <p>Type: microsim</p> <p>Bloom Level: Apply (L3) Bloom Verb: Use</p> <p>Learning Objective: Students will be able to use logic analyzer features including multi-channel capture, triggering, and timing measurements to debug digital signals.</p> <p>Instructional Rationale: Simulated logic analyzer interface teaches the mental model of capture-based debugging without requiring physical equipment.</p> <p>Canvas Layout:</p> <ul> <li>Top: Toolbar with controls (Run, Stop, Trigger settings)</li> <li>Main area: Waveform display with multiple channels</li> <li>Left: Channel labels with color coding</li> <li>Bottom: Time scale and cursor controls</li> <li>Side panel: Measurements display</li> </ul> <p>Interactive Elements:</p> <ul> <li>Run/Stop capture button</li> <li>Set trigger conditions (rising edge, pattern)</li> <li>Zoom in/out on time scale</li> <li>Place cursors for measurements</li> <li>Add/remove channels</li> <li>Adjust sample rate</li> <li>Protocol decode toggle</li> </ul> <p>Data Visibility:</p> <ul> <li>Multiple signal waveforms</li> <li>Trigger point marker</li> <li>Cursor positions and delta time</li> <li>Frequency measurements</li> <li>Decoded protocol data</li> </ul> <p>Visual Style:</p> <ul> <li>Dark theme matching real analyzers</li> <li>Color-coded channels</li> <li>Grid lines for timing reference</li> <li>Professional measurement tool appearance</li> <li>Responsive to window resize</li> </ul> <p>Implementation: p5.js with simulated signal generation and capture</p>"},{"location":"chapters/15-fpga-lab-skills/#led-indicators-and-switch-inputs","title":"LED Indicators and Switch Inputs","text":"<p>LED Indicators and Switch Inputs are the most basic human interface elements in digital systems. Despite their simplicity, using them correctly requires understanding some important electrical principles.</p> <p>LED Indicators require current limiting:</p> <p>An LED is a current device\u2014you must limit the current flowing through it to prevent damage. The typical forward voltage is 1.8-3.3V depending on color, and safe operating current is 5-20mA.</p> <p>The current-limiting resistor value is calculated as:</p> \\[R = \\frac{V_{supply} - V_{LED}}{I_{LED}}\\] <p>For a typical case with 3.3V supply, 2V LED drop, and 10mA current:</p> \\[R = \\frac{3.3V - 2V}{10mA} = 130\\Omega\\] <p>A 220\u03a9 resistor is commonly used as a safe choice for most situations.</p> <p>LEDs can be connected in two configurations:</p> Configuration Active Current Path Verilog Active high LED on when output = 1 FPGA \u2192 LED \u2192 resistor \u2192 GND <code>led = 1'b1;</code> Active low LED on when output = 0 VCC \u2192 LED \u2192 resistor \u2192 FPGA <code>led = 1'b0;</code> <p>Switch Inputs require pull-up or pull-down resistors:</p> <p>A mechanical switch creates an open or closed circuit, but the FPGA input needs a defined logic level at all times. Pull resistors ensure this:</p> <pre><code>         VCC                           FPGA Pin\n          \u2502                              \u2502\n          \u251c\u2500\u2500[Pull-up 10k\u03a9]\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u2502                  \u2502          \u2502\n         \u2500\u2534\u2500                 \u2502         \u2500\u2534\u2500\n        /   \\  (switch)     \u2500\u2534\u2500       Input\n       \u2500     \u2500              GND       Buffer\n          \u2502\n         GND\n</code></pre> <p>When the switch is open: input sees VCC through resistor (logic 1) When the switch is closed: input sees GND directly (logic 0)</p> <p>FPGA Internal Pull-ups</p> <p>Most FPGAs have configurable internal pull-up resistors. You can enable them in your constraints file, eliminating the need for external resistors on push buttons.</p>"},{"location":"chapters/15-fpga-lab-skills/#debouncing-taming-mechanical-switches","title":"Debouncing: Taming Mechanical Switches","text":"<p>Debouncing is the technique of cleaning up the noisy signals produced by mechanical switches. When a switch closes or opens, the mechanical contacts bounce, producing multiple rapid transitions instead of a clean edge.</p> <p>A typical switch bounce looks like this in time:</p> <pre><code>Switch pressed:\n                   bounce period\n                   \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\nIdeal:    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nActual:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2510\u250c\u2510\u250c\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2518\u2514\u2518\u2514\u2518\u2514\u2500\u2500\u2500\u2518\n</code></pre> <p>This bounce period typically lasts 1-10 milliseconds. Without debouncing, a single button press might register as 5-50 presses!</p> <p>There are two main approaches to debouncing:</p> <p>Hardware debouncing uses an RC filter and Schmitt trigger:</p> <pre><code>Switch \u2500\u2500\u252c\u2500\u2500[R]\u2500\u2500\u252c\u2500\u2500\u25b7o\u2500\u2500 Debounced output\n         \u2502       \u2502      (Schmitt trigger)\n        \u2500\u2534\u2500     \u2500\u252c\u2500\n        GND      C\n                 \u2502\n                GND\n</code></pre> <p>Software/digital debouncing samples the input and waits for stability:</p> <pre><code>module debounce #(\n    parameter DELAY = 1000000  // Clock cycles to wait (20ms at 50MHz)\n)(\n    input  wire clk,\n    input  wire btn_in,\n    output reg  btn_out\n);\n\n    reg [19:0] counter;\n    reg        btn_sync1, btn_sync2;  // Synchronizer\n\n    // Synchronize input to clock domain\n    always @(posedge clk) begin\n        btn_sync1 &lt;= btn_in;\n        btn_sync2 &lt;= btn_sync1;\n    end\n\n    // Debounce logic\n    always @(posedge clk) begin\n        if (btn_sync2 != btn_out) begin\n            counter &lt;= counter + 1;\n            if (counter &gt;= DELAY) begin\n                btn_out &lt;= btn_sync2;\n                counter &lt;= 0;\n            end\n        end else begin\n            counter &lt;= 0;\n        end\n    end\n\nendmodule\n</code></pre>"},{"location":"chapters/15-fpga-lab-skills/#diagram-switch-debouncing-visualization","title":"Diagram: Switch Debouncing Visualization","text":"Switch Debouncing Visualization <p>Type: microsim</p> <p>Bloom Level: Analyze (L4) Bloom Verb: Compare</p> <p>Learning Objective: Students will be able to compare raw bouncing switch signals with debounced outputs, understanding why debouncing is necessary and how different debounce delays affect response.</p> <p>Instructional Rationale: Side-by-side display of raw and debounced signals with adjustable parameters demonstrates the problem and solution interactively.</p> <p>Canvas Layout:</p> <ul> <li>Top: Virtual switch button</li> <li>Middle: Dual waveform display (raw vs debounced)</li> <li>Bottom: Parameter controls</li> <li>Side: Counter showing detected presses</li> </ul> <p>Interactive Elements:</p> <ul> <li>Clickable switch button (simulates mechanical press)</li> <li>Slider for bounce duration</li> <li>Slider for debounce delay</li> <li>Counter for raw transitions</li> <li>Counter for debounced transitions</li> <li>Reset button</li> <li>Show/hide ideal signal overlay</li> </ul> <p>Data Visibility:</p> <ul> <li>Raw switch signal with bounce</li> <li>Debounced signal</li> <li>Number of false triggers (raw)</li> <li>Clean trigger count (debounced)</li> <li>Current debounce delay value</li> <li>Time annotations</li> </ul> <p>Visual Style:</p> <ul> <li>Waveform display similar to logic analyzer</li> <li>Clear distinction between raw (red) and clean (green)</li> <li>Bounce region highlighted</li> <li>Debounce period shaded</li> <li>Responsive layout</li> </ul> <p>Implementation: p5.js with bounce simulation and digital filter</p> <p>Choosing debounce parameters:</p> Application Suggested Delay Reasoning User button 10-20 ms Fast enough to feel responsive Toggle switch 20-50 ms Longer travel = more bounce Limit switch 5-10 ms May need faster response Rotary encoder 1-5 ms High-speed rotation needs quick response"},{"location":"chapters/15-fpga-lab-skills/#design-verification-ensuring-correctness","title":"Design Verification: Ensuring Correctness","text":"<p>Design Verification is the process of ensuring your design works correctly before (and after) implementation. Verification catches bugs that would be expensive to fix in hardware.</p> <p>Verification happens at multiple levels:</p> <ol> <li>Pre-synthesis simulation: Functional testing with testbenches</li> <li>Post-synthesis simulation: Verify synthesis didn't change behavior</li> <li>Post-implementation timing simulation: Include real delays</li> <li>Hardware testing: In-system verification</li> </ol> <p>The verification strategy should be planned:</p> Phase What to Verify Tools Module level Individual block functionality Unit testbenches Integration Blocks work together System testbenches Timing Meets timing constraints Static timing analysis Physical Works in actual FPGA LEDs, logic analyzer, UART <p>Functional Verification confirms logical correctness:</p> <ul> <li>Does the design produce correct outputs for all inputs?</li> <li>Do state machines traverse states correctly?</li> <li>Are edge cases handled properly?</li> <li>Do reset sequences work?</li> </ul> <p>Timing Verification confirms timing correctness:</p> <ul> <li>Are setup times met at all flip-flops?</li> <li>Are hold times met after all clock edges?</li> <li>Do clock domains interact safely?</li> <li>Does the design meet frequency targets?</li> </ul> <pre><code>Setup Time Check:\n              \u25c0\u2500\u2500Setup Time\u2500\u2500\u25b6\n              \u2502               \u2502\nData:  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2571 new value \u2572\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2502               \u2502\nClock: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502 Rising Edge\n              \u2502               \u2502\n\nThe data must be stable BEFORE the clock edge by at least tSU\n</code></pre> <p>Timing Failures Are Subtle</p> <p>A design that fails timing might work... sometimes. It might work on one FPGA but not another. It might work at room temperature but fail when hot. Timing failures are the gremlins of digital design\u2014take timing reports seriously!</p>"},{"location":"chapters/15-fpga-lab-skills/#the-hardware-software-boundary","title":"The Hardware-Software Boundary","text":"<p>The Hardware-Software Boundary is the interface between digital hardware (running on FPGA) and software (running on a processor). Understanding this boundary is essential for system design.</p> <p>In a typical embedded system:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Software                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Application Code (C/C++)                     \u2502  \u2502\n\u2502  \u2502  - User interface                             \u2502  \u2502\n\u2502  \u2502  - High-level algorithms                      \u2502  \u2502\n\u2502  \u2502  - Data processing                            \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                        \u2502                           \u2502\n\u2502                  Memory-Mapped I/O                 \u2502\n\u2502                        \u2502                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     Hardware                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  FPGA Logic (Verilog)                         \u2502  \u2502\n\u2502  \u2502  - Register interfaces                        \u2502  \u2502\n\u2502  \u2502  - High-speed processing                      \u2502  \u2502\n\u2502  \u2502  - Real-time control                          \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key decisions at the hardware-software boundary:</p> Factor Favor Hardware Favor Software Speed Real-time, deterministic Millisecond tolerance OK Parallelism Many things at once Sequential is fine Flexibility Fixed algorithm Frequent changes Complexity Simple operations Complex decisions I/O High-speed, many pins Standard interfaces Development Expertise available Faster iteration <p>Example: An audio processor might implement:</p> <ul> <li>In hardware: High-speed ADC/DAC interface, FFT computation, filtering</li> <li>In software: User interface, preset management, network communication</li> </ul> <p>The interface between hardware and software typically uses:</p> <ul> <li>Memory-mapped registers: Software reads/writes specific addresses</li> <li>Interrupts: Hardware signals events to software</li> <li>DMA: Hardware moves data directly to memory</li> <li>FIFOs: Buffered data transfer between domains</li> </ul>"},{"location":"chapters/15-fpga-lab-skills/#abstraction-levels-in-digital-design","title":"Abstraction Levels in Digital Design","text":"<p>Abstraction Levels help manage complexity by hiding details. Digital design uses multiple abstraction levels, from transistors to systems.</p> <p>The typical abstraction hierarchy:</p> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    Highest         \u2502 System Level      \u2502  \u2190 \"What should it do?\"\n    Abstraction     \u2502 (Architecture)    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Algorithmic Level \u2502  \u2190 \"How does it compute?\"\n                    \u2502 (Behavioral)      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 RTL Level         \u2502  \u2190 \"What registers? What logic?\"\n                    \u2502 (Register Transfer)\u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Gate Level        \u2502  \u2190 \"Which gates?\"\n                    \u2502 (Logic)           \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    Lowest          \u2502 Physical Level    \u2502  \u2190 \"Which transistors? Where?\"\n    Abstraction     \u2502 (Layout)          \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each level has its purpose:</p> Level Focus Verilog Style Who Works Here System Specifications, interfaces N/A (documents) Architects Behavioral Algorithms High-level <code>always</code> blocks Algorithm designers RTL Registers, state machines Synthesizable Verilog RTL designers Gate Specific gates Netlist, gate primitives Synthesis tools Physical Transistors, wires N/A (layout tools) Physical designers <p>As digital designers, you primarily work at the RTL level, with the synthesis tools handling gate-level and below.</p> <p>Think RTL, Not Code</p> <p>Always visualize the hardware your Verilog implies. If you can't draw the circuit, you probably don't understand what you're describing. This RTL thinking is the key skill that separates novice and expert digital designers.</p>"},{"location":"chapters/15-fpga-lab-skills/#design-hierarchy-divide-and-conquer","title":"Design Hierarchy: Divide and Conquer","text":"<p>Design Hierarchy organizes complex systems into manageable modules. A well-structured hierarchy makes designs easier to understand, test, and maintain.</p> <p>Principles of good hierarchy:</p> <ol> <li>Single responsibility: Each module does one thing well</li> <li>Appropriate granularity: Not too big, not too small</li> <li>Clean interfaces: Clear, minimal port lists</li> <li>Reusability: Design for reuse where possible</li> <li>Testability: Each module can be verified independently</li> </ol> <p>Example hierarchy for a simple processor:</p> <pre><code>                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   Top       \u2502\n                        \u2502   (SoC)     \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502               \u2502               \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502    CPU      \u2502 \u2502   Memory    \u2502 \u2502   I/O       \u2502\n        \u2502   Core      \u2502 \u2502 Controller  \u2502 \u2502  Bridge     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502          \u2502          \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n\u2502 Fetch \u2502 \u2502Decode \u2502 \u2502 Execute \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502     \u2502     \u2502\n               \u250c\u2500\u2500\u2500\u25bc\u2500\u2510 \u250c\u2500\u25bc\u2500\u2510 \u250c\u2500\u25bc\u2500\u2500\u2510\n               \u2502 ALU \u2502 \u2502Reg\u2502 \u2502LSU \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Good module sizing guidelines:</p> Module Size Comment &lt; 50 lines Probably too small (exception: simple primitives) 50-200 lines Sweet spot for most modules 200-500 lines Getting large, consider splitting &gt; 500 lines Almost certainly should be split"},{"location":"chapters/15-fpga-lab-skills/#design-reuse-dont-reinvent-the-wheel","title":"Design Reuse: Don't Reinvent the Wheel","text":"<p>Design Reuse is the practice of using existing, verified modules in new designs. Good reuse saves time, reduces bugs, and leverages proven implementations.</p> <p>Types of reusable components:</p> <ul> <li>Soft IP: Verilog/VHDL source code (most flexible)</li> <li>Firm IP: Synthesized but not placed/routed</li> <li>Hard IP: Complete layout (least flexible, best performance)</li> </ul> <p>Sources of reusable designs:</p> Source Examples Considerations Vendor IP DDR controllers, PCIe, transceivers Licensed, optimized for target Open source OpenCores, PULP, LiteX Free, quality varies Commercial IP Arm cores, encryption blocks Licensed, well-supported Your own library Previous projects Know it well, can modify <p>Building a reusable module checklist:</p> <ul> <li>Parameterized: Use parameters for configurable values</li> <li>Well-documented: Clear port descriptions and behavior</li> <li>Self-contained: Minimal external dependencies</li> <li>Thoroughly tested: Comprehensive testbench included</li> <li>Version controlled: Track changes and history</li> </ul> <p>Example of a reusable UART transmitter with good practices:</p> <pre><code>// File: uart_tx.v\n// Description: UART transmitter with configurable baud rate\n// Author: Your Name\n// Version: 1.0\n// Parameters:\n//   CLK_FREQ - System clock frequency in Hz (default 50000000)\n//   BAUD     - Baud rate (default 115200)\n\nmodule uart_tx #(\n    parameter CLK_FREQ = 50_000_000,\n    parameter BAUD     = 115200\n)(\n    input  wire       clk,\n    input  wire       rst,\n    input  wire       start,\n    input  wire [7:0] data,\n    output reg        tx,\n    output wire       busy\n);\n    // Implementation...\nendmodule\n</code></pre>"},{"location":"chapters/15-fpga-lab-skills/#design-documentation-writing-for-humans","title":"Design Documentation: Writing for Humans","text":"<p>Design Documentation captures the intent, structure, and usage of your designs. Good documentation is essential for maintenance, team collaboration, and your future self.</p> <p>Essential documentation elements:</p> <ol> <li>Design specification: What the design does (requirements)</li> <li>Architecture document: How it's organized (block diagrams)</li> <li>Interface specification: Port descriptions, timing, protocols</li> <li>Verification plan: How it will be tested</li> <li>User guide: How to use/integrate the design</li> </ol> <p>Documentation in code:</p> <pre><code>//=============================================================================\n// Module: counter_mod_n\n// Description: Modulo-N counter with enable and synchronous reset\n//\n// Parameters:\n//   N     - Count modulus (default 10)\n//   WIDTH - Counter width, should be ceil(log2(N))\n//\n// Ports:\n//   clk    - System clock (rising edge active)\n//   rst    - Synchronous reset (active high)\n//   en     - Count enable (active high)\n//   count  - Current count value (0 to N-1)\n//   wrap   - Pulses high when count wraps from N-1 to 0\n//\n// Timing:\n//   All outputs registered, valid one cycle after input change\n//\n// Example instantiation:\n//   counter_mod_n #(.N(60)) second_counter (\n//       .clk(clk), .rst(rst), .en(tick_1hz),\n//       .count(seconds), .wrap(minute_tick)\n//   );\n//=============================================================================\n</code></pre> <p>What to document where:</p> Location What to Document File header Module purpose, author, version, license Port list Each port's function and timing Parameters Valid ranges, defaults, dependencies Complex logic Why, not what (what is in the code) Workarounds Why the weird code is necessary TODO/FIXME Known issues and planned changes <p>Document the Why, Not the What</p> <p>Comments like <code>// increment counter</code> are useless\u2014the code already says that. Document why you're incrementing: <code>// Count clock cycles for 1ms timeout</code>. The \"why\" survives code changes; the \"what\" becomes stale.</p>"},{"location":"chapters/15-fpga-lab-skills/#the-complete-digital-system-design-flow","title":"The Complete Digital System Design Flow","text":"<p>Digital System Design follows a structured flow from concept to working hardware. Understanding this flow helps you work effectively and avoid common pitfalls.</p> <p>The complete design flow:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. SPECIFICATION                                            \u2502\n\u2502    \u2022 Define requirements                                    \u2502\n\u2502    \u2022 Create block diagram                                   \u2502\n\u2502    \u2022 Identify interfaces                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 2. ARCHITECTURE                                             \u2502\n\u2502    \u2022 Partition into modules                                 \u2502\n\u2502    \u2022 Define interfaces between modules                      \u2502\n\u2502    \u2022 Create verification plan                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. RTL DESIGN                                               \u2502\n\u2502    \u2022 Write Verilog for each module                          \u2502\n\u2502    \u2022 Create testbenches                                     \u2502\n\u2502    \u2022 Simulate and debug                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 4. SYNTHESIS &amp; IMPLEMENTATION                               \u2502\n\u2502    \u2022 Synthesize design                                      \u2502\n\u2502    \u2022 Review reports, fix issues                             \u2502\n\u2502    \u2022 Place and route                                        \u2502\n\u2502    \u2022 Verify timing                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 5. HARDWARE VERIFICATION                                    \u2502\n\u2502    \u2022 Program FPGA                                           \u2502\n\u2502    \u2022 Test functionality                                     \u2502\n\u2502    \u2022 Debug with logic analyzer                              \u2502\n\u2502    \u2022 Verify in system context                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 6. DOCUMENTATION &amp; RELEASE                                  \u2502\n\u2502    \u2022 Complete documentation                                 \u2502\n\u2502    \u2022 Archive design files                                   \u2502\n\u2502    \u2022 Create release notes                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"chapters/15-fpga-lab-skills/#diagram-digital-design-flow","title":"Diagram: Digital Design Flow","text":"Digital Design Flow <p>Type: workflow</p> <p>Bloom Level: Understand (L2) Bloom Verb: Summarize</p> <p>Learning Objective: Students will be able to summarize the complete digital design flow from specification through hardware verification, identifying key activities and deliverables at each stage.</p> <p>Instructional Rationale: Interactive flow diagram with expandable stages helps students understand the iterative nature of design and the connections between stages.</p> <p>Canvas Layout:</p> <ul> <li>Vertical flow with major stages</li> <li>Expandable detail for each stage</li> <li>Feedback loops shown</li> <li>Deliverables at each stage</li> <li>Time estimate indicators</li> </ul> <p>Interactive Elements:</p> <ul> <li>Click stages to expand details</li> <li>Show deliverables for each stage</li> <li>Highlight feedback loops</li> <li>Show common iteration paths</li> <li>Progress tracking for lab projects</li> <li>Checklist view option</li> </ul> <p>Data Visibility:</p> <ul> <li>Stage descriptions</li> <li>Key activities at each stage</li> <li>Expected deliverables</li> <li>Common problems and solutions</li> <li>Iteration patterns</li> </ul> <p>Visual Style:</p> <ul> <li>Clean flowchart layout</li> <li>Color-coded stages</li> <li>Clear flow direction</li> <li>Professional appearance</li> <li>Responsive design</li> </ul> <p>Implementation: p5.js with expandable workflow visualization</p> <p>Common iteration patterns:</p> Discovery Iterate Between Simulation finds bug RTL Design \u2194 Simulation Timing failure Synthesis \u2194 RTL (or constraints) Hardware doesn't match simulation Simulation \u2194 Hardware test Requirements misunderstood Specification \u2194 Any stage"},{"location":"chapters/15-fpga-lab-skills/#summary-and-key-takeaways","title":"Summary and Key Takeaways","text":"<p>Congratulations! You've learned the essential skills for bridging the gap between digital design theory and working hardware. Let's recap the key points:</p> <p>FPGA Architecture:</p> <ul> <li>FPGAs use LUTs to implement any Boolean function</li> <li>Flip-flops in CLBs provide storage elements</li> <li>Routing resources connect everything together</li> <li>Specialized blocks (BRAM, DSP) handle common tasks efficiently</li> </ul> <p>Implementation Flow:</p> <ul> <li>Synthesis converts Verilog to gates</li> <li>Place and route creates the physical layout</li> <li>Timing analysis verifies the design meets constraints</li> <li>Bitstream programs the actual FPGA</li> </ul> <p>Laboratory Skills:</p> <ul> <li>Pin assignment maps signals to physical pins</li> <li>Breadboards enable quick prototyping</li> <li>Logic analyzers capture and display digital signals</li> <li>LEDs and switches provide basic I/O</li> <li>Debouncing is essential for mechanical inputs</li> </ul> <p>Verification:</p> <ul> <li>Functional verification confirms logical correctness</li> <li>Timing verification ensures signals meet timing requirements</li> <li>Hardware testing catches issues simulation missed</li> </ul> <p>Design Practices:</p> <ul> <li>Hierarchy manages complexity</li> <li>Reuse leverages existing work</li> <li>Documentation enables maintenance and collaboration</li> <li>A structured design flow improves quality</li> </ul> <p>The Practitioner's Mindset</p> <p>You've now crossed the threshold from student to practitioner. You understand not just how digital circuits work, but how to build them in real hardware. This is the difference between knowing about bridges and knowing how to build one. Your circuits can now blink LEDs, respond to buttons, and interact with the physical world.</p> Graphic Novel Suggestion <p>A compelling graphic novel could tell the story of Ross Freeman, the inventor of the FPGA at Xilinx in 1984. Set against the backdrop of Silicon Valley in the early 1980s, the narrative follows Freeman's insight that a programmable array of logic blocks could revolutionize digital design. The tension builds as established semiconductor companies dismiss the idea\u2014why would anyone want programmable logic when they could just make a custom chip? The story could show the early struggles to achieve sufficient logic density, the breakthrough moment when the first Xilinx XC2064 worked, and the gradual realization that FPGAs would become essential to modern electronics. The irony: the very flexibility that critics doubted would now power everything from data centers to spacecraft.</p>"},{"location":"chapters/15-fpga-lab-skills/#practice-problems","title":"Practice Problems","text":"<p>Test your understanding with these exercises:</p> Problem 1: LUT Implementation <p>A 4-input LUT needs to implement the function F = AB + CD. How many bits of configuration data are stored in the LUT, and what are the values for the first four entries (ABCD = 0000, 0001, 0010, 0011)?</p> <p>Solution: A 4-input LUT stores \\(2^4 = 16\\) bits of configuration data.</p> <p>For F = AB + CD: - ABCD = 0000: F = 0\u00b70 + 0\u00b70 = 0 - ABCD = 0001: F = 0\u00b70 + 0\u00b71 = 0 - ABCD = 0010: F = 0\u00b70 + 1\u00b70 = 0 - ABCD = 0011: F = 0\u00b70 + 1\u00b71 = 1</p> Problem 2: Current Limiting Resistor <p>Calculate the current-limiting resistor needed for a red LED (forward voltage 2.0V) connected to a 3.3V FPGA output, with a target current of 8mA.</p> <p>Solution: Using the formula R = (Vsupply - VLED) / I:</p> \\[R = \\frac{3.3V - 2.0V}{8mA} = \\frac{1.3V}{0.008A} = 162.5\\Omega\\] <p>Use the next standard value up: 180\u03a9 or 220\u03a9.</p> Problem 3: Debounce Delay <p>If your FPGA runs at 100 MHz and you want a 20ms debounce delay, how many clock cycles should the debounce counter wait?</p> <p>Solution: Clock period = 1/100MHz = 10ns</p> <p>Cycles needed = 20ms / 10ns = 20 \u00d7 10\u207b\u00b3 / 10 \u00d7 10\u207b\u2079 = 2,000,000 cycles</p> <p>So the counter should count to 2,000,000 (or use a 21-bit counter since 2\u00b2\u00b9 = 2,097,152).</p> Problem 4: FPGA Resource Usage <p>A design uses 5,000 LUTs and 3,000 flip-flops on an FPGA with 20,000 LUTs and 40,000 flip-flops. What is the utilization percentage for each resource? Is routing likely to be a problem?</p> <p>Solution: LUT utilization: 5,000/20,000 = 25% FF utilization: 3,000/40,000 = 7.5%</p> <p>Both utilization levels are well under 80%, so routing should not be a problem. However, the design is unbalanced\u2014it uses relatively few flip-flops compared to LUTs, which might indicate a very combinational design.</p> Problem 5: Pin Assignment <p>You're connecting an FPGA (3.3V I/O) to a sensor that outputs 5V signals. What problem will occur, and how can you solve it?</p> <p>Solution: Problem: The 5V signal exceeds the FPGA's maximum input voltage (typically 3.3V + 0.3V = 3.6V absolute max). This can damage the FPGA.</p> <p>Solutions: 1. Use a voltage level shifter IC 2. Use a resistor divider to reduce 5V to 3.3V (but slows signal) 3. Use a 5V-tolerant FPGA I/O bank if available 4. Add a series resistor and rely on input protection diodes (not recommended for high-speed signals)</p> Problem 6: Hardware-Software Partition <p>A system needs to process video at 60 frames per second (1920\u00d71080 resolution) and overlay text graphics. Which parts should be implemented in FPGA hardware vs. software, and why?</p> <p>Solution: FPGA Hardware: - Video input interface (HDMI/MIPI receiver) - high-speed, real-time - Pixel processing pipeline - 60fps \u00d7 1920 \u00d7 1080 = 124M pixels/sec - Frame buffer controller - continuous memory access - Video output interface - deterministic timing required</p> <p>Software: - Text rendering engine - complex algorithms, infrequent updates - User interface logic - needs flexibility - Content management - high-level decisions - Network communication - protocol stacks are complex</p> <p>The division follows the principle: hardware for high-speed, deterministic, parallel operations; software for complex, changing, sequential logic.</p> Problem 7: Design Hierarchy <p>A traffic light controller design has the following modules: top_level, light_controller, timer_module, button_debounce, seven_segment_display, and pedestrian_crossing. Sketch a reasonable hierarchy and explain why you organized it that way.</p> <p>Solution: <pre><code>top_level\n\u251c\u2500\u2500 light_controller\n\u2502   \u251c\u2500\u2500 timer_module (for light timing)\n\u2502   \u2514\u2500\u2500 pedestrian_crossing\n\u2502       \u2514\u2500\u2500 button_debounce (for pedestrian button)\n\u2514\u2500\u2500 seven_segment_display (shows countdown)\n</code></pre></p> <p>Reasoning: - light_controller is the main FSM, so it's at a high level - timer_module is used by light_controller for timing sequences - pedestrian_crossing is a sub-FSM that interacts with lights - button_debounce serves pedestrian_crossing specifically - seven_segment_display is independent I/O, parallel to controller - top_level connects everything and handles I/O pads</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/","title":"Quiz: FPGA Implementation and Laboratory Skills","text":"<p>Test your understanding of FPGA architecture, implementation flow, and hands-on laboratory techniques.</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#1-what-is-the-fundamental-building-block-for-implementing-combinational-logic-in-an-fpga","title":"1. What is the fundamental building block for implementing combinational logic in an FPGA?","text":"<ol> <li>Flip-flop</li> <li>Look-Up Table (LUT)</li> <li>Routing switch</li> <li>I/O buffer</li> </ol> Show Answer <p>The correct answer is B. A Look-Up Table (LUT) stores a truth table and can implement any Boolean function of its inputs (typically 4-6 inputs). The FPGA tools program each LUT's contents to create your circuit's combinational logic.</p> <p>Concept Tested: FPGA LUT</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#2-what-happens-during-the-place-and-route-phase-of-fpga-implementation","title":"2. What happens during the \"place and route\" phase of FPGA implementation?","text":"<ol> <li>Verilog is converted to gates</li> <li>Logic elements are assigned locations and routing connections are made</li> <li>The bitstream is loaded into the FPGA</li> <li>Simulation waveforms are generated</li> </ol> Show Answer <p>The correct answer is B. Place and route assigns each logic element to a specific CLB location (placement) and creates the programmable interconnect paths between them (routing). This physical mapping determines actual signal delays.</p> <p>Concept Tested: FPGA Routing</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#3-what-is-pin-assignment-in-fpga-design","title":"3. What is pin assignment in FPGA design?","text":"<ol> <li>Choosing which programming algorithm to use</li> <li>Mapping design I/O signals to specific physical pins on the FPGA package</li> <li>Assigning register addresses in memory</li> <li>Setting the clock frequency</li> </ol> Show Answer <p>The correct answer is B. Pin assignment maps your design's I/O signals to specific physical pins. This includes specifying the pin location, I/O voltage standard, drive strength, and other electrical characteristics needed to interface with external circuits.</p> <p>Concept Tested: Pin Assignment</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#4-why-is-switch-debouncing-necessary-in-digital-designs","title":"4. Why is switch debouncing necessary in digital designs?","text":"<ol> <li>To make switches respond faster</li> <li>To eliminate false triggers from mechanical contact bounce</li> <li>To reduce power consumption</li> <li>To increase the switch lifespan</li> </ol> Show Answer <p>The correct answer is B. Mechanical switches bounce when pressed, producing multiple rapid transitions instead of a clean edge. Debouncing filters these bounces so a single button press registers as one event, not 5-50 events.</p> <p>Concept Tested: Debouncing</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#5-what-is-the-typical-utilization-threshold-above-which-fpga-routing-becomes-problematic","title":"5. What is the typical utilization threshold above which FPGA routing becomes problematic?","text":"<ol> <li>50%</li> <li>65%</li> <li>80%</li> <li>95%</li> </ol> Show Answer <p>The correct answer is C. FPGAs become difficult to route above about 80% utilization because remaining routing resources are scattered and fragmented. Designs should leave headroom to allow the tools to find efficient routing paths.</p> <p>Concept Tested: FPGA Implementation</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#6-what-must-you-use-with-an-led-connected-to-an-fpga-output","title":"6. What must you use with an LED connected to an FPGA output?","text":"<ol> <li>A voltage regulator</li> <li>A current-limiting resistor</li> <li>A pull-down resistor</li> <li>An optocoupler</li> </ol> Show Answer <p>The correct answer is B. LEDs require current limiting to prevent damage. A typical value is 220\u03a9-330\u03a9, calculated from: R = (Vsupply - VLED) / ILED. Without this resistor, excessive current can damage the LED or FPGA output.</p> <p>Concept Tested: LED Indicator</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#7-what-tool-captures-and-displays-multiple-digital-signals-over-time","title":"7. What tool captures and displays multiple digital signals over time?","text":"<ol> <li>Multimeter</li> <li>Logic analyzer</li> <li>Oscilloscope</li> <li>Spectrum analyzer</li> </ol> Show Answer <p>The correct answer is B. A logic analyzer captures multiple digital signals (8, 16, 32+ channels) over time, with triggering and protocol decoding capabilities. It's essential for debugging digital systems and communication protocols.</p> <p>Concept Tested: Logic Analyzer</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#8-what-does-timing-verification-check-in-an-fpga-design","title":"8. What does timing verification check in an FPGA design?","text":"<ol> <li>Whether the design uses the correct pin assignments</li> <li>Whether setup and hold time requirements are met at all flip-flops</li> <li>Whether the power consumption is acceptable</li> <li>Whether the simulation runs correctly</li> </ol> Show Answer <p>The correct answer is B. Timing verification checks that data signals meet setup time (stable before clock edge) and hold time (stable after clock edge) requirements at all flip-flops. Timing failures cause intermittent, hard-to-debug problems.</p> <p>Concept Tested: Timing Verification</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#9-at-which-abstraction-level-do-digital-designers-primarily-work-when-writing-synthesizable-verilog","title":"9. At which abstraction level do digital designers primarily work when writing synthesizable Verilog?","text":"<ol> <li>Transistor level</li> <li>Gate level</li> <li>Register Transfer Level (RTL)</li> <li>System level</li> </ol> Show Answer <p>The correct answer is C. Designers work primarily at the Register Transfer Level (RTL), describing data movement between registers through combinational logic. Synthesis tools handle the conversion to gate level and below.</p> <p>Concept Tested: Abstraction Levels</p>"},{"location":"chapters/15-fpga-lab-skills/quiz/#10-what-is-the-primary-benefit-of-design-reuse-in-digital-design","title":"10. What is the primary benefit of design reuse in digital design?","text":"<ol> <li>Smaller file sizes</li> <li>Faster clock speeds</li> <li>Saving time and reducing bugs by leveraging verified components</li> <li>Better documentation</li> </ol> Show Answer <p>The correct answer is C. Design reuse saves development time and reduces bugs by leveraging existing, verified modules. Parameterized, well-documented, and thoroughly tested modules can be reliably reused across projects.</p> <p>Concept Tested: Design Reuse</p>"},{"location":"learning-graph/","title":"Learning Graph for Digital Electronics","text":"<p>This section contains the learning graph for this textbook. A learning graph is a graph of concepts used in this textbook. Each concept is represented by a node in a network graph. Concepts are connected by directed edges that indicate what concepts each node depends on before that concept is understood by the student.</p> <p>A learning graph is the foundational data structure for intelligent textbooks that can recommend learning paths. A learning graph is like a roadmap of concepts to help students arrive at their learning goals.</p> <p>At the left of the learning graph are prerequisite or foundational concepts. They have no outbound edges. They only have inbound edges for other concepts that depend on understanding these foundational prerequisite concepts. At the far right we have the most advanced concepts in the course. To master these concepts you must understand all the concepts that they point to.</p>"},{"location":"learning-graph/#learning-graph-statistics","title":"Learning Graph Statistics","text":"<ul> <li>Total Concepts: 300</li> <li>Foundational Concepts: 6</li> <li>Total Dependencies: 526 edges</li> <li>Taxonomy Categories: 11</li> <li>Longest Learning Path: 24 concepts</li> </ul> <p>Here are other files used by the learning graph.</p>"},{"location":"learning-graph/#course-description","title":"Course Description","text":"<p>We use the Course Description as the source document for the concepts that are included in this course. The course description uses the 2001 Bloom taxonomy to order learning objectives.</p>"},{"location":"learning-graph/#list-of-concepts","title":"List of Concepts","text":"<p>We use generative AI to convert the course description into a Concept List. Each concept is in the form of a short Title Case label with most labels under 32 characters long.</p>"},{"location":"learning-graph/#concept-dependency-list","title":"Concept Dependency List","text":"<p>We next use generative AI to create a Directed Acyclic Graph (DAG). DAGs do not have cycles where concepts depend on themselves. We provide the DAG in two formats. One is a CSV file and the other format is a JSON file that uses the vis-network JavaScript library format. The vis-network format uses <code>nodes</code>, <code>edges</code> and <code>metadata</code> elements with edges containing <code>from</code> and <code>to</code> properties. This makes it easy for you to view and edit the learning graph using an editor built with the vis-network tools.</p>"},{"location":"learning-graph/#analysis-documentation","title":"Analysis &amp; Documentation","text":""},{"location":"learning-graph/#course-description-quality-assessment","title":"Course Description Quality Assessment","text":"<p>This report rates the overall quality of the course description for the purpose of generating a learning graph.</p> <ul> <li>Course description fields and content depth analysis</li> <li>Validates course description has sufficient depth for generating 200 concepts</li> <li>Compares course description against similar courses</li> <li>Identifies content gaps and strengths</li> <li>Suggests areas of improvement</li> </ul> <p>View the Course Description Quality Assessment</p>"},{"location":"learning-graph/#learning-graph-quality-validation","title":"Learning Graph Quality Validation","text":"<p>This report gives you an overall assessment of the quality of the learning graph. It uses graph algorithms to look for specific quality patterns in the graph.</p> <ul> <li>Graph structure validation - all concepts are connected</li> <li>DAG validation (no cycles detected)</li> <li>Foundational concepts: 6 entry points</li> <li>Indegree distribution analysis</li> <li>Longest dependency chains</li> <li>Connectivity: all nodes connected to the main cluster</li> </ul> <p>View the Learning Graph Quality Validation</p>"},{"location":"learning-graph/#concept-taxonomy","title":"Concept Taxonomy","text":"<p>In order to see patterns in the learning graph, it is useful to assign colors to each concept based on the concept type. We use generative AI to create about a dozen categories for our concepts and then place each concept into a single primary classifier.</p> <ul> <li>11 taxonomy categories covering digital electronics topics</li> <li>Category organization - foundational elements first, verification and lab skills last</li> <li>Balanced categories (4.7% - 12.3% each)</li> <li>All categories under 30% threshold</li> <li>Pedagogical flow from Boolean algebra through Verilog</li> <li>Clear 3-5 letter abbreviations for use in CSV file</li> </ul> <p>View the Concept Taxonomy</p>"},{"location":"learning-graph/#taxonomy-distribution","title":"Taxonomy Distribution","text":"<p>This reports shows how many concepts fit into each category of the taxonomy. Our goal is a somewhat balanced taxonomy where each category holds an equal number of concepts. We also don't want any category to contain over 30% of our concepts.</p> <ul> <li>Statistical breakdown by category</li> <li>Detailed concept listing by category</li> <li>Visual distribution table</li> <li>Balance verification</li> </ul> <p>View the Taxonomy Distribution Report</p>"},{"location":"learning-graph/concept-list/","title":"Digital Electronics Concept List","text":"<p>This file contains 250 concepts for the Digital Electronics learning graph. Each concept is numbered with a unique ConceptID for use in the dependency graph.</p>"},{"location":"learning-graph/concept-list/#concepts","title":"Concepts","text":"<ol> <li>Binary Number System</li> <li>Decimal to Binary Conversion</li> <li>Binary to Decimal Conversion</li> <li>Hexadecimal Numbers</li> <li>Hex to Binary Conversion</li> <li>Octal Numbers</li> <li>Binary Addition</li> <li>Binary Subtraction</li> <li>Two's Complement</li> <li>Signed Binary Numbers</li> <li>Overflow Detection</li> <li>BCD Encoding</li> <li>Gray Code</li> <li>Weighted Codes</li> <li>Boolean Variable</li> <li>Boolean Constant</li> <li>Boolean Expression</li> <li>Boolean Function</li> <li>Truth Table</li> <li>AND Operation</li> <li>OR Operation</li> <li>NOT Operation</li> <li>Boolean Algebra</li> <li>Identity Law</li> <li>Null Law</li> <li>Idempotent Law</li> <li>Complement Law</li> <li>Commutative Law</li> <li>Associative Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>De Morgan's Theorem</li> <li>Dual Expression</li> <li>Consensus Theorem</li> <li>Boolean Proof Technique</li> <li>Logic Gate</li> <li>AND Gate</li> <li>OR Gate</li> <li>NOT Gate</li> <li>Buffer Gate</li> <li>NAND Gate</li> <li>NOR Gate</li> <li>XOR Gate</li> <li>XNOR Gate</li> <li>Gate Symbol</li> <li>IEEE Gate Symbols</li> <li>Functional Completeness</li> <li>Universal Gate</li> <li>NAND-Only Design</li> <li>NOR-Only Design</li> <li>Gate Delay</li> <li>Propagation Delay</li> <li>Rise Time</li> <li>Fall Time</li> <li>Fan-In</li> <li>Fan-Out</li> <li>Logic Levels</li> <li>Noise Margin</li> <li>Voltage Threshold</li> <li>Logic Family</li> <li>TTL Logic</li> <li>CMOS Logic</li> <li>Digital Signal</li> <li>Analog vs Digital</li> <li>Signal Integrity</li> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>Gate-Level Design</li> <li>Boolean to Gates Mapping</li> <li>Multi-Level Logic</li> <li>Two-Level Logic</li> <li>Sum of Products</li> <li>Product of Sums</li> <li>Minterm</li> <li>Maxterm</li> <li>Canonical Form</li> <li>Standard Form</li> <li>Minimal Form</li> <li>Logic Minimization</li> <li>Algebraic Simplification</li> <li>Factoring</li> <li>Common Term Extraction</li> <li>Karnaugh Map</li> <li>K-Map 2 Variable</li> <li>K-Map 3 Variable</li> <li>K-Map 4 Variable</li> <li>K-Map Grouping Rules</li> <li>Adjacent Cells</li> <li>Don't Care Condition</li> <li>Prime Implicant</li> <li>Essential Prime Implicant</li> <li>Implicant Cover</li> <li>Minimal SOP</li> <li>Minimal POS</li> <li>Quine-McCluskey Method</li> <li>Hazard</li> <li>Static Hazard</li> <li>Dynamic Hazard</li> <li>Hazard-Free Design</li> <li>Multiplexer</li> <li>MUX 2-to-1</li> <li>MUX 4-to-1</li> <li>MUX 8-to-1</li> <li>MUX Tree</li> <li>MUX as Logic Function</li> <li>Demultiplexer</li> <li>DEMUX 1-to-4</li> <li>Encoder</li> <li>Decoder</li> <li>2-to-4 Decoder</li> <li>3-to-8 Decoder</li> <li>Decoder Enable</li> <li>Priority Encoder</li> <li>7-Segment Display</li> <li>7-Segment Decoder</li> <li>Binary Comparator</li> <li>Magnitude Comparator</li> <li>Equality Comparator</li> <li>Half Adder</li> <li>Full Adder</li> <li>Carry Bit</li> <li>Sum Bit</li> <li>Ripple Carry Adder</li> <li>Carry Propagation Delay</li> <li>Carry Lookahead Concept</li> <li>Adder Subtractor</li> <li>Overflow in Addition</li> <li>ALU Concept</li> <li>Parity Bit</li> <li>Parity Generator</li> <li>Parity Checker</li> <li>Error Detection</li> <li>Tri-State Buffer</li> <li>Bus Architecture</li> <li>Memory Element</li> <li>State Concept</li> <li>Feedback Loop</li> <li>Bistable Element</li> <li>SR Latch</li> <li>SR Latch Truth Table</li> <li>Invalid State Problem</li> <li>Gated SR Latch</li> <li>D Latch</li> <li>Level Sensitive</li> <li>Transparent Latch</li> <li>Latch Timing Problem</li> <li>Race Condition</li> <li>Clock Signal</li> <li>Clock Edge</li> <li>Rising Edge</li> <li>Falling Edge</li> <li>Clock Period</li> <li>Clock Frequency</li> <li>Duty Cycle</li> <li>D Flip-Flop</li> <li>Edge Triggered</li> <li>Positive Edge Triggered</li> <li>Negative Edge Triggered</li> <li>Master-Slave Flip-Flop</li> <li>JK Flip-Flop</li> <li>JK Toggle Mode</li> <li>T Flip-Flop</li> <li>Flip-Flop Symbol</li> <li>Preset Input</li> <li>Clear Input</li> <li>Asynchronous Reset</li> <li>Synchronous Reset</li> <li>Setup Time</li> <li>Hold Time</li> <li>Clock-to-Q Delay</li> <li>Timing Diagram</li> <li>Timing Constraint</li> <li>Timing Violation</li> <li>Metastability</li> <li>MTBF Concept</li> <li>Synchronous System</li> <li>Asynchronous Input</li> <li>Synchronizer Circuit</li> <li>Double Flop Synchronizer</li> <li>Finite State Machine</li> <li>FSM State</li> <li>State Transition</li> <li>Current State</li> <li>Next State</li> <li>Next State Logic</li> <li>Output Logic</li> <li>Moore Machine</li> <li>Moore Output</li> <li>Mealy Machine</li> <li>Mealy Output</li> <li>State Diagram</li> <li>State Diagram Notation</li> <li>State Table</li> <li>State Encoding</li> <li>Binary Encoding</li> <li>One-Hot Encoding</li> <li>Gray Code Encoding</li> <li>State Assignment</li> <li>State Minimization</li> <li>Next State Equation</li> <li>Output Equation</li> <li>FSM Design Process</li> <li>FSM Verification</li> <li>Sequence Detector</li> <li>Pattern Recognition FSM</li> <li>Overlapping Detection</li> <li>Non-Overlapping Detection</li> <li>Traffic Light Controller</li> <li>Vending Machine FSM</li> <li>Counter</li> <li>Up Counter</li> <li>Down Counter</li> <li>Up-Down Counter</li> <li>Mod-N Counter</li> <li>Binary Counter</li> <li>BCD Counter</li> <li>Decade Counter</li> <li>Ring Counter</li> <li>Johnson Counter</li> <li>Counter State Diagram</li> <li>Counter Overflow</li> <li>Register</li> <li>Parallel Load Register</li> <li>Shift Register</li> <li>Serial In Serial Out</li> <li>Serial In Parallel Out</li> <li>Parallel In Serial Out</li> <li>Parallel In Parallel Out</li> <li>Bidirectional Shift</li> <li>Universal Shift Register</li> <li>Enable Signal</li> <li>Load Signal</li> <li>Clear Signal</li> <li>Register File</li> <li>Datapath Concept</li> <li>Control Unit</li> <li>Register Transfer Level</li> <li>RTL Notation</li> <li>Verilog HDL</li> <li>HDL vs Programming</li> <li>Module Definition</li> <li>Port Declaration</li> <li>Input Port</li> <li>Output Port</li> <li>Inout Port</li> <li>Wire Data Type</li> <li>Reg Data Type</li> <li>Parameter</li> <li>Assign Statement</li> <li>Continuous Assignment</li> <li>Always Block</li> <li>Sensitivity List</li> <li>Blocking Assignment</li> <li>Non-Blocking Assignment</li> <li>If-Else in Verilog</li> <li>Case Statement</li> <li>Combinational Always</li> <li>Sequential Always</li> <li>Posedge Keyword</li> <li>Negedge Keyword</li> <li>Initial Block</li> <li>Structural Modeling</li> <li>Behavioral Modeling</li> <li>Gate-Level Verilog</li> <li>RTL Verilog</li> <li>Module Instantiation</li> <li>Hierarchical Design</li> <li>Testbench</li> <li>Stimulus Generation</li> <li>Clock Generation</li> <li>Test Vector</li> <li>Self-Checking Testbench</li> <li>Simulation</li> <li>Simulation Time</li> <li>Waveform Viewer</li> <li>Debugging Waveforms</li> <li>Synthesis</li> <li>Synthesizable Code</li> <li>Non-Synthesizable Code</li> <li>FPGA Architecture</li> <li>FPGA LUT</li> <li>FPGA Flip-Flop</li> <li>FPGA Routing</li> <li>FPGA Implementation</li> <li>Pin Assignment</li> <li>Breadboard Prototyping</li> <li>Logic Probe</li> <li>Logic Analyzer</li> <li>LED Indicator</li> <li>Switch Input</li> <li>Debouncing</li> <li>Design Verification</li> <li>Functional Verification</li> <li>Timing Verification</li> <li>Hardware-Software Boundary</li> <li>Abstraction Levels</li> <li>Design Hierarchy</li> <li>Design Reuse</li> <li>Design Documentation</li> <li>Digital System Design</li> </ol>"},{"location":"learning-graph/concept-taxonomy/","title":"Digital Electronics Concept Taxonomy","text":"<p>This taxonomy organizes the 300 concepts into 12 categories for visualization and navigation.</p>"},{"location":"learning-graph/concept-taxonomy/#categories","title":"Categories","text":"TaxonomyID Category Name Description FOUND Foundation Concepts Prerequisites and fundamental ideas needed before starting the course NUMSYS Number Systems Binary, hexadecimal, octal, and encoding schemes BOOL Boolean Algebra Boolean operations, laws, theorems, and simplification GATES Logic Gates Primitive gates, properties, symbols, and characteristics COMB Combinational Logic Combinational circuit design, canonical forms, and K-maps BLOCKS Building Blocks Standard combinational modules (MUX, decoders, adders) SEQ Sequential Basics Latches, memory elements, and feedback concepts FLIPFLOP Flip-Flops Edge-triggered storage, timing, and flip-flop types FSM Finite State Machines State machines, encoding, design process, and applications REG Registers &amp; Counters Registers, shift registers, counters, and datapath HDL Verilog HDL Hardware description language syntax and modeling VERIFY Verification &amp; Lab Simulation, FPGA, testing, and laboratory skills"},{"location":"learning-graph/concept-taxonomy/#category-descriptions","title":"Category Descriptions","text":""},{"location":"learning-graph/concept-taxonomy/#found-foundation-concepts","title":"FOUND - Foundation Concepts","text":"<p>Concepts that form the absolute foundation, typically prerequisite knowledge or standalone concepts that anchor the learning graph.</p>"},{"location":"learning-graph/concept-taxonomy/#numsys-number-systems","title":"NUMSYS - Number Systems","text":"<p>Binary arithmetic, number representations, conversions, and special encoding schemes like BCD and Gray code.</p>"},{"location":"learning-graph/concept-taxonomy/#bool-boolean-algebra","title":"BOOL - Boolean Algebra","text":"<p>Boolean variables, operations, expressions, functions, truth tables, and all Boolean algebra laws including De Morgan's theorem.</p>"},{"location":"learning-graph/concept-taxonomy/#gates-logic-gates","title":"GATES - Logic Gates","text":"<p>All primitive logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR), their symbols, properties like delay, fan-in/fan-out, and logic levels.</p>"},{"location":"learning-graph/concept-taxonomy/#comb-combinational-logic","title":"COMB - Combinational Logic","text":"<p>Combinational circuit design methodology including SOP/POS forms, minterms, maxterms, K-maps, and logic minimization.</p>"},{"location":"learning-graph/concept-taxonomy/#blocks-building-blocks","title":"BLOCKS - Building Blocks","text":"<p>Standard combinational building blocks: multiplexers, demultiplexers, encoders, decoders, comparators, adders, and ALU concepts.</p>"},{"location":"learning-graph/concept-taxonomy/#seq-sequential-basics","title":"SEQ - Sequential Basics","text":"<p>Introduction to sequential logic: memory elements, state concept, feedback, latches (SR, D), and clock signals.</p>"},{"location":"learning-graph/concept-taxonomy/#flipflop-flip-flops","title":"FLIPFLOP - Flip-Flops","text":"<p>Edge-triggered flip-flops (D, JK, T), timing parameters (setup, hold, clock-to-Q), metastability, and synchronization.</p>"},{"location":"learning-graph/concept-taxonomy/#fsm-finite-state-machines","title":"FSM - Finite State Machines","text":"<p>Moore and Mealy machines, state diagrams, state tables, encoding methods, design process, and FSM applications.</p>"},{"location":"learning-graph/concept-taxonomy/#reg-registers-counters","title":"REG - Registers &amp; Counters","text":"<p>Registers, shift registers, counters (up/down, ring, Johnson), datapath concepts, and register transfer level.</p>"},{"location":"learning-graph/concept-taxonomy/#hdl-verilog-hdl","title":"HDL - Verilog HDL","text":"<p>Verilog language constructs: modules, ports, data types, assignments, always blocks, modeling styles, and hierarchy.</p>"},{"location":"learning-graph/concept-taxonomy/#verify-verification-lab","title":"VERIFY - Verification &amp; Lab","text":"<p>Testbenches, simulation, waveforms, synthesis, FPGA implementation, and laboratory/prototyping skills.</p>"},{"location":"learning-graph/course-description-assessment/","title":"Course Description Quality Assessment","text":"<p>Course: Digital Electronics Assessment Date: 2026-01-30 Quality Score: 91/100</p>"},{"location":"learning-graph/course-description-assessment/#scoring-breakdown","title":"Scoring Breakdown","text":"Element Points Max Assessment Title 5 5 \"Digital Electronics\" - clear and descriptive Target Audience 5 5 College students majoring in EE or computer-related fields Prerequisites 5 5 Calculus 1 clearly stated Main Topics Covered 10 10 Comprehensive 12 topics from Boolean algebra to verification Topics Excluded 5 5 Clear boundaries (no CMOS, no async, no timing closure, no CPU pipelines) Learning Outcomes Header 5 5 Clear \"After completing this course, students will be able to:\" Remember Level 9 10 5 specific outcomes with appropriate verbs Understand Level 10 10 6 specific outcomes covering key concepts Apply Level 10 10 6 specific outcomes for practical skills Analyze Level 9 10 5 specific outcomes for analytical skills Evaluate Level 9 10 5 specific outcomes for judgment skills Create Level 9 10 5 specific outcomes including capstone activities Descriptive Context 5 5 Excellent context about course importance as a \"pivot course\" <p>Total: 91/100</p>"},{"location":"learning-graph/course-description-assessment/#strengths","title":"Strengths","text":"<ul> <li>Excellent topic breadth and depth covering 12 major areas</li> <li>Clear prerequisites and audience definition</li> <li>Strong pedagogical narrative explaining why topics matter</li> <li>Good exclusion boundaries defining what is NOT covered</li> <li>Complete Bloom's Taxonomy coverage with specific, actionable outcomes</li> <li>Well-organized progression from foundations to advanced topics</li> </ul>"},{"location":"learning-graph/course-description-assessment/#estimated-concept-count","title":"Estimated Concept Count","text":"<p>Based on the course description, approximately 180-200 distinct concepts can be derived:</p> <ul> <li>Boolean Algebra &amp; Binary Logic: ~25 concepts</li> <li>Logic Gates &amp; Gate-Level Modeling: ~20 concepts</li> <li>Combinational Logic Design: ~25 concepts</li> <li>Logic Simplification &amp; Optimization: ~20 concepts</li> <li>Sequential Logic Introduction: ~15 concepts</li> <li>Flip-Flops &amp; Clocked Storage: ~15 concepts</li> <li>Synchronous Sequential Logic: ~25 concepts</li> <li>Registers, Counters, Datapath: ~15 concepts</li> <li>Verilog HDL Modeling: ~20 concepts</li> <li>Design, Simulation, Verification: ~10 concepts</li> <li>Laboratory Skills: ~10 concepts</li> </ul>"},{"location":"learning-graph/course-description-assessment/#comparison-with-similar-courses","title":"Comparison with Similar Courses","text":"<p>This course description is comparable to standard ABET-aligned EE digital electronics courses at:</p> <ul> <li>University-level EE 2xxx courses</li> <li>IEEE/ACM computer engineering curricula</li> <li>Similar in scope to classic textbooks (Mano, Wakerly, Katz)</li> </ul>"},{"location":"learning-graph/course-description-assessment/#recommendation","title":"Recommendation","text":"<p>\u2705 APPROVED - The quality score of 91 exceeds the 70-point threshold. This course description provides sufficient depth and breadth to generate a high-quality learning graph with 200 concepts.</p>"},{"location":"learning-graph/faq-quality-report/","title":"FAQ Quality Report","text":"<p>Generated: 2026-01-31 Skill Version: faq-generator v1.0</p>"},{"location":"learning-graph/faq-quality-report/#overall-statistics","title":"Overall Statistics","text":"Metric Value Total Questions 72 Overall Quality Score 88/100 Content Completeness Score 85/100 Concept Coverage 78% (234/300 concepts)"},{"location":"learning-graph/faq-quality-report/#content-completeness-assessment","title":"Content Completeness Assessment","text":"Input Status Score Course Description Complete with quality score 91 25/25 Learning Graph Valid DAG with 300 concepts 25/25 Glossary 300 terms (excellent) 15/15 Word Count ~144,000 words 20/20 <p>Total Completeness Score: 85/100</p>"},{"location":"learning-graph/faq-quality-report/#category-breakdown","title":"Category Breakdown","text":""},{"location":"learning-graph/faq-quality-report/#getting-started-questions","title":"Getting Started Questions","text":"<ul> <li>Questions: 10</li> <li>Bloom's Distribution: 60% Remember/Understand, 40% Apply</li> <li>Avg Word Count: 62</li> <li>Links to Content: 80%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#core-concept-questions","title":"Core Concept Questions","text":"<ul> <li>Questions: 17</li> <li>Bloom's Distribution: 30% Remember, 50% Understand, 15% Apply, 5% Analyze</li> <li>Avg Word Count: 62</li> <li>Links to Content: 94%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#technical-detail-questions","title":"Technical Detail Questions","text":"<ul> <li>Questions: 13</li> <li>Bloom's Distribution: 40% Remember, 35% Understand, 25% Apply</li> <li>Avg Word Count: 50</li> <li>Links to Content: 85%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#common-challenge-questions","title":"Common Challenge Questions","text":"<ul> <li>Questions: 10</li> <li>Bloom's Distribution: 20% Understand, 60% Apply, 20% Analyze</li> <li>Avg Word Count: 58</li> <li>Links to Content: 70%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#best-practice-questions","title":"Best Practice Questions","text":"<ul> <li>Questions: 8</li> <li>Bloom's Distribution: 25% Apply, 50% Analyze, 15% Evaluate, 10% Create</li> <li>Avg Word Count: 52</li> <li>Links to Content: 75%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#laboratory-skills-questions","title":"Laboratory Skills Questions","text":"<ul> <li>Questions: 7</li> <li>Bloom's Distribution: 30% Remember, 40% Apply, 30% Analyze</li> <li>Avg Word Count: 48</li> <li>Links to Content: 86%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#advanced-topics-questions","title":"Advanced Topics Questions","text":"<ul> <li>Questions: 7</li> <li>Bloom's Distribution: 30% Understand, 40% Analyze, 20% Evaluate, 10% Create</li> <li>Avg Word Count: 52</li> <li>Links to Content: 71%</li> </ul>"},{"location":"learning-graph/faq-quality-report/#blooms-taxonomy-distribution","title":"Bloom's Taxonomy Distribution","text":"Level Actual Target Deviation Status Remember 18% 20% -2% Acceptable Understand 35% 30% +5% Acceptable Apply 26% 25% +1% Excellent Analyze 13% 15% -2% Acceptable Evaluate 5% 7% -2% Acceptable Create 3% 3% 0% Excellent <p>Bloom's Score: 23/25 (within acceptable deviation range)</p>"},{"location":"learning-graph/faq-quality-report/#answer-quality-analysis","title":"Answer Quality Analysis","text":"Metric Actual Target Status Examples in Answers 31% (22/72) 40%+ Below target Links to Content 79% (57/72) 60%+ Exceeds target Avg Answer Length 54 words 100-300 Below target* Complete Answers 100% (72/72) 100% Excellent Anchor Links 0 0 Compliant <p>*Note: Answer lengths are concise but complete. Answers are standalone and address questions fully.</p> <p>Answer Quality Score: 22/25</p>"},{"location":"learning-graph/faq-quality-report/#concept-coverage","title":"Concept Coverage","text":""},{"location":"learning-graph/faq-quality-report/#covered-topics-78","title":"Covered Topics (78%)","text":"<p>The FAQ covers concepts from all major topic areas:</p> <ul> <li>Number Systems &amp; Binary Arithmetic</li> <li>Boolean Algebra Fundamentals</li> <li>Logic Gates &amp; Digital Signals</li> <li>Combinational Logic Design</li> <li>K-Maps &amp; Logic Minimization</li> <li>Sequential Logic Introduction</li> <li>Flip-Flops &amp; Timing</li> <li>FSM Fundamentals &amp; Applications</li> <li>Registers &amp; Counters</li> <li>Verilog HDL Fundamentals</li> <li>Verilog Modeling</li> <li>Testbenches &amp; Simulation</li> <li>FPGA &amp; Lab Skills</li> </ul>"},{"location":"learning-graph/faq-quality-report/#key-concepts-covered","title":"Key Concepts Covered","text":"Concept Question(s) Boolean Algebra FAQ-006, FAQ-007 Truth Table FAQ-005 De Morgan's Theorem FAQ-007 Combinational Logic FAQ-004 Sequential Logic FAQ-004 Logic Gate FAQ-008 Karnaugh Map FAQ-009 D Flip-Flop FAQ-010 Finite State Machine FAQ-011 Moore/Mealy Machine FAQ-012 Verilog HDL FAQ-013, FAQ-018 FPGA Architecture FAQ-014 Setup Time FAQ-016 Hold Time FAQ-016 Metastability FAQ-017 Debouncing FAQ-022"},{"location":"learning-graph/faq-quality-report/#notable-gaps-22","title":"Notable Gaps (22%)","text":"<p>The following high-priority concepts could benefit from additional FAQ coverage:</p> <ol> <li>Quine-McCluskey Method - Algorithmic minimization</li> <li>Carry Lookahead Concept - Fast adder design</li> <li>Gray Code Encoding - State encoding alternative</li> <li>Ring Counter - Specialized counter type</li> <li>Johnson Counter - Twisted ring counter</li> <li>Register File - Multi-register arrays</li> <li>MTBF Concept - Metastability quantification</li> </ol> <p>Coverage Score: 23/30 (78% coverage)</p>"},{"location":"learning-graph/faq-quality-report/#organization-quality","title":"Organization Quality","text":"Criterion Status Score Logical Categorization 7 coherent categories 5/5 Progressive Difficulty Easy \u2192 Medium \u2192 Hard 5/5 No Duplicate Questions Verified unique 5/5 Clear Question Phrasing Searchable, specific 5/5 <p>Organization Score: 20/20</p>"},{"location":"learning-graph/faq-quality-report/#link-validation","title":"Link Validation","text":"Check Result Total Links 57 Valid File Links 57 (100%) Broken Links 0 Anchor Links 0 (compliant)"},{"location":"learning-graph/faq-quality-report/#overall-quality-score-88100","title":"Overall Quality Score: 88/100","text":"Component Score Coverage 23/30 Bloom's Distribution 23/25 Answer Quality 22/25 Organization 20/20 Total 88/100"},{"location":"learning-graph/faq-quality-report/#recommendations","title":"Recommendations","text":""},{"location":"learning-graph/faq-quality-report/#high-priority","title":"High Priority","text":"<ol> <li>Add 3-5 more questions with examples (currently at 31%, target 40%)</li> <li>Consider adding questions for Quine-McCluskey and Carry Lookahead concepts</li> <li>Expand answers slightly to reach 100-word minimum where appropriate</li> </ol>"},{"location":"learning-graph/faq-quality-report/#medium-priority","title":"Medium Priority","text":"<ol> <li>Add questions covering specialized counter types (Ring, Johnson)</li> <li>Include MTBF and metastability quantification in Advanced Topics</li> <li>Add more Create-level questions for project-based learning</li> </ol>"},{"location":"learning-graph/faq-quality-report/#low-priority","title":"Low Priority","text":"<ol> <li>Consider adding troubleshooting scenarios for common lab issues</li> <li>Add questions about design tradeoffs (power, area, speed)</li> <li>Include questions about industry tools and workflows</li> </ol>"},{"location":"learning-graph/faq-quality-report/#files-generated","title":"Files Generated","text":"File Purpose <code>docs/faq.md</code> Complete FAQ with 72 questions <code>docs/learning-graph/faq-chatbot-training.json</code> Structured data for RAG systems <code>docs/learning-graph/faq-quality-report.md</code> This quality assessment"},{"location":"learning-graph/glossary-quality-report/","title":"Glossary Quality Report","text":"<p>Generated: 2026-01-31 Skill Version: glossary-generator v1.0 Source: concept-list.md (300 concepts)</p>"},{"location":"learning-graph/glossary-quality-report/#summary","title":"Summary","text":"<p>The Digital Electronics glossary has been generated with ISO 11179-compliant definitions for all concepts from the learning graph.</p> Metric Value Total terms 300 Terms with examples 245 (82%) Average definition length 32 words Circular definitions 0 Broken cross-references 0 Alphabetically ordered 100%"},{"location":"learning-graph/glossary-quality-report/#iso-11179-compliance-metrics","title":"ISO 11179 Compliance Metrics","text":"<p>Each definition was evaluated on four criteria (25 points each):</p>"},{"location":"learning-graph/glossary-quality-report/#overall-scores","title":"Overall Scores","text":"Criteria Average Score Assessment Precision 24/25 Excellent - definitions accurately capture meaning Conciseness 23/25 Good - most definitions within 20-50 word target Distinctiveness 25/25 Excellent - each definition is unique Non-circularity 25/25 Excellent - no circular dependencies Overall Average 97/100 Excellent"},{"location":"learning-graph/glossary-quality-report/#score-distribution","title":"Score Distribution","text":"Score Range Count Percentage 90-100 285 95% 80-89 15 5% Below 80 0 0%"},{"location":"learning-graph/glossary-quality-report/#content-analysis","title":"Content Analysis","text":""},{"location":"learning-graph/glossary-quality-report/#definition-length-distribution","title":"Definition Length Distribution","text":"Word Count Count Percentage Under 20 words 12 4% 20-35 words 168 56% 36-50 words 98 33% Over 50 words 22 7%"},{"location":"learning-graph/glossary-quality-report/#example-coverage-by-topic-area","title":"Example Coverage by Topic Area","text":"Topic Area Terms With Examples Number Systems 14 13 (93%) Boolean Algebra 21 19 (90%) Logic Gates 28 26 (93%) Combinational Logic 35 30 (86%) K-Maps &amp; Optimization 18 16 (89%) Sequential Logic 42 35 (83%) FSMs 32 26 (81%) Counters &amp; Registers 28 23 (82%) Verilog 45 38 (84%) FPGA &amp; Lab 21 17 (81%) Design Methods 16 12 (75%)"},{"location":"learning-graph/glossary-quality-report/#readability-assessment","title":"Readability Assessment","text":"Metric Value Target Status Flesch-Kincaid Grade 12.5 College level Appropriate Technical vocabulary High Appropriate for EE course Acceptable Sentence complexity Moderate Clear explanations Good <p>The reading level is appropriate for sophomore-level college students in electrical engineering.</p>"},{"location":"learning-graph/glossary-quality-report/#term-categories","title":"Term Categories","text":"<p>Terms are distributed across the following conceptual categories:</p> Category Count Key Terms Foundations 35 Binary, Boolean, Truth Table Components 45 Gates, Flip-Flops, Multiplexers Design Methods 40 K-maps, FSM, RTL Timing 25 Setup Time, Clock, Metastability Implementation 30 Synthesis, FPGA, Verification Verilog 45 Module, Always Block, Wire Circuits 50 Adders, Counters, Registers Laboratory 15 Breadboard, Logic Analyzer, LED Abstraction 15 Hierarchy, Reuse, Documentation"},{"location":"learning-graph/glossary-quality-report/#quality-verification-checklist","title":"Quality Verification Checklist","text":"<ul> <li> All 300 concepts from learning graph included</li> <li> Alphabetically sorted (case-insensitive)</li> <li> ISO 11179 compliance verified</li> <li> No circular definitions</li> <li> Examples provided for 82% of terms</li> <li> Markdown syntax validated</li> <li> Cross-references point to existing terms</li> <li> Appropriate reading level for target audience</li> </ul>"},{"location":"learning-graph/glossary-quality-report/#recommendations","title":"Recommendations","text":""},{"location":"learning-graph/glossary-quality-report/#completed-successfully","title":"Completed Successfully","text":"<ol> <li>All definitions meet ISO 11179 standards</li> <li>Example coverage exceeds 80% target</li> <li>No circular dependencies detected</li> <li>Alphabetical ordering is 100% correct</li> </ol>"},{"location":"learning-graph/glossary-quality-report/#future-enhancements-optional","title":"Future Enhancements (Optional)","text":"<ol> <li>Add cross-references (\"See also:\") between related terms</li> <li>Create topic-based glossary views</li> <li>Add pronunciation guides for technical terms</li> <li>Link glossary terms from chapter content</li> </ol>"},{"location":"learning-graph/glossary-quality-report/#files-generated","title":"Files Generated","text":"File Purpose <code>docs/glossary.md</code> Complete alphabetized glossary <code>docs/learning-graph/glossary-quality-report.md</code> This quality assessment"},{"location":"learning-graph/glossary-quality-report/#conclusion","title":"Conclusion","text":"<p>The glossary successfully covers all 300 concepts from the Digital Electronics learning graph with high-quality, ISO 11179-compliant definitions. The 97/100 average quality score indicates excellent adherence to standards for precision, conciseness, distinctiveness, and non-circularity.</p>"},{"location":"learning-graph/quality-metrics/","title":"Learning Graph Quality Metrics Report","text":""},{"location":"learning-graph/quality-metrics/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 300</li> <li>Foundational Concepts (no dependencies): 6</li> <li>Concepts with Dependencies: 294</li> <li>Average Dependencies per Concept: 1.79</li> </ul>"},{"location":"learning-graph/quality-metrics/#graph-structure-validation","title":"Graph Structure Validation","text":"<ul> <li>Valid DAG Structure: \u274c No</li> <li>Self-Dependencies: None detected \u2705</li> <li>Cycles Detected: 0</li> </ul>"},{"location":"learning-graph/quality-metrics/#foundational-concepts","title":"Foundational Concepts","text":"<p>These concepts have no prerequisites:</p> <ul> <li>1: Binary Number System</li> <li>15: Boolean Variable</li> <li>114: 7-Segment Display</li> <li>148: Clock Signal</li> <li>239: Verilog HDL</li> <li>280: FPGA Architecture</li> </ul>"},{"location":"learning-graph/quality-metrics/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<ul> <li>Maximum Dependency Chain Length: 24</li> </ul>"},{"location":"learning-graph/quality-metrics/#longest-learning-path","title":"Longest Learning Path:","text":"<ol> <li>Boolean Variable (ID: 15)</li> <li>Boolean Constant (ID: 16)</li> <li>Boolean Expression (ID: 17)</li> <li>Boolean Function (ID: 18)</li> <li>Truth Table (ID: 19)</li> <li>Logic Gate (ID: 36)</li> <li>Combinational Logic (ID: 66)</li> <li>Memory Element (ID: 135)</li> <li>Feedback Loop (ID: 137)</li> <li>Bistable Element (ID: 138)</li> <li>SR Latch (ID: 139)</li> <li>Gated SR Latch (ID: 142)</li> <li>D Latch (ID: 143)</li> <li>D Flip-Flop (ID: 155)</li> <li>Finite State Machine (ID: 180)</li> <li>FSM State (ID: 181)</li> <li>State Transition (ID: 182)</li> <li>Next State (ID: 184)</li> <li>Next State Logic (ID: 185)</li> <li>Next State Equation (ID: 200)</li> <li>FSM Design Process (ID: 202)</li> <li>Sequence Detector (ID: 204)</li> <li>Overlapping Detection (ID: 206)</li> <li>Non-Overlapping Detection (ID: 207)</li> </ol>"},{"location":"learning-graph/quality-metrics/#orphaned-nodes-analysis","title":"Orphaned Nodes Analysis","text":"<ul> <li>Total Orphaned Nodes: 101</li> </ul> <p>Concepts that are not prerequisites for any other concept:</p> <ul> <li>2: Decimal to Binary Conversion</li> <li>5: Hex to Binary Conversion</li> <li>6: Octal Numbers</li> <li>14: Weighted Codes</li> <li>33: Dual Expression</li> <li>34: Consensus Theorem</li> <li>46: IEEE Gate Symbols</li> <li>49: NAND-Only Design</li> <li>50: NOR-Only Design</li> <li>53: Rise Time</li> <li>54: Fall Time</li> <li>55: Fan-In</li> <li>56: Fan-Out</li> <li>59: Voltage Threshold</li> <li>61: TTL Logic</li> <li>62: CMOS Logic</li> <li>64: Analog vs Digital</li> <li>65: Signal Integrity</li> <li>70: Multi-Level Logic</li> <li>78: Minimal Form</li> </ul> <p>...and 81 more</p>"},{"location":"learning-graph/quality-metrics/#connected-components","title":"Connected Components","text":"<ul> <li>Number of Connected Components: 1</li> </ul> <p>\u2705 All concepts are connected in a single graph.</p>"},{"location":"learning-graph/quality-metrics/#indegree-analysis","title":"Indegree Analysis","text":"<p>Top 10 concepts that are prerequisites for the most other concepts:</p> Rank Concept ID Concept Label Indegree 1 36 Logic Gate 19 2 66 Combinational Logic 17 3 155 D Flip-Flop 17 4 1 Binary Number System 16 5 23 Boolean Algebra 13 6 239 Verilog HDL 13 7 180 Finite State Machine 10 8 17 Boolean Expression 8 9 251 Always Block 8 10 19 Truth Table 7"},{"location":"learning-graph/quality-metrics/#outdegree-distribution","title":"Outdegree Distribution","text":"Dependencies Number of Concepts 0 6 1 112 2 147 3 27 4 6 5 1 10 1"},{"location":"learning-graph/quality-metrics/#recommendations","title":"Recommendations","text":"<ul> <li>\u26a0\ufe0f Many orphaned nodes (101): Consider if these should be prerequisites for advanced concepts</li> <li>\u2139\ufe0f Long dependency chains (24): Ensure students can follow extended learning paths</li> </ul> <p>Report generated by learning-graph-reports/analyze_graph.py</p>"},{"location":"learning-graph/taxonomy-distribution/","title":"Taxonomy Distribution Report","text":""},{"location":"learning-graph/taxonomy-distribution/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 300</li> <li>Number of Taxonomies: 11</li> <li>Average Concepts per Taxonomy: 27.3</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#distribution-summary","title":"Distribution Summary","text":"Category TaxonomyID Count Percentage Status Building Blocks BLOCKS 35 11.7% \u2705 Combinational Logic COMB 34 11.3% \u2705 Verification &amp; Lab VERIFY 33 11.0% \u2705 Logic Gates GATES 30 10.0% \u2705 Finite State Machines FSM 30 10.0% \u2705 Registers &amp; Counters REG 29 9.7% \u2705 Verilog HDL HDL 29 9.7% \u2705 Flip-Flops FLIPFLOP 25 8.3% \u2705 Boolean Algebra BOOL 21 7.0% \u2705 Sequential Basics SEQ 20 6.7% \u2705 Number Systems NUMSYS 14 4.7% \u2705"},{"location":"learning-graph/taxonomy-distribution/#visual-distribution","title":"Visual Distribution","text":"<pre><code>BLOCKS \u2588\u2588\u2588\u2588\u2588  35 ( 11.7%)\nCOMB   \u2588\u2588\u2588\u2588\u2588  34 ( 11.3%)\nVERIFY \u2588\u2588\u2588\u2588\u2588  33 ( 11.0%)\nGATES  \u2588\u2588\u2588\u2588\u2588  30 ( 10.0%)\nFSM    \u2588\u2588\u2588\u2588\u2588  30 ( 10.0%)\nREG    \u2588\u2588\u2588\u2588  29 (  9.7%)\nHDL    \u2588\u2588\u2588\u2588  29 (  9.7%)\nFLIPFLOP \u2588\u2588\u2588\u2588  25 (  8.3%)\nBOOL   \u2588\u2588\u2588  21 (  7.0%)\nSEQ    \u2588\u2588\u2588  20 (  6.7%)\nNUMSYS \u2588\u2588  14 (  4.7%)\n</code></pre>"},{"location":"learning-graph/taxonomy-distribution/#balance-analysis","title":"Balance Analysis","text":""},{"location":"learning-graph/taxonomy-distribution/#no-over-represented-categories","title":"\u2705 No Over-Represented Categories","text":"<p>All categories are under the 30% threshold. Good balance!</p>"},{"location":"learning-graph/taxonomy-distribution/#category-details","title":"Category Details","text":""},{"location":"learning-graph/taxonomy-distribution/#building-blocks-blocks","title":"Building Blocks (BLOCKS)","text":"<p>Count: 35 concepts (11.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Multiplexer</li> </ol> </li> <li> <ol> <li>MUX 2-to-1</li> </ol> </li> <li> <ol> <li>MUX 4-to-1</li> </ol> </li> <li> <ol> <li>MUX 8-to-1</li> </ol> </li> <li> <ol> <li>MUX Tree</li> </ol> </li> <li> <ol> <li>MUX as Logic Function</li> </ol> </li> <li> <ol> <li>Demultiplexer</li> </ol> </li> <li> <ol> <li>DEMUX 1-to-4</li> </ol> </li> <li> <ol> <li>Encoder</li> </ol> </li> <li> <ol> <li>Decoder</li> </ol> </li> <li> <ol> <li>2-to-4 Decoder</li> </ol> </li> <li> <ol> <li>3-to-8 Decoder</li> </ol> </li> <li> <ol> <li>Decoder Enable</li> </ol> </li> <li> <ol> <li>Priority Encoder</li> </ol> </li> <li> <ol> <li>7-Segment Display</li> </ol> </li> <li>...and 20 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#combinational-logic-comb","title":"Combinational Logic (COMB)","text":"<p>Count: 34 concepts (11.3%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Combinational Logic</li> </ol> </li> <li> <ol> <li>Sequential Logic</li> </ol> </li> <li> <ol> <li>Gate-Level Design</li> </ol> </li> <li> <ol> <li>Boolean to Gates Mapping</li> </ol> </li> <li> <ol> <li>Multi-Level Logic</li> </ol> </li> <li> <ol> <li>Two-Level Logic</li> </ol> </li> <li> <ol> <li>Sum of Products</li> </ol> </li> <li> <ol> <li>Product of Sums</li> </ol> </li> <li> <ol> <li>Minterm</li> </ol> </li> <li> <ol> <li>Maxterm</li> </ol> </li> <li> <ol> <li>Canonical Form</li> </ol> </li> <li> <ol> <li>Standard Form</li> </ol> </li> <li> <ol> <li>Minimal Form</li> </ol> </li> <li> <ol> <li>Logic Minimization</li> </ol> </li> <li> <ol> <li>Algebraic Simplification</li> </ol> </li> <li>...and 19 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#verification-lab-verify","title":"Verification &amp; Lab (VERIFY)","text":"<p>Count: 33 concepts (11.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Testbench</li> </ol> </li> <li> <ol> <li>Stimulus Generation</li> </ol> </li> <li> <ol> <li>Clock Generation</li> </ol> </li> <li> <ol> <li>Test Vector</li> </ol> </li> <li> <ol> <li>Self-Checking Testbench</li> </ol> </li> <li> <ol> <li>Simulation</li> </ol> </li> <li> <ol> <li>Simulation Time</li> </ol> </li> <li> <ol> <li>Waveform Viewer</li> </ol> </li> <li> <ol> <li>Debugging Waveforms</li> </ol> </li> <li> <ol> <li>Synthesis</li> </ol> </li> <li> <ol> <li>Synthesizable Code</li> </ol> </li> <li> <ol> <li>Non-Synthesizable Code</li> </ol> </li> <li> <ol> <li>FPGA Architecture</li> </ol> </li> <li> <ol> <li>FPGA LUT</li> </ol> </li> <li> <ol> <li>FPGA Flip-Flop</li> </ol> </li> <li>...and 18 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#logic-gates-gates","title":"Logic Gates (GATES)","text":"<p>Count: 30 concepts (10.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Logic Gate</li> </ol> </li> <li> <ol> <li>AND Gate</li> </ol> </li> <li> <ol> <li>OR Gate</li> </ol> </li> <li> <ol> <li>NOT Gate</li> </ol> </li> <li> <ol> <li>Buffer Gate</li> </ol> </li> <li> <ol> <li>NAND Gate</li> </ol> </li> <li> <ol> <li>NOR Gate</li> </ol> </li> <li> <ol> <li>XOR Gate</li> </ol> </li> <li> <ol> <li>XNOR Gate</li> </ol> </li> <li> <ol> <li>Gate Symbol</li> </ol> </li> <li> <ol> <li>IEEE Gate Symbols</li> </ol> </li> <li> <ol> <li>Functional Completeness</li> </ol> </li> <li> <ol> <li>Universal Gate</li> </ol> </li> <li> <ol> <li>NAND-Only Design</li> </ol> </li> <li> <ol> <li>NOR-Only Design</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#finite-state-machines-fsm","title":"Finite State Machines (FSM)","text":"<p>Count: 30 concepts (10.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Finite State Machine</li> </ol> </li> <li> <ol> <li>FSM State</li> </ol> </li> <li> <ol> <li>State Transition</li> </ol> </li> <li> <ol> <li>Current State</li> </ol> </li> <li> <ol> <li>Next State</li> </ol> </li> <li> <ol> <li>Next State Logic</li> </ol> </li> <li> <ol> <li>Output Logic</li> </ol> </li> <li> <ol> <li>Moore Machine</li> </ol> </li> <li> <ol> <li>Moore Output</li> </ol> </li> <li> <ol> <li>Mealy Machine</li> </ol> </li> <li> <ol> <li>Mealy Output</li> </ol> </li> <li> <ol> <li>State Diagram</li> </ol> </li> <li> <ol> <li>State Diagram Notation</li> </ol> </li> <li> <ol> <li>State Table</li> </ol> </li> <li> <ol> <li>State Encoding</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#registers-counters-reg","title":"Registers &amp; Counters (REG)","text":"<p>Count: 29 concepts (9.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Counter</li> </ol> </li> <li> <ol> <li>Up Counter</li> </ol> </li> <li> <ol> <li>Down Counter</li> </ol> </li> <li> <ol> <li>Up-Down Counter</li> </ol> </li> <li> <ol> <li>Mod-N Counter</li> </ol> </li> <li> <ol> <li>Binary Counter</li> </ol> </li> <li> <ol> <li>BCD Counter</li> </ol> </li> <li> <ol> <li>Decade Counter</li> </ol> </li> <li> <ol> <li>Ring Counter</li> </ol> </li> <li> <ol> <li>Johnson Counter</li> </ol> </li> <li> <ol> <li>Counter State Diagram</li> </ol> </li> <li> <ol> <li>Counter Overflow</li> </ol> </li> <li> <ol> <li>Register</li> </ol> </li> <li> <ol> <li>Parallel Load Register</li> </ol> </li> <li> <ol> <li>Shift Register</li> </ol> </li> <li>...and 14 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#verilog-hdl-hdl","title":"Verilog HDL (HDL)","text":"<p>Count: 29 concepts (9.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Verilog HDL</li> </ol> </li> <li> <ol> <li>HDL vs Programming</li> </ol> </li> <li> <ol> <li>Module Definition</li> </ol> </li> <li> <ol> <li>Port Declaration</li> </ol> </li> <li> <ol> <li>Input Port</li> </ol> </li> <li> <ol> <li>Output Port</li> </ol> </li> <li> <ol> <li>Inout Port</li> </ol> </li> <li> <ol> <li>Wire Data Type</li> </ol> </li> <li> <ol> <li>Reg Data Type</li> </ol> </li> <li> <ol> <li>Parameter</li> </ol> </li> <li> <ol> <li>Assign Statement</li> </ol> </li> <li> <ol> <li>Continuous Assignment</li> </ol> </li> <li> <ol> <li>Always Block</li> </ol> </li> <li> <ol> <li>Sensitivity List</li> </ol> </li> <li> <ol> <li>Blocking Assignment</li> </ol> </li> <li>...and 14 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#flip-flops-flipflop","title":"Flip-Flops (FLIPFLOP)","text":"<p>Count: 25 concepts (8.3%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>D Flip-Flop</li> </ol> </li> <li> <ol> <li>Edge Triggered</li> </ol> </li> <li> <ol> <li>Positive Edge Triggered</li> </ol> </li> <li> <ol> <li>Negative Edge Triggered</li> </ol> </li> <li> <ol> <li>Master-Slave Flip-Flop</li> </ol> </li> <li> <ol> <li>JK Flip-Flop</li> </ol> </li> <li> <ol> <li>JK Toggle Mode</li> </ol> </li> <li> <ol> <li>T Flip-Flop</li> </ol> </li> <li> <ol> <li>Flip-Flop Symbol</li> </ol> </li> <li> <ol> <li>Preset Input</li> </ol> </li> <li> <ol> <li>Clear Input</li> </ol> </li> <li> <ol> <li>Asynchronous Reset</li> </ol> </li> <li> <ol> <li>Synchronous Reset</li> </ol> </li> <li> <ol> <li>Setup Time</li> </ol> </li> <li> <ol> <li>Hold Time</li> </ol> </li> <li>...and 10 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#boolean-algebra-bool","title":"Boolean Algebra (BOOL)","text":"<p>Count: 21 concepts (7.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Boolean Variable</li> </ol> </li> <li> <ol> <li>Boolean Constant</li> </ol> </li> <li> <ol> <li>Boolean Expression</li> </ol> </li> <li> <ol> <li>Boolean Function</li> </ol> </li> <li> <ol> <li>Truth Table</li> </ol> </li> <li> <ol> <li>AND Operation</li> </ol> </li> <li> <ol> <li>OR Operation</li> </ol> </li> <li> <ol> <li>NOT Operation</li> </ol> </li> <li> <ol> <li>Boolean Algebra</li> </ol> </li> <li> <ol> <li>Identity Law</li> </ol> </li> <li> <ol> <li>Null Law</li> </ol> </li> <li> <ol> <li>Idempotent Law</li> </ol> </li> <li> <ol> <li>Complement Law</li> </ol> </li> <li> <ol> <li>Commutative Law</li> </ol> </li> <li> <ol> <li>Associative Law</li> </ol> </li> <li>...and 6 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#sequential-basics-seq","title":"Sequential Basics (SEQ)","text":"<p>Count: 20 concepts (6.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Memory Element</li> </ol> </li> <li> <ol> <li>State Concept</li> </ol> </li> <li> <ol> <li>Feedback Loop</li> </ol> </li> <li> <ol> <li>Bistable Element</li> </ol> </li> <li> <ol> <li>SR Latch</li> </ol> </li> <li> <ol> <li>SR Latch Truth Table</li> </ol> </li> <li> <ol> <li>Invalid State Problem</li> </ol> </li> <li> <ol> <li>Gated SR Latch</li> </ol> </li> <li> <ol> <li>D Latch</li> </ol> </li> <li> <ol> <li>Level Sensitive</li> </ol> </li> <li> <ol> <li>Transparent Latch</li> </ol> </li> <li> <ol> <li>Latch Timing Problem</li> </ol> </li> <li> <ol> <li>Race Condition</li> </ol> </li> <li> <ol> <li>Clock Signal</li> </ol> </li> <li> <ol> <li>Clock Edge</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#number-systems-numsys","title":"Number Systems (NUMSYS)","text":"<p>Count: 14 concepts (4.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Binary Number System</li> </ol> </li> <li> <ol> <li>Decimal to Binary Conversion</li> </ol> </li> <li> <ol> <li>Binary to Decimal Conversion</li> </ol> </li> <li> <ol> <li>Hexadecimal Numbers</li> </ol> </li> <li> <ol> <li>Hex to Binary Conversion</li> </ol> </li> <li> <ol> <li>Octal Numbers</li> </ol> </li> <li> <ol> <li>Binary Addition</li> </ol> </li> <li> <ol> <li>Binary Subtraction</li> </ol> </li> <li> <ol> <li>Two's Complement</li> </ol> </li> <li> <ol> <li>Signed Binary Numbers</li> </ol> </li> <li> <ol> <li>Overflow Detection</li> </ol> </li> <li> <ol> <li>BCD Encoding</li> </ol> </li> <li> <ol> <li>Gray Code</li> </ol> </li> <li> <ol> <li>Weighted Codes</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recommendations","title":"Recommendations","text":"<ul> <li>\u2705 Excellent balance: Categories are evenly distributed (spread: 7.0%)</li> <li>\u2705 MISC category minimal: Good categorization specificity</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#educational-use-recommendations","title":"Educational Use Recommendations","text":"<ul> <li>Use taxonomy categories for color-coding in graph visualizations</li> <li>Design curriculum modules based on taxonomy groupings</li> <li>Create filtered views for focused learning paths</li> <li>Use categories for assessment organization</li> <li>Enable navigation by topic area in interactive tools</li> </ul> <p>Report generated by learning-graph-reports/taxonomy_distribution.py</p>"},{"location":"lessons/logic-gates/","title":"Logic Gates","text":""},{"location":"prompts/equation-standards/","title":"Equation standards","text":"<p>I just realized that our preferred convention for writing LaTeX equations in this       book is to use the \"\\(\" and \"\\)\" notation, not \"\\(\\(\" and \"\\)\\)\" to signify the start       and end of a LaTeX equations.  Please do two things: 1. - fix any existing              equations in chapter 1 and 2 and 2. Add a note to the CLAUDE.md file that this is       our preferred way of adding equations.  </p> <p>I can see both chapters use \\(...\\) for inline math and Chapter 2 also uses \\(\\(...\\)\\) for   display math. I'll convert these to \\(...\\) for inline and [...] for display math,    then update CLAUDE.md. </p>"},{"location":"prompts/generate-chapter-content/","title":"Generate Chapter Content","text":""},{"location":"prompts/generate-chapter-content/#chapter-1","title":"Chapter 1","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/01-number-systems-binary-arithmetic/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. After you generate the content for the chapter, write the log to logs/ch-01.md Make sure to put an  element that points to the main.html after the #### Diagram and before the  when you generate any diagram."},{"location":"prompts/generate-chapter-content/#chapter-2","title":"Chapter 2","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/02-boolean-algebra-fundamentals/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an  element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-02.md"},{"location":"prompts/generate-chapter-content/#chapter-3","title":"Chapter 3","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/03-logic-gates-digital-signals/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-03.md"},{"location":"prompts/generate-chapter-content/#chapter-4","title":"Chapter 4","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/04-combinational-logic-design/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-04.md"},{"location":"prompts/generate-chapter-content/#chapter-5","title":"Chapter 5","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/05-logic-minimization-kmaps/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. After you generate the content for the chapter, write the log to logs/ch-05.md"},{"location":"prompts/generate-chapter-content/#chapter-6","title":"Chapter 6","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/06-combinational-building-blocks/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-06.md"},{"location":"prompts/generate-chapter-content/#chapter-7","title":"Chapter 7","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/07-intro-sequential-logic/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-07.md"},{"location":"prompts/generate-chapter-content/#chapter-8","title":"Chapter 8","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/08-flip-flops-timing/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-08.md"},{"location":"prompts/generate-chapter-content/#chapter-9","title":"Chapter 9","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/09-fsm-fundamentals/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-09.md"},{"location":"prompts/generate-chapter-content/#chapter-10","title":"Chapter 10","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/10-fsm-design-applications/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-10.md"},{"location":"prompts/generate-chapter-content/#chapter-11","title":"Chapter 11","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/11-registers-counters-datapath/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-11.md"},{"location":"prompts/generate-chapter-content/#chapter-12","title":"Chapter 12","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/12-verilog-hdl-fundamentals/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-12.md"},{"location":"prompts/generate-chapter-content/#chapter-13","title":"Chapter 13","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/13-verilog-modeling/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-13.md"},{"location":"prompts/generate-chapter-content/#chapter-14","title":"Chapter 14","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/14-testbenches-simulation/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-14.md"},{"location":"prompts/generate-chapter-content/#chapter-15","title":"Chapter 15","text":"<p>Use the /chapter-content-generator skill on chapter @docs/chapters/15-fpga-lab-skills/index.md The reading level is a sophomore in college. Keep the tone of the chapter light-hearted and positive. Feel free to throw in a joke or pun to keep the reading interesting. Use metaphors and stories when it would make the reading interesting. Make sure to put an </p> <p>element that points to the main.html after the #### Diagram and before the  when you generate any diagram. Please generate equations using the \"backslash\" delimiters, not the \"dollar\" delimiters. Avoid putting equations within admonitions. After you generate the content for the chapter, write the log to logs/ch-15.md"},{"location":"prompts/generate-cover-image/","title":"Generate A Cover Image","text":"<p>You will need an API key for OpenAI and set it as an environment variable. Then run this:</p> <p>../claude-skills/src/image-generation/generate-cover.sh</p>"},{"location":"prompts/generate-quizzes/","title":"Quiz Generation","text":"<p>Prompt</p> <p>Please run the /quiz-generator tool to create quizzes for each chapter.  Place each quiz in the chapter's     folder in a file called quiz.md.  Update the mkdocs.yml file when done.  Use a \"Content\" label for the        chapter content (index.md) and \"Quiz\" label for the quiz file.  </p>"},{"location":"sims/","title":"Digital Electronics Simulations","text":"<p>These simulations all use a common library of simple electronic logic gates.</p>"},{"location":"sims/#logic-gates","title":"Logic Gates","text":"<p>Logic Gate Library</p>"},{"location":"sims/#flip-flop","title":"Flip Flop","text":"<p>Flip Flop</p>"},{"location":"sims/binary-place-value/","title":"Binary Place Value Visualizer","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/binary-place-value/main.html\" width=\"100%\" height=\"402px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run in Fullscreen</p>"},{"location":"sims/binary-place-value/#description","title":"Description","text":"<p>This interactive MicroSim helps students understand how binary positional notation works. Each bit position has a specific weight (power of 2), and the decimal value is the sum of all active bit weights.</p>"},{"location":"sims/binary-place-value/#key-features","title":"Key Features","text":"<ul> <li>8 toggleable bit buttons (positions 7 through 0)</li> <li>Power of 2 labels showing the weight of each position</li> <li>Dynamic calculation display showing active terms (e.g., \"128 + 32 + 4 = 164\")</li> <li>Large decimal result display</li> <li>Challenge mode for practicing binary-to-decimal conversion</li> </ul>"},{"location":"sims/binary-place-value/#how-to-use","title":"How to Use","text":"<ol> <li>Toggle bits: Click any bit button to toggle it between 0 and 1</li> <li>Observe the calculation: Watch how the calculation line updates to show only active terms</li> <li>Check the result: See the decimal equivalent displayed prominently below</li> <li>Practice with challenges: Click \"Challenge\" to get a target decimal number to create</li> </ol>"},{"location":"sims/binary-place-value/#controls","title":"Controls","text":"Button Action Bit buttons Toggle between 0 (gray) and 1 (blue) Clear All Reset all bits to 0 Random Generate a random 8-bit number Challenge Start challenge mode with a target decimal"},{"location":"sims/binary-place-value/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/binary-place-value/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this activity, students will be able to:</p> <ul> <li>Understand how positional notation assigns weight to each bit position</li> <li>Apply binary-to-decimal conversion by summing active bit weights</li> <li>Explain why the rightmost bit is worth 1 and each position doubles in value</li> <li>Create specific decimal values by selecting the correct combination of bits</li> </ul>"},{"location":"sims/binary-place-value/#blooms-taxonomy-level","title":"Bloom's Taxonomy Level","text":"<p>Understand (L2) - Students explain and demonstrate how binary positional notation works through interactive exploration.</p>"},{"location":"sims/binary-place-value/#target-audience","title":"Target Audience","text":"<ul> <li>High school students learning binary number systems</li> <li>College freshmen/sophomores in digital electronics or computer science</li> <li>Prerequisites: Basic understanding of decimal place value</li> </ul>"},{"location":"sims/binary-place-value/#activities","title":"Activities","text":"<ol> <li> <p>Exploration (5 min): Toggle bits randomly and observe patterns in the decimal output.</p> </li> <li> <p>Guided Discovery (10 min):</p> </li> <li>Start with all bits off</li> <li>Turn on only the rightmost bit (position 0) - note the value is 1</li> <li>Turn on only position 1 - note the value is 2</li> <li> <p>Continue through all positions, noting the doubling pattern</p> </li> <li> <p>Pattern Recognition (5 min):</p> </li> <li>What's the maximum value with all 8 bits on? (255)</li> <li>What's the minimum value with at least one bit on? (1)</li> <li> <p>How many different values can 8 bits represent? (256)</p> </li> <li> <p>Challenge Practice (10 min): Use Challenge mode to practice converting decimal to binary.</p> </li> </ol>"},{"location":"sims/binary-place-value/#assessment","title":"Assessment","text":"<ul> <li>Given a binary number, calculate the decimal equivalent without the simulator</li> <li>Given a decimal number (0-255), determine which bits must be on</li> <li>Explain why 8 bits can represent exactly 256 different values</li> </ul>"},{"location":"sims/binary-place-value/#technical-details","title":"Technical Details","text":""},{"location":"sims/binary-place-value/#implementation","title":"Implementation","text":"<ul> <li>Built with p5.js for responsive canvas rendering</li> <li>Canvas-based controls (no DOM elements) for reliable iframe embedding</li> <li>Width-responsive design adapts to container size</li> </ul>"},{"location":"sims/binary-place-value/#canvas-layout","title":"Canvas Layout","text":"<ul> <li>Top section: Binary string display (e.g., \"Binary: 10100100\u2082\")</li> <li>Middle section: 8 bit toggle buttons with power of 2 labels</li> <li>Bottom section: Calculation breakdown and large decimal result</li> <li>Control area: Clear All, Random, and Challenge buttons</li> </ul>"},{"location":"sims/binary-place-value/#references","title":"References","text":"<ul> <li>Wikipedia: Binary Number - Overview of binary number system</li> <li>Khan Academy: Binary Numbers - Video tutorial on binary</li> <li>p5.js Reference - Documentation for the p5.js library</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/","title":"Decimal to Binary Conversion Stepper","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/decimal-to-binary-stepper/main.html\" width=\"100%\" height=\"542px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run in Fullscreen</p>"},{"location":"sims/decimal-to-binary-stepper/#description","title":"Description","text":"<p>This interactive MicroSim teaches the repeated division algorithm for converting decimal numbers to binary. Students can step through each division operation, observing how remainders accumulate to form the binary representation.</p>"},{"location":"sims/decimal-to-binary-stepper/#the-algorithm","title":"The Algorithm","text":"<p>The repeated division method works as follows:</p> <ol> <li>Divide the decimal number by 2</li> <li>Record the remainder (0 or 1)</li> <li>Use the quotient as the new dividend</li> <li>Repeat until the quotient is 0</li> <li>Read the remainders from bottom to top</li> </ol>"},{"location":"sims/decimal-to-binary-stepper/#key-features","title":"Key Features","text":"<ul> <li>Step-by-step progression: Click \"Step\" to advance one division at a time</li> <li>Visual remainder tracking: Each remainder is highlighted as it's computed</li> <li>Binary result building: Watch the binary number grow from right to left</li> <li>Input flexibility: Enter any decimal value from 0-255</li> <li>Verification: Final result shows decimal equivalent for confirmation</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#how-to-use","title":"How to Use","text":"<ol> <li>Enter a value: Click the input field and type a decimal number (0-255)</li> <li>Press Enter to start with your new value</li> <li>Click Step: Advance through one division at a time</li> <li>Predict: Before each step, try to predict the quotient and remainder</li> <li>Click Complete: Skip to see the full solution</li> <li>Click Reset: Start over with the current value</li> </ol>"},{"location":"sims/decimal-to-binary-stepper/#understanding-the-display","title":"Understanding the Display","text":"Column Meaning Division The current dividend divided by 2 Quotient Result of integer division (next dividend) Remainder The bit value for this position (0 or 1) <p>The arrow on the right reminds you to read remainders from bottom to top to form the binary number.</p>"},{"location":"sims/decimal-to-binary-stepper/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/decimal-to-binary-stepper/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this activity, students will be able to:</p> <ul> <li>Apply the repeated division algorithm to convert any decimal number (0-255) to binary</li> <li>Explain why each remainder represents a specific bit position</li> <li>Predict quotients and remainders before seeing them</li> <li>Verify conversions by checking the binary result</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#blooms-taxonomy-level","title":"Bloom's Taxonomy Level","text":"<p>Apply (L3) - Students execute the algorithm step-by-step, practicing the mechanical process while building understanding.</p>"},{"location":"sims/decimal-to-binary-stepper/#target-audience","title":"Target Audience","text":"<ul> <li>High school students learning binary number systems</li> <li>College freshmen/sophomores in digital electronics or computer science</li> <li>Prerequisites: Understanding of division with remainders, familiarity with binary place values</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min):</li> <li>Convert 10 to binary using the stepper</li> <li> <p>Note the pattern of remainders</p> </li> <li> <p>Guided Practice (10 min):</p> </li> <li>Convert 42 to binary, predicting each step before clicking</li> <li> <p>Verify: \\(42 = 32 + 8 + 2 = 2^5 + 2^3 + 2^1 = 101010_2\\)</p> </li> <li> <p>Pattern Recognition (5 min):</p> </li> <li>Convert powers of 2 (2, 4, 8, 16, 32...)</li> <li> <p>What do you notice about the binary representations?</p> </li> <li> <p>Challenge Problems (10 min):</p> </li> <li>Convert 255 (maximum 8-bit value)</li> <li>Convert 128 (minimum 8-bit value with MSB=1)</li> <li>Convert 170 (alternating pattern)</li> </ol>"},{"location":"sims/decimal-to-binary-stepper/#assessment","title":"Assessment","text":"<ul> <li>Given a decimal number, perform the conversion without the simulator</li> <li>Explain why odd numbers always have a 1 in the rightmost position</li> <li>Describe what determines how many bits are needed for a conversion</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#technical-details","title":"Technical Details","text":""},{"location":"sims/decimal-to-binary-stepper/#implementation","title":"Implementation","text":"<ul> <li>Built with p5.js for responsive canvas rendering</li> <li>Canvas-based controls (no DOM elements) for reliable iframe embedding</li> <li>Width-responsive design adapts to container size</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#canvas-layout","title":"Canvas Layout","text":"<ul> <li>Input section: Decimal value entry with editable field</li> <li>Division table: Step-by-step breakdown showing division, quotient, remainder</li> <li>Binary result: Growing binary number with highlighted digits</li> <li>Control area: Step, Complete, and Reset buttons</li> </ul>"},{"location":"sims/decimal-to-binary-stepper/#why-this-algorithm-works","title":"Why This Algorithm Works","text":"<p>Each division by 2 essentially \"peels off\" one bit of the binary representation:</p> <ul> <li>The remainder tells you whether that bit position is 0 or 1</li> <li>The quotient contains the remaining higher-order bits</li> <li>The first remainder is the LSB (rightmost bit)</li> <li>The last remainder is the MSB (leftmost bit)</li> </ul> <p>This is why we read remainders bottom-to-top: we compute the LSB first but need to write the MSB first.</p>"},{"location":"sims/decimal-to-binary-stepper/#references","title":"References","text":"<ul> <li>Wikipedia: Binary Number - Overview of binary number system</li> <li>Khan Academy: Converting decimal to binary - Tutorial on conversion methods</li> <li>p5.js Reference - Documentation for the p5.js library</li> </ul>"},{"location":"sims/flip-flop/","title":"Flip Flop MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/flip-flop/main.html\" width=\"100%\" height=\"450px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Flip Flop MicroSim in Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/flip-flop/#description","title":"Description","text":"<p>This interactive simulation demonstrates the behavior of an SR (Set-Reset) flip-flop, one of the fundamental building blocks of digital memory. The flip-flop is constructed using NAND gates, showing how simple logic gates can be combined to create circuits that \"remember\" their state.</p>"},{"location":"sims/flip-flop/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of NAND gate connections</li> <li>Interactive Set and Reset inputs</li> <li>Real-time display of Q and Q' (not Q) outputs</li> <li>Animation of signal propagation through the circuit</li> </ul>"},{"location":"sims/flip-flop/#how-to-use","title":"How to Use","text":"<ol> <li>Click the Set button to set the flip-flop output Q to 1</li> <li>Click the Reset button to reset the flip-flop output Q to 0</li> <li>Observe how the outputs maintain their state after the input returns to its default value</li> <li>Notice the cross-coupled feedback that enables the memory function</li> </ol>"},{"location":"sims/flip-flop/#challenges","title":"Challenges","text":"<p>Explaining electronic components like flip-flops through animation can be challenging due to several reasons:</p> <ol> <li> <p>Abstract Concepts: Flip-flops are digital logic circuits used in electronics and computing. They store and manipulate binary data (0s and 1s). The concepts involved in how they work\u2014like logic gates, binary states, clock signals, and data storage\u2014are abstract and not directly observable, making them hard to represent visually.</p> </li> <li> <p>Complex Functionality: Flip-flops have different types (like SR, JK, D, and T flip-flops) and each type has its unique mode of operation. This complexity can be difficult to condense into a simplified animation without losing essential details.</p> </li> <li> <p>Timing and Synchronization: Flip-flops often operate based on clock signals, and their behavior is dependent on the timing of these signals. Accurately depicting timing and synchronization in an animation can be challenging, as it requires precise representation of these temporal aspects.</p> </li> <li> <p>Scale and Interaction with Other Components: Flip-flops are usually part of larger electronic systems. Showing how they interact with other components in a system (like processors or memory units) within the limited scope of an animation can be difficult, as it might require a broader context that is hard to visualize succinctly.</p> </li> <li> <p>Viewer Background Knowledge: Understanding the operation of flip-flops often requires a background in electronics or computer science. Animations need to be designed considering the viewer's prior knowledge, which can vary widely, making it hard to create a one-size-fits-all explanation.</p> </li> <li> <p>Visual Simplicity vs. Technical Accuracy: Striking the right balance between simplicity for easier understanding and technical accuracy for correctness is a major challenge. Over-simplification can lead to misconceptions, while too much detail can overwhelm the viewer.</p> </li> </ol> <p>To effectively use animation for explaining flip-flops, it's essential to focus on clear, step-by-step visual representations, using metaphor or analogy where possible, and providing sufficient explanatory context to make the abstract concepts more relatable.</p>"},{"location":"sims/flip-flop/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/flip-flop/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Explain how NAND gates can be combined to create a flip-flop circuit</li> <li>Describe the difference between Set and Reset operations</li> <li>Demonstrate understanding of how flip-flops store binary data</li> <li>Identify the forbidden state in an SR flip-flop and explain why it should be avoided</li> </ul>"},{"location":"sims/flip-flop/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics students</li> <li>College students in introductory digital electronics courses</li> <li>Prerequisites: Basic understanding of logic gates (AND, OR, NOT, NAND)</li> </ul>"},{"location":"sims/flip-flop/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Allow students to freely interact with the simulation, observing how Set and Reset inputs affect the outputs.</p> </li> <li> <p>Guided Investigation: Have students create a truth table for the SR flip-flop by testing all input combinations and recording the outputs.</p> </li> <li> <p>Extension Activity: Discuss how multiple flip-flops can be connected to create registers and counters, leading into the shift register simulation.</p> </li> </ol>"},{"location":"sims/flip-flop/#assessment","title":"Assessment","text":"<ul> <li>What happens when both Set and Reset are activated simultaneously?</li> <li>Why is the flip-flop called a \"memory\" element?</li> <li>Draw the circuit diagram of an SR flip-flop using NAND gates.</li> </ul>"},{"location":"sims/flip-flop/#references","title":"References","text":"<ul> <li>Falstad Flip-Flop Simulator - Interactive circuit simulator with flip-flop examples</li> <li>Wikipedia: Flip-flop (electronics) - Comprehensive overview of flip-flop types and applications</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> </ul>"},{"location":"sims/graph-viewer/","title":"Learning Graph Viewer","text":"<p>This interactive viewer allows you to explore the learning graph for the Digital Electronics course.</p>"},{"location":"sims/graph-viewer/#features","title":"Features","text":"<ul> <li>Search: Type in the search box to find specific concepts</li> <li>Category Filtering: Use checkboxes to show/hide concept categories</li> <li>Interactive Navigation: Click and drag to explore, scroll to zoom</li> <li>Statistics: View real-time counts of visible nodes and edges</li> </ul>"},{"location":"sims/graph-viewer/#using-the-viewer","title":"Using the Viewer","text":"<ol> <li> <p>Search for Concepts: Start typing in the search box to find concepts. Click on a result to focus on that node.</p> </li> <li> <p>Filter by Category: Use the category checkboxes in the sidebar to show or hide groups of related concepts. Use \"Check All\" or \"Uncheck All\" for bulk operations.</p> </li> <li> <p>Navigate the Graph:</p> </li> <li>Drag to pan around the graph</li> <li>Scroll to zoom in and out</li> <li> <p>Click on a node to select it and highlight its connections</p> </li> <li> <p>View Statistics: The sidebar shows counts of visible nodes, edges, and foundational concepts.</p> </li> </ol>"},{"location":"sims/graph-viewer/#graph-structure","title":"Graph Structure","text":"<ul> <li>Foundational Concepts (left side): Prerequisites with no dependencies</li> <li>Advanced Concepts (right side): Topics that build on multiple prerequisites</li> <li>Edges: Arrows point from a concept to its prerequisites</li> </ul>"},{"location":"sims/graph-viewer/#launch-the-viewer","title":"Launch the Viewer","text":"<p>Open Learning Graph Viewer</p>"},{"location":"sims/logic-gates/","title":"Logic Gates MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/logic-gates/main.html\" width=\"100%\" height=\"450px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Logic Gates MicroSim in Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/logic-gates/#description","title":"Description","text":"<p>This interactive simulation provides a visual library of digital logic gates, demonstrating how each gate processes binary inputs to produce outputs. The simulation uses p5.js to render high-quality gate symbols following standard IEEE conventions.</p>"},{"location":"sims/logic-gates/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of all common logic gate types</li> <li>Interactive inputs to test gate behavior</li> <li>Real-time output display</li> <li>Standard IEEE gate symbols</li> <li>Reusable gate drawing library for building complex circuits</li> </ul>"},{"location":"sims/logic-gates/#how-to-use","title":"How to Use","text":"<ol> <li>Click on input nodes to toggle between 0 (LOW) and 1 (HIGH) states</li> <li>Observe how the output changes based on the gate's logic function</li> <li>Experiment with different input combinations to understand each gate's truth table</li> <li>Use the gate library as a foundation for building more complex circuits</li> </ol>"},{"location":"sims/logic-gates/#logic-gate-types","title":"Logic Gate Types","text":"Gate Symbol Function AND Flat back, curved front Output is 1 only when ALL inputs are 1 OR Curved back, pointed front Output is 1 when ANY input is 1 NOT Triangle with bubble Inverts the input NAND AND with bubble Inverted AND output NOR OR with bubble Inverted OR output XOR OR with extra curved line Output is 1 when inputs DIFFER XNOR XOR with bubble Output is 1 when inputs are SAME"},{"location":"sims/logic-gates/#goals","title":"Goals","text":"<p>Our goal in this simulation is to:</p> <ol> <li>Use generative AI to build a library of high-quality logical gate drawings using the p5.js library.</li> <li>Use this library to build a logic simulator that can simulate simple digital logic gates.</li> </ol> <p>Drawing Gates - Tutorial on creating gate graphics</p>"},{"location":"sims/logic-gates/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/logic-gates/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Identify and draw the standard symbols for each logic gate type</li> <li>Create truth tables for each logic gate</li> <li>Predict the output of a logic gate given any combination of inputs</li> <li>Explain the relationship between basic gates (AND, OR, NOT) and derived gates (NAND, NOR, XOR, XNOR)</li> </ul>"},{"location":"sims/logic-gates/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics and computer science students</li> <li>College students in introductory digital logic courses</li> <li>Prerequisites: Understanding of binary numbers (0 and 1)</li> </ul>"},{"location":"sims/logic-gates/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Interact with each gate type, testing all possible input combinations and recording results.</p> </li> <li> <p>Guided Investigation: Complete the truth table worksheet for each gate, verifying answers with the simulation.</p> </li> <li> <p>Extension Activity: Design a simple circuit using multiple gates (e.g., a half-adder) and predict its behavior before testing.</p> </li> </ol>"},{"location":"sims/logic-gates/#assessment","title":"Assessment","text":"<ul> <li>Draw the symbol for each of the seven logic gates from memory</li> <li>Given a truth table, identify which logic gate it represents</li> <li>Explain why NAND and NOR gates are called \"universal gates\"</li> </ul>"},{"location":"sims/logic-gates/#references","title":"References","text":"<ul> <li>Wikipedia: Logic Gate - Overview of logic gate types and applications</li> <li>All About Circuits: Logic Gates - Comprehensive tutorial on digital logic gates</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> <li>IEEE Std 91-1984 - Standard for logic gate symbols</li> </ul>"},{"location":"sims/logic-gates/01-drawing-gates/","title":"Drawing Gates","text":"<p>We will be using the Processing version 5 JavaScript library for doing web-based drawing.  This is called the p5.js library.  Because Processing has been around since 2000 there is able code that generative AI has been trained on.  Getting the correct results is pretty easy. </p> <p>We need a library for drawing gates in our simulators. We use the following drawing conventions:</p> <p>The standard function parameters are:</p> <ol> <li>X position on the canvas</li> <li>Y position on the canvas</li> <li>Width of the gate (not including connecting wires)</li> <li>Height of the gate</li> <li>Length of the connecting wires</li> </ol> <p>The drawing must be made so that the fill color, stroke color, and stroke can all be inherited from the drawing context.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#drawing-basic","title":"Drawing basic","text":""},{"location":"sims/logic-gates/01-drawing-gates/#buffer","title":"Buffer","text":"<p>We will start with a simple buffer logic gate that does not change the input signal.  We use a triangle shape to draw a buffer.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-buffer-prompt","title":"Sample Buffer Prompt","text":"<pre><code>Create a p5.js function called drawBuffer(x,y,w,h,l) for a logic buffer symbol.  The function should take parameters x, y, width, height and wire length.\nPlace the logic gate with the upper left corner of the triangle at the point x,y with a width and height from the parameters.  Add wire length as input and output wires.\n\nCreate a test of this function on a 200x300 canvas drawing three examples of the drawBuffer using different sizes.\n\nDraw the tests on a lightgray background.\n</code></pre> <p>ChatGPT Dialog using the p5.js Visual Art Composer</p>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-buffer-response","title":"Sample Buffer Response","text":"<pre><code>// Draw Buffer Function\nfunction setup() {\n  createCanvas(200, 300);\n  background('lightgray');\n  drawBuffer(50, 50, 30, 40, 20);\n  drawBuffer(100, 120, 40, 60, 30);\n  drawBuffer(30, 200, 50, 70, 40);\n}\n\nfunction drawBuffer(x, y, w, h, l) {\n\n  // Draw input wire\n  line(x - l, y + h / 2, x, y + h / 2);\n\n  // Draw the buffer (triangle)\n  triangle(x, y, x, y + h, x + w, y + h / 2);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n}\n</code></pre> <p>Edit this MicroSim on p5.js Editor</p>"},{"location":"sims/logic-gates/01-drawing-gates/#drawing-an-inverter","title":"Drawing an Inverter","text":""},{"location":"sims/logic-gates/01-drawing-gates/#inverter-prompt","title":"Inverter Prompt","text":"<pre><code>That was perfect!\nNow create a new function called drawInverter.\nIt will have exactly the same input parameters,\nbut the drawing will have a small circle at the\nright tip of the triangle.\n\nDraw the tests on a lightgray background.\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#inverter-response","title":"Inverter Response","text":"<pre><code>// Draw Inverter\n// Test the drawInverter function with different sizes\n\nfunction setup() {\n  createCanvas(200, 300);\n  background(240); // light gray background\n  drawInverter(50, 50, 30, 40, 20);\n  drawInverter(100, 120, 40, 60, 30);\n  drawInverter(30, 200, 50, 70, 40);\n}\n\nfunction drawInverter(x, y, w, h, l) {\n  // Draw input wire\n  line(x - l, y + h / 2, x, y + h / 2);\n\n  // Draw the buffer (triangle)\n  triangle(x, y, x, y + h, x + w, y + h / 2);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n\n  // Draw small circle at the right tip of the triangle\n  circle(x + w, y + h / 2, w / 5);\n}\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#the-and-gate","title":"The AND Gate","text":""},{"location":"sims/logic-gates/01-drawing-gates/#sample-and-prompt","title":"Sample AND Prompt","text":"<pre><code>That was also perfect!\nNow create a new function called drawAND that will draw\na AND logic gate.\nThis will be similar to the previous functions,\nbut instead of drawing a triangle you will need\nto make the right side of the shape a circle.\nPlace a series of points on the canvas using the vertex(x,y) function that makes the correct shape.\nUse beginShape() and endShape() around the points.\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-and-response","title":"Sample AND Response","text":"<pre><code>// Draw And Logic Gate\n// Test the drawAND function with different sizes\n\nfunction setup() {\n  createCanvas(200, 300);\n  background(200); // light gray background\n  drawAND(50, 20, 40, 40, 20);\n  drawAND(100, 70, 40, 60, 30);\n  drawAND(80, 150, 70, 50, 20);\n}\n\nfunction drawAND(x, y, w, h, l) {\n  // Draw input wires\n  line(x - l, y + h / 3, x, y + h / 3);\n  line(x - l, y + 2 * h / 3, x, y + 2 * h / 3);\n\n  // Draw the AND gate shape\n  beginShape();\n  vertex(x, y); // top left corner\n  vertex(x + w * 0.6, y); // top right corner (start of semicircle)\n  // Create semicircle\n  for (let angle = -HALF_PI; angle &lt;= HALF_PI; angle += 0.01) {\n    let sx = x + w * 0.6 + cos(angle) * w * 0.4;\n    let sy = y + h / 2 + sin(angle) * h / 2;\n    vertex(sx, sy);\n  }\n  vertex(x + w * 0.6, y + h); // bottom right corner (end of semicircle)\n  vertex(x, y + h); // bottom left corner\n  endShape(CLOSE);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n}\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#failed-attempts-at-or-gate","title":"Failed Attempts at OR Gate","text":"<p>This is where GPT-4 falls apart.  Despite my best attempts, I could not get GPT-4 to correctly draw the complex curves needed for a logical OR gate.  You can see the results in the transcript.</p> <p>I had to resort to manually drawing the curves, which was a slow-painful process and took several hours to make it robust enough that it could work with a variety of sizes.</p> <p>I think this really demonstrates the limits of what GPT-4 is capable of, and what it can't do.</p> <p></p> <p>Edit the Logical OR gate MicroSim</p> <p>One hint that GPT-4 did give was to use the map function to have the x-coordinates move linearly and only use the sin() functions on the y-coordinates.  This worked reasonably well and the curves do match up pretty closely with the official SVG drawing of the OR gate. If you want a precise mapping you can also write a program that converts the SVG points to a set of (x,y) points.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#nor-symbol-prompt","title":"NOR Symbol Prompt","text":"<p>Once we have a good OR gate, we can ask GPT to just use that to create a NOR gate.  All it has to do is add a circle on the output.</p> <p>Here is the code it generated:</p> <pre><code>function drawNOR(x, y, w, h, l) {\n  // Draw the OR part\n  drawOR(x, y, w, h, l);\n\n  // Draw the NOT circle at the output\n  let outputX = x + w + l * 0.5;\n  let outputY = y + h / 2;\n  let circleRadius = l * 0.3;\n  ellipse(outputX, outputY, circleRadius, circleRadius);\n}\n</code></pre> <p>So it is clear that GPT-4 has been trained on how to add a small bit of drawing to an existing function.</p> <p>Note that it tends to use ellipse() rather than circle(). I don't know exactly why it does this.  Perhaps it believes that ellipse is more general and easier to customize.  I think that circle with only three parameters is a little easier to read.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#xor-gate","title":"XOR Gate","text":""},{"location":"sims/logic-gates/01-drawing-gates/#xnor-prompt","title":"XNOR Prompt","text":"<pre><code>Now can you please repeat the same process \nbut this time generate the code for an exclusive OR.  \nPlease call the new function drawXOR and make the \nparameters exactly the same.\n</code></pre> <p>It got the result pretty close.  The only real cleanup is to move the new arc to the end and add a noFill() for the new extra curve. This is an easy to change.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#xnor","title":"XNOR","text":"<p>Our last function is XNOR, which just adds a circle to the XOR symbol.</p> <p>Edit the XNOR MicroSim</p> <p>Note that we did not automatically fill the circle with black.  We decided to inherit the fill from the drawing context.  Forcing the circle to fill with black is a valid option and might make drawings a little easier to read.  This could also be an additional parameter to these functions.</p>"},{"location":"sims/shift-register/","title":"Shift Register MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/shift-register/main.html\" width=\"100%\" height=\"400px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Shift Register MicroSim in Fullscreen</p>"},{"location":"sims/shift-register/#description","title":"Description","text":"<p>This interactive simulation demonstrates the operation of a 74HC594 shift register, a common integrated circuit used to convert serial data into parallel output. The simulation includes a logic analyzer display that shows the timing relationships between the DATA IN, CLOCK, and LATCH signals.</p>"},{"location":"sims/shift-register/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of the 74HC594 shift register chip</li> <li>Real-time logic analyzer showing signal waveforms</li> <li>Interactive DATA IN toggle (ON/OFF)</li> <li>CLOCK button to shift data into the register</li> <li>LATCH button to transfer shift register contents to output</li> <li>Reset button to clear all states</li> <li>8-bit output display with LED indicators</li> </ul>"},{"location":"sims/shift-register/#how-to-use","title":"How to Use","text":"<ol> <li>Set DATA IN to ON or OFF using the radio buttons</li> <li>Click Next Clock to shift the current DATA IN value into the register</li> <li>Repeat steps 1-2 to load a complete 8-bit pattern</li> <li>Click Latch to transfer the shift register contents to the output pins</li> <li>Observe the LED indicators showing the parallel output</li> <li>Watch the Logic Analyzer to see the timing of each signal</li> <li>Click Reset to clear the register and start over</li> </ol>"},{"location":"sims/shift-register/#understanding-the-logic-analyzer","title":"Understanding the Logic Analyzer","text":"<p>The logic analyzer display shows three signals:</p> <ul> <li>DATA IN (blue): The current input data level</li> <li>CLOCK (red): Pulses each time you click \"Next Clock\"</li> <li>LATCH (green): Pulses when you click \"Latch\"</li> </ul> <p>Each rising edge of the CLOCK signal shifts the DATA IN value into the first position of the shift register, pushing all existing bits one position to the right.</p>"},{"location":"sims/shift-register/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/shift-register/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Explain the difference between serial and parallel data transfer</li> <li>Describe how a shift register converts serial input to parallel output</li> <li>Identify the function of CLOCK and LATCH signals in a shift register</li> <li>Demonstrate the sequence of operations needed to load an 8-bit pattern</li> </ul>"},{"location":"sims/shift-register/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics students</li> <li>College students in digital electronics courses</li> <li>Prerequisites: Understanding of flip-flops and binary numbers</li> </ul>"},{"location":"sims/shift-register/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Load the binary pattern for the letter \"A\" (01000001) into the shift register and display it on the outputs.</p> </li> <li> <p>Guided Investigation: Document the timing sequence by recording what happens at each clock pulse as you shift in a specific bit pattern.</p> </li> <li> <p>Extension Activity: Calculate how many clock pulses are needed to shift data through multiple cascaded shift registers. Discuss applications like LED displays or motor control.</p> </li> </ol>"},{"location":"sims/shift-register/#assessment","title":"Assessment","text":"<ul> <li>What is the difference between the shift register and the output register in the 74HC594?</li> <li>Why is a separate LATCH signal needed?</li> <li>How many clock pulses are required to load all 8 bits?</li> <li>Describe a real-world application where shift registers are used.</li> </ul>"},{"location":"sims/shift-register/#references","title":"References","text":"<ul> <li>Wikipedia: Shift Register - Overview of shift register types and applications</li> <li>Texas Instruments 74HC594 Datasheet - Technical specifications for the 74HC594</li> <li>SparkFun Shift Register Tutorial - Practical guide to using shift registers with microcontrollers</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> </ul>"},{"location":"sims/template/","title":"MicroSim Template","text":"Figure caption. <p>Run the MicroSim Edit the MicroSim</p>"},{"location":"sims/template/#about-this-microsim","title":"About this MicroSim","text":"<p>This MicroSim teaches us how to specify the drawing of a static filled circle.</p>"},{"location":"sims/template/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a single file p5.js sketch.\nDraw a green circle on a 600x400 canvas with a radius of 200.\n</code></pre>"},{"location":"sims/template/#sample-response","title":"Sample Response","text":"<pre><code>let canvasHeight = 400;\nlet aspectRatio = 1.91; // Open Graph standard\nlet canvasWidth = canvasHeight * aspectRatio;\nlet radius = 200;\nfunction setup() {\nconst canvas = createCanvas(canvasWidth, canvasHeight);\n  canvas.parent('canvas-container');\n  fill(245);\n  rect(0,0, canvasWidth, canvasHeight);\n  fill('green');\n  circle(canvasWidth/2, canvasHeight/2, radius);\n}\n</code></pre>"},{"location":"sims/template/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/template/#grade-level-subject-and-topic","title":"Grade Level, Subject and Topic","text":"<p>9th grade geometry. Circle and radius.</p>"},{"location":"sims/template/#activities","title":"Activities","text":""},{"location":"sims/template/#fill-color","title":"Fill Color","text":"<p>Change the color in the prompt.  You can specify any one of the 140 named colors.</p>"},{"location":"sims/template/#border-weight","title":"Border Weight","text":"<p>Change the prompt to include a black border of width 10.</p>"},{"location":"sims/template/#border-color","title":"Border Color","text":"<p>Change the prompt to make the border purple.</p>"},{"location":"sims/template/#change-the-radius","title":"Change the Radius","text":"<p>Change the prompt to make the circle smaller or larger by changing the radius from 10 to 200.</p>"},{"location":"sims/template/#change-the-location","title":"Change the Location","text":"<p>Change the prompt to move the circle to the left or right.</p>"},{"location":"sims/template/TODO/","title":"TODO: Fix MicroSim Metadata","text":"<p>MicroSim: template Repository: digital-electronics Generated: 2026-01-23</p>"},{"location":"sims/template/TODO/#issues-found","title":"Issues Found","text":"<p>The following issues prevented automatic metadata generation:</p> <ol> <li>No description found</li> </ol>"},{"location":"sims/template/TODO/#required-actions","title":"Required Actions","text":""},{"location":"sims/template/TODO/#high-priority","title":"High Priority","text":"<ul> <li> Create or fix <code>main.html</code> - the main simulation file</li> <li> Add a meaningful title that describes the simulation</li> <li> Write a clear description (2-3 sentences) explaining what the MicroSim does</li> </ul>"},{"location":"sims/template/TODO/#medium-priority","title":"Medium Priority","text":"<ul> <li> Create <code>index.md</code> with proper YAML frontmatter:   <pre><code>---\ntitle: \"Your Title Here\"\ndescription: \"Brief description for SEO\"\n---\n</code></pre></li> <li> Add an iframe to display the simulation</li> <li> Add a \"Run Fullscreen\" button</li> </ul>"},{"location":"sims/template/TODO/#low-priority","title":"Low Priority","text":"<ul> <li> Add a lesson plan section</li> <li> Add references section</li> <li> Create a screenshot for social media preview</li> </ul>"},{"location":"sims/template/TODO/#detected-information","title":"Detected Information","text":"<ul> <li>Framework: p5.js</li> <li>Detected subjects: Mathematics, Computer Science, Chemistry, Engineering</li> <li>Visualization types: graph, interactive-demo, map</li> <li>Has main.html: Yes</li> <li>Has index.md: Yes</li> </ul>"},{"location":"sims/template/TODO/#after-fixing","title":"After Fixing","text":"<p>Once you've addressed the issues above, run the metadata standardization:</p> <pre><code># Use Claude Code's microsim-utils skill to standardize\n# Or manually create metadata.json following the schema\n</code></pre> <p>Delete this TODO.md file after creating proper metadata.json.</p>"}]}
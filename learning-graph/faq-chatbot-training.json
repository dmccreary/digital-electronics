{
  "faq_version": "1.0",
  "generated_date": "2026-01-31",
  "source_textbook": "Digital Electronics",
  "total_questions": 72,
  "categories": [
    {
      "name": "Getting Started Questions",
      "question_count": 10
    },
    {
      "name": "Core Concept Questions",
      "question_count": 17
    },
    {
      "name": "Technical Detail Questions",
      "question_count": 13
    },
    {
      "name": "Common Challenge Questions",
      "question_count": 10
    },
    {
      "name": "Best Practice Questions",
      "question_count": 8
    },
    {
      "name": "Laboratory Skills Questions",
      "question_count": 7
    },
    {
      "name": "Advanced Topics Questions",
      "question_count": 7
    }
  ],
  "questions": [
    {
      "id": "faq-001",
      "category": "Getting Started",
      "question": "What is this course about?",
      "answer": "This is a sophomore-level digital electronics course covering the ABET-aligned electrical engineering curriculum. You'll learn how digital circuits work, from basic logic gates to complete synchronous systems. The course bridges the gap between abstract Boolean algebra and physical hardware implementation, preparing you for upper-division courses in computer architecture, VLSI design, and embedded systems.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Digital Electronics", "ABET Curriculum", "Boolean Algebra"],
      "keywords": ["course", "overview", "objectives", "digital electronics", "ABET"],
      "source_links": ["docs/course-description.md"],
      "has_example": false,
      "word_count": 78
    },
    {
      "id": "faq-002",
      "category": "Getting Started",
      "question": "Who is this course designed for?",
      "answer": "This course is designed for college students majoring in electrical engineering or computer-related fields. It's typically taken in the sophomore year after completing introductory circuits and Calculus 1.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": ["Target Audience", "Prerequisites"],
      "keywords": ["audience", "students", "electrical engineering", "prerequisites"],
      "source_links": ["docs/course-description.md"],
      "has_example": false,
      "word_count": 42
    },
    {
      "id": "faq-003",
      "category": "Getting Started",
      "question": "What prerequisites do I need?",
      "answer": "Calculus 1 is required for several advanced topics in this course. You should also have basic familiarity with algebra and logical reasoning. Prior programming experience is helpful but not required.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": ["Prerequisites", "Calculus"],
      "keywords": ["prerequisites", "calculus", "requirements", "preparation"],
      "source_links": ["docs/course-description.md"],
      "has_example": false,
      "word_count": 41
    },
    {
      "id": "faq-004",
      "category": "Core Concepts",
      "question": "What is the difference between combinational and sequential logic?",
      "answer": "Combinational logic circuits produce outputs based solely on current inputs—like a vending machine's price display responding to button presses. Sequential logic circuits have memory and produce outputs based on both current inputs AND past history—like the vending machine tracking how much money you've inserted. This distinction is fundamental: combinational circuits are stateless, sequential circuits have state.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Combinational Logic", "Sequential Logic", "State Concept"],
      "keywords": ["combinational", "sequential", "logic", "state", "memory", "difference"],
      "source_links": ["docs/chapters/04-combinational-logic-design/index.md", "docs/chapters/07-intro-sequential-logic/index.md"],
      "has_example": true,
      "word_count": 82
    },
    {
      "id": "faq-005",
      "category": "Core Concepts",
      "question": "What is a truth table and why is it important?",
      "answer": "A truth table is a complete specification of a logic function, listing every possible input combination and its corresponding output. It's important because it provides an unambiguous definition of circuit behavior—there's no guessing about edge cases. Truth tables form the foundation for both circuit design and verification.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Truth Table", "Boolean Function", "Circuit Specification"],
      "keywords": ["truth table", "specification", "inputs", "outputs", "combinations"],
      "source_links": ["docs/chapters/02-boolean-algebra-fundamentals/index.md"],
      "has_example": false,
      "word_count": 62
    },
    {
      "id": "faq-006",
      "category": "Core Concepts",
      "question": "What is Boolean algebra?",
      "answer": "Boolean algebra is the mathematical system for manipulating logical expressions using AND, OR, and NOT operations. Unlike regular algebra with infinite real numbers, Boolean algebra works with just two values: 0 and 1. Its laws allow systematic simplification of logic expressions and form the theoretical foundation for all digital circuit design.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Boolean Algebra", "AND Operation", "OR Operation", "NOT Operation"],
      "keywords": ["boolean algebra", "logic", "and", "or", "not", "simplification"],
      "source_links": ["docs/chapters/02-boolean-algebra-fundamentals/index.md"],
      "has_example": false,
      "word_count": 59
    },
    {
      "id": "faq-007",
      "category": "Core Concepts",
      "question": "What are De Morgan's Theorems and why are they important?",
      "answer": "De Morgan's theorems state that (A + B)' = A'B' and (AB)' = A' + B'. In words: the complement of an OR equals the AND of the complements, and vice versa. These theorems are critical because they allow conversion between AND/OR forms and enable implementing any circuit using only NAND gates or only NOR gates.",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["De Morgan's Theorem", "NAND Gate", "NOR Gate", "Functional Completeness"],
      "keywords": ["de morgan", "theorem", "complement", "nand", "nor", "conversion"],
      "source_links": ["docs/chapters/02-boolean-algebra-fundamentals/index.md"],
      "has_example": true,
      "word_count": 72
    },
    {
      "id": "faq-008",
      "category": "Core Concepts",
      "question": "Why are NAND and NOR gates called universal gates?",
      "answer": "NAND and NOR are functionally complete, meaning any Boolean function can be implemented using only that one gate type. You can build an inverter, AND, OR—any gate—from NANDs alone or NORs alone. This is practically important because manufacturing a single gate type is simpler and cheaper.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Universal Gate", "Functional Completeness", "NAND Gate", "NOR Gate"],
      "keywords": ["universal", "nand", "nor", "functionally complete", "gates"],
      "source_links": ["docs/chapters/03-logic-gates-digital-signals/index.md"],
      "has_example": false,
      "word_count": 57
    },
    {
      "id": "faq-009",
      "category": "Core Concepts",
      "question": "What is a Karnaugh map?",
      "answer": "A Karnaugh map (K-map) is a graphical method for simplifying Boolean expressions. It arranges truth table outputs in a grid where adjacent cells differ by exactly one variable, making grouping of terms visual and intuitive. K-maps work well for 2, 3, or 4 variables.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Karnaugh Map", "Logic Minimization", "Adjacent Cells"],
      "keywords": ["karnaugh map", "k-map", "simplification", "grouping", "minimization"],
      "source_links": ["docs/chapters/05-logic-minimization-kmaps/index.md"],
      "has_example": false,
      "word_count": 54
    },
    {
      "id": "faq-010",
      "category": "Core Concepts",
      "question": "What is a flip-flop?",
      "answer": "A flip-flop is an edge-triggered storage element that captures and holds one bit of data. Unlike latches (which are level-sensitive), flip-flops only change state at the clock edge—either rising or falling. The D flip-flop is most common: on the active clock edge, Q takes the value present at D. Flip-flops are the building blocks of registers, counters, and state machines.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["D Flip-Flop", "Edge Triggered", "Clock Edge", "Register"],
      "keywords": ["flip-flop", "edge triggered", "storage", "d flip-flop", "clock"],
      "source_links": ["docs/chapters/08-flip-flops-timing/index.md"],
      "has_example": false,
      "word_count": 73
    },
    {
      "id": "faq-011",
      "category": "Core Concepts",
      "question": "What is a finite state machine?",
      "answer": "A finite state machine is a sequential circuit with a finite number of states, rules for transitioning between states, and outputs that depend on the current state (and possibly inputs). FSMs are the primary model for designing sequential logic. Common examples include counters, sequence detectors, and controllers.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Finite State Machine", "FSM State", "State Transition", "Moore Machine", "Mealy Machine"],
      "keywords": ["fsm", "finite state machine", "states", "transitions", "sequential"],
      "source_links": ["docs/chapters/09-fsm-fundamentals/index.md", "docs/chapters/10-fsm-design-applications/index.md"],
      "has_example": true,
      "word_count": 58
    },
    {
      "id": "faq-012",
      "category": "Core Concepts",
      "question": "What is the difference between Moore and Mealy machines?",
      "answer": "In a Moore machine, outputs depend only on the current state—outputs are associated with states. In a Mealy machine, outputs depend on both the current state AND current inputs—outputs are associated with transitions. Moore machines have more predictable timing; Mealy machines can respond faster.",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": ["Moore Machine", "Mealy Machine", "Moore Output", "Mealy Output"],
      "keywords": ["moore", "mealy", "state machine", "outputs", "difference"],
      "source_links": ["docs/chapters/09-fsm-fundamentals/index.md"],
      "has_example": false,
      "word_count": 54
    },
    {
      "id": "faq-013",
      "category": "Core Concepts",
      "question": "What is Verilog?",
      "answer": "Verilog is a hardware description language (HDL) used to model and design digital systems. Unlike programming languages that describe sequential execution, Verilog describes concurrent hardware behavior. It supports multiple abstraction levels: gate-level, RTL, and behavioral. Verilog is used for both simulation and synthesis to actual hardware.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Verilog HDL", "Behavioral Modeling", "Structural Modeling", "Synthesis"],
      "keywords": ["verilog", "hdl", "hardware description", "synthesis", "simulation"],
      "source_links": ["docs/chapters/12-verilog-hdl-fundamentals/index.md"],
      "has_example": false,
      "word_count": 56
    },
    {
      "id": "faq-014",
      "category": "Core Concepts",
      "question": "What is an FPGA?",
      "answer": "An FPGA (Field-Programmable Gate Array) is an integrated circuit designed to be configured after manufacturing. It contains an array of configurable logic blocks, programmable routing, and I/O blocks. Unlike ASICs with fixed functionality, FPGAs can be reprogrammed to implement virtually any digital circuit.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["FPGA Architecture", "FPGA LUT", "FPGA Routing", "FPGA Implementation"],
      "keywords": ["fpga", "field programmable", "configurable", "reprogrammable"],
      "source_links": ["docs/chapters/15-fpga-lab-skills/index.md"],
      "has_example": false,
      "word_count": 54
    },
    {
      "id": "faq-015",
      "category": "Technical Details",
      "question": "What is propagation delay?",
      "answer": "Propagation delay is the time from when an input changes until the corresponding output change appears. Every gate and wire has propagation delay. In combinational circuits, total delay equals the sum of delays along the longest path. Propagation delay limits circuit speed.",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": ["Propagation Delay", "Gate Delay", "Critical Path"],
      "keywords": ["propagation delay", "timing", "gates", "path delay"],
      "source_links": ["docs/chapters/03-logic-gates-digital-signals/index.md"],
      "has_example": false,
      "word_count": 49
    },
    {
      "id": "faq-016",
      "category": "Technical Details",
      "question": "What are setup time and hold time?",
      "answer": "Setup time is the minimum time data must be stable BEFORE the clock edge. Hold time is the minimum time data must remain stable AFTER the clock edge. Violating these requirements causes unreliable operation—the flip-flop may capture incorrect data or enter metastability.",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": ["Setup Time", "Hold Time", "Timing Violation", "Metastability"],
      "keywords": ["setup time", "hold time", "timing", "clock edge", "flip-flop"],
      "source_links": ["docs/chapters/08-flip-flops-timing/index.md"],
      "has_example": false,
      "word_count": 51
    },
    {
      "id": "faq-017",
      "category": "Technical Details",
      "question": "What is metastability?",
      "answer": "Metastability occurs when a flip-flop samples an input that's changing at the exact moment of the clock edge, violating setup or hold time. The flip-flop enters an unstable intermediate state and takes unpredictable time to resolve to 0 or 1. Synchronizer circuits mitigate this risk.",
      "bloom_level": "Understand",
      "difficulty": "hard",
      "concepts": ["Metastability", "Synchronizer Circuit", "Double Flop Synchronizer"],
      "keywords": ["metastability", "synchronizer", "unstable", "clock domain"],
      "source_links": ["docs/chapters/08-flip-flops-timing/index.md"],
      "has_example": false,
      "word_count": 52
    },
    {
      "id": "faq-018",
      "category": "Technical Details",
      "question": "What are blocking and non-blocking assignments in Verilog?",
      "answer": "Blocking assignments (=) execute immediately and in order. Non-blocking assignments (<=) schedule updates for the end of the time step. Use blocking for combinational logic, non-blocking for sequential logic. Mixing them incorrectly causes simulation/synthesis mismatches.",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["Blocking Assignment", "Non-Blocking Assignment", "Sequential Always", "Combinational Always"],
      "keywords": ["blocking", "non-blocking", "assignment", "verilog", "sequential"],
      "source_links": ["docs/chapters/13-verilog-modeling/index.md"],
      "has_example": false,
      "word_count": 44
    },
    {
      "id": "faq-019",
      "category": "Technical Details",
      "question": "What is two's complement?",
      "answer": "Two's complement is the standard representation for signed integers in digital systems. Positive numbers have a leading 0; negative numbers are formed by inverting all bits and adding 1. The key advantage: addition and subtraction use the same hardware regardless of sign.",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": ["Two's Complement", "Signed Binary Numbers", "Binary Subtraction"],
      "keywords": ["twos complement", "signed", "negative", "binary", "arithmetic"],
      "source_links": ["docs/chapters/01-number-systems-binary-arithmetic/index.md"],
      "has_example": false,
      "word_count": 50
    },
    {
      "id": "faq-020",
      "category": "Common Challenges",
      "question": "Why does my combinational always block infer a latch?",
      "answer": "This happens when not all outputs are assigned for all input combinations. If you have an if-statement without an else, or a case statement without default, the synthesis tool infers a latch. Solution: ensure every path assigns every output, use else clauses, and include default in case statements.",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["D Latch", "Combinational Always", "Case Statement", "If-Else in Verilog"],
      "keywords": ["latch", "infer", "combinational", "always block", "synthesis"],
      "source_links": ["docs/chapters/13-verilog-modeling/index.md"],
      "has_example": false,
      "word_count": 57
    },
    {
      "id": "faq-021",
      "category": "Common Challenges",
      "question": "How do I debug timing violations?",
      "answer": "Timing violations mean signals don't meet setup or hold requirements. For setup violations: the combinational path is too long—simplify logic, add pipeline stages, or reduce clock frequency. For hold violations: the path is too short—add buffers. Use timing reports to identify failing paths.",
      "bloom_level": "Apply",
      "difficulty": "hard",
      "concepts": ["Timing Violation", "Setup Time", "Hold Time", "Timing Constraint"],
      "keywords": ["timing", "violation", "debug", "setup", "hold", "slack"],
      "source_links": ["docs/chapters/08-flip-flops-timing/index.md"],
      "has_example": false,
      "word_count": 55
    },
    {
      "id": "faq-022",
      "category": "Common Challenges",
      "question": "How do I properly debounce a mechanical switch?",
      "answer": "Mechanical switches bounce—the contacts make and break multiple times over 1-10ms. Without debouncing, a single press may register as many presses. Solutions: hardware (RC filter with Schmitt trigger) or digital (sample the input, wait for it to be stable for 10-20ms).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["Debouncing", "Switch Input", "Synchronizer Circuit"],
      "keywords": ["debounce", "switch", "bounce", "button", "mechanical"],
      "source_links": ["docs/chapters/15-fpga-lab-skills/index.md"],
      "has_example": false,
      "word_count": 56
    },
    {
      "id": "faq-023",
      "category": "Best Practices",
      "question": "What makes Verilog code good quality?",
      "answer": "Good Verilog is: consistent in style; well-documented with header comments; synthesizable where intended; thoroughly tested with self-checking testbenches; hierarchical with clean module interfaces; and parameterized for reuse. Avoid clever tricks that obscure intent—clarity beats cleverness.",
      "bloom_level": "Evaluate",
      "difficulty": "medium",
      "concepts": ["Verilog HDL", "Testbench", "Hierarchical Design", "Design Documentation"],
      "keywords": ["verilog", "quality", "style", "best practices", "documentation"],
      "source_links": ["docs/chapters/12-verilog-hdl-fundamentals/index.md"],
      "has_example": false,
      "word_count": 48
    },
    {
      "id": "faq-024",
      "category": "Best Practices",
      "question": "How do I design a state machine from a word problem?",
      "answer": "Follow this process: (1) Identify the states. (2) Determine transitions. (3) Define outputs. (4) Draw the state diagram. (5) Create the state table. (6) Choose encoding. (7) Derive next-state and output equations. (8) Implement and verify.",
      "bloom_level": "Create",
      "difficulty": "medium",
      "concepts": ["FSM Design Process", "State Diagram", "State Table", "State Encoding"],
      "keywords": ["state machine", "design", "fsm", "process", "methodology"],
      "source_links": ["docs/chapters/09-fsm-fundamentals/index.md", "docs/chapters/10-fsm-design-applications/index.md"],
      "has_example": false,
      "word_count": 51
    },
    {
      "id": "faq-025",
      "category": "Laboratory Skills",
      "question": "How do I read a breadboard layout?",
      "answer": "Breadboards have internal connections: terminal strips have 5-hole rows connected horizontally, power rails run vertically along the edges. The center gap separates the two halves (important for IC placement). Use color-coded wires and keep connections neat for easier debugging.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": ["Breadboard Prototyping"],
      "keywords": ["breadboard", "connections", "layout", "wiring", "prototyping"],
      "source_links": ["docs/chapters/15-fpga-lab-skills/index.md"],
      "has_example": false,
      "word_count": 50
    },
    {
      "id": "faq-026",
      "category": "Laboratory Skills",
      "question": "How do I use a logic analyzer effectively?",
      "answer": "Set up triggers to capture the behavior you want. Adjust sample rate based on your clock frequency. Use protocol decoders for standard interfaces. Learn to set cursors for timing measurements. Save captures for documentation.",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["Logic Analyzer", "Debugging Waveforms", "Design Verification"],
      "keywords": ["logic analyzer", "debug", "capture", "trigger", "waveform"],
      "source_links": ["docs/chapters/15-fpga-lab-skills/index.md"],
      "has_example": false,
      "word_count": 42
    },
    {
      "id": "faq-027",
      "category": "Advanced Topics",
      "question": "What happens after this course?",
      "answer": "This course prepares you for computer architecture, embedded systems, VLSI design, and FPGA-based system design. The concepts of synchronous design, state machines, and timing analysis apply throughout. Your Verilog skills transfer directly to industry tools.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Digital System Design", "Design Hierarchy", "Abstraction Levels"],
      "keywords": ["next", "future", "courses", "career", "architecture", "vlsi"],
      "source_links": ["docs/course-description.md"],
      "has_example": false,
      "word_count": 46
    },
    {
      "id": "faq-028",
      "category": "Advanced Topics",
      "question": "How do clock domain crossings work?",
      "answer": "When signals move between different clock domains, careful synchronization is required to prevent metastability. Use synchronizer flip-flops for single-bit signals. For multi-bit data, use FIFOs with asynchronous clocks or Gray code encoding.",
      "bloom_level": "Analyze",
      "difficulty": "hard",
      "concepts": ["Synchronizer Circuit", "Double Flop Synchronizer", "Gray Code", "Metastability"],
      "keywords": ["clock domain", "crossing", "synchronizer", "cdc", "metastability"],
      "source_links": ["docs/chapters/08-flip-flops-timing/index.md"],
      "has_example": false,
      "word_count": 43
    }
  ]
}

{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Digital Electronics","text":"<p>Welcome to the digital electronics course website!</p> <p>Our goal is to provide resources for teaching some of the most difficult concepts in an introduction to digital electronics course by using generative AI to create lesson plans and simulations.</p> <p>To use this site you can use the search function in the upper right corner or use the navigation system on the left side of the pages.</p> <p>Please let me know if you have any comments or suggestions for improvements.</p> <p>Have fun!</p> <p>Dan McCreary LinkedIn</p>"},{"location":"about/","title":"About the Digital Electronics Course","text":"<p>What are the most difficult concepts for an undergraduate college student to understand in a digital electronics course?</p> <p>In an undergraduate digital electronics course, several concepts are often challenging for students to grasp due to their abstract nature or the level of detail involved. Some of the most difficult concepts typically include:</p> <ol> <li> <p>Boolean Algebra and Logic Gates: Understanding how Boolean algebra relates to the operation of basic logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR) and their use in creating complex circuits.</p> </li> <li> <p>Karnaugh Maps (K-Maps): These are used for simplifying Boolean expressions and can be quite challenging due to the need for spatial and logical reasoning.</p> </li> <li> <p>Flip-Flops and Latches: The concepts of storage elements like flip-flops and latches, which are fundamental to memory and sequential circuits, can be abstract and require a solid understanding of timing and control signals.</p> </li> <li> <p>Finite State Machines (FSMs): Designing and understanding FSMs, which are models of computation used in sequential logic, can be complex, especially when dealing with larger systems.</p> </li> <li> <p>Timing Analysis: Understanding the timing characteristics of digital circuits, such as setup and hold times, clock skew, and propagation delay, is crucial but can be difficult due to the abstract nature of these concepts.</p> </li> <li> <p>Digital-to-Analog (DAC) and Analog-to-Digital Converters (ADC): Understanding how digital systems interface with the analog world through DACs and ADCs requires a good grasp of both digital and analog principles.</p> </li> <li> <p>Signal Integrity and Noise Issues: Learning about how noise affects digital signals and the techniques used to mitigate these effects can be challenging, especially in high-speed digital design.</p> </li> <li> <p>Microprocessor Architecture and Assembly Language Programming: The intricacies of microprocessor architecture and the details of assembly language programming are often complex for students new to these concepts.</p> </li> <li> <p>Memory Architecture: Understanding different types of memory (RAM, ROM, Cache, etc.) and their architecture can be intricate due to the details involved in how they store and retrieve data.</p> </li> <li> <p>VHDL/Verilog for FPGA Design: Learning hardware description languages like VHDL or Verilog for FPGA (Field-Programmable Gate Array) design can be daunting due to the need to think in terms of hardware rather than software.</p> </li> </ol> <p>These topics require a solid foundation in basic electronics and mathematics, along with the ability to think abstractly and logically. The difficulty often lies in the transition from theoretical knowledge to practical application and understanding how these concepts interconnect to form complex digital systems.</p>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"Digital Electronics","text":"<p>This is a sophomore-level digital electronics course that covers the ABET-aligned EE curricula for digital electronics. This course feeds upper-division computer architecture, VLSI, and embedded systems courses.</p> <p>Here are the topics covered roughly in the order they are taught.</p>"},{"location":"course-description/#intended-audience","title":"Intended Audience","text":"<p>College students that plan on becoming majors in electrical engineering or computer-related fields.</p>"},{"location":"course-description/#prerequisites","title":"Prerequisites","text":"<p>Calculus 1 is required for several of the advanced topics in this course.</p>"},{"location":"course-description/#1-foundations-boolean-algebra-binary-logic","title":"1. Foundations: Boolean Algebra &amp; Binary Logic","text":""},{"location":"course-description/#core-concepts","title":"Core concepts","text":"<ul> <li>Binary number system (review, but formalized)</li> <li>Boolean variables, constants (0, 1)</li> <li>Boolean operators: AND, OR, NOT</li> <li>Truth tables as formal specifications</li> <li>Boolean expressions vs Boolean functions</li> </ul>"},{"location":"course-description/#boolean-algebra-laws-memorized-applied","title":"Boolean algebra laws (memorized + applied)","text":"<ul> <li>Identity, Null, Idempotent</li> <li>Complement</li> <li>Commutative, Associative, Distributive</li> <li>Absorption</li> <li>De Morgan\u2019s Theorems (very important)</li> </ul>"},{"location":"course-description/#why-this-matters","title":"Why this matters","text":"<p>This is where logical reasoning becomes mathematical, and students learn that:</p> <p>Digital circuits are physical realizations of Boolean functions.</p>"},{"location":"course-description/#2-logic-gates-gate-level-modeling","title":"2. Logic Gates &amp; Gate-Level Modeling","text":""},{"location":"course-description/#primitive-gates","title":"Primitive gates","text":"<ul> <li>NOT, AND, OR</li> <li>NAND, NOR (emphasized as functionally complete)</li> <li>XOR, XNOR</li> </ul>"},{"location":"course-description/#gate-properties","title":"Gate properties","text":"<ul> <li>Functional completeness</li> <li>Gate delay (introductory timing intuition)</li> <li>Fan-in / fan-out (qualitative)</li> <li>Symbol conventions and schematics</li> </ul>"},{"location":"course-description/#gate-level-abstraction","title":"Gate-level abstraction","text":"<ul> <li>Mapping Boolean expressions \u2192 gates</li> <li>Understanding that NAND/NOR dominate real hardware</li> </ul>"},{"location":"course-description/#3-combinational-logic-design","title":"3. Combinational Logic Design","text":""},{"location":"course-description/#canonical-representations","title":"Canonical representations","text":"<ul> <li>Sum-of-Products (SOP)</li> <li>Product-of-Sums (POS)</li> <li>Canonical vs minimal forms</li> </ul>"},{"location":"course-description/#standard-combinational-blocks","title":"Standard combinational blocks","text":"<p>Students design and analyze:</p> <ul> <li>Multiplexers (MUX)</li> <li>Demultiplexers</li> <li>Encoders / Decoders</li> <li>Priority encoders</li> <li>Comparators</li> <li> <p>Adders</p> </li> <li> <p>Half adder</p> </li> <li>Full adder</li> <li>Ripple-carry adder (conceptual)</li> </ul>"},{"location":"course-description/#design-workflow","title":"Design workflow","text":"<ol> <li>Problem statement</li> <li>Truth table</li> <li>Boolean expression</li> <li>Simplification</li> <li>Gate-level implementation</li> <li>(Later) Verilog model</li> </ol>"},{"location":"course-description/#4-logic-simplification-optimization","title":"4. Logic Simplification &amp; Optimization","text":""},{"location":"course-description/#algebraic-simplification","title":"Algebraic simplification","text":"<ul> <li>Manual application of Boolean laws</li> <li>Factoring and common-term extraction</li> </ul>"},{"location":"course-description/#karnaugh-maps-k-maps","title":"Karnaugh Maps (K-maps)","text":"<ul> <li>2-, 3-, and 4-variable K-maps</li> <li>Grouping rules</li> <li>Don\u2019t-care conditions</li> <li>Minimal SOP / POS solutions</li> </ul>"},{"location":"course-description/#design-tradeoffs","title":"Design tradeoffs","text":"<ul> <li>Gate count vs clarity</li> <li>Depth vs width</li> <li>Cost, power, and delay (introductory, not transistor-level)</li> </ul>"},{"location":"course-description/#5-introduction-to-sequential-logic","title":"5. Introduction to Sequential Logic","text":"<p>This is the big conceptual leap of the course.</p>"},{"location":"course-description/#memory-state","title":"Memory &amp; state","text":"<ul> <li>Difference between combinational and sequential logic</li> <li>Concept of state</li> <li>Clocked vs unclocked systems</li> </ul>"},{"location":"course-description/#latches","title":"Latches","text":"<ul> <li>SR latch</li> <li>D latch</li> <li>Level-sensitive behavior</li> <li>Why latches are dangerous in large designs</li> </ul>"},{"location":"course-description/#6-flip-flops-clocked-storage","title":"6. Flip-Flops &amp; Clocked Storage","text":""},{"location":"course-description/#flip-flop-types","title":"Flip-flop types","text":"<ul> <li>D flip-flop (primary focus)</li> <li>JK, T flip-flops (often covered conceptually)</li> </ul>"},{"location":"course-description/#timing-concepts-qualitative","title":"Timing concepts (qualitative)","text":"<ul> <li>Clock edge</li> <li>Setup time</li> <li>Hold time</li> <li>Clock-to-Q delay</li> <li>Metastability (introduced, not deeply analyzed)</li> </ul>"},{"location":"course-description/#7-synchronous-sequential-logic-design","title":"7. Synchronous Sequential Logic Design","text":"<p>This is the heart of EE 2301.</p>"},{"location":"course-description/#finite-state-machines-fsms","title":"Finite State Machines (FSMs)","text":"<ul> <li>Moore machines</li> <li>Mealy machines</li> <li>State diagrams</li> <li>State tables</li> <li>State encoding (binary, one-hot \u2014 at least conceptually)</li> </ul>"},{"location":"course-description/#fsm-design-process","title":"FSM design process","text":"<ol> <li>Word problem \u2192 states</li> <li>State diagram</li> <li>State table</li> <li>Next-state equations</li> <li>Output equations</li> <li>Implementation with flip-flops + combinational logic</li> </ol>"},{"location":"course-description/#common-examples","title":"Common examples","text":"<ul> <li>Counters (mod-N, up/down)</li> <li>Sequence detectors</li> <li>Controllers (traffic light, vending machine-style problems)</li> </ul>"},{"location":"course-description/#8-registers-counters-and-datapath-elements","title":"8. Registers, Counters, and Datapath Elements","text":""},{"location":"course-description/#registers","title":"Registers","text":"<ul> <li>Parallel registers</li> <li>Enable signals</li> <li>Load vs hold behavior</li> </ul>"},{"location":"course-description/#counters","title":"Counters","text":"<ul> <li>Synchronous counters</li> <li>Reset (synchronous vs asynchronous)</li> <li>Modulus control</li> </ul>"},{"location":"course-description/#datapath-intuition","title":"Datapath intuition","text":"<ul> <li>Registers + combinational logic + control</li> <li>Early exposure to CPU-style thinking</li> </ul>"},{"location":"course-description/#9-verilog-hdl-modeling","title":"9. Verilog HDL Modeling","text":"<p>This is where software-thinking students shine.</p>"},{"location":"course-description/#verilog-basics","title":"Verilog basics","text":"<ul> <li>Modules</li> <li>Ports (input/output)</li> <li>Wire vs reg</li> <li>Continuous assignments (<code>assign</code>)</li> <li>Procedural blocks (<code>always</code>)</li> </ul>"},{"location":"course-description/#modeling-styles","title":"Modeling styles","text":"<ul> <li>Combinational logic (<code>always @(*)</code>)</li> <li>Sequential logic (<code>always @(posedge clk)</code>)</li> <li>Structural vs behavioral modeling</li> </ul>"},{"location":"course-description/#testbenches","title":"Testbenches","text":"<ul> <li>Stimulus generation</li> <li>Observing outputs</li> <li>Simulation as verification</li> </ul>"},{"location":"course-description/#key-learning-outcome","title":"Key learning outcome","text":"<p>Students learn that:</p> <p>HDLs describe hardware behavior, not software execution.</p>"},{"location":"course-description/#10-design-simulation-and-verification-flow","title":"10. Design, Simulation, and Verification Flow","text":""},{"location":"course-description/#typical-toolchain","title":"Typical toolchain","text":"<ul> <li>Verilog editor</li> <li>Simulator (ModelSim / Questa / similar)</li> <li>FPGA or logic lab hardware</li> </ul>"},{"location":"course-description/#concepts-emphasized","title":"Concepts emphasized","text":"<ul> <li>Separation of design and verification</li> <li>Debugging with waveforms</li> <li>Functional correctness before optimization</li> </ul>"},{"location":"course-description/#11-integral-laboratory-component","title":"11. Integral Laboratory Component","text":"<p>The lab is not optional or cosmetic.</p>"},{"location":"course-description/#labs","title":"Labs","text":"<ul> <li>Breadboarding simple gate circuits (early)</li> <li>Using logic analyzers or FPGA boards</li> <li>Implementing combinational logic modules</li> <li>FSM implementations in Verilog</li> <li>Testing with switches, LEDs, clocks</li> </ul>"},{"location":"course-description/#skills-developed","title":"Skills developed","text":"<ul> <li>Translating theory \u2192 working hardware</li> <li>Debugging timing and logic errors</li> <li>Working within constraints (pins, clocks, resets)</li> </ul>"},{"location":"course-description/#12-professional-programmatic-outcomes","title":"12. Professional &amp; Programmatic Outcomes","text":"<p>By the end of EE 2301, students can:</p> <ul> <li>Think in Boolean abstractions</li> <li>Design correct, clocked digital systems</li> <li>Read and write Verilog</li> <li>Understand how hardware differs fundamentally from software</li> <li> <p>Prepare for:</p> </li> <li> <p>Computer architecture</p> </li> <li>Embedded systems</li> <li>VLSI / FPGA design</li> <li>Operating systems (indirectly)</li> </ul>"},{"location":"course-description/#topics-not-covered","title":"Topics Not Covered","text":"<p>Important boundary clarification:</p> <ul> <li>\u274c No transistor-level CMOS design</li> <li>\u274c No asynchronous circuit theory</li> <li>\u274c No advanced timing closure or synthesis</li> <li>\u274c No CPU pipeline design</li> </ul> <p>These topics will come later \u2014 this course builds the mental scaffolding.</p>"},{"location":"course-description/#why-ee-2301-is-a-pivot-course","title":"Why EE 2301 Is a Pivot Course","text":"<p>This course is where students stop thinking:</p> <p>\"The computer just runs code\"</p> <p>\u2026and start thinking:</p> <p>\"The computer is a carefully synchronized state machine built from logic.\"</p>"},{"location":"course-description/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this course, students will be able to:</p>"},{"location":"course-description/#remember","title":"Remember","text":"<ul> <li>Recall the truth tables for all primitive logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR)</li> <li>List the fundamental Boolean algebra laws (Identity, Null, Idempotent, Complement, Commutative, Associative, Distributive, Absorption)</li> <li>State De Morgan's Theorems</li> <li>Identify the symbols for standard logic gates</li> <li>Name the timing parameters for flip-flops (setup time, hold time, clock-to-Q delay)</li> </ul>"},{"location":"course-description/#understand","title":"Understand","text":"<ul> <li>Explain the difference between combinational and sequential logic</li> <li>Describe how Boolean expressions map to physical gate implementations</li> <li>Interpret truth tables and state diagrams</li> <li>Distinguish between Moore and Mealy state machines</li> <li>Explain why NAND and NOR gates are functionally complete</li> <li>Describe the concept of metastability in digital systems</li> </ul>"},{"location":"course-description/#apply","title":"Apply","text":"<ul> <li>Use Karnaugh maps to simplify Boolean expressions up to 4 variables</li> <li>Apply Boolean algebra laws to reduce logic expressions</li> <li>Implement combinational circuits using standard blocks (MUX, decoders, adders)</li> <li>Design finite state machines from word problem specifications</li> <li>Write synthesizable Verilog code for combinational and sequential logic</li> <li>Use simulation tools to verify digital designs</li> </ul>"},{"location":"course-description/#analyze","title":"Analyze","text":"<ul> <li>Analyze timing diagrams to identify setup and hold violations</li> <li>Decompose complex digital systems into combinational and sequential components</li> <li>Trace signal propagation through multi-level logic circuits</li> <li>Debug logic errors using waveform analysis</li> <li>Examine FSM state transitions for correctness and completeness</li> </ul>"},{"location":"course-description/#evaluate","title":"Evaluate","text":"<ul> <li>Compare design tradeoffs between gate count, propagation delay, and power consumption</li> <li>Assess whether a circuit implementation meets functional specifications</li> <li>Critique state encoding choices (binary vs. one-hot) for specific applications</li> <li>Judge the quality of Verilog code for clarity and synthesizability</li> <li>Evaluate when to use latches versus flip-flops in a design</li> </ul>"},{"location":"course-description/#create","title":"Create","text":"<ul> <li>Design complete synchronous digital systems from specifications</li> <li>Construct testbenches to verify Verilog module functionality</li> <li>Develop FSM-based controllers for real-world applications (traffic lights, vending machines)</li> <li>Build working circuits on breadboards and FPGA platforms</li> <li>Synthesize optimized gate-level implementations from behavioral descriptions</li> </ul>"},{"location":"glossary/","title":"Digital Electronics Glossary of Terms","text":""},{"location":"glossary/#abet-aligned-ee-curriculum","title":"ABET-aligned EE Curriculum","text":"<p>A curriculum aligned with the standards of the Accreditation Board for Engineering and Technology.</p> <p>A carefully scaffolded, outcomes-driven program that ensures students don\u2019t just learn electrical engineering concepts \u2014 they learn how to think, design, build, and verify real engineering systems at a professional level.</p> <p>ABET stands for Accreditation Board for Engineering and Technology. It is not a government agency; it is a professional accreditor recognized by industry, licensing boards, and universities.</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#python","title":"Python","text":"<p>MicroSims are about how we use generative AI to create animations and simulations.  The language of AI is Python.  So we wanted to create a site that could be easily understood by Python developers.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"references/","title":"References for Digital Electronics","text":""},{"location":"references/#commercial-tools","title":"Commercial Tools","text":"<p>Logicly - Logicly is a $50 digital circuit simulator.  It has components for the standard logic gates and flip-flops.</p>"},{"location":"chapters/","title":"Chapters","text":"<p>This textbook is organized into 15 chapters covering 300 concepts in digital electronics.</p>"},{"location":"chapters/#chapter-overview","title":"Chapter Overview","text":"<ol> <li> <p>Number Systems and Binary Arithmetic - Covers binary, hexadecimal, and octal number systems along with arithmetic operations and encoding schemes.</p> </li> <li> <p>Boolean Algebra Fundamentals - Introduces Boolean variables, operations, expressions, functions, truth tables, and Boolean algebra laws.</p> </li> <li> <p>Logic Gates and Digital Signal Properties - Covers primitive logic gates, functional completeness, timing parameters, and signal characteristics.</p> </li> <li> <p>Combinational Logic Design Fundamentals - Introduces combinational vs sequential logic, gate-level design, and canonical forms.</p> </li> <li> <p>Logic Minimization and Karnaugh Maps - Covers K-maps, grouping rules, prime implicants, and hazard-free design.</p> </li> <li> <p>Combinational Building Blocks - Covers multiplexers, decoders, comparators, adders, and ALU concepts.</p> </li> <li> <p>Introduction to Sequential Logic - Introduces memory elements, latches, and clock signals.</p> </li> <li> <p>Flip-Flops and Timing - Covers edge-triggered flip-flops, timing parameters, and synchronization.</p> </li> <li> <p>Finite State Machine Fundamentals - Introduces FSMs, Moore and Mealy machines, state diagrams, and encoding methods.</p> </li> <li> <p>FSM Design and Applications - Covers the FSM design process and practical applications.</p> </li> <li> <p>Registers, Counters, and Datapath - Covers registers, shift registers, counters, and datapath concepts.</p> </li> <li> <p>Verilog HDL Fundamentals - Introduces Verilog modules, ports, data types, and assignments.</p> </li> <li> <p>Verilog Behavioral and Structural Modeling - Covers always blocks, modeling styles, and hierarchical design.</p> </li> <li> <p>Testbenches and Simulation - Covers testbench creation, simulation, and synthesis concepts.</p> </li> <li> <p>FPGA Implementation and Laboratory Skills - Covers FPGA architecture, implementation, and laboratory practices.</p> </li> </ol>"},{"location":"chapters/#how-to-use-this-textbook","title":"How to Use This Textbook","text":"<p>This textbook is designed with a careful progression of concepts where each chapter builds on the knowledge from previous chapters. The learning graph ensures that all prerequisite concepts are covered before they are needed. Students should work through chapters sequentially, as later chapters assume familiarity with earlier material.</p> <p>Note: Each chapter includes a list of concepts covered from the learning graph. Make sure to complete prerequisites before moving to advanced chapters.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/","title":"Number Systems and Binary Arithmetic","text":""},{"location":"chapters/01-number-systems-binary-arithmetic/#summary","title":"Summary","text":"<p>This chapter establishes the mathematical foundation for digital electronics by introducing number systems used in digital design. Students will learn to convert between binary, decimal, hexadecimal, and octal representations, perform binary arithmetic operations, understand signed number representation using two's complement, and work with specialized encoding schemes like BCD and Gray code. These skills are essential for all subsequent work in digital circuit design.</p>"},{"location":"chapters/01-number-systems-binary-arithmetic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>Binary Number System</li> <li>Decimal to Binary Conversion</li> <li>Binary to Decimal Conversion</li> <li>Hexadecimal Numbers</li> <li>Hex to Binary Conversion</li> <li>Octal Numbers</li> <li>Binary Addition</li> <li>Binary Subtraction</li> <li>Two's Complement</li> <li>Signed Binary Numbers</li> <li>Overflow Detection</li> <li>BCD Encoding</li> <li>Gray Code</li> <li>Weighted Codes</li> </ol>"},{"location":"chapters/01-number-systems-binary-arithmetic/#prerequisites","title":"Prerequisites","text":"<p>This chapter assumes only the prerequisites listed in the course description. Students should have a basic understanding of arithmetic and number representation from prior mathematics courses.</p> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/","title":"Boolean Algebra Fundamentals","text":""},{"location":"chapters/02-boolean-algebra-fundamentals/#summary","title":"Summary","text":"<p>This chapter transforms logical reasoning into a mathematical framework that forms the theoretical foundation of all digital circuits. Students will learn about Boolean variables, constants, and the three fundamental operations (AND, OR, NOT), how to construct and interpret Boolean expressions and functions, the role of truth tables as formal specifications, and all essential Boolean algebra laws including De Morgan's theorem. Mastering these concepts enables students to analyze and simplify digital logic mathematically.</p>"},{"location":"chapters/02-boolean-algebra-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>Boolean Variable</li> <li>Boolean Constant</li> <li>Boolean Expression</li> <li>Boolean Function</li> <li>Truth Table</li> <li>AND Operation</li> <li>OR Operation</li> <li>NOT Operation</li> <li>Boolean Algebra</li> <li>Identity Law</li> <li>Null Law</li> <li>Idempotent Law</li> <li>Complement Law</li> <li>Commutative Law</li> <li>Associative Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>De Morgan's Theorem</li> <li>Dual Expression</li> <li>Consensus Theorem</li> <li>Boolean Proof Technique</li> </ol>"},{"location":"chapters/02-boolean-algebra-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Number Systems and Binary Arithmetic</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/03-logic-gates-digital-signals/","title":"Logic Gates and Digital Signal Properties","text":""},{"location":"chapters/03-logic-gates-digital-signals/#summary","title":"Summary","text":"<p>This chapter bridges the gap between Boolean algebra theory and physical circuit implementation by introducing logic gates as the building blocks of digital systems. Students will learn about all primitive gates (AND, OR, NOT, NAND, NOR, XOR, XNOR), the concept of functional completeness and universal gates, gate timing characteristics including propagation delay, fan-in and fan-out considerations, logic families (TTL and CMOS), and digital signal properties. Understanding these concepts is essential for designing real hardware that correctly implements Boolean functions.</p>"},{"location":"chapters/03-logic-gates-digital-signals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 30 concepts from the learning graph:</p> <ol> <li>Logic Gate</li> <li>AND Gate</li> <li>OR Gate</li> <li>NOT Gate</li> <li>Buffer Gate</li> <li>NAND Gate</li> <li>NOR Gate</li> <li>XOR Gate</li> <li>XNOR Gate</li> <li>Gate Symbol</li> <li>IEEE Gate Symbols</li> <li>Functional Completeness</li> <li>Universal Gate</li> <li>NAND-Only Design</li> <li>NOR-Only Design</li> <li>Gate Delay</li> <li>Propagation Delay</li> <li>Rise Time</li> <li>Fall Time</li> <li>Fan-In</li> <li>Fan-Out</li> <li>Logic Levels</li> <li>Noise Margin</li> <li>Voltage Threshold</li> <li>Logic Family</li> <li>TTL Logic</li> <li>CMOS Logic</li> <li>Digital Signal</li> <li>Analog vs Digital</li> <li>Signal Integrity</li> </ol>"},{"location":"chapters/03-logic-gates-digital-signals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Boolean Algebra Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/04-combinational-logic-design/","title":"Combinational Logic Design Fundamentals","text":""},{"location":"chapters/04-combinational-logic-design/#summary","title":"Summary","text":"<p>This chapter introduces the systematic methodology for designing combinational logic circuits where outputs depend only on current inputs. Students will learn the distinction between combinational and sequential logic, how to map Boolean expressions to gate-level implementations, canonical representations including Sum of Products (SOP) and Product of Sums (POS), minterms and maxterms, and the foundations of logic minimization including an introduction to Karnaugh maps. These design techniques form the core workflow for creating digital circuits from specifications.</p>"},{"location":"chapters/04-combinational-logic-design/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>Gate-Level Design</li> <li>Boolean to Gates Mapping</li> <li>Multi-Level Logic</li> <li>Two-Level Logic</li> <li>Sum of Products</li> <li>Product of Sums</li> <li>Minterm</li> <li>Maxterm</li> <li>Canonical Form</li> <li>Standard Form</li> <li>Minimal Form</li> <li>Logic Minimization</li> <li>Algebraic Simplification</li> <li>Factoring</li> <li>Common Term Extraction</li> <li>Karnaugh Map</li> <li>K-Map 2 Variable</li> <li>K-Map 3 Variable</li> </ol>"},{"location":"chapters/04-combinational-logic-design/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Boolean Algebra Fundamentals</li> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/05-logic-minimization-kmaps/","title":"Logic Minimization and Karnaugh Maps","text":""},{"location":"chapters/05-logic-minimization-kmaps/#summary","title":"Summary","text":"<p>This chapter provides advanced techniques for optimizing Boolean functions to create efficient circuit implementations. Students will master 4-variable Karnaugh maps and their grouping rules, learn to identify prime implicants and essential prime implicants, handle don't-care conditions for further optimization, derive minimal SOP and POS expressions, understand the Quine-McCluskey method for larger functions, and design hazard-free circuits. These optimization skills are critical for creating practical, cost-effective digital systems.</p>"},{"location":"chapters/05-logic-minimization-kmaps/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>K-Map 4 Variable</li> <li>K-Map Grouping Rules</li> <li>Adjacent Cells</li> <li>Don't Care Condition</li> <li>Prime Implicant</li> <li>Essential Prime Implicant</li> <li>Implicant Cover</li> <li>Minimal SOP</li> <li>Minimal POS</li> <li>Quine-McCluskey Method</li> <li>Hazard</li> <li>Static Hazard</li> <li>Dynamic Hazard</li> <li>Hazard-Free Design</li> </ol>"},{"location":"chapters/05-logic-minimization-kmaps/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/06-combinational-building-blocks/","title":"Combinational Building Blocks","text":""},{"location":"chapters/06-combinational-building-blocks/#summary","title":"Summary","text":"<p>This chapter introduces the standard combinational circuit modules that serve as building blocks for larger digital systems. Students will design and analyze multiplexers, demultiplexers, encoders, decoders, priority encoders, binary and magnitude comparators, half and full adders, ripple-carry adders, and understand ALU concepts. Additional topics include parity generation and checking for error detection, tri-state buffers, and bus architecture. These modular components are fundamental to constructing complex digital systems efficiently.</p>"},{"location":"chapters/06-combinational-building-blocks/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 35 concepts from the learning graph:</p> <ol> <li>Multiplexer</li> <li>MUX 2-to-1</li> <li>MUX 4-to-1</li> <li>MUX 8-to-1</li> <li>MUX Tree</li> <li>MUX as Logic Function</li> <li>Demultiplexer</li> <li>DEMUX 1-to-4</li> <li>Encoder</li> <li>Decoder</li> <li>2-to-4 Decoder</li> <li>3-to-8 Decoder</li> <li>Decoder Enable</li> <li>Priority Encoder</li> <li>7-Segment Display</li> <li>7-Segment Decoder</li> <li>Binary Comparator</li> <li>Magnitude Comparator</li> <li>Equality Comparator</li> <li>Half Adder</li> <li>Full Adder</li> <li>Carry Bit</li> <li>Sum Bit</li> <li>Ripple Carry Adder</li> <li>Carry Propagation Delay</li> <li>Carry Lookahead Concept</li> <li>Adder Subtractor</li> <li>Overflow in Addition</li> <li>ALU Concept</li> <li>Parity Bit</li> <li>Parity Generator</li> <li>Parity Checker</li> <li>Error Detection</li> <li>Tri-State Buffer</li> <li>Bus Architecture</li> </ol>"},{"location":"chapters/06-combinational-building-blocks/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/07-intro-sequential-logic/","title":"Introduction to Sequential Logic","text":""},{"location":"chapters/07-intro-sequential-logic/#summary","title":"Summary","text":"<p>This chapter marks the conceptual leap from combinational to sequential logic, where circuits can store information and their outputs depend on both current inputs and past history. Students will learn about memory elements, the concept of state, feedback loops in circuits, bistable elements, and latches including SR and D latches. The chapter also covers level-sensitive behavior, timing problems with latches, race conditions, and introduces clock signals as the foundation for synchronous design. Understanding these concepts is essential before studying flip-flops and finite state machines.</p>"},{"location":"chapters/07-intro-sequential-logic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Memory Element</li> <li>State Concept</li> <li>Feedback Loop</li> <li>Bistable Element</li> <li>SR Latch</li> <li>SR Latch Truth Table</li> <li>Invalid State Problem</li> <li>Gated SR Latch</li> <li>D Latch</li> <li>Level Sensitive</li> <li>Transparent Latch</li> <li>Latch Timing Problem</li> <li>Race Condition</li> <li>Clock Signal</li> <li>Clock Edge</li> <li>Rising Edge</li> <li>Falling Edge</li> <li>Clock Period</li> <li>Clock Frequency</li> <li>Duty Cycle</li> </ol>"},{"location":"chapters/07-intro-sequential-logic/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Logic Gates and Digital Signal Properties</li> <li>Chapter 4: Combinational Logic Design Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/08-flip-flops-timing/","title":"Flip-Flops and Timing","text":""},{"location":"chapters/08-flip-flops-timing/#summary","title":"Summary","text":"<p>This chapter covers edge-triggered flip-flops, the fundamental storage elements in synchronous digital systems. Students will learn about D, JK, and T flip-flops, understand edge-triggering mechanisms including master-slave configurations, and work with asynchronous preset and clear inputs. Critical timing concepts including setup time, hold time, clock-to-Q delay, timing diagrams, and timing violations are thoroughly covered. The chapter also addresses metastability, its causes, and synchronization techniques including the double-flop synchronizer for handling asynchronous inputs safely.</p>"},{"location":"chapters/08-flip-flops-timing/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>D Flip-Flop</li> <li>Edge Triggered</li> <li>Positive Edge Triggered</li> <li>Negative Edge Triggered</li> <li>Master-Slave Flip-Flop</li> <li>JK Flip-Flop</li> <li>JK Toggle Mode</li> <li>T Flip-Flop</li> <li>Flip-Flop Symbol</li> <li>Preset Input</li> <li>Clear Input</li> <li>Asynchronous Reset</li> <li>Synchronous Reset</li> <li>Setup Time</li> <li>Hold Time</li> <li>Clock-to-Q Delay</li> <li>Timing Diagram</li> <li>Timing Constraint</li> <li>Timing Violation</li> <li>Metastability</li> <li>MTBF Concept</li> <li>Synchronous System</li> <li>Asynchronous Input</li> <li>Synchronizer Circuit</li> <li>Double Flop Synchronizer</li> </ol>"},{"location":"chapters/08-flip-flops-timing/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 7: Introduction to Sequential Logic</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/09-fsm-fundamentals/","title":"Finite State Machine Fundamentals","text":""},{"location":"chapters/09-fsm-fundamentals/#summary","title":"Summary","text":"<p>This chapter introduces finite state machines (FSMs), the core abstraction for designing sequential digital systems with well-defined behavior. Students will learn the FSM model including states, transitions, inputs, and outputs, understand the distinction between Moore machines (outputs depend only on state) and Mealy machines (outputs depend on state and inputs), and master state diagram and state table representations. The chapter covers state encoding strategies including binary, one-hot, and Gray code encoding, along with state assignment optimization and state minimization techniques.</p>"},{"location":"chapters/09-fsm-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Finite State Machine</li> <li>FSM State</li> <li>State Transition</li> <li>Current State</li> <li>Next State</li> <li>Next State Logic</li> <li>Output Logic</li> <li>Moore Machine</li> <li>Moore Output</li> <li>Mealy Machine</li> <li>Mealy Output</li> <li>State Diagram</li> <li>State Diagram Notation</li> <li>State Table</li> <li>State Encoding</li> <li>Binary Encoding</li> <li>One-Hot Encoding</li> <li>Gray Code Encoding</li> <li>State Assignment</li> <li>State Minimization</li> </ol>"},{"location":"chapters/09-fsm-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> <li>Chapter 7: Introduction to Sequential Logic</li> <li>Chapter 8: Flip-Flops and Timing</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/10-fsm-design-applications/","title":"FSM Design and Applications","text":""},{"location":"chapters/10-fsm-design-applications/#summary","title":"Summary","text":"<p>This chapter applies FSM theory to practical design problems, teaching students the complete workflow from specification to implementation. Students will learn to derive next-state and output equations from state tables, follow the systematic FSM design process, and verify FSM designs for correctness. The chapter includes practical applications including sequence detectors with overlapping and non-overlapping detection modes, pattern recognition FSMs, and classic controller examples such as traffic light controllers and vending machine FSMs.</p>"},{"location":"chapters/10-fsm-design-applications/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>Next State Equation</li> <li>Output Equation</li> <li>FSM Design Process</li> <li>FSM Verification</li> <li>Sequence Detector</li> <li>Pattern Recognition FSM</li> <li>Overlapping Detection</li> <li>Non-Overlapping Detection</li> <li>Traffic Light Controller</li> <li>Vending Machine FSM</li> </ol>"},{"location":"chapters/10-fsm-design-applications/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 9: Finite State Machine Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/11-registers-counters-datapath/","title":"Registers, Counters, and Datapath","text":""},{"location":"chapters/11-registers-counters-datapath/#summary","title":"Summary","text":"<p>This chapter covers the sequential building blocks that form the foundation of digital datapath design. Students will learn about registers including parallel load and shift registers with various configurations (SISO, SIPO, PISO, PIPO), bidirectional and universal shift registers, and control signals for enable, load, and clear operations. Counter design is thoroughly covered including up, down, and up-down counters, mod-N counters, BCD and decade counters, and specialized counters like ring and Johnson counters. The chapter concludes with datapath concepts, control units, and register transfer level (RTL) abstraction.</p>"},{"location":"chapters/11-registers-counters-datapath/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 29 concepts from the learning graph:</p> <ol> <li>Counter</li> <li>Up Counter</li> <li>Down Counter</li> <li>Up-Down Counter</li> <li>Mod-N Counter</li> <li>Binary Counter</li> <li>BCD Counter</li> <li>Decade Counter</li> <li>Ring Counter</li> <li>Johnson Counter</li> <li>Counter State Diagram</li> <li>Counter Overflow</li> <li>Register</li> <li>Parallel Load Register</li> <li>Shift Register</li> <li>Serial In Serial Out</li> <li>Serial In Parallel Out</li> <li>Parallel In Serial Out</li> <li>Parallel In Parallel Out</li> <li>Bidirectional Shift</li> <li>Universal Shift Register</li> <li>Enable Signal</li> <li>Load Signal</li> <li>Clear Signal</li> <li>Register File</li> <li>Datapath Concept</li> <li>Control Unit</li> <li>Register Transfer Level</li> <li>RTL Notation</li> </ol>"},{"location":"chapters/11-registers-counters-datapath/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 8: Flip-Flops and Timing</li> <li>Chapter 9: Finite State Machine Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/","title":"Verilog HDL Fundamentals","text":""},{"location":"chapters/12-verilog-hdl-fundamentals/#summary","title":"Summary","text":"<p>This chapter introduces Verilog as a hardware description language, emphasizing that HDLs describe hardware behavior rather than software execution. Students will learn the fundamental distinction between HDL and programming languages, Verilog module structure and syntax, port declarations (input, output, inout), data types including wire and reg, parameters for configurable designs, continuous assignments using the assign statement, initial blocks for simulation, and module instantiation for building hierarchical designs. These fundamentals prepare students for behavioral and structural modeling.</p>"},{"location":"chapters/12-verilog-hdl-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 14 concepts from the learning graph:</p> <ol> <li>Verilog HDL</li> <li>HDL vs Programming</li> <li>Module Definition</li> <li>Port Declaration</li> <li>Input Port</li> <li>Output Port</li> <li>Inout Port</li> <li>Wire Data Type</li> <li>Reg Data Type</li> <li>Parameter</li> <li>Assign Statement</li> <li>Continuous Assignment</li> <li>Initial Block</li> <li>Module Instantiation</li> </ol>"},{"location":"chapters/12-verilog-hdl-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: Combinational Logic Design Fundamentals</li> <li>Chapter 7: Introduction to Sequential Logic</li> <li>Chapter 11: Registers, Counters, and Datapath</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/13-verilog-modeling/","title":"Verilog Behavioral and Structural Modeling","text":""},{"location":"chapters/13-verilog-modeling/#summary","title":"Summary","text":"<p>This chapter covers advanced Verilog constructs for modeling digital systems at various levels of abstraction. Students will master the always block and sensitivity lists, understand the critical difference between blocking and non-blocking assignments, use if-else and case statements for decision logic, and write combinational always blocks (with @(*)) and sequential always blocks (with @(posedge clk)). The chapter covers three modeling styles: structural modeling using gate primitives and module instantiation, behavioral modeling using procedural statements, and gate-level Verilog. RTL Verilog and hierarchical design principles complete the coverage.</p>"},{"location":"chapters/13-verilog-modeling/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Always Block</li> <li>Sensitivity List</li> <li>Blocking Assignment</li> <li>Non-Blocking Assignment</li> <li>If-Else in Verilog</li> <li>Case Statement</li> <li>Combinational Always</li> <li>Sequential Always</li> <li>Posedge Keyword</li> <li>Negedge Keyword</li> <li>Structural Modeling</li> <li>Behavioral Modeling</li> <li>Gate-Level Verilog</li> <li>RTL Verilog</li> <li>Hierarchical Design</li> </ol>"},{"location":"chapters/13-verilog-modeling/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 12: Verilog HDL Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/14-testbenches-simulation/","title":"Testbenches and Simulation","text":""},{"location":"chapters/14-testbenches-simulation/#summary","title":"Summary","text":"<p>This chapter covers the verification side of digital design, teaching students to validate their Verilog designs through simulation before hardware implementation. Students will learn to create testbenches, generate stimulus including clock signals and test vectors, build self-checking testbenches for automated verification, run simulations, and interpret results using waveform viewers for debugging. The chapter also covers the synthesis process, distinguishing between synthesizable and non-synthesizable code constructs, preparing students for FPGA implementation.</p>"},{"location":"chapters/14-testbenches-simulation/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 12 concepts from the learning graph:</p> <ol> <li>Testbench</li> <li>Stimulus Generation</li> <li>Clock Generation</li> <li>Test Vector</li> <li>Self-Checking Testbench</li> <li>Simulation</li> <li>Simulation Time</li> <li>Waveform Viewer</li> <li>Debugging Waveforms</li> <li>Synthesis</li> <li>Synthesizable Code</li> <li>Non-Synthesizable Code</li> </ol>"},{"location":"chapters/14-testbenches-simulation/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 12: Verilog HDL Fundamentals</li> <li>Chapter 13: Verilog Behavioral and Structural Modeling</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/15-fpga-lab-skills/","title":"FPGA Implementation and Laboratory Skills","text":""},{"location":"chapters/15-fpga-lab-skills/#summary","title":"Summary","text":"<p>This chapter bridges theory and practice by covering FPGA implementation and hands-on laboratory skills. Students will learn FPGA architecture including look-up tables (LUTs), flip-flops, and routing resources, the FPGA implementation flow, and pin assignment. Laboratory skills include breadboard prototyping, using logic probes and logic analyzers, working with LED indicators and switch inputs, and implementing switch debouncing. The chapter covers design verification approaches including functional and timing verification, design hierarchy and reuse principles, documentation practices, and the complete digital system design workflow.</p>"},{"location":"chapters/15-fpga-lab-skills/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>FPGA Architecture</li> <li>FPGA LUT</li> <li>FPGA Flip-Flop</li> <li>FPGA Routing</li> <li>FPGA Implementation</li> <li>Pin Assignment</li> <li>Breadboard Prototyping</li> <li>Logic Probe</li> <li>Logic Analyzer</li> <li>LED Indicator</li> <li>Switch Input</li> <li>Debouncing</li> <li>Design Verification</li> <li>Functional Verification</li> <li>Timing Verification</li> <li>Hardware-Software Boundary</li> <li>Abstraction Levels</li> <li>Design Hierarchy</li> <li>Design Reuse</li> <li>Design Documentation</li> <li>Digital System Design</li> </ol>"},{"location":"chapters/15-fpga-lab-skills/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 8: Flip-Flops and Timing</li> <li>Chapter 10: FSM Design and Applications</li> <li>Chapter 13: Verilog Behavioral and Structural Modeling</li> <li>Chapter 14: Testbenches and Simulation</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"learning-graph/","title":"Learning Graph for Digital Electronics","text":"<p>This section contains the learning graph for this textbook. A learning graph is a graph of concepts used in this textbook. Each concept is represented by a node in a network graph. Concepts are connected by directed edges that indicate what concepts each node depends on before that concept is understood by the student.</p> <p>A learning graph is the foundational data structure for intelligent textbooks that can recommend learning paths. A learning graph is like a roadmap of concepts to help students arrive at their learning goals.</p> <p>At the left of the learning graph are prerequisite or foundational concepts. They have no outbound edges. They only have inbound edges for other concepts that depend on understanding these foundational prerequisite concepts. At the far right we have the most advanced concepts in the course. To master these concepts you must understand all the concepts that they point to.</p>"},{"location":"learning-graph/#learning-graph-statistics","title":"Learning Graph Statistics","text":"<ul> <li>Total Concepts: 300</li> <li>Foundational Concepts: 6</li> <li>Total Dependencies: 526 edges</li> <li>Taxonomy Categories: 11</li> <li>Longest Learning Path: 24 concepts</li> </ul> <p>Here are other files used by the learning graph.</p>"},{"location":"learning-graph/#course-description","title":"Course Description","text":"<p>We use the Course Description as the source document for the concepts that are included in this course. The course description uses the 2001 Bloom taxonomy to order learning objectives.</p>"},{"location":"learning-graph/#list-of-concepts","title":"List of Concepts","text":"<p>We use generative AI to convert the course description into a Concept List. Each concept is in the form of a short Title Case label with most labels under 32 characters long.</p>"},{"location":"learning-graph/#concept-dependency-list","title":"Concept Dependency List","text":"<p>We next use generative AI to create a Directed Acyclic Graph (DAG). DAGs do not have cycles where concepts depend on themselves. We provide the DAG in two formats. One is a CSV file and the other format is a JSON file that uses the vis-network JavaScript library format. The vis-network format uses <code>nodes</code>, <code>edges</code> and <code>metadata</code> elements with edges containing <code>from</code> and <code>to</code> properties. This makes it easy for you to view and edit the learning graph using an editor built with the vis-network tools.</p>"},{"location":"learning-graph/#analysis-documentation","title":"Analysis &amp; Documentation","text":""},{"location":"learning-graph/#course-description-quality-assessment","title":"Course Description Quality Assessment","text":"<p>This report rates the overall quality of the course description for the purpose of generating a learning graph.</p> <ul> <li>Course description fields and content depth analysis</li> <li>Validates course description has sufficient depth for generating 200 concepts</li> <li>Compares course description against similar courses</li> <li>Identifies content gaps and strengths</li> <li>Suggests areas of improvement</li> </ul> <p>View the Course Description Quality Assessment</p>"},{"location":"learning-graph/#learning-graph-quality-validation","title":"Learning Graph Quality Validation","text":"<p>This report gives you an overall assessment of the quality of the learning graph. It uses graph algorithms to look for specific quality patterns in the graph.</p> <ul> <li>Graph structure validation - all concepts are connected</li> <li>DAG validation (no cycles detected)</li> <li>Foundational concepts: 6 entry points</li> <li>Indegree distribution analysis</li> <li>Longest dependency chains</li> <li>Connectivity: all nodes connected to the main cluster</li> </ul> <p>View the Learning Graph Quality Validation</p>"},{"location":"learning-graph/#concept-taxonomy","title":"Concept Taxonomy","text":"<p>In order to see patterns in the learning graph, it is useful to assign colors to each concept based on the concept type. We use generative AI to create about a dozen categories for our concepts and then place each concept into a single primary classifier.</p> <ul> <li>11 taxonomy categories covering digital electronics topics</li> <li>Category organization - foundational elements first, verification and lab skills last</li> <li>Balanced categories (4.7% - 12.3% each)</li> <li>All categories under 30% threshold</li> <li>Pedagogical flow from Boolean algebra through Verilog</li> <li>Clear 3-5 letter abbreviations for use in CSV file</li> </ul> <p>View the Concept Taxonomy</p>"},{"location":"learning-graph/#taxonomy-distribution","title":"Taxonomy Distribution","text":"<p>This reports shows how many concepts fit into each category of the taxonomy. Our goal is a somewhat balanced taxonomy where each category holds an equal number of concepts. We also don't want any category to contain over 30% of our concepts.</p> <ul> <li>Statistical breakdown by category</li> <li>Detailed concept listing by category</li> <li>Visual distribution table</li> <li>Balance verification</li> </ul> <p>View the Taxonomy Distribution Report</p>"},{"location":"learning-graph/concept-list/","title":"Digital Electronics Concept List","text":"<p>This file contains 250 concepts for the Digital Electronics learning graph. Each concept is numbered with a unique ConceptID for use in the dependency graph.</p>"},{"location":"learning-graph/concept-list/#concepts","title":"Concepts","text":"<ol> <li>Binary Number System</li> <li>Decimal to Binary Conversion</li> <li>Binary to Decimal Conversion</li> <li>Hexadecimal Numbers</li> <li>Hex to Binary Conversion</li> <li>Octal Numbers</li> <li>Binary Addition</li> <li>Binary Subtraction</li> <li>Two's Complement</li> <li>Signed Binary Numbers</li> <li>Overflow Detection</li> <li>BCD Encoding</li> <li>Gray Code</li> <li>Weighted Codes</li> <li>Boolean Variable</li> <li>Boolean Constant</li> <li>Boolean Expression</li> <li>Boolean Function</li> <li>Truth Table</li> <li>AND Operation</li> <li>OR Operation</li> <li>NOT Operation</li> <li>Boolean Algebra</li> <li>Identity Law</li> <li>Null Law</li> <li>Idempotent Law</li> <li>Complement Law</li> <li>Commutative Law</li> <li>Associative Law</li> <li>Distributive Law</li> <li>Absorption Law</li> <li>De Morgan's Theorem</li> <li>Dual Expression</li> <li>Consensus Theorem</li> <li>Boolean Proof Technique</li> <li>Logic Gate</li> <li>AND Gate</li> <li>OR Gate</li> <li>NOT Gate</li> <li>Buffer Gate</li> <li>NAND Gate</li> <li>NOR Gate</li> <li>XOR Gate</li> <li>XNOR Gate</li> <li>Gate Symbol</li> <li>IEEE Gate Symbols</li> <li>Functional Completeness</li> <li>Universal Gate</li> <li>NAND-Only Design</li> <li>NOR-Only Design</li> <li>Gate Delay</li> <li>Propagation Delay</li> <li>Rise Time</li> <li>Fall Time</li> <li>Fan-In</li> <li>Fan-Out</li> <li>Logic Levels</li> <li>Noise Margin</li> <li>Voltage Threshold</li> <li>Logic Family</li> <li>TTL Logic</li> <li>CMOS Logic</li> <li>Digital Signal</li> <li>Analog vs Digital</li> <li>Signal Integrity</li> <li>Combinational Logic</li> <li>Sequential Logic</li> <li>Gate-Level Design</li> <li>Boolean to Gates Mapping</li> <li>Multi-Level Logic</li> <li>Two-Level Logic</li> <li>Sum of Products</li> <li>Product of Sums</li> <li>Minterm</li> <li>Maxterm</li> <li>Canonical Form</li> <li>Standard Form</li> <li>Minimal Form</li> <li>Logic Minimization</li> <li>Algebraic Simplification</li> <li>Factoring</li> <li>Common Term Extraction</li> <li>Karnaugh Map</li> <li>K-Map 2 Variable</li> <li>K-Map 3 Variable</li> <li>K-Map 4 Variable</li> <li>K-Map Grouping Rules</li> <li>Adjacent Cells</li> <li>Don't Care Condition</li> <li>Prime Implicant</li> <li>Essential Prime Implicant</li> <li>Implicant Cover</li> <li>Minimal SOP</li> <li>Minimal POS</li> <li>Quine-McCluskey Method</li> <li>Hazard</li> <li>Static Hazard</li> <li>Dynamic Hazard</li> <li>Hazard-Free Design</li> <li>Multiplexer</li> <li>MUX 2-to-1</li> <li>MUX 4-to-1</li> <li>MUX 8-to-1</li> <li>MUX Tree</li> <li>MUX as Logic Function</li> <li>Demultiplexer</li> <li>DEMUX 1-to-4</li> <li>Encoder</li> <li>Decoder</li> <li>2-to-4 Decoder</li> <li>3-to-8 Decoder</li> <li>Decoder Enable</li> <li>Priority Encoder</li> <li>7-Segment Display</li> <li>7-Segment Decoder</li> <li>Binary Comparator</li> <li>Magnitude Comparator</li> <li>Equality Comparator</li> <li>Half Adder</li> <li>Full Adder</li> <li>Carry Bit</li> <li>Sum Bit</li> <li>Ripple Carry Adder</li> <li>Carry Propagation Delay</li> <li>Carry Lookahead Concept</li> <li>Adder Subtractor</li> <li>Overflow in Addition</li> <li>ALU Concept</li> <li>Parity Bit</li> <li>Parity Generator</li> <li>Parity Checker</li> <li>Error Detection</li> <li>Tri-State Buffer</li> <li>Bus Architecture</li> <li>Memory Element</li> <li>State Concept</li> <li>Feedback Loop</li> <li>Bistable Element</li> <li>SR Latch</li> <li>SR Latch Truth Table</li> <li>Invalid State Problem</li> <li>Gated SR Latch</li> <li>D Latch</li> <li>Level Sensitive</li> <li>Transparent Latch</li> <li>Latch Timing Problem</li> <li>Race Condition</li> <li>Clock Signal</li> <li>Clock Edge</li> <li>Rising Edge</li> <li>Falling Edge</li> <li>Clock Period</li> <li>Clock Frequency</li> <li>Duty Cycle</li> <li>D Flip-Flop</li> <li>Edge Triggered</li> <li>Positive Edge Triggered</li> <li>Negative Edge Triggered</li> <li>Master-Slave Flip-Flop</li> <li>JK Flip-Flop</li> <li>JK Toggle Mode</li> <li>T Flip-Flop</li> <li>Flip-Flop Symbol</li> <li>Preset Input</li> <li>Clear Input</li> <li>Asynchronous Reset</li> <li>Synchronous Reset</li> <li>Setup Time</li> <li>Hold Time</li> <li>Clock-to-Q Delay</li> <li>Timing Diagram</li> <li>Timing Constraint</li> <li>Timing Violation</li> <li>Metastability</li> <li>MTBF Concept</li> <li>Synchronous System</li> <li>Asynchronous Input</li> <li>Synchronizer Circuit</li> <li>Double Flop Synchronizer</li> <li>Finite State Machine</li> <li>FSM State</li> <li>State Transition</li> <li>Current State</li> <li>Next State</li> <li>Next State Logic</li> <li>Output Logic</li> <li>Moore Machine</li> <li>Moore Output</li> <li>Mealy Machine</li> <li>Mealy Output</li> <li>State Diagram</li> <li>State Diagram Notation</li> <li>State Table</li> <li>State Encoding</li> <li>Binary Encoding</li> <li>One-Hot Encoding</li> <li>Gray Code Encoding</li> <li>State Assignment</li> <li>State Minimization</li> <li>Next State Equation</li> <li>Output Equation</li> <li>FSM Design Process</li> <li>FSM Verification</li> <li>Sequence Detector</li> <li>Pattern Recognition FSM</li> <li>Overlapping Detection</li> <li>Non-Overlapping Detection</li> <li>Traffic Light Controller</li> <li>Vending Machine FSM</li> <li>Counter</li> <li>Up Counter</li> <li>Down Counter</li> <li>Up-Down Counter</li> <li>Mod-N Counter</li> <li>Binary Counter</li> <li>BCD Counter</li> <li>Decade Counter</li> <li>Ring Counter</li> <li>Johnson Counter</li> <li>Counter State Diagram</li> <li>Counter Overflow</li> <li>Register</li> <li>Parallel Load Register</li> <li>Shift Register</li> <li>Serial In Serial Out</li> <li>Serial In Parallel Out</li> <li>Parallel In Serial Out</li> <li>Parallel In Parallel Out</li> <li>Bidirectional Shift</li> <li>Universal Shift Register</li> <li>Enable Signal</li> <li>Load Signal</li> <li>Clear Signal</li> <li>Register File</li> <li>Datapath Concept</li> <li>Control Unit</li> <li>Register Transfer Level</li> <li>RTL Notation</li> <li>Verilog HDL</li> <li>HDL vs Programming</li> <li>Module Definition</li> <li>Port Declaration</li> <li>Input Port</li> <li>Output Port</li> <li>Inout Port</li> <li>Wire Data Type</li> <li>Reg Data Type</li> <li>Parameter</li> <li>Assign Statement</li> <li>Continuous Assignment</li> <li>Always Block</li> <li>Sensitivity List</li> <li>Blocking Assignment</li> <li>Non-Blocking Assignment</li> <li>If-Else in Verilog</li> <li>Case Statement</li> <li>Combinational Always</li> <li>Sequential Always</li> <li>Posedge Keyword</li> <li>Negedge Keyword</li> <li>Initial Block</li> <li>Structural Modeling</li> <li>Behavioral Modeling</li> <li>Gate-Level Verilog</li> <li>RTL Verilog</li> <li>Module Instantiation</li> <li>Hierarchical Design</li> <li>Testbench</li> <li>Stimulus Generation</li> <li>Clock Generation</li> <li>Test Vector</li> <li>Self-Checking Testbench</li> <li>Simulation</li> <li>Simulation Time</li> <li>Waveform Viewer</li> <li>Debugging Waveforms</li> <li>Synthesis</li> <li>Synthesizable Code</li> <li>Non-Synthesizable Code</li> <li>FPGA Architecture</li> <li>FPGA LUT</li> <li>FPGA Flip-Flop</li> <li>FPGA Routing</li> <li>FPGA Implementation</li> <li>Pin Assignment</li> <li>Breadboard Prototyping</li> <li>Logic Probe</li> <li>Logic Analyzer</li> <li>LED Indicator</li> <li>Switch Input</li> <li>Debouncing</li> <li>Design Verification</li> <li>Functional Verification</li> <li>Timing Verification</li> <li>Hardware-Software Boundary</li> <li>Abstraction Levels</li> <li>Design Hierarchy</li> <li>Design Reuse</li> <li>Design Documentation</li> <li>Digital System Design</li> </ol>"},{"location":"learning-graph/concept-taxonomy/","title":"Digital Electronics Concept Taxonomy","text":"<p>This taxonomy organizes the 300 concepts into 12 categories for visualization and navigation.</p>"},{"location":"learning-graph/concept-taxonomy/#categories","title":"Categories","text":"TaxonomyID Category Name Description FOUND Foundation Concepts Prerequisites and fundamental ideas needed before starting the course NUMSYS Number Systems Binary, hexadecimal, octal, and encoding schemes BOOL Boolean Algebra Boolean operations, laws, theorems, and simplification GATES Logic Gates Primitive gates, properties, symbols, and characteristics COMB Combinational Logic Combinational circuit design, canonical forms, and K-maps BLOCKS Building Blocks Standard combinational modules (MUX, decoders, adders) SEQ Sequential Basics Latches, memory elements, and feedback concepts FLIPFLOP Flip-Flops Edge-triggered storage, timing, and flip-flop types FSM Finite State Machines State machines, encoding, design process, and applications REG Registers &amp; Counters Registers, shift registers, counters, and datapath HDL Verilog HDL Hardware description language syntax and modeling VERIFY Verification &amp; Lab Simulation, FPGA, testing, and laboratory skills"},{"location":"learning-graph/concept-taxonomy/#category-descriptions","title":"Category Descriptions","text":""},{"location":"learning-graph/concept-taxonomy/#found-foundation-concepts","title":"FOUND - Foundation Concepts","text":"<p>Concepts that form the absolute foundation, typically prerequisite knowledge or standalone concepts that anchor the learning graph.</p>"},{"location":"learning-graph/concept-taxonomy/#numsys-number-systems","title":"NUMSYS - Number Systems","text":"<p>Binary arithmetic, number representations, conversions, and special encoding schemes like BCD and Gray code.</p>"},{"location":"learning-graph/concept-taxonomy/#bool-boolean-algebra","title":"BOOL - Boolean Algebra","text":"<p>Boolean variables, operations, expressions, functions, truth tables, and all Boolean algebra laws including De Morgan's theorem.</p>"},{"location":"learning-graph/concept-taxonomy/#gates-logic-gates","title":"GATES - Logic Gates","text":"<p>All primitive logic gates (AND, OR, NOT, NAND, NOR, XOR, XNOR), their symbols, properties like delay, fan-in/fan-out, and logic levels.</p>"},{"location":"learning-graph/concept-taxonomy/#comb-combinational-logic","title":"COMB - Combinational Logic","text":"<p>Combinational circuit design methodology including SOP/POS forms, minterms, maxterms, K-maps, and logic minimization.</p>"},{"location":"learning-graph/concept-taxonomy/#blocks-building-blocks","title":"BLOCKS - Building Blocks","text":"<p>Standard combinational building blocks: multiplexers, demultiplexers, encoders, decoders, comparators, adders, and ALU concepts.</p>"},{"location":"learning-graph/concept-taxonomy/#seq-sequential-basics","title":"SEQ - Sequential Basics","text":"<p>Introduction to sequential logic: memory elements, state concept, feedback, latches (SR, D), and clock signals.</p>"},{"location":"learning-graph/concept-taxonomy/#flipflop-flip-flops","title":"FLIPFLOP - Flip-Flops","text":"<p>Edge-triggered flip-flops (D, JK, T), timing parameters (setup, hold, clock-to-Q), metastability, and synchronization.</p>"},{"location":"learning-graph/concept-taxonomy/#fsm-finite-state-machines","title":"FSM - Finite State Machines","text":"<p>Moore and Mealy machines, state diagrams, state tables, encoding methods, design process, and FSM applications.</p>"},{"location":"learning-graph/concept-taxonomy/#reg-registers-counters","title":"REG - Registers &amp; Counters","text":"<p>Registers, shift registers, counters (up/down, ring, Johnson), datapath concepts, and register transfer level.</p>"},{"location":"learning-graph/concept-taxonomy/#hdl-verilog-hdl","title":"HDL - Verilog HDL","text":"<p>Verilog language constructs: modules, ports, data types, assignments, always blocks, modeling styles, and hierarchy.</p>"},{"location":"learning-graph/concept-taxonomy/#verify-verification-lab","title":"VERIFY - Verification &amp; Lab","text":"<p>Testbenches, simulation, waveforms, synthesis, FPGA implementation, and laboratory/prototyping skills.</p>"},{"location":"learning-graph/course-description-assessment/","title":"Course Description Quality Assessment","text":"<p>Course: Digital Electronics Assessment Date: 2026-01-30 Quality Score: 91/100</p>"},{"location":"learning-graph/course-description-assessment/#scoring-breakdown","title":"Scoring Breakdown","text":"Element Points Max Assessment Title 5 5 \"Digital Electronics\" - clear and descriptive Target Audience 5 5 College students majoring in EE or computer-related fields Prerequisites 5 5 Calculus 1 clearly stated Main Topics Covered 10 10 Comprehensive 12 topics from Boolean algebra to verification Topics Excluded 5 5 Clear boundaries (no CMOS, no async, no timing closure, no CPU pipelines) Learning Outcomes Header 5 5 Clear \"After completing this course, students will be able to:\" Remember Level 9 10 5 specific outcomes with appropriate verbs Understand Level 10 10 6 specific outcomes covering key concepts Apply Level 10 10 6 specific outcomes for practical skills Analyze Level 9 10 5 specific outcomes for analytical skills Evaluate Level 9 10 5 specific outcomes for judgment skills Create Level 9 10 5 specific outcomes including capstone activities Descriptive Context 5 5 Excellent context about course importance as a \"pivot course\" <p>Total: 91/100</p>"},{"location":"learning-graph/course-description-assessment/#strengths","title":"Strengths","text":"<ul> <li>Excellent topic breadth and depth covering 12 major areas</li> <li>Clear prerequisites and audience definition</li> <li>Strong pedagogical narrative explaining why topics matter</li> <li>Good exclusion boundaries defining what is NOT covered</li> <li>Complete Bloom's Taxonomy coverage with specific, actionable outcomes</li> <li>Well-organized progression from foundations to advanced topics</li> </ul>"},{"location":"learning-graph/course-description-assessment/#estimated-concept-count","title":"Estimated Concept Count","text":"<p>Based on the course description, approximately 180-200 distinct concepts can be derived:</p> <ul> <li>Boolean Algebra &amp; Binary Logic: ~25 concepts</li> <li>Logic Gates &amp; Gate-Level Modeling: ~20 concepts</li> <li>Combinational Logic Design: ~25 concepts</li> <li>Logic Simplification &amp; Optimization: ~20 concepts</li> <li>Sequential Logic Introduction: ~15 concepts</li> <li>Flip-Flops &amp; Clocked Storage: ~15 concepts</li> <li>Synchronous Sequential Logic: ~25 concepts</li> <li>Registers, Counters, Datapath: ~15 concepts</li> <li>Verilog HDL Modeling: ~20 concepts</li> <li>Design, Simulation, Verification: ~10 concepts</li> <li>Laboratory Skills: ~10 concepts</li> </ul>"},{"location":"learning-graph/course-description-assessment/#comparison-with-similar-courses","title":"Comparison with Similar Courses","text":"<p>This course description is comparable to standard ABET-aligned EE digital electronics courses at:</p> <ul> <li>University-level EE 2xxx courses</li> <li>IEEE/ACM computer engineering curricula</li> <li>Similar in scope to classic textbooks (Mano, Wakerly, Katz)</li> </ul>"},{"location":"learning-graph/course-description-assessment/#recommendation","title":"Recommendation","text":"<p>\u2705 APPROVED - The quality score of 91 exceeds the 70-point threshold. This course description provides sufficient depth and breadth to generate a high-quality learning graph with 200 concepts.</p>"},{"location":"learning-graph/quality-metrics/","title":"Learning Graph Quality Metrics Report","text":""},{"location":"learning-graph/quality-metrics/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 300</li> <li>Foundational Concepts (no dependencies): 6</li> <li>Concepts with Dependencies: 294</li> <li>Average Dependencies per Concept: 1.79</li> </ul>"},{"location":"learning-graph/quality-metrics/#graph-structure-validation","title":"Graph Structure Validation","text":"<ul> <li>Valid DAG Structure: \u274c No</li> <li>Self-Dependencies: None detected \u2705</li> <li>Cycles Detected: 0</li> </ul>"},{"location":"learning-graph/quality-metrics/#foundational-concepts","title":"Foundational Concepts","text":"<p>These concepts have no prerequisites:</p> <ul> <li>1: Binary Number System</li> <li>15: Boolean Variable</li> <li>114: 7-Segment Display</li> <li>148: Clock Signal</li> <li>239: Verilog HDL</li> <li>280: FPGA Architecture</li> </ul>"},{"location":"learning-graph/quality-metrics/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<ul> <li>Maximum Dependency Chain Length: 24</li> </ul>"},{"location":"learning-graph/quality-metrics/#longest-learning-path","title":"Longest Learning Path:","text":"<ol> <li>Boolean Variable (ID: 15)</li> <li>Boolean Constant (ID: 16)</li> <li>Boolean Expression (ID: 17)</li> <li>Boolean Function (ID: 18)</li> <li>Truth Table (ID: 19)</li> <li>Logic Gate (ID: 36)</li> <li>Combinational Logic (ID: 66)</li> <li>Memory Element (ID: 135)</li> <li>Feedback Loop (ID: 137)</li> <li>Bistable Element (ID: 138)</li> <li>SR Latch (ID: 139)</li> <li>Gated SR Latch (ID: 142)</li> <li>D Latch (ID: 143)</li> <li>D Flip-Flop (ID: 155)</li> <li>Finite State Machine (ID: 180)</li> <li>FSM State (ID: 181)</li> <li>State Transition (ID: 182)</li> <li>Next State (ID: 184)</li> <li>Next State Logic (ID: 185)</li> <li>Next State Equation (ID: 200)</li> <li>FSM Design Process (ID: 202)</li> <li>Sequence Detector (ID: 204)</li> <li>Overlapping Detection (ID: 206)</li> <li>Non-Overlapping Detection (ID: 207)</li> </ol>"},{"location":"learning-graph/quality-metrics/#orphaned-nodes-analysis","title":"Orphaned Nodes Analysis","text":"<ul> <li>Total Orphaned Nodes: 101</li> </ul> <p>Concepts that are not prerequisites for any other concept:</p> <ul> <li>2: Decimal to Binary Conversion</li> <li>5: Hex to Binary Conversion</li> <li>6: Octal Numbers</li> <li>14: Weighted Codes</li> <li>33: Dual Expression</li> <li>34: Consensus Theorem</li> <li>46: IEEE Gate Symbols</li> <li>49: NAND-Only Design</li> <li>50: NOR-Only Design</li> <li>53: Rise Time</li> <li>54: Fall Time</li> <li>55: Fan-In</li> <li>56: Fan-Out</li> <li>59: Voltage Threshold</li> <li>61: TTL Logic</li> <li>62: CMOS Logic</li> <li>64: Analog vs Digital</li> <li>65: Signal Integrity</li> <li>70: Multi-Level Logic</li> <li>78: Minimal Form</li> </ul> <p>...and 81 more</p>"},{"location":"learning-graph/quality-metrics/#connected-components","title":"Connected Components","text":"<ul> <li>Number of Connected Components: 1</li> </ul> <p>\u2705 All concepts are connected in a single graph.</p>"},{"location":"learning-graph/quality-metrics/#indegree-analysis","title":"Indegree Analysis","text":"<p>Top 10 concepts that are prerequisites for the most other concepts:</p> Rank Concept ID Concept Label Indegree 1 36 Logic Gate 19 2 66 Combinational Logic 17 3 155 D Flip-Flop 17 4 1 Binary Number System 16 5 23 Boolean Algebra 13 6 239 Verilog HDL 13 7 180 Finite State Machine 10 8 17 Boolean Expression 8 9 251 Always Block 8 10 19 Truth Table 7"},{"location":"learning-graph/quality-metrics/#outdegree-distribution","title":"Outdegree Distribution","text":"Dependencies Number of Concepts 0 6 1 112 2 147 3 27 4 6 5 1 10 1"},{"location":"learning-graph/quality-metrics/#recommendations","title":"Recommendations","text":"<ul> <li>\u26a0\ufe0f Many orphaned nodes (101): Consider if these should be prerequisites for advanced concepts</li> <li>\u2139\ufe0f Long dependency chains (24): Ensure students can follow extended learning paths</li> </ul> <p>Report generated by learning-graph-reports/analyze_graph.py</p>"},{"location":"learning-graph/taxonomy-distribution/","title":"Taxonomy Distribution Report","text":""},{"location":"learning-graph/taxonomy-distribution/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 300</li> <li>Number of Taxonomies: 11</li> <li>Average Concepts per Taxonomy: 27.3</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#distribution-summary","title":"Distribution Summary","text":"Category TaxonomyID Count Percentage Status Building Blocks BLOCKS 35 11.7% \u2705 Combinational Logic COMB 34 11.3% \u2705 Verification &amp; Lab VERIFY 33 11.0% \u2705 Logic Gates GATES 30 10.0% \u2705 Finite State Machines FSM 30 10.0% \u2705 Registers &amp; Counters REG 29 9.7% \u2705 Verilog HDL HDL 29 9.7% \u2705 Flip-Flops FLIPFLOP 25 8.3% \u2705 Boolean Algebra BOOL 21 7.0% \u2705 Sequential Basics SEQ 20 6.7% \u2705 Number Systems NUMSYS 14 4.7% \u2705"},{"location":"learning-graph/taxonomy-distribution/#visual-distribution","title":"Visual Distribution","text":"<pre><code>BLOCKS \u2588\u2588\u2588\u2588\u2588  35 ( 11.7%)\nCOMB   \u2588\u2588\u2588\u2588\u2588  34 ( 11.3%)\nVERIFY \u2588\u2588\u2588\u2588\u2588  33 ( 11.0%)\nGATES  \u2588\u2588\u2588\u2588\u2588  30 ( 10.0%)\nFSM    \u2588\u2588\u2588\u2588\u2588  30 ( 10.0%)\nREG    \u2588\u2588\u2588\u2588  29 (  9.7%)\nHDL    \u2588\u2588\u2588\u2588  29 (  9.7%)\nFLIPFLOP \u2588\u2588\u2588\u2588  25 (  8.3%)\nBOOL   \u2588\u2588\u2588  21 (  7.0%)\nSEQ    \u2588\u2588\u2588  20 (  6.7%)\nNUMSYS \u2588\u2588  14 (  4.7%)\n</code></pre>"},{"location":"learning-graph/taxonomy-distribution/#balance-analysis","title":"Balance Analysis","text":""},{"location":"learning-graph/taxonomy-distribution/#no-over-represented-categories","title":"\u2705 No Over-Represented Categories","text":"<p>All categories are under the 30% threshold. Good balance!</p>"},{"location":"learning-graph/taxonomy-distribution/#category-details","title":"Category Details","text":""},{"location":"learning-graph/taxonomy-distribution/#building-blocks-blocks","title":"Building Blocks (BLOCKS)","text":"<p>Count: 35 concepts (11.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Multiplexer</li> </ol> </li> <li> <ol> <li>MUX 2-to-1</li> </ol> </li> <li> <ol> <li>MUX 4-to-1</li> </ol> </li> <li> <ol> <li>MUX 8-to-1</li> </ol> </li> <li> <ol> <li>MUX Tree</li> </ol> </li> <li> <ol> <li>MUX as Logic Function</li> </ol> </li> <li> <ol> <li>Demultiplexer</li> </ol> </li> <li> <ol> <li>DEMUX 1-to-4</li> </ol> </li> <li> <ol> <li>Encoder</li> </ol> </li> <li> <ol> <li>Decoder</li> </ol> </li> <li> <ol> <li>2-to-4 Decoder</li> </ol> </li> <li> <ol> <li>3-to-8 Decoder</li> </ol> </li> <li> <ol> <li>Decoder Enable</li> </ol> </li> <li> <ol> <li>Priority Encoder</li> </ol> </li> <li> <ol> <li>7-Segment Display</li> </ol> </li> <li>...and 20 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#combinational-logic-comb","title":"Combinational Logic (COMB)","text":"<p>Count: 34 concepts (11.3%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Combinational Logic</li> </ol> </li> <li> <ol> <li>Sequential Logic</li> </ol> </li> <li> <ol> <li>Gate-Level Design</li> </ol> </li> <li> <ol> <li>Boolean to Gates Mapping</li> </ol> </li> <li> <ol> <li>Multi-Level Logic</li> </ol> </li> <li> <ol> <li>Two-Level Logic</li> </ol> </li> <li> <ol> <li>Sum of Products</li> </ol> </li> <li> <ol> <li>Product of Sums</li> </ol> </li> <li> <ol> <li>Minterm</li> </ol> </li> <li> <ol> <li>Maxterm</li> </ol> </li> <li> <ol> <li>Canonical Form</li> </ol> </li> <li> <ol> <li>Standard Form</li> </ol> </li> <li> <ol> <li>Minimal Form</li> </ol> </li> <li> <ol> <li>Logic Minimization</li> </ol> </li> <li> <ol> <li>Algebraic Simplification</li> </ol> </li> <li>...and 19 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#verification-lab-verify","title":"Verification &amp; Lab (VERIFY)","text":"<p>Count: 33 concepts (11.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Testbench</li> </ol> </li> <li> <ol> <li>Stimulus Generation</li> </ol> </li> <li> <ol> <li>Clock Generation</li> </ol> </li> <li> <ol> <li>Test Vector</li> </ol> </li> <li> <ol> <li>Self-Checking Testbench</li> </ol> </li> <li> <ol> <li>Simulation</li> </ol> </li> <li> <ol> <li>Simulation Time</li> </ol> </li> <li> <ol> <li>Waveform Viewer</li> </ol> </li> <li> <ol> <li>Debugging Waveforms</li> </ol> </li> <li> <ol> <li>Synthesis</li> </ol> </li> <li> <ol> <li>Synthesizable Code</li> </ol> </li> <li> <ol> <li>Non-Synthesizable Code</li> </ol> </li> <li> <ol> <li>FPGA Architecture</li> </ol> </li> <li> <ol> <li>FPGA LUT</li> </ol> </li> <li> <ol> <li>FPGA Flip-Flop</li> </ol> </li> <li>...and 18 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#logic-gates-gates","title":"Logic Gates (GATES)","text":"<p>Count: 30 concepts (10.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Logic Gate</li> </ol> </li> <li> <ol> <li>AND Gate</li> </ol> </li> <li> <ol> <li>OR Gate</li> </ol> </li> <li> <ol> <li>NOT Gate</li> </ol> </li> <li> <ol> <li>Buffer Gate</li> </ol> </li> <li> <ol> <li>NAND Gate</li> </ol> </li> <li> <ol> <li>NOR Gate</li> </ol> </li> <li> <ol> <li>XOR Gate</li> </ol> </li> <li> <ol> <li>XNOR Gate</li> </ol> </li> <li> <ol> <li>Gate Symbol</li> </ol> </li> <li> <ol> <li>IEEE Gate Symbols</li> </ol> </li> <li> <ol> <li>Functional Completeness</li> </ol> </li> <li> <ol> <li>Universal Gate</li> </ol> </li> <li> <ol> <li>NAND-Only Design</li> </ol> </li> <li> <ol> <li>NOR-Only Design</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#finite-state-machines-fsm","title":"Finite State Machines (FSM)","text":"<p>Count: 30 concepts (10.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Finite State Machine</li> </ol> </li> <li> <ol> <li>FSM State</li> </ol> </li> <li> <ol> <li>State Transition</li> </ol> </li> <li> <ol> <li>Current State</li> </ol> </li> <li> <ol> <li>Next State</li> </ol> </li> <li> <ol> <li>Next State Logic</li> </ol> </li> <li> <ol> <li>Output Logic</li> </ol> </li> <li> <ol> <li>Moore Machine</li> </ol> </li> <li> <ol> <li>Moore Output</li> </ol> </li> <li> <ol> <li>Mealy Machine</li> </ol> </li> <li> <ol> <li>Mealy Output</li> </ol> </li> <li> <ol> <li>State Diagram</li> </ol> </li> <li> <ol> <li>State Diagram Notation</li> </ol> </li> <li> <ol> <li>State Table</li> </ol> </li> <li> <ol> <li>State Encoding</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#registers-counters-reg","title":"Registers &amp; Counters (REG)","text":"<p>Count: 29 concepts (9.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Counter</li> </ol> </li> <li> <ol> <li>Up Counter</li> </ol> </li> <li> <ol> <li>Down Counter</li> </ol> </li> <li> <ol> <li>Up-Down Counter</li> </ol> </li> <li> <ol> <li>Mod-N Counter</li> </ol> </li> <li> <ol> <li>Binary Counter</li> </ol> </li> <li> <ol> <li>BCD Counter</li> </ol> </li> <li> <ol> <li>Decade Counter</li> </ol> </li> <li> <ol> <li>Ring Counter</li> </ol> </li> <li> <ol> <li>Johnson Counter</li> </ol> </li> <li> <ol> <li>Counter State Diagram</li> </ol> </li> <li> <ol> <li>Counter Overflow</li> </ol> </li> <li> <ol> <li>Register</li> </ol> </li> <li> <ol> <li>Parallel Load Register</li> </ol> </li> <li> <ol> <li>Shift Register</li> </ol> </li> <li>...and 14 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#verilog-hdl-hdl","title":"Verilog HDL (HDL)","text":"<p>Count: 29 concepts (9.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Verilog HDL</li> </ol> </li> <li> <ol> <li>HDL vs Programming</li> </ol> </li> <li> <ol> <li>Module Definition</li> </ol> </li> <li> <ol> <li>Port Declaration</li> </ol> </li> <li> <ol> <li>Input Port</li> </ol> </li> <li> <ol> <li>Output Port</li> </ol> </li> <li> <ol> <li>Inout Port</li> </ol> </li> <li> <ol> <li>Wire Data Type</li> </ol> </li> <li> <ol> <li>Reg Data Type</li> </ol> </li> <li> <ol> <li>Parameter</li> </ol> </li> <li> <ol> <li>Assign Statement</li> </ol> </li> <li> <ol> <li>Continuous Assignment</li> </ol> </li> <li> <ol> <li>Always Block</li> </ol> </li> <li> <ol> <li>Sensitivity List</li> </ol> </li> <li> <ol> <li>Blocking Assignment</li> </ol> </li> <li>...and 14 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#flip-flops-flipflop","title":"Flip-Flops (FLIPFLOP)","text":"<p>Count: 25 concepts (8.3%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>D Flip-Flop</li> </ol> </li> <li> <ol> <li>Edge Triggered</li> </ol> </li> <li> <ol> <li>Positive Edge Triggered</li> </ol> </li> <li> <ol> <li>Negative Edge Triggered</li> </ol> </li> <li> <ol> <li>Master-Slave Flip-Flop</li> </ol> </li> <li> <ol> <li>JK Flip-Flop</li> </ol> </li> <li> <ol> <li>JK Toggle Mode</li> </ol> </li> <li> <ol> <li>T Flip-Flop</li> </ol> </li> <li> <ol> <li>Flip-Flop Symbol</li> </ol> </li> <li> <ol> <li>Preset Input</li> </ol> </li> <li> <ol> <li>Clear Input</li> </ol> </li> <li> <ol> <li>Asynchronous Reset</li> </ol> </li> <li> <ol> <li>Synchronous Reset</li> </ol> </li> <li> <ol> <li>Setup Time</li> </ol> </li> <li> <ol> <li>Hold Time</li> </ol> </li> <li>...and 10 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#boolean-algebra-bool","title":"Boolean Algebra (BOOL)","text":"<p>Count: 21 concepts (7.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Boolean Variable</li> </ol> </li> <li> <ol> <li>Boolean Constant</li> </ol> </li> <li> <ol> <li>Boolean Expression</li> </ol> </li> <li> <ol> <li>Boolean Function</li> </ol> </li> <li> <ol> <li>Truth Table</li> </ol> </li> <li> <ol> <li>AND Operation</li> </ol> </li> <li> <ol> <li>OR Operation</li> </ol> </li> <li> <ol> <li>NOT Operation</li> </ol> </li> <li> <ol> <li>Boolean Algebra</li> </ol> </li> <li> <ol> <li>Identity Law</li> </ol> </li> <li> <ol> <li>Null Law</li> </ol> </li> <li> <ol> <li>Idempotent Law</li> </ol> </li> <li> <ol> <li>Complement Law</li> </ol> </li> <li> <ol> <li>Commutative Law</li> </ol> </li> <li> <ol> <li>Associative Law</li> </ol> </li> <li>...and 6 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#sequential-basics-seq","title":"Sequential Basics (SEQ)","text":"<p>Count: 20 concepts (6.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Memory Element</li> </ol> </li> <li> <ol> <li>State Concept</li> </ol> </li> <li> <ol> <li>Feedback Loop</li> </ol> </li> <li> <ol> <li>Bistable Element</li> </ol> </li> <li> <ol> <li>SR Latch</li> </ol> </li> <li> <ol> <li>SR Latch Truth Table</li> </ol> </li> <li> <ol> <li>Invalid State Problem</li> </ol> </li> <li> <ol> <li>Gated SR Latch</li> </ol> </li> <li> <ol> <li>D Latch</li> </ol> </li> <li> <ol> <li>Level Sensitive</li> </ol> </li> <li> <ol> <li>Transparent Latch</li> </ol> </li> <li> <ol> <li>Latch Timing Problem</li> </ol> </li> <li> <ol> <li>Race Condition</li> </ol> </li> <li> <ol> <li>Clock Signal</li> </ol> </li> <li> <ol> <li>Clock Edge</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#number-systems-numsys","title":"Number Systems (NUMSYS)","text":"<p>Count: 14 concepts (4.7%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Binary Number System</li> </ol> </li> <li> <ol> <li>Decimal to Binary Conversion</li> </ol> </li> <li> <ol> <li>Binary to Decimal Conversion</li> </ol> </li> <li> <ol> <li>Hexadecimal Numbers</li> </ol> </li> <li> <ol> <li>Hex to Binary Conversion</li> </ol> </li> <li> <ol> <li>Octal Numbers</li> </ol> </li> <li> <ol> <li>Binary Addition</li> </ol> </li> <li> <ol> <li>Binary Subtraction</li> </ol> </li> <li> <ol> <li>Two's Complement</li> </ol> </li> <li> <ol> <li>Signed Binary Numbers</li> </ol> </li> <li> <ol> <li>Overflow Detection</li> </ol> </li> <li> <ol> <li>BCD Encoding</li> </ol> </li> <li> <ol> <li>Gray Code</li> </ol> </li> <li> <ol> <li>Weighted Codes</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recommendations","title":"Recommendations","text":"<ul> <li>\u2705 Excellent balance: Categories are evenly distributed (spread: 7.0%)</li> <li>\u2705 MISC category minimal: Good categorization specificity</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#educational-use-recommendations","title":"Educational Use Recommendations","text":"<ul> <li>Use taxonomy categories for color-coding in graph visualizations</li> <li>Design curriculum modules based on taxonomy groupings</li> <li>Create filtered views for focused learning paths</li> <li>Use categories for assessment organization</li> <li>Enable navigation by topic area in interactive tools</li> </ul> <p>Report generated by learning-graph-reports/taxonomy_distribution.py</p>"},{"location":"lessons/logic-gates/","title":"Logic Gates","text":""},{"location":"sims/","title":"Digital Electronics Simulations","text":"<p>These simulations all use a common library of simple electronic logic gates.</p>"},{"location":"sims/#logic-gates","title":"Logic Gates","text":"<p>Logic Gate Library</p>"},{"location":"sims/#flip-flop","title":"Flip Flop","text":"<p>Flip Flop</p>"},{"location":"sims/flip-flop/","title":"Flip Flop MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/flip-flop/main.html\" width=\"100%\" height=\"450px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Flip Flop MicroSim in Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/flip-flop/#description","title":"Description","text":"<p>This interactive simulation demonstrates the behavior of an SR (Set-Reset) flip-flop, one of the fundamental building blocks of digital memory. The flip-flop is constructed using NAND gates, showing how simple logic gates can be combined to create circuits that \"remember\" their state.</p>"},{"location":"sims/flip-flop/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of NAND gate connections</li> <li>Interactive Set and Reset inputs</li> <li>Real-time display of Q and Q' (not Q) outputs</li> <li>Animation of signal propagation through the circuit</li> </ul>"},{"location":"sims/flip-flop/#how-to-use","title":"How to Use","text":"<ol> <li>Click the Set button to set the flip-flop output Q to 1</li> <li>Click the Reset button to reset the flip-flop output Q to 0</li> <li>Observe how the outputs maintain their state after the input returns to its default value</li> <li>Notice the cross-coupled feedback that enables the memory function</li> </ol>"},{"location":"sims/flip-flop/#challenges","title":"Challenges","text":"<p>Explaining electronic components like flip-flops through animation can be challenging due to several reasons:</p> <ol> <li> <p>Abstract Concepts: Flip-flops are digital logic circuits used in electronics and computing. They store and manipulate binary data (0s and 1s). The concepts involved in how they work\u2014like logic gates, binary states, clock signals, and data storage\u2014are abstract and not directly observable, making them hard to represent visually.</p> </li> <li> <p>Complex Functionality: Flip-flops have different types (like SR, JK, D, and T flip-flops) and each type has its unique mode of operation. This complexity can be difficult to condense into a simplified animation without losing essential details.</p> </li> <li> <p>Timing and Synchronization: Flip-flops often operate based on clock signals, and their behavior is dependent on the timing of these signals. Accurately depicting timing and synchronization in an animation can be challenging, as it requires precise representation of these temporal aspects.</p> </li> <li> <p>Scale and Interaction with Other Components: Flip-flops are usually part of larger electronic systems. Showing how they interact with other components in a system (like processors or memory units) within the limited scope of an animation can be difficult, as it might require a broader context that is hard to visualize succinctly.</p> </li> <li> <p>Viewer Background Knowledge: Understanding the operation of flip-flops often requires a background in electronics or computer science. Animations need to be designed considering the viewer's prior knowledge, which can vary widely, making it hard to create a one-size-fits-all explanation.</p> </li> <li> <p>Visual Simplicity vs. Technical Accuracy: Striking the right balance between simplicity for easier understanding and technical accuracy for correctness is a major challenge. Over-simplification can lead to misconceptions, while too much detail can overwhelm the viewer.</p> </li> </ol> <p>To effectively use animation for explaining flip-flops, it's essential to focus on clear, step-by-step visual representations, using metaphor or analogy where possible, and providing sufficient explanatory context to make the abstract concepts more relatable.</p>"},{"location":"sims/flip-flop/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/flip-flop/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Explain how NAND gates can be combined to create a flip-flop circuit</li> <li>Describe the difference between Set and Reset operations</li> <li>Demonstrate understanding of how flip-flops store binary data</li> <li>Identify the forbidden state in an SR flip-flop and explain why it should be avoided</li> </ul>"},{"location":"sims/flip-flop/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics students</li> <li>College students in introductory digital electronics courses</li> <li>Prerequisites: Basic understanding of logic gates (AND, OR, NOT, NAND)</li> </ul>"},{"location":"sims/flip-flop/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Allow students to freely interact with the simulation, observing how Set and Reset inputs affect the outputs.</p> </li> <li> <p>Guided Investigation: Have students create a truth table for the SR flip-flop by testing all input combinations and recording the outputs.</p> </li> <li> <p>Extension Activity: Discuss how multiple flip-flops can be connected to create registers and counters, leading into the shift register simulation.</p> </li> </ol>"},{"location":"sims/flip-flop/#assessment","title":"Assessment","text":"<ul> <li>What happens when both Set and Reset are activated simultaneously?</li> <li>Why is the flip-flop called a \"memory\" element?</li> <li>Draw the circuit diagram of an SR flip-flop using NAND gates.</li> </ul>"},{"location":"sims/flip-flop/#references","title":"References","text":"<ul> <li>Falstad Flip-Flop Simulator - Interactive circuit simulator with flip-flop examples</li> <li>Wikipedia: Flip-flop (electronics) - Comprehensive overview of flip-flop types and applications</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> </ul>"},{"location":"sims/graph-viewer/","title":"Learning Graph Viewer","text":"<p>This interactive viewer allows you to explore the learning graph for the Digital Electronics course.</p>"},{"location":"sims/graph-viewer/#features","title":"Features","text":"<ul> <li>Search: Type in the search box to find specific concepts</li> <li>Category Filtering: Use checkboxes to show/hide concept categories</li> <li>Interactive Navigation: Click and drag to explore, scroll to zoom</li> <li>Statistics: View real-time counts of visible nodes and edges</li> </ul>"},{"location":"sims/graph-viewer/#using-the-viewer","title":"Using the Viewer","text":"<ol> <li> <p>Search for Concepts: Start typing in the search box to find concepts. Click on a result to focus on that node.</p> </li> <li> <p>Filter by Category: Use the category checkboxes in the sidebar to show or hide groups of related concepts. Use \"Check All\" or \"Uncheck All\" for bulk operations.</p> </li> <li> <p>Navigate the Graph:</p> </li> <li>Drag to pan around the graph</li> <li>Scroll to zoom in and out</li> <li> <p>Click on a node to select it and highlight its connections</p> </li> <li> <p>View Statistics: The sidebar shows counts of visible nodes, edges, and foundational concepts.</p> </li> </ol>"},{"location":"sims/graph-viewer/#graph-structure","title":"Graph Structure","text":"<ul> <li>Foundational Concepts (left side): Prerequisites with no dependencies</li> <li>Advanced Concepts (right side): Topics that build on multiple prerequisites</li> <li>Edges: Arrows point from a concept to its prerequisites</li> </ul>"},{"location":"sims/graph-viewer/#launch-the-viewer","title":"Launch the Viewer","text":"<p>Open Learning Graph Viewer</p>"},{"location":"sims/logic-gates/","title":"Logic Gates MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/logic-gates/main.html\" width=\"100%\" height=\"450px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Logic Gates MicroSim in Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/logic-gates/#description","title":"Description","text":"<p>This interactive simulation provides a visual library of digital logic gates, demonstrating how each gate processes binary inputs to produce outputs. The simulation uses p5.js to render high-quality gate symbols following standard IEEE conventions.</p>"},{"location":"sims/logic-gates/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of all common logic gate types</li> <li>Interactive inputs to test gate behavior</li> <li>Real-time output display</li> <li>Standard IEEE gate symbols</li> <li>Reusable gate drawing library for building complex circuits</li> </ul>"},{"location":"sims/logic-gates/#how-to-use","title":"How to Use","text":"<ol> <li>Click on input nodes to toggle between 0 (LOW) and 1 (HIGH) states</li> <li>Observe how the output changes based on the gate's logic function</li> <li>Experiment with different input combinations to understand each gate's truth table</li> <li>Use the gate library as a foundation for building more complex circuits</li> </ol>"},{"location":"sims/logic-gates/#logic-gate-types","title":"Logic Gate Types","text":"Gate Symbol Function AND Flat back, curved front Output is 1 only when ALL inputs are 1 OR Curved back, pointed front Output is 1 when ANY input is 1 NOT Triangle with bubble Inverts the input NAND AND with bubble Inverted AND output NOR OR with bubble Inverted OR output XOR OR with extra curved line Output is 1 when inputs DIFFER XNOR XOR with bubble Output is 1 when inputs are SAME"},{"location":"sims/logic-gates/#goals","title":"Goals","text":"<p>Our goal in this simulation is to:</p> <ol> <li>Use generative AI to build a library of high-quality logical gate drawings using the p5.js library.</li> <li>Use this library to build a logic simulator that can simulate simple digital logic gates.</li> </ol> <p>Drawing Gates - Tutorial on creating gate graphics</p>"},{"location":"sims/logic-gates/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/logic-gates/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Identify and draw the standard symbols for each logic gate type</li> <li>Create truth tables for each logic gate</li> <li>Predict the output of a logic gate given any combination of inputs</li> <li>Explain the relationship between basic gates (AND, OR, NOT) and derived gates (NAND, NOR, XOR, XNOR)</li> </ul>"},{"location":"sims/logic-gates/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics and computer science students</li> <li>College students in introductory digital logic courses</li> <li>Prerequisites: Understanding of binary numbers (0 and 1)</li> </ul>"},{"location":"sims/logic-gates/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Interact with each gate type, testing all possible input combinations and recording results.</p> </li> <li> <p>Guided Investigation: Complete the truth table worksheet for each gate, verifying answers with the simulation.</p> </li> <li> <p>Extension Activity: Design a simple circuit using multiple gates (e.g., a half-adder) and predict its behavior before testing.</p> </li> </ol>"},{"location":"sims/logic-gates/#assessment","title":"Assessment","text":"<ul> <li>Draw the symbol for each of the seven logic gates from memory</li> <li>Given a truth table, identify which logic gate it represents</li> <li>Explain why NAND and NOR gates are called \"universal gates\"</li> </ul>"},{"location":"sims/logic-gates/#references","title":"References","text":"<ul> <li>Wikipedia: Logic Gate - Overview of logic gate types and applications</li> <li>All About Circuits: Logic Gates - Comprehensive tutorial on digital logic gates</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> <li>IEEE Std 91-1984 - Standard for logic gate symbols</li> </ul>"},{"location":"sims/logic-gates/01-drawing-gates/","title":"Drawing Gates","text":"<p>We will be using the Processing version 5 JavaScript library for doing web-based drawing.  This is called the p5.js library.  Because Processing has been around since 2000 there is able code that generative AI has been trained on.  Getting the correct results is pretty easy. </p> <p>We need a library for drawing gates in our simulators. We use the following drawing conventions:</p> <p>The standard function parameters are:</p> <ol> <li>X position on the canvas</li> <li>Y position on the canvas</li> <li>Width of the gate (not including connecting wires)</li> <li>Height of the gate</li> <li>Length of the connecting wires</li> </ol> <p>The drawing must be made so that the fill color, stroke color, and stroke can all be inherited from the drawing context.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#drawing-basic","title":"Drawing basic","text":""},{"location":"sims/logic-gates/01-drawing-gates/#buffer","title":"Buffer","text":"<p>We will start with a simple buffer logic gate that does not change the input signal.  We use a triangle shape to draw a buffer.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-buffer-prompt","title":"Sample Buffer Prompt","text":"<pre><code>Create a p5.js function called drawBuffer(x,y,w,h,l) for a logic buffer symbol.  The function should take parameters x, y, width, height and wire length.\nPlace the logic gate with the upper left corner of the triangle at the point x,y with a width and height from the parameters.  Add wire length as input and output wires.\n\nCreate a test of this function on a 200x300 canvas drawing three examples of the drawBuffer using different sizes.\n\nDraw the tests on a lightgray background.\n</code></pre> <p>ChatGPT Dialog using the p5.js Visual Art Composer</p>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-buffer-response","title":"Sample Buffer Response","text":"<pre><code>// Draw Buffer Function\nfunction setup() {\n  createCanvas(200, 300);\n  background('lightgray');\n  drawBuffer(50, 50, 30, 40, 20);\n  drawBuffer(100, 120, 40, 60, 30);\n  drawBuffer(30, 200, 50, 70, 40);\n}\n\nfunction drawBuffer(x, y, w, h, l) {\n\n  // Draw input wire\n  line(x - l, y + h / 2, x, y + h / 2);\n\n  // Draw the buffer (triangle)\n  triangle(x, y, x, y + h, x + w, y + h / 2);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n}\n</code></pre> <p>Edit this MicroSim on p5.js Editor</p>"},{"location":"sims/logic-gates/01-drawing-gates/#drawing-an-inverter","title":"Drawing an Inverter","text":""},{"location":"sims/logic-gates/01-drawing-gates/#inverter-prompt","title":"Inverter Prompt","text":"<pre><code>That was perfect!\nNow create a new function called drawInverter.\nIt will have exactly the same input parameters,\nbut the drawing will have a small circle at the\nright tip of the triangle.\n\nDraw the tests on a lightgray background.\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#inverter-response","title":"Inverter Response","text":"<pre><code>// Draw Inverter\n// Test the drawInverter function with different sizes\n\nfunction setup() {\n  createCanvas(200, 300);\n  background(240); // light gray background\n  drawInverter(50, 50, 30, 40, 20);\n  drawInverter(100, 120, 40, 60, 30);\n  drawInverter(30, 200, 50, 70, 40);\n}\n\nfunction drawInverter(x, y, w, h, l) {\n  // Draw input wire\n  line(x - l, y + h / 2, x, y + h / 2);\n\n  // Draw the buffer (triangle)\n  triangle(x, y, x, y + h, x + w, y + h / 2);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n\n  // Draw small circle at the right tip of the triangle\n  circle(x + w, y + h / 2, w / 5);\n}\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#the-and-gate","title":"The AND Gate","text":""},{"location":"sims/logic-gates/01-drawing-gates/#sample-and-prompt","title":"Sample AND Prompt","text":"<pre><code>That was also perfect!\nNow create a new function called drawAND that will draw\na AND logic gate.\nThis will be similar to the previous functions,\nbut instead of drawing a triangle you will need\nto make the right side of the shape a circle.\nPlace a series of points on the canvas using the vertex(x,y) function that makes the correct shape.\nUse beginShape() and endShape() around the points.\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#sample-and-response","title":"Sample AND Response","text":"<pre><code>// Draw And Logic Gate\n// Test the drawAND function with different sizes\n\nfunction setup() {\n  createCanvas(200, 300);\n  background(200); // light gray background\n  drawAND(50, 20, 40, 40, 20);\n  drawAND(100, 70, 40, 60, 30);\n  drawAND(80, 150, 70, 50, 20);\n}\n\nfunction drawAND(x, y, w, h, l) {\n  // Draw input wires\n  line(x - l, y + h / 3, x, y + h / 3);\n  line(x - l, y + 2 * h / 3, x, y + 2 * h / 3);\n\n  // Draw the AND gate shape\n  beginShape();\n  vertex(x, y); // top left corner\n  vertex(x + w * 0.6, y); // top right corner (start of semicircle)\n  // Create semicircle\n  for (let angle = -HALF_PI; angle &lt;= HALF_PI; angle += 0.01) {\n    let sx = x + w * 0.6 + cos(angle) * w * 0.4;\n    let sy = y + h / 2 + sin(angle) * h / 2;\n    vertex(sx, sy);\n  }\n  vertex(x + w * 0.6, y + h); // bottom right corner (end of semicircle)\n  vertex(x, y + h); // bottom left corner\n  endShape(CLOSE);\n\n  // Draw output wire\n  line(x + w, y + h / 2, x + w + l, y + h / 2);\n}\n</code></pre>"},{"location":"sims/logic-gates/01-drawing-gates/#failed-attempts-at-or-gate","title":"Failed Attempts at OR Gate","text":"<p>This is where GPT-4 falls apart.  Despite my best attempts, I could not get GPT-4 to correctly draw the complex curves needed for a logical OR gate.  You can see the results in the transcript.</p> <p>I had to resort to manually drawing the curves, which was a slow-painful process and took several hours to make it robust enough that it could work with a variety of sizes.</p> <p>I think this really demonstrates the limits of what GPT-4 is capable of, and what it can't do.</p> <p></p> <p>Edit the Logical OR gate MicroSim</p> <p>One hint that GPT-4 did give was to use the map function to have the x-coordinates move linearly and only use the sin() functions on the y-coordinates.  This worked reasonably well and the curves do match up pretty closely with the official SVG drawing of the OR gate. If you want a precise mapping you can also write a program that converts the SVG points to a set of (x,y) points.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#nor-symbol-prompt","title":"NOR Symbol Prompt","text":"<p>Once we have a good OR gate, we can ask GPT to just use that to create a NOR gate.  All it has to do is add a circle on the output.</p> <p>Here is the code it generated:</p> <pre><code>function drawNOR(x, y, w, h, l) {\n  // Draw the OR part\n  drawOR(x, y, w, h, l);\n\n  // Draw the NOT circle at the output\n  let outputX = x + w + l * 0.5;\n  let outputY = y + h / 2;\n  let circleRadius = l * 0.3;\n  ellipse(outputX, outputY, circleRadius, circleRadius);\n}\n</code></pre> <p>So it is clear that GPT-4 has been trained on how to add a small bit of drawing to an existing function.</p> <p>Note that it tends to use ellipse() rather than circle(). I don't know exactly why it does this.  Perhaps it believes that ellipse is more general and easier to customize.  I think that circle with only three parameters is a little easier to read.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#xor-gate","title":"XOR Gate","text":""},{"location":"sims/logic-gates/01-drawing-gates/#xnor-prompt","title":"XNOR Prompt","text":"<pre><code>Now can you please repeat the same process \nbut this time generate the code for an exclusive OR.  \nPlease call the new function drawXOR and make the \nparameters exactly the same.\n</code></pre> <p>It got the result pretty close.  The only real cleanup is to move the new arc to the end and add a noFill() for the new extra curve. This is an easy to change.</p>"},{"location":"sims/logic-gates/01-drawing-gates/#xnor","title":"XNOR","text":"<p>Our last function is XNOR, which just adds a circle to the XOR symbol.</p> <p>Edit the XNOR MicroSim</p> <p>Note that we did not automatically fill the circle with black.  We decided to inherit the fill from the drawing context.  Forcing the circle to fill with black is a valid option and might make drawings a little easier to read.  This could also be an additional parameter to these functions.</p>"},{"location":"sims/shift-register/","title":"Shift Register MicroSim","text":"<p>Copy this iframe to your website:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/digital-electronics/sims/shift-register/main.html\" width=\"100%\" height=\"400px\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Run the Shift Register MicroSim in Fullscreen</p>"},{"location":"sims/shift-register/#description","title":"Description","text":"<p>This interactive simulation demonstrates the operation of a 74HC594 shift register, a common integrated circuit used to convert serial data into parallel output. The simulation includes a logic analyzer display that shows the timing relationships between the DATA IN, CLOCK, and LATCH signals.</p>"},{"location":"sims/shift-register/#key-features","title":"Key Features","text":"<ul> <li>Visual representation of the 74HC594 shift register chip</li> <li>Real-time logic analyzer showing signal waveforms</li> <li>Interactive DATA IN toggle (ON/OFF)</li> <li>CLOCK button to shift data into the register</li> <li>LATCH button to transfer shift register contents to output</li> <li>Reset button to clear all states</li> <li>8-bit output display with LED indicators</li> </ul>"},{"location":"sims/shift-register/#how-to-use","title":"How to Use","text":"<ol> <li>Set DATA IN to ON or OFF using the radio buttons</li> <li>Click Next Clock to shift the current DATA IN value into the register</li> <li>Repeat steps 1-2 to load a complete 8-bit pattern</li> <li>Click Latch to transfer the shift register contents to the output pins</li> <li>Observe the LED indicators showing the parallel output</li> <li>Watch the Logic Analyzer to see the timing of each signal</li> <li>Click Reset to clear the register and start over</li> </ol>"},{"location":"sims/shift-register/#understanding-the-logic-analyzer","title":"Understanding the Logic Analyzer","text":"<p>The logic analyzer display shows three signals:</p> <ul> <li>DATA IN (blue): The current input data level</li> <li>CLOCK (red): Pulses each time you click \"Next Clock\"</li> <li>LATCH (green): Pulses when you click \"Latch\"</li> </ul> <p>Each rising edge of the CLOCK signal shifts the DATA IN value into the first position of the shift register, pushing all existing bits one position to the right.</p>"},{"location":"sims/shift-register/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/shift-register/#learning-objectives","title":"Learning Objectives","text":"<p>After completing this lesson, students will be able to:</p> <ul> <li>Explain the difference between serial and parallel data transfer</li> <li>Describe how a shift register converts serial input to parallel output</li> <li>Identify the function of CLOCK and LATCH signals in a shift register</li> <li>Demonstrate the sequence of operations needed to load an 8-bit pattern</li> </ul>"},{"location":"sims/shift-register/#target-audience","title":"Target Audience","text":"<ul> <li>High school electronics students</li> <li>College students in digital electronics courses</li> <li>Prerequisites: Understanding of flip-flops and binary numbers</li> </ul>"},{"location":"sims/shift-register/#activities","title":"Activities","text":"<ol> <li> <p>Exploration Activity: Load the binary pattern for the letter \"A\" (01000001) into the shift register and display it on the outputs.</p> </li> <li> <p>Guided Investigation: Document the timing sequence by recording what happens at each clock pulse as you shift in a specific bit pattern.</p> </li> <li> <p>Extension Activity: Calculate how many clock pulses are needed to shift data through multiple cascaded shift registers. Discuss applications like LED displays or motor control.</p> </li> </ol>"},{"location":"sims/shift-register/#assessment","title":"Assessment","text":"<ul> <li>What is the difference between the shift register and the output register in the 74HC594?</li> <li>Why is a separate LATCH signal needed?</li> <li>How many clock pulses are required to load all 8 bits?</li> <li>Describe a real-world application where shift registers are used.</li> </ul>"},{"location":"sims/shift-register/#references","title":"References","text":"<ul> <li>Wikipedia: Shift Register - Overview of shift register types and applications</li> <li>Texas Instruments 74HC594 Datasheet - Technical specifications for the 74HC594</li> <li>SparkFun Shift Register Tutorial - Practical guide to using shift registers with microcontrollers</li> <li>p5.js Reference - Documentation for the p5.js library used in this simulation</li> </ul>"},{"location":"sims/template/","title":"MicroSim Template","text":"![Image Name](./image.png){ width=\"400\" }    Figure caption. <p>Run the MicroSim Edit the MicroSim</p>"},{"location":"sims/template/#about-this-microsim","title":"About this MicroSim","text":"<p>This MicroSim teaches us how to specify the drawing of a static filled circle.</p>"},{"location":"sims/template/#sample-prompt","title":"Sample Prompt","text":"<pre><code>Create a single file p5.js sketch.\nDraw a green circle on a 600x400 canvas with a radius of 200.\n</code></pre>"},{"location":"sims/template/#sample-response","title":"Sample Response","text":"<pre><code>let canvasHeight = 400;\nlet aspectRatio = 1.91; // Open Graph standard\nlet canvasWidth = canvasHeight * aspectRatio;\nlet radius = 200;\nfunction setup() {\nconst canvas = createCanvas(canvasWidth, canvasHeight);\n  canvas.parent('canvas-container');\n  fill(245);\n  rect(0,0, canvasWidth, canvasHeight);\n  fill('green');\n  circle(canvasWidth/2, canvasHeight/2, radius);\n}\n</code></pre>"},{"location":"sims/template/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/template/#grade-level-subject-and-topic","title":"Grade Level, Subject and Topic","text":"<p>9th grade geometry. Circle and radius.</p>"},{"location":"sims/template/#activities","title":"Activities","text":""},{"location":"sims/template/#fill-color","title":"Fill Color","text":"<p>Change the color in the prompt.  You can specify any one of the 140 named colors.</p>"},{"location":"sims/template/#border-weight","title":"Border Weight","text":"<p>Change the prompt to include a black border of width 10.</p>"},{"location":"sims/template/#border-color","title":"Border Color","text":"<p>Change the prompt to make the border purple.</p>"},{"location":"sims/template/#change-the-radius","title":"Change the Radius","text":"<p>Change the prompt to make the circle smaller or larger by changing the radius from 10 to 200.</p>"},{"location":"sims/template/#change-the-location","title":"Change the Location","text":"<p>Change the prompt to move the circle to the left or right.</p>"},{"location":"sims/template/TODO/","title":"TODO: Fix MicroSim Metadata","text":"<p>MicroSim: template Repository: digital-electronics Generated: 2026-01-23</p>"},{"location":"sims/template/TODO/#issues-found","title":"Issues Found","text":"<p>The following issues prevented automatic metadata generation:</p> <ol> <li>No description found</li> </ol>"},{"location":"sims/template/TODO/#required-actions","title":"Required Actions","text":""},{"location":"sims/template/TODO/#high-priority","title":"High Priority","text":"<ul> <li>[ ] Create or fix <code>main.html</code> - the main simulation file</li> <li>[ ] Add a meaningful title that describes the simulation</li> <li>[ ] Write a clear description (2-3 sentences) explaining what the MicroSim does</li> </ul>"},{"location":"sims/template/TODO/#medium-priority","title":"Medium Priority","text":"<ul> <li>[ ] Create <code>index.md</code> with proper YAML frontmatter:   <pre><code>---\ntitle: \"Your Title Here\"\ndescription: \"Brief description for SEO\"\n---\n</code></pre></li> <li>[ ] Add an iframe to display the simulation</li> <li>[ ] Add a \"Run Fullscreen\" button</li> </ul>"},{"location":"sims/template/TODO/#low-priority","title":"Low Priority","text":"<ul> <li>[ ] Add a lesson plan section</li> <li>[ ] Add references section</li> <li>[ ] Create a screenshot for social media preview</li> </ul>"},{"location":"sims/template/TODO/#detected-information","title":"Detected Information","text":"<ul> <li>Framework: p5.js</li> <li>Detected subjects: Mathematics, Computer Science, Chemistry, Engineering</li> <li>Visualization types: graph, interactive-demo, map</li> <li>Has main.html: Yes</li> <li>Has index.md: Yes</li> </ul>"},{"location":"sims/template/TODO/#after-fixing","title":"After Fixing","text":"<p>Once you've addressed the issues above, run the metadata standardization:</p> <pre><code># Use Claude Code's microsim-utils skill to standardize\n# Or manually create metadata.json following the schema\n</code></pre> <p>Delete this TODO.md file after creating proper metadata.json.</p>"}]}